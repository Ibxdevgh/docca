(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
  new MutationObserver((s) => {
    for (const o of s)
      if (o.type === "childList")
        for (const a of o.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && r(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(s) {
    const o = {};
    return (
      s.integrity && (o.integrity = s.integrity),
      s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy),
      s.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : s.crossOrigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function r(s) {
    if (s.ep) return;
    s.ep = !0;
    const o = t(s);
    fetch(s.href, o);
  }
})();
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function getDefaultExportFromCjs(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var jsxRuntime = { exports: {} },
  reactJsxRuntime_production_min = {},
  react = { exports: {} },
  react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var n = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    s = Symbol.for("react.profiler"),
    o = Symbol.for("react.provider"),
    a = Symbol.for("react.context"),
    l = Symbol.for("react.forward_ref"),
    c = Symbol.for("react.suspense"),
    u = Symbol.for("react.memo"),
    p = Symbol.for("react.lazy"),
    N = Symbol.iterator;
  function P(Ot) {
    return Ot === null || typeof Ot != "object"
      ? null
      : ((Ot = (N && Ot[N]) || Ot["@@iterator"]),
        typeof Ot == "function" ? Ot : null);
  }
  var de = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    me = Object.assign,
    Ye = {};
  function nt(Ot, Xt, sn) {
    (this.props = Ot),
      (this.context = Xt),
      (this.refs = Ye),
      (this.updater = sn || de);
  }
  (nt.prototype.isReactComponent = {}),
    (nt.prototype.setState = function (Ot, Xt) {
      if (typeof Ot != "object" && typeof Ot != "function" && Ot != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, Ot, Xt, "setState");
    }),
    (nt.prototype.forceUpdate = function (Ot) {
      this.updater.enqueueForceUpdate(this, Ot, "forceUpdate");
    });
  function Be() {}
  Be.prototype = nt.prototype;
  function ot(Ot, Xt, sn) {
    (this.props = Ot),
      (this.context = Xt),
      (this.refs = Ye),
      (this.updater = sn || de);
  }
  var st = (ot.prototype = new Be());
  (st.constructor = ot), me(st, nt.prototype), (st.isPureReactComponent = !0);
  var vt = Array.isArray,
    xt = Object.prototype.hasOwnProperty,
    St = { current: null },
    wt = { key: !0, ref: !0, __self: !0, __source: !0 };
  function bt(Ot, Xt, sn) {
    var Kt,
      tn = {},
      pn = null,
      _n = null;
    if (Xt != null)
      for (Kt in (Xt.ref !== void 0 && (_n = Xt.ref),
      Xt.key !== void 0 && (pn = "" + Xt.key),
      Xt))
        xt.call(Xt, Kt) && !wt.hasOwnProperty(Kt) && (tn[Kt] = Xt[Kt]);
    var bn = arguments.length - 2;
    if (bn === 1) tn.children = sn;
    else if (1 < bn) {
      for (var $n = Array(bn), tr = 0; tr < bn; tr++)
        $n[tr] = arguments[tr + 2];
      tn.children = $n;
    }
    if (Ot && Ot.defaultProps)
      for (Kt in ((bn = Ot.defaultProps), bn))
        tn[Kt] === void 0 && (tn[Kt] = bn[Kt]);
    return {
      $$typeof: n,
      type: Ot,
      key: pn,
      ref: _n,
      props: tn,
      _owner: St.current,
    };
  }
  function Tt(Ot, Xt) {
    return {
      $$typeof: n,
      type: Ot.type,
      key: Xt,
      ref: Ot.ref,
      props: Ot.props,
      _owner: Ot._owner,
    };
  }
  function Ct(Ot) {
    return typeof Ot == "object" && Ot !== null && Ot.$$typeof === n;
  }
  function kt(Ot) {
    var Xt = { "=": "=0", ":": "=2" };
    return (
      "$" +
      Ot.replace(/[=:]/g, function (sn) {
        return Xt[sn];
      })
    );
  }
  var Dt = /\/+/g;
  function Vt(Ot, Xt) {
    return typeof Ot == "object" && Ot !== null && Ot.key != null
      ? kt("" + Ot.key)
      : Xt.toString(36);
  }
  function Ht(Ot, Xt, sn, Kt, tn) {
    var pn = typeof Ot;
    (pn === "undefined" || pn === "boolean") && (Ot = null);
    var _n = !1;
    if (Ot === null) _n = !0;
    else
      switch (pn) {
        case "string":
        case "number":
          _n = !0;
          break;
        case "object":
          switch (Ot.$$typeof) {
            case n:
            case e:
              _n = !0;
          }
      }
    if (_n)
      return (
        (_n = Ot),
        (tn = tn(_n)),
        (Ot = Kt === "" ? "." + Vt(_n, 0) : Kt),
        vt(tn)
          ? ((sn = ""),
            Ot != null && (sn = Ot.replace(Dt, "$&/") + "/"),
            Ht(tn, Xt, sn, "", function (tr) {
              return tr;
            }))
          : tn != null &&
            (Ct(tn) &&
              (tn = Tt(
                tn,
                sn +
                  (!tn.key || (_n && _n.key === tn.key)
                    ? ""
                    : ("" + tn.key).replace(Dt, "$&/") + "/") +
                  Ot
              )),
            Xt.push(tn)),
        1
      );
    if (((_n = 0), (Kt = Kt === "" ? "." : Kt + ":"), vt(Ot)))
      for (var bn = 0; bn < Ot.length; bn++) {
        pn = Ot[bn];
        var $n = Kt + Vt(pn, bn);
        _n += Ht(pn, Xt, sn, $n, tn);
      }
    else if ((($n = P(Ot)), typeof $n == "function"))
      for (Ot = $n.call(Ot), bn = 0; !(pn = Ot.next()).done; )
        (pn = pn.value),
          ($n = Kt + Vt(pn, bn++)),
          (_n += Ht(pn, Xt, sn, $n, tn));
    else if (pn === "object")
      throw (
        ((Xt = String(Ot)),
        Error(
          "Objects are not valid as a React child (found: " +
            (Xt === "[object Object]"
              ? "object with keys {" + Object.keys(Ot).join(", ") + "}"
              : Xt) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return _n;
  }
  function qt(Ot, Xt, sn) {
    if (Ot == null) return Ot;
    var Kt = [],
      tn = 0;
    return (
      Ht(Ot, Kt, "", "", function (pn) {
        return Xt.call(sn, pn, tn++);
      }),
      Kt
    );
  }
  function Ft(Ot) {
    if (Ot._status === -1) {
      var Xt = Ot._result;
      (Xt = Xt()),
        Xt.then(
          function (sn) {
            (Ot._status === 0 || Ot._status === -1) &&
              ((Ot._status = 1), (Ot._result = sn));
          },
          function (sn) {
            (Ot._status === 0 || Ot._status === -1) &&
              ((Ot._status = 2), (Ot._result = sn));
          }
        ),
        Ot._status === -1 && ((Ot._status = 0), (Ot._result = Xt));
    }
    if (Ot._status === 1) return Ot._result.default;
    throw Ot._result;
  }
  var Bt = { current: null },
    Mt = { transition: null },
    Pt = {
      ReactCurrentDispatcher: Bt,
      ReactCurrentBatchConfig: Mt,
      ReactCurrentOwner: St,
    };
  function It() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return (
    (react_production_min.Children = {
      map: qt,
      forEach: function (Ot, Xt, sn) {
        qt(
          Ot,
          function () {
            Xt.apply(this, arguments);
          },
          sn
        );
      },
      count: function (Ot) {
        var Xt = 0;
        return (
          qt(Ot, function () {
            Xt++;
          }),
          Xt
        );
      },
      toArray: function (Ot) {
        return (
          qt(Ot, function (Xt) {
            return Xt;
          }) || []
        );
      },
      only: function (Ot) {
        if (!Ct(Ot))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return Ot;
      },
    }),
    (react_production_min.Component = nt),
    (react_production_min.Fragment = t),
    (react_production_min.Profiler = s),
    (react_production_min.PureComponent = ot),
    (react_production_min.StrictMode = r),
    (react_production_min.Suspense = c),
    (react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED =
      Pt),
    (react_production_min.act = It),
    (react_production_min.cloneElement = function (Ot, Xt, sn) {
      if (Ot == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            Ot +
            "."
        );
      var Kt = me({}, Ot.props),
        tn = Ot.key,
        pn = Ot.ref,
        _n = Ot._owner;
      if (Xt != null) {
        if (
          (Xt.ref !== void 0 && ((pn = Xt.ref), (_n = St.current)),
          Xt.key !== void 0 && (tn = "" + Xt.key),
          Ot.type && Ot.type.defaultProps)
        )
          var bn = Ot.type.defaultProps;
        for ($n in Xt)
          xt.call(Xt, $n) &&
            !wt.hasOwnProperty($n) &&
            (Kt[$n] = Xt[$n] === void 0 && bn !== void 0 ? bn[$n] : Xt[$n]);
      }
      var $n = arguments.length - 2;
      if ($n === 1) Kt.children = sn;
      else if (1 < $n) {
        bn = Array($n);
        for (var tr = 0; tr < $n; tr++) bn[tr] = arguments[tr + 2];
        Kt.children = bn;
      }
      return {
        $$typeof: n,
        type: Ot.type,
        key: tn,
        ref: pn,
        props: Kt,
        _owner: _n,
      };
    }),
    (react_production_min.createContext = function (Ot) {
      return (
        (Ot = {
          $$typeof: a,
          _currentValue: Ot,
          _currentValue2: Ot,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (Ot.Provider = { $$typeof: o, _context: Ot }),
        (Ot.Consumer = Ot)
      );
    }),
    (react_production_min.createElement = bt),
    (react_production_min.createFactory = function (Ot) {
      var Xt = bt.bind(null, Ot);
      return (Xt.type = Ot), Xt;
    }),
    (react_production_min.createRef = function () {
      return { current: null };
    }),
    (react_production_min.forwardRef = function (Ot) {
      return { $$typeof: l, render: Ot };
    }),
    (react_production_min.isValidElement = Ct),
    (react_production_min.lazy = function (Ot) {
      return { $$typeof: p, _payload: { _status: -1, _result: Ot }, _init: Ft };
    }),
    (react_production_min.memo = function (Ot, Xt) {
      return { $$typeof: u, type: Ot, compare: Xt === void 0 ? null : Xt };
    }),
    (react_production_min.startTransition = function (Ot) {
      var Xt = Mt.transition;
      Mt.transition = {};
      try {
        Ot();
      } finally {
        Mt.transition = Xt;
      }
    }),
    (react_production_min.unstable_act = It),
    (react_production_min.useCallback = function (Ot, Xt) {
      return Bt.current.useCallback(Ot, Xt);
    }),
    (react_production_min.useContext = function (Ot) {
      return Bt.current.useContext(Ot);
    }),
    (react_production_min.useDebugValue = function () {}),
    (react_production_min.useDeferredValue = function (Ot) {
      return Bt.current.useDeferredValue(Ot);
    }),
    (react_production_min.useEffect = function (Ot, Xt) {
      return Bt.current.useEffect(Ot, Xt);
    }),
    (react_production_min.useId = function () {
      return Bt.current.useId();
    }),
    (react_production_min.useImperativeHandle = function (Ot, Xt, sn) {
      return Bt.current.useImperativeHandle(Ot, Xt, sn);
    }),
    (react_production_min.useInsertionEffect = function (Ot, Xt) {
      return Bt.current.useInsertionEffect(Ot, Xt);
    }),
    (react_production_min.useLayoutEffect = function (Ot, Xt) {
      return Bt.current.useLayoutEffect(Ot, Xt);
    }),
    (react_production_min.useMemo = function (Ot, Xt) {
      return Bt.current.useMemo(Ot, Xt);
    }),
    (react_production_min.useReducer = function (Ot, Xt, sn) {
      return Bt.current.useReducer(Ot, Xt, sn);
    }),
    (react_production_min.useRef = function (Ot) {
      return Bt.current.useRef(Ot);
    }),
    (react_production_min.useState = function (Ot) {
      return Bt.current.useState(Ot);
    }),
    (react_production_min.useSyncExternalStore = function (Ot, Xt, sn) {
      return Bt.current.useSyncExternalStore(Ot, Xt, sn);
    }),
    (react_production_min.useTransition = function () {
      return Bt.current.useTransition();
    }),
    (react_production_min.version = "18.3.1"),
    react_production_min
  );
}
var hasRequiredReact;
function requireReact() {
  return (
    hasRequiredReact ||
      ((hasRequiredReact = 1), (react.exports = requireReact_production_min())),
    react.exports
  );
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var n = requireReact(),
    e = Symbol.for("react.element"),
    t = Symbol.for("react.fragment"),
    r = Object.prototype.hasOwnProperty,
    s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(l, c, u) {
    var p,
      N = {},
      P = null,
      de = null;
    u !== void 0 && (P = "" + u),
      c.key !== void 0 && (P = "" + c.key),
      c.ref !== void 0 && (de = c.ref);
    for (p in c) r.call(c, p) && !o.hasOwnProperty(p) && (N[p] = c[p]);
    if (l && l.defaultProps)
      for (p in ((c = l.defaultProps), c)) N[p] === void 0 && (N[p] = c[p]);
    return {
      $$typeof: e,
      type: l,
      key: P,
      ref: de,
      props: N,
      _owner: s.current,
    };
  }
  return (
    (reactJsxRuntime_production_min.Fragment = t),
    (reactJsxRuntime_production_min.jsx = a),
    (reactJsxRuntime_production_min.jsxs = a),
    reactJsxRuntime_production_min
  );
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  return (
    hasRequiredJsxRuntime ||
      ((hasRequiredJsxRuntime = 1),
      (jsxRuntime.exports = requireReactJsxRuntime_production_min())),
    jsxRuntime.exports
  );
}
var jsxRuntimeExports = requireJsxRuntime(),
  reactExports = requireReact();
const React = getDefaultExportFromCjs(reactExports);
var client = {},
  reactDom = { exports: {} },
  reactDom_production_min = {},
  scheduler$1 = { exports: {} },
  scheduler_production_min$1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_production_min$1;
function requireScheduler_production_min$1() {
  return (
    hasRequiredScheduler_production_min$1 ||
      ((hasRequiredScheduler_production_min$1 = 1),
      (function (n) {
        function e(Mt, Pt) {
          var It = Mt.length;
          Mt.push(Pt);
          e: for (; 0 < It; ) {
            var Ot = (It - 1) >>> 1,
              Xt = Mt[Ot];
            if (0 < s(Xt, Pt)) (Mt[Ot] = Pt), (Mt[It] = Xt), (It = Ot);
            else break e;
          }
        }
        function t(Mt) {
          return Mt.length === 0 ? null : Mt[0];
        }
        function r(Mt) {
          if (Mt.length === 0) return null;
          var Pt = Mt[0],
            It = Mt.pop();
          if (It !== Pt) {
            Mt[0] = It;
            e: for (var Ot = 0, Xt = Mt.length, sn = Xt >>> 1; Ot < sn; ) {
              var Kt = 2 * (Ot + 1) - 1,
                tn = Mt[Kt],
                pn = Kt + 1,
                _n = Mt[pn];
              if (0 > s(tn, It))
                pn < Xt && 0 > s(_n, tn)
                  ? ((Mt[Ot] = _n), (Mt[pn] = It), (Ot = pn))
                  : ((Mt[Ot] = tn), (Mt[Kt] = It), (Ot = Kt));
              else if (pn < Xt && 0 > s(_n, It))
                (Mt[Ot] = _n), (Mt[pn] = It), (Ot = pn);
              else break e;
            }
          }
          return Pt;
        }
        function s(Mt, Pt) {
          var It = Mt.sortIndex - Pt.sortIndex;
          return It !== 0 ? It : Mt.id - Pt.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var a = Date,
            l = a.now();
          n.unstable_now = function () {
            return a.now() - l;
          };
        }
        var c = [],
          u = [],
          p = 1,
          N = null,
          P = 3,
          de = !1,
          me = !1,
          Ye = !1,
          nt = typeof setTimeout == "function" ? setTimeout : null,
          Be = typeof clearTimeout == "function" ? clearTimeout : null,
          ot = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function st(Mt) {
          for (var Pt = t(u); Pt !== null; ) {
            if (Pt.callback === null) r(u);
            else if (Pt.startTime <= Mt)
              r(u), (Pt.sortIndex = Pt.expirationTime), e(c, Pt);
            else break;
            Pt = t(u);
          }
        }
        function vt(Mt) {
          if (((Ye = !1), st(Mt), !me))
            if (t(c) !== null) (me = !0), Ft(xt);
            else {
              var Pt = t(u);
              Pt !== null && Bt(vt, Pt.startTime - Mt);
            }
        }
        function xt(Mt, Pt) {
          (me = !1), Ye && ((Ye = !1), Be(bt), (bt = -1)), (de = !0);
          var It = P;
          try {
            for (
              st(Pt), N = t(c);
              N !== null && (!(N.expirationTime > Pt) || (Mt && !kt()));

            ) {
              var Ot = N.callback;
              if (typeof Ot == "function") {
                (N.callback = null), (P = N.priorityLevel);
                var Xt = Ot(N.expirationTime <= Pt);
                (Pt = n.unstable_now()),
                  typeof Xt == "function"
                    ? (N.callback = Xt)
                    : N === t(c) && r(c),
                  st(Pt);
              } else r(c);
              N = t(c);
            }
            if (N !== null) var sn = !0;
            else {
              var Kt = t(u);
              Kt !== null && Bt(vt, Kt.startTime - Pt), (sn = !1);
            }
            return sn;
          } finally {
            (N = null), (P = It), (de = !1);
          }
        }
        var St = !1,
          wt = null,
          bt = -1,
          Tt = 5,
          Ct = -1;
        function kt() {
          return !(n.unstable_now() - Ct < Tt);
        }
        function Dt() {
          if (wt !== null) {
            var Mt = n.unstable_now();
            Ct = Mt;
            var Pt = !0;
            try {
              Pt = wt(!0, Mt);
            } finally {
              Pt ? Vt() : ((St = !1), (wt = null));
            }
          } else St = !1;
        }
        var Vt;
        if (typeof ot == "function")
          Vt = function () {
            ot(Dt);
          };
        else if (typeof MessageChannel < "u") {
          var Ht = new MessageChannel(),
            qt = Ht.port2;
          (Ht.port1.onmessage = Dt),
            (Vt = function () {
              qt.postMessage(null);
            });
        } else
          Vt = function () {
            nt(Dt, 0);
          };
        function Ft(Mt) {
          (wt = Mt), St || ((St = !0), Vt());
        }
        function Bt(Mt, Pt) {
          bt = nt(function () {
            Mt(n.unstable_now());
          }, Pt);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (Mt) {
            Mt.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            me || de || ((me = !0), Ft(xt));
          }),
          (n.unstable_forceFrameRate = function (Mt) {
            0 > Mt || 125 < Mt
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (Tt = 0 < Mt ? Math.floor(1e3 / Mt) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return P;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(c);
          }),
          (n.unstable_next = function (Mt) {
            switch (P) {
              case 1:
              case 2:
              case 3:
                var Pt = 3;
                break;
              default:
                Pt = P;
            }
            var It = P;
            P = Pt;
            try {
              return Mt();
            } finally {
              P = It;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (Mt, Pt) {
            switch (Mt) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                Mt = 3;
            }
            var It = P;
            P = Mt;
            try {
              return Pt();
            } finally {
              P = It;
            }
          }),
          (n.unstable_scheduleCallback = function (Mt, Pt, It) {
            var Ot = n.unstable_now();
            switch (
              (typeof It == "object" && It !== null
                ? ((It = It.delay),
                  (It = typeof It == "number" && 0 < It ? Ot + It : Ot))
                : (It = Ot),
              Mt)
            ) {
              case 1:
                var Xt = -1;
                break;
              case 2:
                Xt = 250;
                break;
              case 5:
                Xt = 1073741823;
                break;
              case 4:
                Xt = 1e4;
                break;
              default:
                Xt = 5e3;
            }
            return (
              (Xt = It + Xt),
              (Mt = {
                id: p++,
                callback: Pt,
                priorityLevel: Mt,
                startTime: It,
                expirationTime: Xt,
                sortIndex: -1,
              }),
              It > Ot
                ? ((Mt.sortIndex = It),
                  e(u, Mt),
                  t(c) === null &&
                    Mt === t(u) &&
                    (Ye ? (Be(bt), (bt = -1)) : (Ye = !0), Bt(vt, It - Ot)))
                : ((Mt.sortIndex = Xt),
                  e(c, Mt),
                  me || de || ((me = !0), Ft(xt))),
              Mt
            );
          }),
          (n.unstable_shouldYield = kt),
          (n.unstable_wrapCallback = function (Mt) {
            var Pt = P;
            return function () {
              var It = P;
              P = Pt;
              try {
                return Mt.apply(this, arguments);
              } finally {
                P = It;
              }
            };
          });
      })(scheduler_production_min$1)),
    scheduler_production_min$1
  );
}
var hasRequiredScheduler$1;
function requireScheduler$1() {
  return (
    hasRequiredScheduler$1 ||
      ((hasRequiredScheduler$1 = 1),
      (scheduler$1.exports = requireScheduler_production_min$1())),
    scheduler$1.exports
  );
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var n = requireReact(),
    e = requireScheduler$1();
  function t(d) {
    for (
      var pe = "https://reactjs.org/docs/error-decoder.html?invariant=" + d,
        gt = 1;
      gt < arguments.length;
      gt++
    )
      pe += "&args[]=" + encodeURIComponent(arguments[gt]);
    return (
      "Minified React error #" +
      d +
      "; visit " +
      pe +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var r = new Set(),
    s = {};
  function o(d, pe) {
    a(d, pe), a(d + "Capture", pe);
  }
  function a(d, pe) {
    for (s[d] = pe, d = 0; d < pe.length; d++) r.add(pe[d]);
  }
  var l = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    c = Object.prototype.hasOwnProperty,
    u =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    p = {},
    N = {};
  function P(d) {
    return c.call(N, d)
      ? !0
      : c.call(p, d)
      ? !1
      : u.test(d)
      ? (N[d] = !0)
      : ((p[d] = !0), !1);
  }
  function de(d, pe, gt, yt) {
    if (gt !== null && gt.type === 0) return !1;
    switch (typeof pe) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return yt
          ? !1
          : gt !== null
          ? !gt.acceptsBooleans
          : ((d = d.toLowerCase().slice(0, 5)), d !== "data-" && d !== "aria-");
      default:
        return !1;
    }
  }
  function me(d, pe, gt, yt) {
    if (pe === null || typeof pe > "u" || de(d, pe, gt, yt)) return !0;
    if (yt) return !1;
    if (gt !== null)
      switch (gt.type) {
        case 3:
          return !pe;
        case 4:
          return pe === !1;
        case 5:
          return isNaN(pe);
        case 6:
          return isNaN(pe) || 1 > pe;
      }
    return !1;
  }
  function Ye(d, pe, gt, yt, At, Lt, Wt) {
    (this.acceptsBooleans = pe === 2 || pe === 3 || pe === 4),
      (this.attributeName = yt),
      (this.attributeNamespace = At),
      (this.mustUseProperty = gt),
      (this.propertyName = d),
      (this.type = pe),
      (this.sanitizeURL = Lt),
      (this.removeEmptyString = Wt);
  }
  var nt = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (d) {
      nt[d] = new Ye(d, 0, !1, d, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (d) {
      var pe = d[0];
      nt[pe] = new Ye(pe, 1, !1, d[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      d
    ) {
      nt[d] = new Ye(d, 2, !1, d.toLowerCase(), null, !1, !1);
    }),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (d) {
      nt[d] = new Ye(d, 2, !1, d, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (d) {
        nt[d] = new Ye(d, 3, !1, d.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (d) {
      nt[d] = new Ye(d, 3, !0, d, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (d) {
      nt[d] = new Ye(d, 4, !1, d, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (d) {
      nt[d] = new Ye(d, 6, !1, d, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (d) {
      nt[d] = new Ye(d, 5, !1, d.toLowerCase(), null, !1, !1);
    });
  var Be = /[\-:]([a-z])/g;
  function ot(d) {
    return d[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (d) {
      var pe = d.replace(Be, ot);
      nt[pe] = new Ye(pe, 1, !1, d, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (d) {
        var pe = d.replace(Be, ot);
        nt[pe] = new Ye(pe, 1, !1, d, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (d) {
      var pe = d.replace(Be, ot);
      nt[pe] = new Ye(
        pe,
        1,
        !1,
        d,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        !1
      );
    }),
    ["tabIndex", "crossOrigin"].forEach(function (d) {
      nt[d] = new Ye(d, 1, !1, d.toLowerCase(), null, !1, !1);
    }),
    (nt.xlinkHref = new Ye(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    )),
    ["src", "href", "action", "formAction"].forEach(function (d) {
      nt[d] = new Ye(d, 1, !1, d.toLowerCase(), null, !0, !0);
    });
  function st(d, pe, gt, yt) {
    var At = nt.hasOwnProperty(pe) ? nt[pe] : null;
    (At !== null
      ? At.type !== 0
      : yt ||
        !(2 < pe.length) ||
        (pe[0] !== "o" && pe[0] !== "O") ||
        (pe[1] !== "n" && pe[1] !== "N")) &&
      (me(pe, gt, At, yt) && (gt = null),
      yt || At === null
        ? P(pe) &&
          (gt === null ? d.removeAttribute(pe) : d.setAttribute(pe, "" + gt))
        : At.mustUseProperty
        ? (d[At.propertyName] = gt === null ? (At.type === 3 ? !1 : "") : gt)
        : ((pe = At.attributeName),
          (yt = At.attributeNamespace),
          gt === null
            ? d.removeAttribute(pe)
            : ((At = At.type),
              (gt = At === 3 || (At === 4 && gt === !0) ? "" : "" + gt),
              yt ? d.setAttributeNS(yt, pe, gt) : d.setAttribute(pe, gt))));
  }
  var vt = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    xt = Symbol.for("react.element"),
    St = Symbol.for("react.portal"),
    wt = Symbol.for("react.fragment"),
    bt = Symbol.for("react.strict_mode"),
    Tt = Symbol.for("react.profiler"),
    Ct = Symbol.for("react.provider"),
    kt = Symbol.for("react.context"),
    Dt = Symbol.for("react.forward_ref"),
    Vt = Symbol.for("react.suspense"),
    Ht = Symbol.for("react.suspense_list"),
    qt = Symbol.for("react.memo"),
    Ft = Symbol.for("react.lazy"),
    Bt = Symbol.for("react.offscreen"),
    Mt = Symbol.iterator;
  function Pt(d) {
    return d === null || typeof d != "object"
      ? null
      : ((d = (Mt && d[Mt]) || d["@@iterator"]),
        typeof d == "function" ? d : null);
  }
  var It = Object.assign,
    Ot;
  function Xt(d) {
    if (Ot === void 0)
      try {
        throw Error();
      } catch (gt) {
        var pe = gt.stack.trim().match(/\n( *(at )?)/);
        Ot = (pe && pe[1]) || "";
      }
    return (
      `
` +
      Ot +
      d
    );
  }
  var sn = !1;
  function Kt(d, pe) {
    if (!d || sn) return "";
    sn = !0;
    var gt = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (pe)
        if (
          ((pe = function () {
            throw Error();
          }),
          Object.defineProperty(pe.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(pe, []);
          } catch (Dn) {
            var yt = Dn;
          }
          Reflect.construct(d, [], pe);
        } else {
          try {
            pe.call();
          } catch (Dn) {
            yt = Dn;
          }
          d.call(pe.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Dn) {
          yt = Dn;
        }
        d();
      }
    } catch (Dn) {
      if (Dn && yt && typeof Dn.stack == "string") {
        for (
          var At = Dn.stack.split(`
`),
            Lt = yt.stack.split(`
`),
            Wt = At.length - 1,
            nn = Lt.length - 1;
          1 <= Wt && 0 <= nn && At[Wt] !== Lt[nn];

        )
          nn--;
        for (; 1 <= Wt && 0 <= nn; Wt--, nn--)
          if (At[Wt] !== Lt[nn]) {
            if (Wt !== 1 || nn !== 1)
              do
                if ((Wt--, nn--, 0 > nn || At[Wt] !== Lt[nn])) {
                  var dn =
                    `
` + At[Wt].replace(" at new ", " at ");
                  return (
                    d.displayName &&
                      dn.includes("<anonymous>") &&
                      (dn = dn.replace("<anonymous>", d.displayName)),
                    dn
                  );
                }
              while (1 <= Wt && 0 <= nn);
            break;
          }
      }
    } finally {
      (sn = !1), (Error.prepareStackTrace = gt);
    }
    return (d = d ? d.displayName || d.name : "") ? Xt(d) : "";
  }
  function tn(d) {
    switch (d.tag) {
      case 5:
        return Xt(d.type);
      case 16:
        return Xt("Lazy");
      case 13:
        return Xt("Suspense");
      case 19:
        return Xt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (d = Kt(d.type, !1)), d;
      case 11:
        return (d = Kt(d.type.render, !1)), d;
      case 1:
        return (d = Kt(d.type, !0)), d;
      default:
        return "";
    }
  }
  function pn(d) {
    if (d == null) return null;
    if (typeof d == "function") return d.displayName || d.name || null;
    if (typeof d == "string") return d;
    switch (d) {
      case wt:
        return "Fragment";
      case St:
        return "Portal";
      case Tt:
        return "Profiler";
      case bt:
        return "StrictMode";
      case Vt:
        return "Suspense";
      case Ht:
        return "SuspenseList";
    }
    if (typeof d == "object")
      switch (d.$$typeof) {
        case kt:
          return (d.displayName || "Context") + ".Consumer";
        case Ct:
          return (d._context.displayName || "Context") + ".Provider";
        case Dt:
          var pe = d.render;
          return (
            (d = d.displayName),
            d ||
              ((d = pe.displayName || pe.name || ""),
              (d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")),
            d
          );
        case qt:
          return (
            (pe = d.displayName || null),
            pe !== null ? pe : pn(d.type) || "Memo"
          );
        case Ft:
          (pe = d._payload), (d = d._init);
          try {
            return pn(d(pe));
          } catch {}
      }
    return null;
  }
  function _n(d) {
    var pe = d.type;
    switch (d.tag) {
      case 24:
        return "Cache";
      case 9:
        return (pe.displayName || "Context") + ".Consumer";
      case 10:
        return (pe._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (d = pe.render),
          (d = d.displayName || d.name || ""),
          pe.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return pe;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return pn(pe);
      case 8:
        return pe === bt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof pe == "function") return pe.displayName || pe.name || null;
        if (typeof pe == "string") return pe;
    }
    return null;
  }
  function bn(d) {
    switch (typeof d) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return d;
      case "object":
        return d;
      default:
        return "";
    }
  }
  function $n(d) {
    var pe = d.type;
    return (
      (d = d.nodeName) &&
      d.toLowerCase() === "input" &&
      (pe === "checkbox" || pe === "radio")
    );
  }
  function tr(d) {
    var pe = $n(d) ? "checked" : "value",
      gt = Object.getOwnPropertyDescriptor(d.constructor.prototype, pe),
      yt = "" + d[pe];
    if (
      !d.hasOwnProperty(pe) &&
      typeof gt < "u" &&
      typeof gt.get == "function" &&
      typeof gt.set == "function"
    ) {
      var At = gt.get,
        Lt = gt.set;
      return (
        Object.defineProperty(d, pe, {
          configurable: !0,
          get: function () {
            return At.call(this);
          },
          set: function (Wt) {
            (yt = "" + Wt), Lt.call(this, Wt);
          },
        }),
        Object.defineProperty(d, pe, { enumerable: gt.enumerable }),
        {
          getValue: function () {
            return yt;
          },
          setValue: function (Wt) {
            yt = "" + Wt;
          },
          stopTracking: function () {
            (d._valueTracker = null), delete d[pe];
          },
        }
      );
    }
  }
  function ur(d) {
    d._valueTracker || (d._valueTracker = tr(d));
  }
  function _r(d) {
    if (!d) return !1;
    var pe = d._valueTracker;
    if (!pe) return !0;
    var gt = pe.getValue(),
      yt = "";
    return (
      d && (yt = $n(d) ? (d.checked ? "true" : "false") : d.value),
      (d = yt),
      d !== gt ? (pe.setValue(d), !0) : !1
    );
  }
  function Bn(d) {
    if (
      ((d = d || (typeof document < "u" ? document : void 0)), typeof d > "u")
    )
      return null;
    try {
      return d.activeElement || d.body;
    } catch {
      return d.body;
    }
  }
  function jt(d, pe) {
    var gt = pe.checked;
    return It({}, pe, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: gt ?? d._wrapperState.initialChecked,
    });
  }
  function Yn(d, pe) {
    var gt = pe.defaultValue == null ? "" : pe.defaultValue,
      yt = pe.checked != null ? pe.checked : pe.defaultChecked;
    (gt = bn(pe.value != null ? pe.value : gt)),
      (d._wrapperState = {
        initialChecked: yt,
        initialValue: gt,
        controlled:
          pe.type === "checkbox" || pe.type === "radio"
            ? pe.checked != null
            : pe.value != null,
      });
  }
  function zn(d, pe) {
    (pe = pe.checked), pe != null && st(d, "checked", pe, !1);
  }
  function rn(d, pe) {
    zn(d, pe);
    var gt = bn(pe.value),
      yt = pe.type;
    if (gt != null)
      yt === "number"
        ? ((gt === 0 && d.value === "") || d.value != gt) && (d.value = "" + gt)
        : d.value !== "" + gt && (d.value = "" + gt);
    else if (yt === "submit" || yt === "reset") {
      d.removeAttribute("value");
      return;
    }
    pe.hasOwnProperty("value")
      ? or(d, pe.type, gt)
      : pe.hasOwnProperty("defaultValue") &&
        or(d, pe.type, bn(pe.defaultValue)),
      pe.checked == null &&
        pe.defaultChecked != null &&
        (d.defaultChecked = !!pe.defaultChecked);
  }
  function In(d, pe, gt) {
    if (pe.hasOwnProperty("value") || pe.hasOwnProperty("defaultValue")) {
      var yt = pe.type;
      if (
        !(
          (yt !== "submit" && yt !== "reset") ||
          (pe.value !== void 0 && pe.value !== null)
        )
      )
        return;
      (pe = "" + d._wrapperState.initialValue),
        gt || pe === d.value || (d.value = pe),
        (d.defaultValue = pe);
    }
    (gt = d.name),
      gt !== "" && (d.name = ""),
      (d.defaultChecked = !!d._wrapperState.initialChecked),
      gt !== "" && (d.name = gt);
  }
  function or(d, pe, gt) {
    (pe !== "number" || Bn(d.ownerDocument) !== d) &&
      (gt == null
        ? (d.defaultValue = "" + d._wrapperState.initialValue)
        : d.defaultValue !== "" + gt && (d.defaultValue = "" + gt));
  }
  var Gn = Array.isArray;
  function Yt(d, pe, gt, yt) {
    if (((d = d.options), pe)) {
      pe = {};
      for (var At = 0; At < gt.length; At++) pe["$" + gt[At]] = !0;
      for (gt = 0; gt < d.length; gt++)
        (At = pe.hasOwnProperty("$" + d[gt].value)),
          d[gt].selected !== At && (d[gt].selected = At),
          At && yt && (d[gt].defaultSelected = !0);
    } else {
      for (gt = "" + bn(gt), pe = null, At = 0; At < d.length; At++) {
        if (d[At].value === gt) {
          (d[At].selected = !0), yt && (d[At].defaultSelected = !0);
          return;
        }
        pe !== null || d[At].disabled || (pe = d[At]);
      }
      pe !== null && (pe.selected = !0);
    }
  }
  function Gt(d, pe) {
    if (pe.dangerouslySetInnerHTML != null) throw Error(t(91));
    return It({}, pe, {
      value: void 0,
      defaultValue: void 0,
      children: "" + d._wrapperState.initialValue,
    });
  }
  function hn(d, pe) {
    var gt = pe.value;
    if (gt == null) {
      if (((gt = pe.children), (pe = pe.defaultValue), gt != null)) {
        if (pe != null) throw Error(t(92));
        if (Gn(gt)) {
          if (1 < gt.length) throw Error(t(93));
          gt = gt[0];
        }
        pe = gt;
      }
      pe == null && (pe = ""), (gt = pe);
    }
    d._wrapperState = { initialValue: bn(gt) };
  }
  function En(d, pe) {
    var gt = bn(pe.value),
      yt = bn(pe.defaultValue);
    gt != null &&
      ((gt = "" + gt),
      gt !== d.value && (d.value = gt),
      pe.defaultValue == null &&
        d.defaultValue !== gt &&
        (d.defaultValue = gt)),
      yt != null && (d.defaultValue = "" + yt);
  }
  function Ln(d) {
    var pe = d.textContent;
    pe === d._wrapperState.initialValue &&
      pe !== "" &&
      pe !== null &&
      (d.value = pe);
  }
  function mn(d) {
    switch (d) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Vn(d, pe) {
    return d == null || d === "http://www.w3.org/1999/xhtml"
      ? mn(pe)
      : d === "http://www.w3.org/2000/svg" && pe === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : d;
  }
  var Fn,
    nr = (function (d) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (pe, gt, yt, At) {
            MSApp.execUnsafeLocalFunction(function () {
              return d(pe, gt, yt, At);
            });
          }
        : d;
    })(function (d, pe) {
      if (d.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in d)
        d.innerHTML = pe;
      else {
        for (
          Fn = Fn || document.createElement("div"),
            Fn.innerHTML = "<svg>" + pe.valueOf().toString() + "</svg>",
            pe = Fn.firstChild;
          d.firstChild;

        )
          d.removeChild(d.firstChild);
        for (; pe.firstChild; ) d.appendChild(pe.firstChild);
      }
    });
  function yr(d, pe) {
    if (pe) {
      var gt = d.firstChild;
      if (gt && gt === d.lastChild && gt.nodeType === 3) {
        gt.nodeValue = pe;
        return;
      }
    }
    d.textContent = pe;
  }
  var qn = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    jn = ["Webkit", "ms", "Moz", "O"];
  Object.keys(qn).forEach(function (d) {
    jn.forEach(function (pe) {
      (pe = pe + d.charAt(0).toUpperCase() + d.substring(1)), (qn[pe] = qn[d]);
    });
  });
  function Jn(d, pe, gt) {
    return pe == null || typeof pe == "boolean" || pe === ""
      ? ""
      : gt ||
        typeof pe != "number" ||
        pe === 0 ||
        (qn.hasOwnProperty(d) && qn[d])
      ? ("" + pe).trim()
      : pe + "px";
  }
  function mr(d, pe) {
    d = d.style;
    for (var gt in pe)
      if (pe.hasOwnProperty(gt)) {
        var yt = gt.indexOf("--") === 0,
          At = Jn(gt, pe[gt], yt);
        gt === "float" && (gt = "cssFloat"),
          yt ? d.setProperty(gt, At) : (d[gt] = At);
      }
  }
  var Sr = It(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function Ur(d, pe) {
    if (pe) {
      if (Sr[d] && (pe.children != null || pe.dangerouslySetInnerHTML != null))
        throw Error(t(137, d));
      if (pe.dangerouslySetInnerHTML != null) {
        if (pe.children != null) throw Error(t(60));
        if (
          typeof pe.dangerouslySetInnerHTML != "object" ||
          !("__html" in pe.dangerouslySetInnerHTML)
        )
          throw Error(t(61));
      }
      if (pe.style != null && typeof pe.style != "object") throw Error(t(62));
    }
  }
  function Pr(d, pe) {
    if (d.indexOf("-") === -1) return typeof pe.is == "string";
    switch (d) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Hr = null;
  function cn(d) {
    return (
      (d = d.target || d.srcElement || window),
      d.correspondingUseElement && (d = d.correspondingUseElement),
      d.nodeType === 3 ? d.parentNode : d
    );
  }
  var An = null,
    Mn = null,
    Hn = null;
  function hr(d) {
    if ((d = ko(d))) {
      if (typeof An != "function") throw Error(t(280));
      var pe = d.stateNode;
      pe && ((pe = Lc(pe)), An(d.stateNode, d.type, pe));
    }
  }
  function pr(d) {
    Mn ? (Hn ? Hn.push(d) : (Hn = [d])) : (Mn = d);
  }
  function jr() {
    if (Mn) {
      var d = Mn,
        pe = Hn;
      if (((Hn = Mn = null), hr(d), pe))
        for (d = 0; d < pe.length; d++) hr(pe[d]);
    }
  }
  function fi(d, pe) {
    return d(pe);
  }
  function wi() {}
  var wr = !1;
  function Rr(d, pe, gt) {
    if (wr) return d(pe, gt);
    wr = !0;
    try {
      return fi(d, pe, gt);
    } finally {
      (wr = !1), (Mn !== null || Hn !== null) && (wi(), jr());
    }
  }
  function $r(d, pe) {
    var gt = d.stateNode;
    if (gt === null) return null;
    var yt = Lc(gt);
    if (yt === null) return null;
    gt = yt[pe];
    e: switch (pe) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (yt = !yt.disabled) ||
          ((d = d.type),
          (yt = !(
            d === "button" ||
            d === "input" ||
            d === "select" ||
            d === "textarea"
          ))),
          (d = !yt);
        break e;
      default:
        d = !1;
    }
    if (d) return null;
    if (gt && typeof gt != "function") throw Error(t(231, pe, typeof gt));
    return gt;
  }
  var xr = !1;
  if (l)
    try {
      var Fr = {};
      Object.defineProperty(Fr, "passive", {
        get: function () {
          xr = !0;
        },
      }),
        window.addEventListener("test", Fr, Fr),
        window.removeEventListener("test", Fr, Fr);
    } catch {
      xr = !1;
    }
  function Cr(d, pe, gt, yt, At, Lt, Wt, nn, dn) {
    var Dn = Array.prototype.slice.call(arguments, 3);
    try {
      pe.apply(gt, Dn);
    } catch (sr) {
      this.onError(sr);
    }
  }
  var zr = !1,
    pi = null,
    qr = !1,
    Ir = null,
    Pi = {
      onError: function (d) {
        (zr = !0), (pi = d);
      },
    };
  function mi(d, pe, gt, yt, At, Lt, Wt, nn, dn) {
    (zr = !1), (pi = null), Cr.apply(Pi, arguments);
  }
  function Ut(d, pe, gt, yt, At, Lt, Wt, nn, dn) {
    if ((mi.apply(this, arguments), zr)) {
      if (zr) {
        var Dn = pi;
        (zr = !1), (pi = null);
      } else throw Error(t(198));
      qr || ((qr = !0), (Ir = Dn));
    }
  }
  function $t(d) {
    var pe = d,
      gt = d;
    if (d.alternate) for (; pe.return; ) pe = pe.return;
    else {
      d = pe;
      do (pe = d), (pe.flags & 4098) !== 0 && (gt = pe.return), (d = pe.return);
      while (d);
    }
    return pe.tag === 3 ? gt : null;
  }
  function un(d) {
    if (d.tag === 13) {
      var pe = d.memoizedState;
      if (
        (pe === null &&
          ((d = d.alternate), d !== null && (pe = d.memoizedState)),
        pe !== null)
      )
        return pe.dehydrated;
    }
    return null;
  }
  function yn(d) {
    if ($t(d) !== d) throw Error(t(188));
  }
  function Rn(d) {
    var pe = d.alternate;
    if (!pe) {
      if (((pe = $t(d)), pe === null)) throw Error(t(188));
      return pe !== d ? null : d;
    }
    for (var gt = d, yt = pe; ; ) {
      var At = gt.return;
      if (At === null) break;
      var Lt = At.alternate;
      if (Lt === null) {
        if (((yt = At.return), yt !== null)) {
          gt = yt;
          continue;
        }
        break;
      }
      if (At.child === Lt.child) {
        for (Lt = At.child; Lt; ) {
          if (Lt === gt) return yn(At), d;
          if (Lt === yt) return yn(At), pe;
          Lt = Lt.sibling;
        }
        throw Error(t(188));
      }
      if (gt.return !== yt.return) (gt = At), (yt = Lt);
      else {
        for (var Wt = !1, nn = At.child; nn; ) {
          if (nn === gt) {
            (Wt = !0), (gt = At), (yt = Lt);
            break;
          }
          if (nn === yt) {
            (Wt = !0), (yt = At), (gt = Lt);
            break;
          }
          nn = nn.sibling;
        }
        if (!Wt) {
          for (nn = Lt.child; nn; ) {
            if (nn === gt) {
              (Wt = !0), (gt = Lt), (yt = At);
              break;
            }
            if (nn === yt) {
              (Wt = !0), (yt = Lt), (gt = At);
              break;
            }
            nn = nn.sibling;
          }
          if (!Wt) throw Error(t(189));
        }
      }
      if (gt.alternate !== yt) throw Error(t(190));
    }
    if (gt.tag !== 3) throw Error(t(188));
    return gt.stateNode.current === gt ? d : pe;
  }
  function kn(d) {
    return (d = Rn(d)), d !== null ? er(d) : null;
  }
  function er(d) {
    if (d.tag === 5 || d.tag === 6) return d;
    for (d = d.child; d !== null; ) {
      var pe = er(d);
      if (pe !== null) return pe;
      d = d.sibling;
    }
    return null;
  }
  var Xn = e.unstable_scheduleCallback,
    zt = e.unstable_cancelCallback,
    Zt = e.unstable_shouldYield,
    an = e.unstable_requestPaint,
    Qt = e.unstable_now,
    fn = e.unstable_getCurrentPriorityLevel,
    wn = e.unstable_ImmediatePriority,
    On = e.unstable_UserBlockingPriority,
    Kn = e.unstable_NormalPriority,
    Zn = e.unstable_LowPriority,
    ar = e.unstable_IdlePriority,
    cr = null,
    Qn = null;
  function gr(d) {
    if (Qn && typeof Qn.onCommitFiberRoot == "function")
      try {
        Qn.onCommitFiberRoot(cr, d, void 0, (d.current.flags & 128) === 128);
      } catch {}
  }
  var Tr = Math.clz32 ? Math.clz32 : Br,
    Qr = Math.log,
    Dr = Math.LN2;
  function Br(d) {
    return (d >>>= 0), d === 0 ? 32 : (31 - ((Qr(d) / Dr) | 0)) | 0;
  }
  var Mr = 64,
    oi = 4194304;
  function Xr(d) {
    switch (d & -d) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return d & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return d;
    }
  }
  function ti(d, pe) {
    var gt = d.pendingLanes;
    if (gt === 0) return 0;
    var yt = 0,
      At = d.suspendedLanes,
      Lt = d.pingedLanes,
      Wt = gt & 268435455;
    if (Wt !== 0) {
      var nn = Wt & ~At;
      nn !== 0 ? (yt = Xr(nn)) : ((Lt &= Wt), Lt !== 0 && (yt = Xr(Lt)));
    } else
      (Wt = gt & ~At), Wt !== 0 ? (yt = Xr(Wt)) : Lt !== 0 && (yt = Xr(Lt));
    if (yt === 0) return 0;
    if (
      pe !== 0 &&
      pe !== yt &&
      (pe & At) === 0 &&
      ((At = yt & -yt),
      (Lt = pe & -pe),
      At >= Lt || (At === 16 && (Lt & 4194240) !== 0))
    )
      return pe;
    if (((yt & 4) !== 0 && (yt |= gt & 16), (pe = d.entangledLanes), pe !== 0))
      for (d = d.entanglements, pe &= yt; 0 < pe; )
        (gt = 31 - Tr(pe)), (At = 1 << gt), (yt |= d[gt]), (pe &= ~At);
    return yt;
  }
  function bi(d, pe) {
    switch (d) {
      case 1:
      case 2:
      case 4:
        return pe + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return pe + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function ni(d, pe) {
    for (
      var gt = d.suspendedLanes,
        yt = d.pingedLanes,
        At = d.expirationTimes,
        Lt = d.pendingLanes;
      0 < Lt;

    ) {
      var Wt = 31 - Tr(Lt),
        nn = 1 << Wt,
        dn = At[Wt];
      dn === -1
        ? ((nn & gt) === 0 || (nn & yt) !== 0) && (At[Wt] = bi(nn, pe))
        : dn <= pe && (d.expiredLanes |= nn),
        (Lt &= ~nn);
    }
  }
  function ai(d) {
    return (
      (d = d.pendingLanes & -1073741825),
      d !== 0 ? d : d & 1073741824 ? 1073741824 : 0
    );
  }
  function Kr() {
    var d = Mr;
    return (Mr <<= 1), (Mr & 4194240) === 0 && (Mr = 64), d;
  }
  function Ii(d) {
    for (var pe = [], gt = 0; 31 > gt; gt++) pe.push(d);
    return pe;
  }
  function gi(d, pe, gt) {
    (d.pendingLanes |= pe),
      pe !== 536870912 && ((d.suspendedLanes = 0), (d.pingedLanes = 0)),
      (d = d.eventTimes),
      (pe = 31 - Tr(pe)),
      (d[pe] = gt);
  }
  function Mi(d, pe) {
    var gt = d.pendingLanes & ~pe;
    (d.pendingLanes = pe),
      (d.suspendedLanes = 0),
      (d.pingedLanes = 0),
      (d.expiredLanes &= pe),
      (d.mutableReadLanes &= pe),
      (d.entangledLanes &= pe),
      (pe = d.entanglements);
    var yt = d.eventTimes;
    for (d = d.expirationTimes; 0 < gt; ) {
      var At = 31 - Tr(gt),
        Lt = 1 << At;
      (pe[At] = 0), (yt[At] = -1), (d[At] = -1), (gt &= ~Lt);
    }
  }
  function Ui(d, pe) {
    var gt = (d.entangledLanes |= pe);
    for (d = d.entanglements; gt; ) {
      var yt = 31 - Tr(gt),
        At = 1 << yt;
      (At & pe) | (d[yt] & pe) && (d[yt] |= pe), (gt &= ~At);
    }
  }
  var di = 0;
  function ps(d) {
    return (
      (d &= -d),
      1 < d ? (4 < d ? ((d & 268435455) !== 0 ? 16 : 536870912) : 4) : 1
    );
  }
  var la,
    El,
    oc,
    za,
    Va,
    Eo = !1,
    Ga = [],
    qs = null,
    ci = null,
    ro = null,
    To = new Map(),
    Xo = new Map(),
    po = [],
    Zc =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function ji(d, pe) {
    switch (d) {
      case "focusin":
      case "focusout":
        qs = null;
        break;
      case "dragenter":
      case "dragleave":
        ci = null;
        break;
      case "mouseover":
      case "mouseout":
        ro = null;
        break;
      case "pointerover":
      case "pointerout":
        To.delete(pe.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Xo.delete(pe.pointerId);
    }
  }
  function bo(d, pe, gt, yt, At, Lt) {
    return d === null || d.nativeEvent !== Lt
      ? ((d = {
          blockedOn: pe,
          domEventName: gt,
          eventSystemFlags: yt,
          nativeEvent: Lt,
          targetContainers: [At],
        }),
        pe !== null && ((pe = ko(pe)), pe !== null && El(pe)),
        d)
      : ((d.eventSystemFlags |= yt),
        (pe = d.targetContainers),
        At !== null && pe.indexOf(At) === -1 && pe.push(At),
        d);
  }
  function ac(d, pe, gt, yt, At) {
    switch (pe) {
      case "focusin":
        return (qs = bo(qs, d, pe, gt, yt, At)), !0;
      case "dragenter":
        return (ci = bo(ci, d, pe, gt, yt, At)), !0;
      case "mouseover":
        return (ro = bo(ro, d, pe, gt, yt, At)), !0;
      case "pointerover":
        var Lt = At.pointerId;
        return To.set(Lt, bo(To.get(Lt) || null, d, pe, gt, yt, At)), !0;
      case "gotpointercapture":
        return (
          (Lt = At.pointerId),
          Xo.set(Lt, bo(Xo.get(Lt) || null, d, pe, gt, yt, At)),
          !0
        );
    }
    return !1;
  }
  function Ha(d) {
    var pe = na(d.target);
    if (pe !== null) {
      var gt = $t(pe);
      if (gt !== null) {
        if (((pe = gt.tag), pe === 13)) {
          if (((pe = un(gt)), pe !== null)) {
            (d.blockedOn = pe),
              Va(d.priority, function () {
                oc(gt);
              });
            return;
          }
        } else if (
          pe === 3 &&
          gt.stateNode.current.memoizedState.isDehydrated
        ) {
          d.blockedOn = gt.tag === 3 ? gt.stateNode.containerInfo : null;
          return;
        }
      }
    }
    d.blockedOn = null;
  }
  function Sn(d) {
    if (d.blockedOn !== null) return !1;
    for (var pe = d.targetContainers; 0 < pe.length; ) {
      var gt = xs(d.domEventName, d.eventSystemFlags, pe[0], d.nativeEvent);
      if (gt === null) {
        gt = d.nativeEvent;
        var yt = new gt.constructor(gt.type, gt);
        (Hr = yt), gt.target.dispatchEvent(yt), (Hr = null);
      } else
        return (pe = ko(gt)), pe !== null && El(pe), (d.blockedOn = gt), !1;
      pe.shift();
    }
    return !0;
  }
  function en(d, pe, gt) {
    Sn(d) && gt.delete(pe);
  }
  function ln() {
    (Eo = !1),
      qs !== null && Sn(qs) && (qs = null),
      ci !== null && Sn(ci) && (ci = null),
      ro !== null && Sn(ro) && (ro = null),
      To.forEach(en),
      Xo.forEach(en);
  }
  function Un(d, pe) {
    d.blockedOn === pe &&
      ((d.blockedOn = null),
      Eo ||
        ((Eo = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, ln)));
  }
  function rr(d) {
    function pe(At) {
      return Un(At, d);
    }
    if (0 < Ga.length) {
      Un(Ga[0], d);
      for (var gt = 1; gt < Ga.length; gt++) {
        var yt = Ga[gt];
        yt.blockedOn === d && (yt.blockedOn = null);
      }
    }
    for (
      qs !== null && Un(qs, d),
        ci !== null && Un(ci, d),
        ro !== null && Un(ro, d),
        To.forEach(pe),
        Xo.forEach(pe),
        gt = 0;
      gt < po.length;
      gt++
    )
      (yt = po[gt]), yt.blockedOn === d && (yt.blockedOn = null);
    for (; 0 < po.length && ((gt = po[0]), gt.blockedOn === null); )
      Ha(gt), gt.blockedOn === null && po.shift();
  }
  var Yr = vt.ReactCurrentBatchConfig,
    yi = !0;
  function Zi(d, pe, gt, yt) {
    var At = di,
      Lt = Yr.transition;
    Yr.transition = null;
    try {
      (di = 1), Wa(d, pe, gt, yt);
    } finally {
      (di = At), (Yr.transition = Lt);
    }
  }
  function Yo(d, pe, gt, yt) {
    var At = di,
      Lt = Yr.transition;
    Yr.transition = null;
    try {
      (di = 4), Wa(d, pe, gt, yt);
    } finally {
      (di = At), (Yr.transition = Lt);
    }
  }
  function Wa(d, pe, gt, yt) {
    if (yi) {
      var At = xs(d, pe, gt, yt);
      if (At === null) Mc(d, pe, yt, ja, gt), ji(d, yt);
      else if (ac(At, d, pe, gt, yt)) yt.stopPropagation();
      else if ((ji(d, yt), pe & 4 && -1 < Zc.indexOf(d))) {
        for (; At !== null; ) {
          var Lt = ko(At);
          if (
            (Lt !== null && la(Lt),
            (Lt = xs(d, pe, gt, yt)),
            Lt === null && Mc(d, pe, yt, ja, gt),
            Lt === At)
          )
            break;
          At = Lt;
        }
        At !== null && yt.stopPropagation();
      } else Mc(d, pe, yt, null, gt);
    }
  }
  var ja = null;
  function xs(d, pe, gt, yt) {
    if (((ja = null), (d = cn(yt)), (d = na(d)), d !== null))
      if (((pe = $t(d)), pe === null)) d = null;
      else if (((gt = pe.tag), gt === 13)) {
        if (((d = un(pe)), d !== null)) return d;
        d = null;
      } else if (gt === 3) {
        if (pe.stateNode.current.memoizedState.isDehydrated)
          return pe.tag === 3 ? pe.stateNode.containerInfo : null;
        d = null;
      } else pe !== d && (d = null);
    return (ja = d), null;
  }
  function Tl(d) {
    switch (d) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (fn()) {
          case wn:
            return 1;
          case On:
            return 4;
          case Kn:
          case Zn:
            return 16;
          case ar:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ps = null,
    $a = null,
    Rs = null;
  function bl() {
    if (Rs) return Rs;
    var d,
      pe = $a,
      gt = pe.length,
      yt,
      At = "value" in Ps ? Ps.value : Ps.textContent,
      Lt = At.length;
    for (d = 0; d < gt && pe[d] === At[d]; d++);
    var Wt = gt - d;
    for (yt = 1; yt <= Wt && pe[gt - yt] === At[Lt - yt]; yt++);
    return (Rs = At.slice(d, 1 < yt ? 1 - yt : void 0));
  }
  function ca(d) {
    var pe = d.keyCode;
    return (
      "charCode" in d
        ? ((d = d.charCode), d === 0 && pe === 13 && (d = 13))
        : (d = pe),
      d === 10 && (d = 13),
      32 <= d || d === 13 ? d : 0
    );
  }
  function Mo() {
    return !0;
  }
  function lc() {
    return !1;
  }
  function Ss(d) {
    function pe(gt, yt, At, Lt, Wt) {
      (this._reactName = gt),
        (this._targetInst = At),
        (this.type = yt),
        (this.nativeEvent = Lt),
        (this.target = Wt),
        (this.currentTarget = null);
      for (var nn in d)
        d.hasOwnProperty(nn) &&
          ((gt = d[nn]), (this[nn] = gt ? gt(Lt) : Lt[nn]));
      return (
        (this.isDefaultPrevented = (
          Lt.defaultPrevented != null
            ? Lt.defaultPrevented
            : Lt.returnValue === !1
        )
          ? Mo
          : lc),
        (this.isPropagationStopped = lc),
        this
      );
    }
    return (
      It(pe.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var gt = this.nativeEvent;
          gt &&
            (gt.preventDefault
              ? gt.preventDefault()
              : typeof gt.returnValue != "unknown" && (gt.returnValue = !1),
            (this.isDefaultPrevented = Mo));
        },
        stopPropagation: function () {
          var gt = this.nativeEvent;
          gt &&
            (gt.stopPropagation
              ? gt.stopPropagation()
              : typeof gt.cancelBubble != "unknown" && (gt.cancelBubble = !0),
            (this.isPropagationStopped = Mo));
        },
        persist: function () {},
        isPersistent: Mo,
      }),
      pe
    );
  }
  var ua = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (d) {
        return d.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Ml = Ss(ua),
    fa = It({}, ua, { view: 0, detail: 0 }),
    qa = Ss(fa),
    Is,
    Xs,
    Ys,
    Xa = It({}, fa, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Zo,
      button: 0,
      buttons: 0,
      relatedTarget: function (d) {
        return d.relatedTarget === void 0
          ? d.fromElement === d.srcElement
            ? d.toElement
            : d.fromElement
          : d.relatedTarget;
      },
      movementX: function (d) {
        return "movementX" in d
          ? d.movementX
          : (d !== Ys &&
              (Ys && d.type === "mousemove"
                ? ((Is = d.screenX - Ys.screenX), (Xs = d.screenY - Ys.screenY))
                : (Xs = Is = 0),
              (Ys = d)),
            Is);
      },
      movementY: function (d) {
        return "movementY" in d ? d.movementY : Xs;
      },
    }),
    Qc = Ss(Xa),
    Co = It({}, Xa, { dataTransfer: 0 }),
    Ko = Ss(Co),
    cc = It({}, fa, { relatedTarget: 0 }),
    uc = Ss(cc),
    fc = It({}, ua, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Hu = Ss(fc),
    Wu = It({}, ua, {
      clipboardData: function (d) {
        return "clipboardData" in d ? d.clipboardData : window.clipboardData;
      },
    }),
    Jc = Ss(Wu),
    hc = It({}, ua, { data: 0 }),
    eu = Ss(hc),
    ju = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    $u = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    tu = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function Ya(d) {
    var pe = this.nativeEvent;
    return pe.getModifierState
      ? pe.getModifierState(d)
      : (d = tu[d])
      ? !!pe[d]
      : !1;
  }
  function Zo() {
    return Ya;
  }
  var dc = It({}, fa, {
      key: function (d) {
        if (d.key) {
          var pe = ju[d.key] || d.key;
          if (pe !== "Unidentified") return pe;
        }
        return d.type === "keypress"
          ? ((d = ca(d)), d === 13 ? "Enter" : String.fromCharCode(d))
          : d.type === "keydown" || d.type === "keyup"
          ? $u[d.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Zo,
      charCode: function (d) {
        return d.type === "keypress" ? ca(d) : 0;
      },
      keyCode: function (d) {
        return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
      },
      which: function (d) {
        return d.type === "keypress"
          ? ca(d)
          : d.type === "keydown" || d.type === "keyup"
          ? d.keyCode
          : 0;
      },
    }),
    pc = Ss(dc),
    Ks = It({}, Xa, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Ns = Ss(Ks),
    ha = It({}, fa, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Zo,
    }),
    Ao = Ss(ha),
    Po = It({}, ua, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    da = Ss(Po),
    qu = It({}, Xa, {
      deltaX: function (d) {
        return "deltaX" in d
          ? d.deltaX
          : "wheelDeltaX" in d
          ? -d.wheelDeltaX
          : 0;
      },
      deltaY: function (d) {
        return "deltaY" in d
          ? d.deltaY
          : "wheelDeltaY" in d
          ? -d.wheelDeltaY
          : "wheelDelta" in d
          ? -d.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    nu = Ss(qu),
    ru = [9, 13, 27, 32],
    ws = l && "CompositionEvent" in window,
    as = null;
  l && "documentMode" in document && (as = document.documentMode);
  var Ni = l && "TextEvent" in window && !as,
    Ka = l && (!ws || (as && 8 < as && 11 >= as)),
    Zs = " ",
    iu = !1;
  function su(d, pe) {
    switch (d) {
      case "keyup":
        return ru.indexOf(pe.keyCode) !== -1;
      case "keydown":
        return pe.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function mc(d) {
    return (d = d.detail), typeof d == "object" && "data" in d ? d.data : null;
  }
  var Qo = !1;
  function Xu(d, pe) {
    switch (d) {
      case "compositionend":
        return mc(pe);
      case "keypress":
        return pe.which !== 32 ? null : ((iu = !0), Zs);
      case "textInput":
        return (d = pe.data), d === Zs && iu ? null : d;
      default:
        return null;
    }
  }
  function Cl(d, pe) {
    if (Qo)
      return d === "compositionend" || (!ws && su(d, pe))
        ? ((d = bl()), (Rs = $a = Ps = null), (Qo = !1), d)
        : null;
    switch (d) {
      case "paste":
        return null;
      case "keypress":
        if (
          !(pe.ctrlKey || pe.altKey || pe.metaKey) ||
          (pe.ctrlKey && pe.altKey)
        ) {
          if (pe.char && 1 < pe.char.length) return pe.char;
          if (pe.which) return String.fromCharCode(pe.which);
        }
        return null;
      case "compositionend":
        return Ka && pe.locale !== "ko" ? null : pe.data;
      default:
        return null;
    }
  }
  var Za = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function gc(d) {
    var pe = d && d.nodeName && d.nodeName.toLowerCase();
    return pe === "input" ? !!Za[d.type] : pe === "textarea";
  }
  function Qa(d, pe, gt, yt) {
    pr(yt),
      (pe = Cc(pe, "onChange")),
      0 < pe.length &&
        ((gt = new Ml("onChange", "change", null, gt, yt)),
        d.push({ event: gt, listeners: pe }));
  }
  var Jo = null,
    Ja = null;
  function Yu(d) {
    rl(d, 0);
  }
  function Ro(d) {
    var pe = $i(d);
    if (_r(pe)) return d;
  }
  function Ku(d, pe) {
    if (d === "change") return pe;
  }
  var el = !1;
  if (l) {
    var Ls;
    if (l) {
      var pa = "oninput" in document;
      if (!pa) {
        var ma = document.createElement("div");
        ma.setAttribute("oninput", "return;"),
          (pa = typeof ma.oninput == "function");
      }
      Ls = pa;
    } else Ls = !1;
    el = Ls && (!document.documentMode || 9 < document.documentMode);
  }
  function io() {
    Jo && (Jo.detachEvent("onpropertychange", vc), (Ja = Jo = null));
  }
  function vc(d) {
    if (d.propertyName === "value" && Ro(Ja)) {
      var pe = [];
      Qa(pe, Ja, d, cn(d)), Rr(Yu, pe);
    }
  }
  function tl(d, pe, gt) {
    d === "focusin"
      ? (io(), (Jo = pe), (Ja = gt), Jo.attachEvent("onpropertychange", vc))
      : d === "focusout" && io();
  }
  function Zu(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown")
      return Ro(Ja);
  }
  function ou(d, pe) {
    if (d === "click") return Ro(pe);
  }
  function zi(d, pe) {
    if (d === "input" || d === "change") return Ro(pe);
  }
  function _c(d, pe) {
    return (
      (d === pe && (d !== 0 || 1 / d === 1 / pe)) || (d !== d && pe !== pe)
    );
  }
  var Bs = typeof Object.is == "function" ? Object.is : _c;
  function ga(d, pe) {
    if (Bs(d, pe)) return !0;
    if (
      typeof d != "object" ||
      d === null ||
      typeof pe != "object" ||
      pe === null
    )
      return !1;
    var gt = Object.keys(d),
      yt = Object.keys(pe);
    if (gt.length !== yt.length) return !1;
    for (yt = 0; yt < gt.length; yt++) {
      var At = gt[yt];
      if (!c.call(pe, At) || !Bs(d[At], pe[At])) return !1;
    }
    return !0;
  }
  function Al(d) {
    for (; d && d.firstChild; ) d = d.firstChild;
    return d;
  }
  function Us(d, pe) {
    var gt = Al(d);
    d = 0;
    for (var yt; gt; ) {
      if (gt.nodeType === 3) {
        if (((yt = d + gt.textContent.length), d <= pe && yt >= pe))
          return { node: gt, offset: pe - d };
        d = yt;
      }
      e: {
        for (; gt; ) {
          if (gt.nextSibling) {
            gt = gt.nextSibling;
            break e;
          }
          gt = gt.parentNode;
        }
        gt = void 0;
      }
      gt = Al(gt);
    }
  }
  function va(d, pe) {
    return d && pe
      ? d === pe
        ? !0
        : d && d.nodeType === 3
        ? !1
        : pe && pe.nodeType === 3
        ? va(d, pe.parentNode)
        : "contains" in d
        ? d.contains(pe)
        : d.compareDocumentPosition
        ? !!(d.compareDocumentPosition(pe) & 16)
        : !1
      : !1;
  }
  function Vi() {
    for (var d = window, pe = Bn(); pe instanceof d.HTMLIFrameElement; ) {
      try {
        var gt = typeof pe.contentWindow.location.href == "string";
      } catch {
        gt = !1;
      }
      if (gt) d = pe.contentWindow;
      else break;
      pe = Bn(d.document);
    }
    return pe;
  }
  function es(d) {
    var pe = d && d.nodeName && d.nodeName.toLowerCase();
    return (
      pe &&
      ((pe === "input" &&
        (d.type === "text" ||
          d.type === "search" ||
          d.type === "tel" ||
          d.type === "url" ||
          d.type === "password")) ||
        pe === "textarea" ||
        d.contentEditable === "true")
    );
  }
  function ts(d) {
    var pe = Vi(),
      gt = d.focusedElem,
      yt = d.selectionRange;
    if (
      pe !== gt &&
      gt &&
      gt.ownerDocument &&
      va(gt.ownerDocument.documentElement, gt)
    ) {
      if (yt !== null && es(gt)) {
        if (
          ((pe = yt.start),
          (d = yt.end),
          d === void 0 && (d = pe),
          "selectionStart" in gt)
        )
          (gt.selectionStart = pe),
            (gt.selectionEnd = Math.min(d, gt.value.length));
        else if (
          ((d =
            ((pe = gt.ownerDocument || document) && pe.defaultView) || window),
          d.getSelection)
        ) {
          d = d.getSelection();
          var At = gt.textContent.length,
            Lt = Math.min(yt.start, At);
          (yt = yt.end === void 0 ? Lt : Math.min(yt.end, At)),
            !d.extend && Lt > yt && ((At = yt), (yt = Lt), (Lt = At)),
            (At = Us(gt, Lt));
          var Wt = Us(gt, yt);
          At &&
            Wt &&
            (d.rangeCount !== 1 ||
              d.anchorNode !== At.node ||
              d.anchorOffset !== At.offset ||
              d.focusNode !== Wt.node ||
              d.focusOffset !== Wt.offset) &&
            ((pe = pe.createRange()),
            pe.setStart(At.node, At.offset),
            d.removeAllRanges(),
            Lt > yt
              ? (d.addRange(pe), d.extend(Wt.node, Wt.offset))
              : (pe.setEnd(Wt.node, Wt.offset), d.addRange(pe)));
        }
      }
      for (pe = [], d = gt; (d = d.parentNode); )
        d.nodeType === 1 &&
          pe.push({ element: d, left: d.scrollLeft, top: d.scrollTop });
      for (
        typeof gt.focus == "function" && gt.focus(), gt = 0;
        gt < pe.length;
        gt++
      )
        (d = pe[gt]),
          (d.element.scrollLeft = d.left),
          (d.element.scrollTop = d.top);
    }
  }
  var yc = l && "documentMode" in document && 11 >= document.documentMode,
    mo = null,
    ya = null,
    Pl = null,
    ns = !1;
  function xc(d, pe, gt) {
    var yt =
      gt.window === gt
        ? gt.document
        : gt.nodeType === 9
        ? gt
        : gt.ownerDocument;
    ns ||
      mo == null ||
      mo !== Bn(yt) ||
      ((yt = mo),
      "selectionStart" in yt && es(yt)
        ? (yt = { start: yt.selectionStart, end: yt.selectionEnd })
        : ((yt = (
            (yt.ownerDocument && yt.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (yt = {
            anchorNode: yt.anchorNode,
            anchorOffset: yt.anchorOffset,
            focusNode: yt.focusNode,
            focusOffset: yt.focusOffset,
          })),
      (Pl && ga(Pl, yt)) ||
        ((Pl = yt),
        (yt = Cc(ya, "onSelect")),
        0 < yt.length &&
          ((pe = new Ml("onSelect", "select", null, pe, gt)),
          d.push({ event: pe, listeners: yt }),
          (pe.target = mo))));
  }
  function nl(d, pe) {
    var gt = {};
    return (
      (gt[d.toLowerCase()] = pe.toLowerCase()),
      (gt["Webkit" + d] = "webkit" + pe),
      (gt["Moz" + d] = "moz" + pe),
      gt
    );
  }
  var ea = {
      animationend: nl("Animation", "AnimationEnd"),
      animationiteration: nl("Animation", "AnimationIteration"),
      animationstart: nl("Animation", "AnimationStart"),
      transitionend: nl("Transition", "TransitionEnd"),
    },
    so = {},
    oo = {};
  l &&
    ((oo = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete ea.animationend.animation,
      delete ea.animationiteration.animation,
      delete ea.animationstart.animation),
    "TransitionEvent" in window || delete ea.transitionend.transition);
  function go(d) {
    if (so[d]) return so[d];
    if (!ea[d]) return d;
    var pe = ea[d],
      gt;
    for (gt in pe)
      if (pe.hasOwnProperty(gt) && gt in oo) return (so[d] = pe[gt]);
    return d;
  }
  var Rl = go("animationend"),
    Il = go("animationiteration"),
    au = go("animationstart"),
    lu = go("transitionend"),
    cu = new Map(),
    uu =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function Io(d, pe) {
    cu.set(d, pe), o(pe, [d]);
  }
  for (var Sc = 0; Sc < uu.length; Sc++) {
    var Ll = uu[Sc],
      kl = Ll.toLowerCase(),
      Qu = Ll[0].toUpperCase() + Ll.slice(1);
    Io(kl, "on" + Qu);
  }
  Io(Rl, "onAnimationEnd"),
    Io(Il, "onAnimationIteration"),
    Io(au, "onAnimationStart"),
    Io("dblclick", "onDoubleClick"),
    Io("focusin", "onFocus"),
    Io("focusout", "onBlur"),
    Io(lu, "onTransitionEnd"),
    a("onMouseEnter", ["mouseout", "mouseover"]),
    a("onMouseLeave", ["mouseout", "mouseover"]),
    a("onPointerEnter", ["pointerout", "pointerover"]),
    a("onPointerLeave", ["pointerout", "pointerover"]),
    o(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    o(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    o(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    o(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var ta =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    wc = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(ta)
    );
  function Ec(d, pe, gt) {
    var yt = d.type || "unknown-event";
    (d.currentTarget = gt), Ut(yt, pe, void 0, d), (d.currentTarget = null);
  }
  function rl(d, pe) {
    pe = (pe & 4) !== 0;
    for (var gt = 0; gt < d.length; gt++) {
      var yt = d[gt],
        At = yt.event;
      yt = yt.listeners;
      e: {
        var Lt = void 0;
        if (pe)
          for (var Wt = yt.length - 1; 0 <= Wt; Wt--) {
            var nn = yt[Wt],
              dn = nn.instance,
              Dn = nn.currentTarget;
            if (((nn = nn.listener), dn !== Lt && At.isPropagationStopped()))
              break e;
            Ec(At, nn, Dn), (Lt = dn);
          }
        else
          for (Wt = 0; Wt < yt.length; Wt++) {
            if (
              ((nn = yt[Wt]),
              (dn = nn.instance),
              (Dn = nn.currentTarget),
              (nn = nn.listener),
              dn !== Lt && At.isPropagationStopped())
            )
              break e;
            Ec(At, nn, Dn), (Lt = dn);
          }
      }
    }
    if (qr) throw ((d = Ir), (qr = !1), (Ir = null), d);
  }
  function Li(d, pe) {
    var gt = pe[wa];
    gt === void 0 && (gt = pe[wa] = new Set());
    var yt = d + "__bubble";
    gt.has(yt) || (bc(pe, d, 2, !1), gt.add(yt));
  }
  function Tc(d, pe, gt) {
    var yt = 0;
    pe && (yt |= 4), bc(gt, d, yt, pe);
  }
  var Fl = "_reactListening" + Math.random().toString(36).slice(2);
  function il(d) {
    if (!d[Fl]) {
      (d[Fl] = !0),
        r.forEach(function (gt) {
          gt !== "selectionchange" &&
            (wc.has(gt) || Tc(gt, !1, d), Tc(gt, !0, d));
        });
      var pe = d.nodeType === 9 ? d : d.ownerDocument;
      pe === null || pe[Fl] || ((pe[Fl] = !0), Tc("selectionchange", !1, pe));
    }
  }
  function bc(d, pe, gt, yt) {
    switch (Tl(pe)) {
      case 1:
        var At = Zi;
        break;
      case 4:
        At = Yo;
        break;
      default:
        At = Wa;
    }
    (gt = At.bind(null, pe, gt, d)),
      (At = void 0),
      !xr ||
        (pe !== "touchstart" && pe !== "touchmove" && pe !== "wheel") ||
        (At = !0),
      yt
        ? At !== void 0
          ? d.addEventListener(pe, gt, { capture: !0, passive: At })
          : d.addEventListener(pe, gt, !0)
        : At !== void 0
        ? d.addEventListener(pe, gt, { passive: At })
        : d.addEventListener(pe, gt, !1);
  }
  function Mc(d, pe, gt, yt, At) {
    var Lt = yt;
    if ((pe & 1) === 0 && (pe & 2) === 0 && yt !== null)
      e: for (;;) {
        if (yt === null) return;
        var Wt = yt.tag;
        if (Wt === 3 || Wt === 4) {
          var nn = yt.stateNode.containerInfo;
          if (nn === At || (nn.nodeType === 8 && nn.parentNode === At)) break;
          if (Wt === 4)
            for (Wt = yt.return; Wt !== null; ) {
              var dn = Wt.tag;
              if (
                (dn === 3 || dn === 4) &&
                ((dn = Wt.stateNode.containerInfo),
                dn === At || (dn.nodeType === 8 && dn.parentNode === At))
              )
                return;
              Wt = Wt.return;
            }
          for (; nn !== null; ) {
            if (((Wt = na(nn)), Wt === null)) return;
            if (((dn = Wt.tag), dn === 5 || dn === 6)) {
              yt = Lt = Wt;
              continue e;
            }
            nn = nn.parentNode;
          }
        }
        yt = yt.return;
      }
    Rr(function () {
      var Dn = Lt,
        sr = cn(gt),
        lr = [];
      e: {
        var ir = cu.get(d);
        if (ir !== void 0) {
          var Lr = Ml,
            Nr = d;
          switch (d) {
            case "keypress":
              if (ca(gt) === 0) break e;
            case "keydown":
            case "keyup":
              Lr = pc;
              break;
            case "focusin":
              (Nr = "focus"), (Lr = uc);
              break;
            case "focusout":
              (Nr = "blur"), (Lr = uc);
              break;
            case "beforeblur":
            case "afterblur":
              Lr = uc;
              break;
            case "click":
              if (gt.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Lr = Qc;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Lr = Ko;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Lr = Ao;
              break;
            case Rl:
            case Il:
            case au:
              Lr = Hu;
              break;
            case lu:
              Lr = da;
              break;
            case "scroll":
              Lr = qa;
              break;
            case "wheel":
              Lr = nu;
              break;
            case "copy":
            case "cut":
            case "paste":
              Lr = Jc;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Lr = Ns;
          }
          var Vr = (pe & 4) !== 0,
            Ji = !Vr && d === "scroll",
            Tn = Vr ? (ir !== null ? ir + "Capture" : null) : ir;
          Vr = [];
          for (var gn = Dn, Cn; gn !== null; ) {
            Cn = gn;
            var vr = Cn.stateNode;
            if (
              (Cn.tag === 5 &&
                vr !== null &&
                ((Cn = vr),
                Tn !== null &&
                  ((vr = $r(gn, Tn)), vr != null && Vr.push(sl(gn, vr, Cn)))),
              Ji)
            )
              break;
            gn = gn.return;
          }
          0 < Vr.length &&
            ((ir = new Lr(ir, Nr, null, gt, sr)),
            lr.push({ event: ir, listeners: Vr }));
        }
      }
      if ((pe & 7) === 0) {
        e: {
          if (
            ((ir = d === "mouseover" || d === "pointerover"),
            (Lr = d === "mouseout" || d === "pointerout"),
            ir &&
              gt !== Hr &&
              (Nr = gt.relatedTarget || gt.fromElement) &&
              (na(Nr) || Nr[zs]))
          )
            break e;
          if (
            (Lr || ir) &&
            ((ir =
              sr.window === sr
                ? sr
                : (ir = sr.ownerDocument)
                ? ir.defaultView || ir.parentWindow
                : window),
            Lr
              ? ((Nr = gt.relatedTarget || gt.toElement),
                (Lr = Dn),
                (Nr = Nr ? na(Nr) : null),
                Nr !== null &&
                  ((Ji = $t(Nr)),
                  Nr !== Ji || (Nr.tag !== 5 && Nr.tag !== 6)) &&
                  (Nr = null))
              : ((Lr = null), (Nr = Dn)),
            Lr !== Nr)
          ) {
            if (
              ((Vr = Qc),
              (vr = "onMouseLeave"),
              (Tn = "onMouseEnter"),
              (gn = "mouse"),
              (d === "pointerout" || d === "pointerover") &&
                ((Vr = Ns),
                (vr = "onPointerLeave"),
                (Tn = "onPointerEnter"),
                (gn = "pointer")),
              (Ji = Lr == null ? ir : $i(Lr)),
              (Cn = Nr == null ? ir : $i(Nr)),
              (ir = new Vr(vr, gn + "leave", Lr, gt, sr)),
              (ir.target = Ji),
              (ir.relatedTarget = Cn),
              (vr = null),
              na(sr) === Dn &&
                ((Vr = new Vr(Tn, gn + "enter", Nr, gt, sr)),
                (Vr.target = Cn),
                (Vr.relatedTarget = Ji),
                (vr = Vr)),
              (Ji = vr),
              Lr && Nr)
            )
              t: {
                for (Vr = Lr, Tn = Nr, gn = 0, Cn = Vr; Cn; Cn = xa(Cn)) gn++;
                for (Cn = 0, vr = Tn; vr; vr = xa(vr)) Cn++;
                for (; 0 < gn - Cn; ) (Vr = xa(Vr)), gn--;
                for (; 0 < Cn - gn; ) (Tn = xa(Tn)), Cn--;
                for (; gn--; ) {
                  if (Vr === Tn || (Tn !== null && Vr === Tn.alternate))
                    break t;
                  (Vr = xa(Vr)), (Tn = xa(Tn));
                }
                Vr = null;
              }
            else Vr = null;
            Lr !== null && Ju(lr, ir, Lr, Vr, !1),
              Nr !== null && Ji !== null && Ju(lr, Ji, Nr, Vr, !0);
          }
        }
        e: {
          if (
            ((ir = Dn ? $i(Dn) : window),
            (Lr = ir.nodeName && ir.nodeName.toLowerCase()),
            Lr === "select" || (Lr === "input" && ir.type === "file"))
          )
            var Wr = Ku;
          else if (gc(ir))
            if (el) Wr = zi;
            else {
              Wr = Zu;
              var Jr = tl;
            }
          else
            (Lr = ir.nodeName) &&
              Lr.toLowerCase() === "input" &&
              (ir.type === "checkbox" || ir.type === "radio") &&
              (Wr = ou);
          if (Wr && (Wr = Wr(d, Dn))) {
            Qa(lr, Wr, gt, sr);
            break e;
          }
          Jr && Jr(d, ir, Dn),
            d === "focusout" &&
              (Jr = ir._wrapperState) &&
              Jr.controlled &&
              ir.type === "number" &&
              or(ir, "number", ir.value);
        }
        switch (((Jr = Dn ? $i(Dn) : window), d)) {
          case "focusin":
            (gc(Jr) || Jr.contentEditable === "true") &&
              ((mo = Jr), (ya = Dn), (Pl = null));
            break;
          case "focusout":
            Pl = ya = mo = null;
            break;
          case "mousedown":
            ns = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (ns = !1), xc(lr, gt, sr);
            break;
          case "selectionchange":
            if (yc) break;
          case "keydown":
          case "keyup":
            xc(lr, gt, sr);
        }
        var ei;
        if (ws)
          e: {
            switch (d) {
              case "compositionstart":
                var ri = "onCompositionStart";
                break e;
              case "compositionend":
                ri = "onCompositionEnd";
                break e;
              case "compositionupdate":
                ri = "onCompositionUpdate";
                break e;
            }
            ri = void 0;
          }
        else
          Qo
            ? su(d, gt) && (ri = "onCompositionEnd")
            : d === "keydown" &&
              gt.keyCode === 229 &&
              (ri = "onCompositionStart");
        ri &&
          (Ka &&
            gt.locale !== "ko" &&
            (Qo || ri !== "onCompositionStart"
              ? ri === "onCompositionEnd" && Qo && (ei = bl())
              : ((Ps = sr),
                ($a = "value" in Ps ? Ps.value : Ps.textContent),
                (Qo = !0))),
          (Jr = Cc(Dn, ri)),
          0 < Jr.length &&
            ((ri = new eu(ri, d, null, gt, sr)),
            lr.push({ event: ri, listeners: Jr }),
            ei
              ? (ri.data = ei)
              : ((ei = mc(gt)), ei !== null && (ri.data = ei)))),
          (ei = Ni ? Xu(d, gt) : Cl(d, gt)) &&
            ((Dn = Cc(Dn, "onBeforeInput")),
            0 < Dn.length &&
              ((sr = new eu("onBeforeInput", "beforeinput", null, gt, sr)),
              lr.push({ event: sr, listeners: Dn }),
              (sr.data = ei)));
      }
      rl(lr, pe);
    });
  }
  function sl(d, pe, gt) {
    return { instance: d, listener: pe, currentTarget: gt };
  }
  function Cc(d, pe) {
    for (var gt = pe + "Capture", yt = []; d !== null; ) {
      var At = d,
        Lt = At.stateNode;
      At.tag === 5 &&
        Lt !== null &&
        ((At = Lt),
        (Lt = $r(d, gt)),
        Lt != null && yt.unshift(sl(d, Lt, At)),
        (Lt = $r(d, pe)),
        Lt != null && yt.push(sl(d, Lt, At))),
        (d = d.return);
    }
    return yt;
  }
  function xa(d) {
    if (d === null) return null;
    do d = d.return;
    while (d && d.tag !== 5);
    return d || null;
  }
  function Ju(d, pe, gt, yt, At) {
    for (var Lt = pe._reactName, Wt = []; gt !== null && gt !== yt; ) {
      var nn = gt,
        dn = nn.alternate,
        Dn = nn.stateNode;
      if (dn !== null && dn === yt) break;
      nn.tag === 5 &&
        Dn !== null &&
        ((nn = Dn),
        At
          ? ((dn = $r(gt, Lt)), dn != null && Wt.unshift(sl(gt, dn, nn)))
          : At || ((dn = $r(gt, Lt)), dn != null && Wt.push(sl(gt, dn, nn)))),
        (gt = gt.return);
    }
    Wt.length !== 0 && d.push({ event: pe, listeners: Wt });
  }
  var Ff = /\r\n?/g,
    ef = /\u0000|\uFFFD/g;
  function fu(d) {
    return (typeof d == "string" ? d : "" + d)
      .replace(
        Ff,
        `
`
      )
      .replace(ef, "");
  }
  function Dl(d, pe, gt) {
    if (((pe = fu(pe)), fu(d) !== pe && gt)) throw Error(t(425));
  }
  function Ol() {}
  var ol = null,
    hu = null;
  function du(d, pe) {
    return (
      d === "textarea" ||
      d === "noscript" ||
      typeof pe.children == "string" ||
      typeof pe.children == "number" ||
      (typeof pe.dangerouslySetInnerHTML == "object" &&
        pe.dangerouslySetInnerHTML !== null &&
        pe.dangerouslySetInnerHTML.__html != null)
    );
  }
  var pu = typeof setTimeout == "function" ? setTimeout : void 0,
    mu = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Ac = typeof Promise == "function" ? Promise : void 0,
    Df =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof Ac < "u"
        ? function (d) {
            return Ac.resolve(null).then(d).catch(tf);
          }
        : pu;
  function tf(d) {
    setTimeout(function () {
      throw d;
    });
  }
  function Pc(d, pe) {
    var gt = pe,
      yt = 0;
    do {
      var At = gt.nextSibling;
      if ((d.removeChild(gt), At && At.nodeType === 8))
        if (((gt = At.data), gt === "/$")) {
          if (yt === 0) {
            d.removeChild(At), rr(pe);
            return;
          }
          yt--;
        } else (gt !== "$" && gt !== "$?" && gt !== "$!") || yt++;
      gt = At;
    } while (gt);
    rr(pe);
  }
  function Lo(d) {
    for (; d != null; d = d.nextSibling) {
      var pe = d.nodeType;
      if (pe === 1 || pe === 3) break;
      if (pe === 8) {
        if (((pe = d.data), pe === "$" || pe === "$!" || pe === "$?")) break;
        if (pe === "/$") return null;
      }
    }
    return d;
  }
  function gu(d) {
    d = d.previousSibling;
    for (var pe = 0; d; ) {
      if (d.nodeType === 8) {
        var gt = d.data;
        if (gt === "$" || gt === "$!" || gt === "$?") {
          if (pe === 0) return d;
          pe--;
        } else gt === "/$" && pe++;
      }
      d = d.previousSibling;
    }
    return null;
  }
  var Sa = Math.random().toString(36).slice(2),
    Qi = "__reactFiber$" + Sa,
    al = "__reactProps$" + Sa,
    zs = "__reactContainer$" + Sa,
    wa = "__reactEvents$" + Sa,
    Rc = "__reactListeners$" + Sa,
    Ic = "__reactHandles$" + Sa;
  function na(d) {
    var pe = d[Qi];
    if (pe) return pe;
    for (var gt = d.parentNode; gt; ) {
      if ((pe = gt[zs] || gt[Qi])) {
        if (
          ((gt = pe.alternate),
          pe.child !== null || (gt !== null && gt.child !== null))
        )
          for (d = gu(d); d !== null; ) {
            if ((gt = d[Qi])) return gt;
            d = gu(d);
          }
        return pe;
      }
      (d = gt), (gt = d.parentNode);
    }
    return null;
  }
  function ko(d) {
    return (
      (d = d[Qi] || d[zs]),
      !d || (d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3)
        ? null
        : d
    );
  }
  function $i(d) {
    if (d.tag === 5 || d.tag === 6) return d.stateNode;
    throw Error(t(33));
  }
  function Lc(d) {
    return d[al] || null;
  }
  var vu = [],
    rs = -1;
  function Gi(d) {
    return { current: d };
  }
  function ki(d) {
    0 > rs || ((d.current = vu[rs]), (vu[rs] = null), rs--);
  }
  function Ri(d, pe) {
    rs++, (vu[rs] = d.current), (d.current = pe);
  }
  var Fo = {},
    ls = Gi(Fo),
    Es = Gi(!1),
    Do = Fo;
  function Ea(d, pe) {
    var gt = d.type.contextTypes;
    if (!gt) return Fo;
    var yt = d.stateNode;
    if (yt && yt.__reactInternalMemoizedUnmaskedChildContext === pe)
      return yt.__reactInternalMemoizedMaskedChildContext;
    var At = {},
      Lt;
    for (Lt in gt) At[Lt] = pe[Lt];
    return (
      yt &&
        ((d = d.stateNode),
        (d.__reactInternalMemoizedUnmaskedChildContext = pe),
        (d.__reactInternalMemoizedMaskedChildContext = At)),
      At
    );
  }
  function ms(d) {
    return (d = d.childContextTypes), d != null;
  }
  function Nl() {
    ki(Es), ki(ls);
  }
  function _u(d, pe, gt) {
    if (ls.current !== Fo) throw Error(t(168));
    Ri(ls, pe), Ri(Es, gt);
  }
  function Bl(d, pe, gt) {
    var yt = d.stateNode;
    if (((pe = pe.childContextTypes), typeof yt.getChildContext != "function"))
      return gt;
    yt = yt.getChildContext();
    for (var At in yt)
      if (!(At in pe)) throw Error(t(108, _n(d) || "Unknown", At));
    return It({}, gt, yt);
  }
  function Ta(d) {
    return (
      (d =
        ((d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext) ||
        Fo),
      (Do = ls.current),
      Ri(ls, d),
      Ri(Es, Es.current),
      !0
    );
  }
  function yu(d, pe, gt) {
    var yt = d.stateNode;
    if (!yt) throw Error(t(169));
    gt
      ? ((d = Bl(d, pe, Do)),
        (yt.__reactInternalMemoizedMergedChildContext = d),
        ki(Es),
        ki(ls),
        Ri(ls, d))
      : ki(Es),
      Ri(Es, gt);
  }
  var ao = null,
    Ul = !1,
    kc = !1;
  function zl(d) {
    ao === null ? (ao = [d]) : ao.push(d);
  }
  function nf(d) {
    (Ul = !0), zl(d);
  }
  function vo() {
    if (!kc && ao !== null) {
      kc = !0;
      var d = 0,
        pe = di;
      try {
        var gt = ao;
        for (di = 1; d < gt.length; d++) {
          var yt = gt[d];
          do yt = yt(!0);
          while (yt !== null);
        }
        (ao = null), (Ul = !1);
      } catch (At) {
        throw (ao !== null && (ao = ao.slice(d + 1)), Xn(wn, vo), At);
      } finally {
        (di = pe), (kc = !1);
      }
    }
    return null;
  }
  var ba = [],
    ks = 0,
    Fc = null,
    Dc = 0,
    Ts = [],
    ss = 0,
    Ma = null,
    Er = 1,
    Qs = "";
  function Oo(d, pe) {
    (ba[ks++] = Dc), (ba[ks++] = Fc), (Fc = d), (Dc = pe);
  }
  function xu(d, pe, gt) {
    (Ts[ss++] = Er), (Ts[ss++] = Qs), (Ts[ss++] = Ma), (Ma = d);
    var yt = Er;
    d = Qs;
    var At = 32 - Tr(yt) - 1;
    (yt &= ~(1 << At)), (gt += 1);
    var Lt = 32 - Tr(pe) + At;
    if (30 < Lt) {
      var Wt = At - (At % 5);
      (Lt = (yt & ((1 << Wt) - 1)).toString(32)),
        (yt >>= Wt),
        (At -= Wt),
        (Er = (1 << (32 - Tr(pe) + At)) | (gt << At) | yt),
        (Qs = Lt + d);
    } else (Er = (1 << Lt) | (gt << At) | yt), (Qs = d);
  }
  function Su(d) {
    d.return !== null && (Oo(d, 1), xu(d, 1, 0));
  }
  function No(d) {
    for (; d === Fc; )
      (Fc = ba[--ks]), (ba[ks] = null), (Dc = ba[--ks]), (ba[ks] = null);
    for (; d === Ma; )
      (Ma = Ts[--ss]),
        (Ts[ss] = null),
        (Qs = Ts[--ss]),
        (Ts[ss] = null),
        (Er = Ts[--ss]),
        (Ts[ss] = null);
  }
  var cs = null,
    bs = null,
    Di = !1,
    Js = null;
  function wu(d, pe) {
    var gt = wo(5, null, null, 0);
    (gt.elementType = "DELETED"),
      (gt.stateNode = pe),
      (gt.return = d),
      (pe = d.deletions),
      pe === null ? ((d.deletions = [gt]), (d.flags |= 16)) : pe.push(gt);
  }
  function Eu(d, pe) {
    switch (d.tag) {
      case 5:
        var gt = d.type;
        return (
          (pe =
            pe.nodeType !== 1 || gt.toLowerCase() !== pe.nodeName.toLowerCase()
              ? null
              : pe),
          pe !== null
            ? ((d.stateNode = pe), (cs = d), (bs = Lo(pe.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (pe = d.pendingProps === "" || pe.nodeType !== 3 ? null : pe),
          pe !== null ? ((d.stateNode = pe), (cs = d), (bs = null), !0) : !1
        );
      case 13:
        return (
          (pe = pe.nodeType !== 8 ? null : pe),
          pe !== null
            ? ((gt = Ma !== null ? { id: Er, overflow: Qs } : null),
              (d.memoizedState = {
                dehydrated: pe,
                treeContext: gt,
                retryLane: 1073741824,
              }),
              (gt = wo(18, null, null, 0)),
              (gt.stateNode = pe),
              (gt.return = d),
              (d.child = gt),
              (cs = d),
              (bs = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function Oc(d) {
    return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
  }
  function Nc(d) {
    if (Di) {
      var pe = bs;
      if (pe) {
        var gt = pe;
        if (!Eu(d, pe)) {
          if (Oc(d)) throw Error(t(418));
          pe = Lo(gt.nextSibling);
          var yt = cs;
          pe && Eu(d, pe)
            ? wu(yt, gt)
            : ((d.flags = (d.flags & -4097) | 2), (Di = !1), (cs = d));
        }
      } else {
        if (Oc(d)) throw Error(t(418));
        (d.flags = (d.flags & -4097) | 2), (Di = !1), (cs = d);
      }
    }
  }
  function Bc(d) {
    for (
      d = d.return;
      d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13;

    )
      d = d.return;
    cs = d;
  }
  function ll(d) {
    if (d !== cs) return !1;
    if (!Di) return Bc(d), (Di = !0), !1;
    var pe;
    if (
      ((pe = d.tag !== 3) &&
        !(pe = d.tag !== 5) &&
        ((pe = d.type),
        (pe = pe !== "head" && pe !== "body" && !du(d.type, d.memoizedProps))),
      pe && (pe = bs))
    ) {
      if (Oc(d)) throw (Tu(), Error(t(418)));
      for (; pe; ) wu(d, pe), (pe = Lo(pe.nextSibling));
    }
    if ((Bc(d), d.tag === 13)) {
      if (((d = d.memoizedState), (d = d !== null ? d.dehydrated : null), !d))
        throw Error(t(317));
      e: {
        for (d = d.nextSibling, pe = 0; d; ) {
          if (d.nodeType === 8) {
            var gt = d.data;
            if (gt === "/$") {
              if (pe === 0) {
                bs = Lo(d.nextSibling);
                break e;
              }
              pe--;
            } else (gt !== "$" && gt !== "$!" && gt !== "$?") || pe++;
          }
          d = d.nextSibling;
        }
        bs = null;
      }
    } else bs = cs ? Lo(d.stateNode.nextSibling) : null;
    return !0;
  }
  function Tu() {
    for (var d = bs; d; ) d = Lo(d.nextSibling);
  }
  function ra() {
    (bs = cs = null), (Di = !1);
  }
  function cl(d) {
    Js === null ? (Js = [d]) : Js.push(d);
  }
  var Of = vt.ReactCurrentBatchConfig;
  function Vl(d, pe, gt) {
    if (
      ((d = gt.ref),
      d !== null && typeof d != "function" && typeof d != "object")
    ) {
      if (gt._owner) {
        if (((gt = gt._owner), gt)) {
          if (gt.tag !== 1) throw Error(t(309));
          var yt = gt.stateNode;
        }
        if (!yt) throw Error(t(147, d));
        var At = yt,
          Lt = "" + d;
        return pe !== null &&
          pe.ref !== null &&
          typeof pe.ref == "function" &&
          pe.ref._stringRef === Lt
          ? pe.ref
          : ((pe = function (Wt) {
              var nn = At.refs;
              Wt === null ? delete nn[Lt] : (nn[Lt] = Wt);
            }),
            (pe._stringRef = Lt),
            pe);
      }
      if (typeof d != "string") throw Error(t(284));
      if (!gt._owner) throw Error(t(290, d));
    }
    return d;
  }
  function Gl(d, pe) {
    throw (
      ((d = Object.prototype.toString.call(pe)),
      Error(
        t(
          31,
          d === "[object Object]"
            ? "object with keys {" + Object.keys(pe).join(", ") + "}"
            : d
        )
      ))
    );
  }
  function bu(d) {
    var pe = d._init;
    return pe(d._payload);
  }
  function Mu(d) {
    function pe(Tn, gn) {
      if (d) {
        var Cn = Tn.deletions;
        Cn === null ? ((Tn.deletions = [gn]), (Tn.flags |= 16)) : Cn.push(gn);
      }
    }
    function gt(Tn, gn) {
      if (!d) return null;
      for (; gn !== null; ) pe(Tn, gn), (gn = gn.sibling);
      return null;
    }
    function yt(Tn, gn) {
      for (Tn = new Map(); gn !== null; )
        gn.key !== null ? Tn.set(gn.key, gn) : Tn.set(gn.index, gn),
          (gn = gn.sibling);
      return Tn;
    }
    function At(Tn, gn) {
      return (Tn = Sl(Tn, gn)), (Tn.index = 0), (Tn.sibling = null), Tn;
    }
    function Lt(Tn, gn, Cn) {
      return (
        (Tn.index = Cn),
        d
          ? ((Cn = Tn.alternate),
            Cn !== null
              ? ((Cn = Cn.index), Cn < gn ? ((Tn.flags |= 2), gn) : Cn)
              : ((Tn.flags |= 2), gn))
          : ((Tn.flags |= 1048576), gn)
      );
    }
    function Wt(Tn) {
      return d && Tn.alternate === null && (Tn.flags |= 2), Tn;
    }
    function nn(Tn, gn, Cn, vr) {
      return gn === null || gn.tag !== 6
        ? ((gn = th(Cn, Tn.mode, vr)), (gn.return = Tn), gn)
        : ((gn = At(gn, Cn)), (gn.return = Tn), gn);
    }
    function dn(Tn, gn, Cn, vr) {
      var Wr = Cn.type;
      return Wr === wt
        ? sr(Tn, gn, Cn.props.children, vr, Cn.key)
        : gn !== null &&
          (gn.elementType === Wr ||
            (typeof Wr == "object" &&
              Wr !== null &&
              Wr.$$typeof === Ft &&
              bu(Wr) === gn.type))
        ? ((vr = At(gn, Cn.props)),
          (vr.ref = Vl(Tn, gn, Cn)),
          (vr.return = Tn),
          vr)
        : ((vr = Mf(Cn.type, Cn.key, Cn.props, null, Tn.mode, vr)),
          (vr.ref = Vl(Tn, gn, Cn)),
          (vr.return = Tn),
          vr);
    }
    function Dn(Tn, gn, Cn, vr) {
      return gn === null ||
        gn.tag !== 4 ||
        gn.stateNode.containerInfo !== Cn.containerInfo ||
        gn.stateNode.implementation !== Cn.implementation
        ? ((gn = nh(Cn, Tn.mode, vr)), (gn.return = Tn), gn)
        : ((gn = At(gn, Cn.children || [])), (gn.return = Tn), gn);
    }
    function sr(Tn, gn, Cn, vr, Wr) {
      return gn === null || gn.tag !== 7
        ? ((gn = sc(Cn, Tn.mode, vr, Wr)), (gn.return = Tn), gn)
        : ((gn = At(gn, Cn)), (gn.return = Tn), gn);
    }
    function lr(Tn, gn, Cn) {
      if ((typeof gn == "string" && gn !== "") || typeof gn == "number")
        return (gn = th("" + gn, Tn.mode, Cn)), (gn.return = Tn), gn;
      if (typeof gn == "object" && gn !== null) {
        switch (gn.$$typeof) {
          case xt:
            return (
              (Cn = Mf(gn.type, gn.key, gn.props, null, Tn.mode, Cn)),
              (Cn.ref = Vl(Tn, null, gn)),
              (Cn.return = Tn),
              Cn
            );
          case St:
            return (gn = nh(gn, Tn.mode, Cn)), (gn.return = Tn), gn;
          case Ft:
            var vr = gn._init;
            return lr(Tn, vr(gn._payload), Cn);
        }
        if (Gn(gn) || Pt(gn))
          return (gn = sc(gn, Tn.mode, Cn, null)), (gn.return = Tn), gn;
        Gl(Tn, gn);
      }
      return null;
    }
    function ir(Tn, gn, Cn, vr) {
      var Wr = gn !== null ? gn.key : null;
      if ((typeof Cn == "string" && Cn !== "") || typeof Cn == "number")
        return Wr !== null ? null : nn(Tn, gn, "" + Cn, vr);
      if (typeof Cn == "object" && Cn !== null) {
        switch (Cn.$$typeof) {
          case xt:
            return Cn.key === Wr ? dn(Tn, gn, Cn, vr) : null;
          case St:
            return Cn.key === Wr ? Dn(Tn, gn, Cn, vr) : null;
          case Ft:
            return (Wr = Cn._init), ir(Tn, gn, Wr(Cn._payload), vr);
        }
        if (Gn(Cn) || Pt(Cn))
          return Wr !== null ? null : sr(Tn, gn, Cn, vr, null);
        Gl(Tn, Cn);
      }
      return null;
    }
    function Lr(Tn, gn, Cn, vr, Wr) {
      if ((typeof vr == "string" && vr !== "") || typeof vr == "number")
        return (Tn = Tn.get(Cn) || null), nn(gn, Tn, "" + vr, Wr);
      if (typeof vr == "object" && vr !== null) {
        switch (vr.$$typeof) {
          case xt:
            return (
              (Tn = Tn.get(vr.key === null ? Cn : vr.key) || null),
              dn(gn, Tn, vr, Wr)
            );
          case St:
            return (
              (Tn = Tn.get(vr.key === null ? Cn : vr.key) || null),
              Dn(gn, Tn, vr, Wr)
            );
          case Ft:
            var Jr = vr._init;
            return Lr(Tn, gn, Cn, Jr(vr._payload), Wr);
        }
        if (Gn(vr) || Pt(vr))
          return (Tn = Tn.get(Cn) || null), sr(gn, Tn, vr, Wr, null);
        Gl(gn, vr);
      }
      return null;
    }
    function Nr(Tn, gn, Cn, vr) {
      for (
        var Wr = null, Jr = null, ei = gn, ri = (gn = 0), ys = null;
        ei !== null && ri < Cn.length;
        ri++
      ) {
        ei.index > ri ? ((ys = ei), (ei = null)) : (ys = ei.sibling);
        var Ti = ir(Tn, ei, Cn[ri], vr);
        if (Ti === null) {
          ei === null && (ei = ys);
          break;
        }
        d && ei && Ti.alternate === null && pe(Tn, ei),
          (gn = Lt(Ti, gn, ri)),
          Jr === null ? (Wr = Ti) : (Jr.sibling = Ti),
          (Jr = Ti),
          (ei = ys);
      }
      if (ri === Cn.length) return gt(Tn, ei), Di && Oo(Tn, ri), Wr;
      if (ei === null) {
        for (; ri < Cn.length; ri++)
          (ei = lr(Tn, Cn[ri], vr)),
            ei !== null &&
              ((gn = Lt(ei, gn, ri)),
              Jr === null ? (Wr = ei) : (Jr.sibling = ei),
              (Jr = ei));
        return Di && Oo(Tn, ri), Wr;
      }
      for (ei = yt(Tn, ei); ri < Cn.length; ri++)
        (ys = Lr(ei, Tn, ri, Cn[ri], vr)),
          ys !== null &&
            (d &&
              ys.alternate !== null &&
              ei.delete(ys.key === null ? ri : ys.key),
            (gn = Lt(ys, gn, ri)),
            Jr === null ? (Wr = ys) : (Jr.sibling = ys),
            (Jr = ys));
      return (
        d &&
          ei.forEach(function (wl) {
            return pe(Tn, wl);
          }),
        Di && Oo(Tn, ri),
        Wr
      );
    }
    function Vr(Tn, gn, Cn, vr) {
      var Wr = Pt(Cn);
      if (typeof Wr != "function") throw Error(t(150));
      if (((Cn = Wr.call(Cn)), Cn == null)) throw Error(t(151));
      for (
        var Jr = (Wr = null), ei = gn, ri = (gn = 0), ys = null, Ti = Cn.next();
        ei !== null && !Ti.done;
        ri++, Ti = Cn.next()
      ) {
        ei.index > ri ? ((ys = ei), (ei = null)) : (ys = ei.sibling);
        var wl = ir(Tn, ei, Ti.value, vr);
        if (wl === null) {
          ei === null && (ei = ys);
          break;
        }
        d && ei && wl.alternate === null && pe(Tn, ei),
          (gn = Lt(wl, gn, ri)),
          Jr === null ? (Wr = wl) : (Jr.sibling = wl),
          (Jr = wl),
          (ei = ys);
      }
      if (Ti.done) return gt(Tn, ei), Di && Oo(Tn, ri), Wr;
      if (ei === null) {
        for (; !Ti.done; ri++, Ti = Cn.next())
          (Ti = lr(Tn, Ti.value, vr)),
            Ti !== null &&
              ((gn = Lt(Ti, gn, ri)),
              Jr === null ? (Wr = Ti) : (Jr.sibling = Ti),
              (Jr = Ti));
        return Di && Oo(Tn, ri), Wr;
      }
      for (ei = yt(Tn, ei); !Ti.done; ri++, Ti = Cn.next())
        (Ti = Lr(ei, Tn, ri, Ti.value, vr)),
          Ti !== null &&
            (d &&
              Ti.alternate !== null &&
              ei.delete(Ti.key === null ? ri : Ti.key),
            (gn = Lt(Ti, gn, ri)),
            Jr === null ? (Wr = Ti) : (Jr.sibling = Ti),
            (Jr = Ti));
      return (
        d &&
          ei.forEach(function (ld) {
            return pe(Tn, ld);
          }),
        Di && Oo(Tn, ri),
        Wr
      );
    }
    function Ji(Tn, gn, Cn, vr) {
      if (
        (typeof Cn == "object" &&
          Cn !== null &&
          Cn.type === wt &&
          Cn.key === null &&
          (Cn = Cn.props.children),
        typeof Cn == "object" && Cn !== null)
      ) {
        switch (Cn.$$typeof) {
          case xt:
            e: {
              for (var Wr = Cn.key, Jr = gn; Jr !== null; ) {
                if (Jr.key === Wr) {
                  if (((Wr = Cn.type), Wr === wt)) {
                    if (Jr.tag === 7) {
                      gt(Tn, Jr.sibling),
                        (gn = At(Jr, Cn.props.children)),
                        (gn.return = Tn),
                        (Tn = gn);
                      break e;
                    }
                  } else if (
                    Jr.elementType === Wr ||
                    (typeof Wr == "object" &&
                      Wr !== null &&
                      Wr.$$typeof === Ft &&
                      bu(Wr) === Jr.type)
                  ) {
                    gt(Tn, Jr.sibling),
                      (gn = At(Jr, Cn.props)),
                      (gn.ref = Vl(Tn, Jr, Cn)),
                      (gn.return = Tn),
                      (Tn = gn);
                    break e;
                  }
                  gt(Tn, Jr);
                  break;
                } else pe(Tn, Jr);
                Jr = Jr.sibling;
              }
              Cn.type === wt
                ? ((gn = sc(Cn.props.children, Tn.mode, vr, Cn.key)),
                  (gn.return = Tn),
                  (Tn = gn))
                : ((vr = Mf(Cn.type, Cn.key, Cn.props, null, Tn.mode, vr)),
                  (vr.ref = Vl(Tn, gn, Cn)),
                  (vr.return = Tn),
                  (Tn = vr));
            }
            return Wt(Tn);
          case St:
            e: {
              for (Jr = Cn.key; gn !== null; ) {
                if (gn.key === Jr)
                  if (
                    gn.tag === 4 &&
                    gn.stateNode.containerInfo === Cn.containerInfo &&
                    gn.stateNode.implementation === Cn.implementation
                  ) {
                    gt(Tn, gn.sibling),
                      (gn = At(gn, Cn.children || [])),
                      (gn.return = Tn),
                      (Tn = gn);
                    break e;
                  } else {
                    gt(Tn, gn);
                    break;
                  }
                else pe(Tn, gn);
                gn = gn.sibling;
              }
              (gn = nh(Cn, Tn.mode, vr)), (gn.return = Tn), (Tn = gn);
            }
            return Wt(Tn);
          case Ft:
            return (Jr = Cn._init), Ji(Tn, gn, Jr(Cn._payload), vr);
        }
        if (Gn(Cn)) return Nr(Tn, gn, Cn, vr);
        if (Pt(Cn)) return Vr(Tn, gn, Cn, vr);
        Gl(Tn, Cn);
      }
      return (typeof Cn == "string" && Cn !== "") || typeof Cn == "number"
        ? ((Cn = "" + Cn),
          gn !== null && gn.tag === 6
            ? (gt(Tn, gn.sibling),
              (gn = At(gn, Cn)),
              (gn.return = Tn),
              (Tn = gn))
            : (gt(Tn, gn),
              (gn = th(Cn, Tn.mode, vr)),
              (gn.return = Tn),
              (Tn = gn)),
          Wt(Tn))
        : gt(Tn, gn);
    }
    return Ji;
  }
  var Ca = Mu(!0),
    Hl = Mu(!1),
    Aa = Gi(null),
    Pa = null,
    Bo = null,
    ul = null;
  function Ra() {
    ul = Bo = Pa = null;
  }
  function Wl(d) {
    var pe = Aa.current;
    ki(Aa), (d._currentValue = pe);
  }
  function jl(d, pe, gt) {
    for (; d !== null; ) {
      var yt = d.alternate;
      if (
        ((d.childLanes & pe) !== pe
          ? ((d.childLanes |= pe), yt !== null && (yt.childLanes |= pe))
          : yt !== null && (yt.childLanes & pe) !== pe && (yt.childLanes |= pe),
        d === gt)
      )
        break;
      d = d.return;
    }
  }
  function ia(d, pe) {
    (Pa = d),
      (ul = Bo = null),
      (d = d.dependencies),
      d !== null &&
        d.firstContext !== null &&
        ((d.lanes & pe) !== 0 && (hi = !0), (d.firstContext = null));
  }
  function Vs(d) {
    var pe = d._currentValue;
    if (ul !== d)
      if (((d = { context: d, memoizedValue: pe, next: null }), Bo === null)) {
        if (Pa === null) throw Error(t(308));
        (Bo = d), (Pa.dependencies = { lanes: 0, firstContext: d });
      } else Bo = Bo.next = d;
    return pe;
  }
  var Uo = null;
  function Cu(d) {
    Uo === null ? (Uo = [d]) : Uo.push(d);
  }
  function $l(d, pe, gt, yt) {
    var At = pe.interleaved;
    return (
      At === null
        ? ((gt.next = gt), Cu(pe))
        : ((gt.next = At.next), (At.next = gt)),
      (pe.interleaved = gt),
      lo(d, yt)
    );
  }
  function lo(d, pe) {
    d.lanes |= pe;
    var gt = d.alternate;
    for (gt !== null && (gt.lanes |= pe), gt = d, d = d.return; d !== null; )
      (d.childLanes |= pe),
        (gt = d.alternate),
        gt !== null && (gt.childLanes |= pe),
        (gt = d),
        (d = d.return);
    return gt.tag === 3 ? gt.stateNode : null;
  }
  var Ci = !1;
  function ui(d) {
    d.updateQueue = {
      baseState: d.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function qi(d, pe) {
    (d = d.updateQueue),
      pe.updateQueue === d &&
        (pe.updateQueue = {
          baseState: d.baseState,
          firstBaseUpdate: d.firstBaseUpdate,
          lastBaseUpdate: d.lastBaseUpdate,
          shared: d.shared,
          effects: d.effects,
        });
  }
  function Ai(d, pe) {
    return {
      eventTime: d,
      lane: pe,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Bi(d, pe, gt) {
    var yt = d.updateQueue;
    if (yt === null) return null;
    if (((yt = yt.shared), (Ei & 2) !== 0)) {
      var At = yt.pending;
      return (
        At === null ? (pe.next = pe) : ((pe.next = At.next), (At.next = pe)),
        (yt.pending = pe),
        lo(d, gt)
      );
    }
    return (
      (At = yt.interleaved),
      At === null
        ? ((pe.next = pe), Cu(yt))
        : ((pe.next = At.next), (At.next = pe)),
      (yt.interleaved = pe),
      lo(d, gt)
    );
  }
  function gs(d, pe, gt) {
    if (
      ((pe = pe.updateQueue),
      pe !== null && ((pe = pe.shared), (gt & 4194240) !== 0))
    ) {
      var yt = pe.lanes;
      (yt &= d.pendingLanes), (gt |= yt), (pe.lanes = gt), Ui(d, gt);
    }
  }
  function Ia(d, pe) {
    var gt = d.updateQueue,
      yt = d.alternate;
    if (yt !== null && ((yt = yt.updateQueue), gt === yt)) {
      var At = null,
        Lt = null;
      if (((gt = gt.firstBaseUpdate), gt !== null)) {
        do {
          var Wt = {
            eventTime: gt.eventTime,
            lane: gt.lane,
            tag: gt.tag,
            payload: gt.payload,
            callback: gt.callback,
            next: null,
          };
          Lt === null ? (At = Lt = Wt) : (Lt = Lt.next = Wt), (gt = gt.next);
        } while (gt !== null);
        Lt === null ? (At = Lt = pe) : (Lt = Lt.next = pe);
      } else At = Lt = pe;
      (gt = {
        baseState: yt.baseState,
        firstBaseUpdate: At,
        lastBaseUpdate: Lt,
        shared: yt.shared,
        effects: yt.effects,
      }),
        (d.updateQueue = gt);
      return;
    }
    (d = gt.lastBaseUpdate),
      d === null ? (gt.firstBaseUpdate = pe) : (d.next = pe),
      (gt.lastBaseUpdate = pe);
  }
  function Hi(d, pe, gt, yt) {
    var At = d.updateQueue;
    Ci = !1;
    var Lt = At.firstBaseUpdate,
      Wt = At.lastBaseUpdate,
      nn = At.shared.pending;
    if (nn !== null) {
      At.shared.pending = null;
      var dn = nn,
        Dn = dn.next;
      (dn.next = null), Wt === null ? (Lt = Dn) : (Wt.next = Dn), (Wt = dn);
      var sr = d.alternate;
      sr !== null &&
        ((sr = sr.updateQueue),
        (nn = sr.lastBaseUpdate),
        nn !== Wt &&
          (nn === null ? (sr.firstBaseUpdate = Dn) : (nn.next = Dn),
          (sr.lastBaseUpdate = dn)));
    }
    if (Lt !== null) {
      var lr = At.baseState;
      (Wt = 0), (sr = Dn = dn = null), (nn = Lt);
      do {
        var ir = nn.lane,
          Lr = nn.eventTime;
        if ((yt & ir) === ir) {
          sr !== null &&
            (sr = sr.next =
              {
                eventTime: Lr,
                lane: 0,
                tag: nn.tag,
                payload: nn.payload,
                callback: nn.callback,
                next: null,
              });
          e: {
            var Nr = d,
              Vr = nn;
            switch (((ir = pe), (Lr = gt), Vr.tag)) {
              case 1:
                if (((Nr = Vr.payload), typeof Nr == "function")) {
                  lr = Nr.call(Lr, lr, ir);
                  break e;
                }
                lr = Nr;
                break e;
              case 3:
                Nr.flags = (Nr.flags & -65537) | 128;
              case 0:
                if (
                  ((Nr = Vr.payload),
                  (ir = typeof Nr == "function" ? Nr.call(Lr, lr, ir) : Nr),
                  ir == null)
                )
                  break e;
                lr = It({}, lr, ir);
                break e;
              case 2:
                Ci = !0;
            }
          }
          nn.callback !== null &&
            nn.lane !== 0 &&
            ((d.flags |= 64),
            (ir = At.effects),
            ir === null ? (At.effects = [nn]) : ir.push(nn));
        } else
          (Lr = {
            eventTime: Lr,
            lane: ir,
            tag: nn.tag,
            payload: nn.payload,
            callback: nn.callback,
            next: null,
          }),
            sr === null ? ((Dn = sr = Lr), (dn = lr)) : (sr = sr.next = Lr),
            (Wt |= ir);
        if (((nn = nn.next), nn === null)) {
          if (((nn = At.shared.pending), nn === null)) break;
          (ir = nn),
            (nn = ir.next),
            (ir.next = null),
            (At.lastBaseUpdate = ir),
            (At.shared.pending = null);
        }
      } while (!0);
      if (
        (sr === null && (dn = lr),
        (At.baseState = dn),
        (At.firstBaseUpdate = Dn),
        (At.lastBaseUpdate = sr),
        (pe = At.shared.interleaved),
        pe !== null)
      ) {
        At = pe;
        do (Wt |= At.lane), (At = At.next);
        while (At !== pe);
      } else Lt === null && (At.shared.lanes = 0);
      (tc |= Wt), (d.lanes = Wt), (d.memoizedState = lr);
    }
  }
  function hl(d, pe, gt) {
    if (((d = pe.effects), (pe.effects = null), d !== null))
      for (pe = 0; pe < d.length; pe++) {
        var yt = d[pe],
          At = yt.callback;
        if (At !== null) {
          if (((yt.callback = null), (yt = gt), typeof At != "function"))
            throw Error(t(191, At));
          At.call(yt);
        }
      }
  }
  var _o = {},
    Gs = Gi(_o),
    La = Gi(_o),
    zo = Gi(_o);
  function Xi(d) {
    if (d === _o) throw Error(t(174));
    return d;
  }
  function ql(d, pe) {
    switch ((Ri(zo, pe), Ri(La, d), Ri(Gs, _o), (d = pe.nodeType), d)) {
      case 9:
      case 11:
        pe = (pe = pe.documentElement) ? pe.namespaceURI : Vn(null, "");
        break;
      default:
        (d = d === 8 ? pe.parentNode : pe),
          (pe = d.namespaceURI || null),
          (d = d.tagName),
          (pe = Vn(pe, d));
    }
    ki(Gs), Ri(Gs, pe);
  }
  function sa() {
    ki(Gs), ki(La), ki(zo);
  }
  function ka(d) {
    Xi(zo.current);
    var pe = Xi(Gs.current),
      gt = Vn(pe, d.type);
    pe !== gt && (Ri(La, d), Ri(Gs, gt));
  }
  function dl(d) {
    La.current === d && (ki(Gs), ki(La));
  }
  var Oi = Gi(0);
  function co(d) {
    for (var pe = d; pe !== null; ) {
      if (pe.tag === 13) {
        var gt = pe.memoizedState;
        if (
          gt !== null &&
          ((gt = gt.dehydrated),
          gt === null || gt.data === "$?" || gt.data === "$!")
        )
          return pe;
      } else if (pe.tag === 19 && pe.memoizedProps.revealOrder !== void 0) {
        if ((pe.flags & 128) !== 0) return pe;
      } else if (pe.child !== null) {
        (pe.child.return = pe), (pe = pe.child);
        continue;
      }
      if (pe === d) break;
      for (; pe.sibling === null; ) {
        if (pe.return === null || pe.return === d) return null;
        pe = pe.return;
      }
      (pe.sibling.return = pe.return), (pe = pe.sibling);
    }
    return null;
  }
  var pl = [];
  function yo() {
    for (var d = 0; d < pl.length; d++)
      pl[d]._workInProgressVersionPrimary = null;
    pl.length = 0;
  }
  var Fa = vt.ReactCurrentDispatcher,
    Da = vt.ReactCurrentBatchConfig,
    Vo = 0,
    Fi = null,
    Wi = null,
    Si = null,
    uo = !1,
    vs = !1,
    oa = 0,
    Fs = 0;
  function us() {
    throw Error(t(321));
  }
  function Xl(d, pe) {
    if (pe === null) return !1;
    for (var gt = 0; gt < pe.length && gt < d.length; gt++)
      if (!Bs(d[gt], pe[gt])) return !1;
    return !0;
  }
  function Yl(d, pe, gt, yt, At, Lt) {
    if (
      ((Vo = Lt),
      (Fi = pe),
      (pe.memoizedState = null),
      (pe.updateQueue = null),
      (pe.lanes = 0),
      (Fa.current = d === null || d.memoizedState === null ? uf : ff),
      (d = gt(yt, At)),
      vs)
    ) {
      Lt = 0;
      do {
        if (((vs = !1), (oa = 0), 25 <= Lt)) throw Error(t(301));
        (Lt += 1),
          (Si = Wi = null),
          (pe.updateQueue = null),
          (Fa.current = hf),
          (d = gt(yt, At));
      } while (vs);
    }
    if (
      ((Fa.current = jc),
      (pe = Wi !== null && Wi.next !== null),
      (Vo = 0),
      (Si = Wi = Fi = null),
      (uo = !1),
      pe)
    )
      throw Error(t(300));
    return d;
  }
  function Au() {
    var d = oa !== 0;
    return (oa = 0), d;
  }
  function fs() {
    var d = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Si === null ? (Fi.memoizedState = Si = d) : (Si = Si.next = d), Si;
  }
  function Hs() {
    if (Wi === null) {
      var d = Fi.alternate;
      d = d !== null ? d.memoizedState : null;
    } else d = Wi.next;
    var pe = Si === null ? Fi.memoizedState : Si.next;
    if (pe !== null) (Si = pe), (Wi = d);
    else {
      if (d === null) throw Error(t(310));
      (Wi = d),
        (d = {
          memoizedState: Wi.memoizedState,
          baseState: Wi.baseState,
          baseQueue: Wi.baseQueue,
          queue: Wi.queue,
          next: null,
        }),
        Si === null ? (Fi.memoizedState = Si = d) : (Si = Si.next = d);
    }
    return Si;
  }
  function ml(d, pe) {
    return typeof pe == "function" ? pe(d) : pe;
  }
  function Kl(d) {
    var pe = Hs(),
      gt = pe.queue;
    if (gt === null) throw Error(t(311));
    gt.lastRenderedReducer = d;
    var yt = Wi,
      At = yt.baseQueue,
      Lt = gt.pending;
    if (Lt !== null) {
      if (At !== null) {
        var Wt = At.next;
        (At.next = Lt.next), (Lt.next = Wt);
      }
      (yt.baseQueue = At = Lt), (gt.pending = null);
    }
    if (At !== null) {
      (Lt = At.next), (yt = yt.baseState);
      var nn = (Wt = null),
        dn = null,
        Dn = Lt;
      do {
        var sr = Dn.lane;
        if ((Vo & sr) === sr)
          dn !== null &&
            (dn = dn.next =
              {
                lane: 0,
                action: Dn.action,
                hasEagerState: Dn.hasEagerState,
                eagerState: Dn.eagerState,
                next: null,
              }),
            (yt = Dn.hasEagerState ? Dn.eagerState : d(yt, Dn.action));
        else {
          var lr = {
            lane: sr,
            action: Dn.action,
            hasEagerState: Dn.hasEagerState,
            eagerState: Dn.eagerState,
            next: null,
          };
          dn === null ? ((nn = dn = lr), (Wt = yt)) : (dn = dn.next = lr),
            (Fi.lanes |= sr),
            (tc |= sr);
        }
        Dn = Dn.next;
      } while (Dn !== null && Dn !== Lt);
      dn === null ? (Wt = yt) : (dn.next = nn),
        Bs(yt, pe.memoizedState) || (hi = !0),
        (pe.memoizedState = yt),
        (pe.baseState = Wt),
        (pe.baseQueue = dn),
        (gt.lastRenderedState = yt);
    }
    if (((d = gt.interleaved), d !== null)) {
      At = d;
      do (Lt = At.lane), (Fi.lanes |= Lt), (tc |= Lt), (At = At.next);
      while (At !== d);
    } else At === null && (gt.lanes = 0);
    return [pe.memoizedState, gt.dispatch];
  }
  function Go(d) {
    var pe = Hs(),
      gt = pe.queue;
    if (gt === null) throw Error(t(311));
    gt.lastRenderedReducer = d;
    var yt = gt.dispatch,
      At = gt.pending,
      Lt = pe.memoizedState;
    if (At !== null) {
      gt.pending = null;
      var Wt = (At = At.next);
      do (Lt = d(Lt, Wt.action)), (Wt = Wt.next);
      while (Wt !== At);
      Bs(Lt, pe.memoizedState) || (hi = !0),
        (pe.memoizedState = Lt),
        pe.baseQueue === null && (pe.baseState = Lt),
        (gt.lastRenderedState = Lt);
    }
    return [Lt, yt];
  }
  function Pu() {}
  function Ru(d, pe) {
    var gt = Fi,
      yt = Hs(),
      At = pe(),
      Lt = !Bs(yt.memoizedState, At);
    if (
      (Lt && ((yt.memoizedState = At), (hi = !0)),
      (yt = yt.queue),
      ku(rf.bind(null, gt, yt, d), [d]),
      yt.getSnapshot !== pe || Lt || (Si !== null && Si.memoizedState.tag & 1))
    ) {
      if (
        ((gt.flags |= 2048),
        fo(9, Zl.bind(null, gt, yt, At, pe), void 0, null),
        _s === null)
      )
        throw Error(t(349));
      (Vo & 30) !== 0 || Uc(gt, pe, At);
    }
    return At;
  }
  function Uc(d, pe, gt) {
    (d.flags |= 16384),
      (d = { getSnapshot: pe, value: gt }),
      (pe = Fi.updateQueue),
      pe === null
        ? ((pe = { lastEffect: null, stores: null }),
          (Fi.updateQueue = pe),
          (pe.stores = [d]))
        : ((gt = pe.stores), gt === null ? (pe.stores = [d]) : gt.push(d));
  }
  function Zl(d, pe, gt, yt) {
    (pe.value = gt), (pe.getSnapshot = yt), sf(pe) && Iu(d);
  }
  function rf(d, pe, gt) {
    return gt(function () {
      sf(pe) && Iu(d);
    });
  }
  function sf(d) {
    var pe = d.getSnapshot;
    d = d.value;
    try {
      var gt = pe();
      return !Bs(d, gt);
    } catch {
      return !0;
    }
  }
  function Iu(d) {
    var pe = lo(d, 1);
    pe !== null && qo(pe, d, 1, -1);
  }
  function Lu(d) {
    var pe = fs();
    return (
      typeof d == "function" && (d = d()),
      (pe.memoizedState = pe.baseState = d),
      (d = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ml,
        lastRenderedState: d,
      }),
      (pe.queue = d),
      (d = d.dispatch = Oa.bind(null, Fi, d)),
      [pe.memoizedState, d]
    );
  }
  function fo(d, pe, gt, yt) {
    return (
      (d = { tag: d, create: pe, destroy: gt, deps: yt, next: null }),
      (pe = Fi.updateQueue),
      pe === null
        ? ((pe = { lastEffect: null, stores: null }),
          (Fi.updateQueue = pe),
          (pe.lastEffect = d.next = d))
        : ((gt = pe.lastEffect),
          gt === null
            ? (pe.lastEffect = d.next = d)
            : ((yt = gt.next),
              (gt.next = d),
              (d.next = yt),
              (pe.lastEffect = d))),
      d
    );
  }
  function of() {
    return Hs().memoizedState;
  }
  function xo(d, pe, gt, yt) {
    var At = fs();
    (Fi.flags |= d),
      (At.memoizedState = fo(1 | pe, gt, void 0, yt === void 0 ? null : yt));
  }
  function Ql(d, pe, gt, yt) {
    var At = Hs();
    yt = yt === void 0 ? null : yt;
    var Lt = void 0;
    if (Wi !== null) {
      var Wt = Wi.memoizedState;
      if (((Lt = Wt.destroy), yt !== null && Xl(yt, Wt.deps))) {
        At.memoizedState = fo(pe, gt, Lt, yt);
        return;
      }
    }
    (Fi.flags |= d), (At.memoizedState = fo(1 | pe, gt, Lt, yt));
  }
  function Ms(d, pe) {
    return xo(8390656, 8, d, pe);
  }
  function ku(d, pe) {
    return Ql(2048, 8, d, pe);
  }
  function Fu(d, pe) {
    return Ql(4, 2, d, pe);
  }
  function af(d, pe) {
    return Ql(4, 4, d, pe);
  }
  function lf(d, pe) {
    if (typeof pe == "function")
      return (
        (d = d()),
        pe(d),
        function () {
          pe(null);
        }
      );
    if (pe != null)
      return (
        (d = d()),
        (pe.current = d),
        function () {
          pe.current = null;
        }
      );
  }
  function Du(d, pe, gt) {
    return (
      (gt = gt != null ? gt.concat([d]) : null),
      Ql(4, 4, lf.bind(null, pe, d), gt)
    );
  }
  function zc() {}
  function cf(d, pe) {
    var gt = Hs();
    pe = pe === void 0 ? null : pe;
    var yt = gt.memoizedState;
    return yt !== null && pe !== null && Xl(pe, yt[1])
      ? yt[0]
      : ((gt.memoizedState = [d, pe]), d);
  }
  function Ws(d, pe) {
    var gt = Hs();
    pe = pe === void 0 ? null : pe;
    var yt = gt.memoizedState;
    return yt !== null && pe !== null && Xl(pe, yt[1])
      ? yt[0]
      : ((d = d()), (gt.memoizedState = [d, pe]), d);
  }
  function Vc(d, pe, gt) {
    return (Vo & 21) === 0
      ? (d.baseState && ((d.baseState = !1), (hi = !0)), (d.memoizedState = gt))
      : (Bs(gt, pe) ||
          ((gt = Kr()), (Fi.lanes |= gt), (tc |= gt), (d.baseState = !0)),
        pe);
  }
  function Nf(d, pe) {
    var gt = di;
    (di = gt !== 0 && 4 > gt ? gt : 4), d(!0);
    var yt = Da.transition;
    Da.transition = {};
    try {
      d(!1), pe();
    } finally {
      (di = gt), (Da.transition = yt);
    }
  }
  function Ho() {
    return Hs().memoizedState;
  }
  function Gc(d, pe, gt) {
    var yt = yl(d);
    if (
      ((gt = {
        lane: yt,
        action: gt,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      Jl(d))
    )
      Hc(pe, gt);
    else if (((gt = $l(d, pe, gt, yt)), gt !== null)) {
      var At = $s();
      qo(gt, d, yt, At), Wc(gt, pe, yt);
    }
  }
  function Oa(d, pe, gt) {
    var yt = yl(d),
      At = {
        lane: yt,
        action: gt,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (Jl(d)) Hc(pe, At);
    else {
      var Lt = d.alternate;
      if (
        d.lanes === 0 &&
        (Lt === null || Lt.lanes === 0) &&
        ((Lt = pe.lastRenderedReducer), Lt !== null)
      )
        try {
          var Wt = pe.lastRenderedState,
            nn = Lt(Wt, gt);
          if (((At.hasEagerState = !0), (At.eagerState = nn), Bs(nn, Wt))) {
            var dn = pe.interleaved;
            dn === null
              ? ((At.next = At), Cu(pe))
              : ((At.next = dn.next), (dn.next = At)),
              (pe.interleaved = At);
            return;
          }
        } catch {
        } finally {
        }
      (gt = $l(d, pe, At, yt)),
        gt !== null && ((At = $s()), qo(gt, d, yt, At), Wc(gt, pe, yt));
    }
  }
  function Jl(d) {
    var pe = d.alternate;
    return d === Fi || (pe !== null && pe === Fi);
  }
  function Hc(d, pe) {
    vs = uo = !0;
    var gt = d.pending;
    gt === null ? (pe.next = pe) : ((pe.next = gt.next), (gt.next = pe)),
      (d.pending = pe);
  }
  function Wc(d, pe, gt) {
    if ((gt & 4194240) !== 0) {
      var yt = pe.lanes;
      (yt &= d.pendingLanes), (gt |= yt), (pe.lanes = gt), Ui(d, gt);
    }
  }
  var jc = {
      readContext: Vs,
      useCallback: us,
      useContext: us,
      useEffect: us,
      useImperativeHandle: us,
      useInsertionEffect: us,
      useLayoutEffect: us,
      useMemo: us,
      useReducer: us,
      useRef: us,
      useState: us,
      useDebugValue: us,
      useDeferredValue: us,
      useTransition: us,
      useMutableSource: us,
      useSyncExternalStore: us,
      useId: us,
      unstable_isNewReconciler: !1,
    },
    uf = {
      readContext: Vs,
      useCallback: function (d, pe) {
        return (fs().memoizedState = [d, pe === void 0 ? null : pe]), d;
      },
      useContext: Vs,
      useEffect: Ms,
      useImperativeHandle: function (d, pe, gt) {
        return (
          (gt = gt != null ? gt.concat([d]) : null),
          xo(4194308, 4, lf.bind(null, pe, d), gt)
        );
      },
      useLayoutEffect: function (d, pe) {
        return xo(4194308, 4, d, pe);
      },
      useInsertionEffect: function (d, pe) {
        return xo(4, 2, d, pe);
      },
      useMemo: function (d, pe) {
        var gt = fs();
        return (
          (pe = pe === void 0 ? null : pe),
          (d = d()),
          (gt.memoizedState = [d, pe]),
          d
        );
      },
      useReducer: function (d, pe, gt) {
        var yt = fs();
        return (
          (pe = gt !== void 0 ? gt(pe) : pe),
          (yt.memoizedState = yt.baseState = pe),
          (d = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: d,
            lastRenderedState: pe,
          }),
          (yt.queue = d),
          (d = d.dispatch = Gc.bind(null, Fi, d)),
          [yt.memoizedState, d]
        );
      },
      useRef: function (d) {
        var pe = fs();
        return (d = { current: d }), (pe.memoizedState = d);
      },
      useState: Lu,
      useDebugValue: zc,
      useDeferredValue: function (d) {
        return (fs().memoizedState = d);
      },
      useTransition: function () {
        var d = Lu(!1),
          pe = d[0];
        return (d = Nf.bind(null, d[1])), (fs().memoizedState = d), [pe, d];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (d, pe, gt) {
        var yt = Fi,
          At = fs();
        if (Di) {
          if (gt === void 0) throw Error(t(407));
          gt = gt();
        } else {
          if (((gt = pe()), _s === null)) throw Error(t(349));
          (Vo & 30) !== 0 || Uc(yt, pe, gt);
        }
        At.memoizedState = gt;
        var Lt = { value: gt, getSnapshot: pe };
        return (
          (At.queue = Lt),
          Ms(rf.bind(null, yt, Lt, d), [d]),
          (yt.flags |= 2048),
          fo(9, Zl.bind(null, yt, Lt, gt, pe), void 0, null),
          gt
        );
      },
      useId: function () {
        var d = fs(),
          pe = _s.identifierPrefix;
        if (Di) {
          var gt = Qs,
            yt = Er;
          (gt = (yt & ~(1 << (32 - Tr(yt) - 1))).toString(32) + gt),
            (pe = ":" + pe + "R" + gt),
            (gt = oa++),
            0 < gt && (pe += "H" + gt.toString(32)),
            (pe += ":");
        } else (gt = Fs++), (pe = ":" + pe + "r" + gt.toString(32) + ":");
        return (d.memoizedState = pe);
      },
      unstable_isNewReconciler: !1,
    },
    ff = {
      readContext: Vs,
      useCallback: cf,
      useContext: Vs,
      useEffect: ku,
      useImperativeHandle: Du,
      useInsertionEffect: Fu,
      useLayoutEffect: af,
      useMemo: Ws,
      useReducer: Kl,
      useRef: of,
      useState: function () {
        return Kl(ml);
      },
      useDebugValue: zc,
      useDeferredValue: function (d) {
        var pe = Hs();
        return Vc(pe, Wi.memoizedState, d);
      },
      useTransition: function () {
        var d = Kl(ml)[0],
          pe = Hs().memoizedState;
        return [d, pe];
      },
      useMutableSource: Pu,
      useSyncExternalStore: Ru,
      useId: Ho,
      unstable_isNewReconciler: !1,
    },
    hf = {
      readContext: Vs,
      useCallback: cf,
      useContext: Vs,
      useEffect: ku,
      useImperativeHandle: Du,
      useInsertionEffect: Fu,
      useLayoutEffect: af,
      useMemo: Ws,
      useReducer: Go,
      useRef: of,
      useState: function () {
        return Go(ml);
      },
      useDebugValue: zc,
      useDeferredValue: function (d) {
        var pe = Hs();
        return Wi === null
          ? (pe.memoizedState = d)
          : Vc(pe, Wi.memoizedState, d);
      },
      useTransition: function () {
        var d = Go(ml)[0],
          pe = Hs().memoizedState;
        return [d, pe];
      },
      useMutableSource: Pu,
      useSyncExternalStore: Ru,
      useId: Ho,
      unstable_isNewReconciler: !1,
    };
  function eo(d, pe) {
    if (d && d.defaultProps) {
      (pe = It({}, pe)), (d = d.defaultProps);
      for (var gt in d) pe[gt] === void 0 && (pe[gt] = d[gt]);
      return pe;
    }
    return pe;
  }
  function ec(d, pe, gt, yt) {
    (pe = d.memoizedState),
      (gt = gt(yt, pe)),
      (gt = gt == null ? pe : It({}, pe, gt)),
      (d.memoizedState = gt),
      d.lanes === 0 && (d.updateQueue.baseState = gt);
  }
  var $c = {
    isMounted: function (d) {
      return (d = d._reactInternals) ? $t(d) === d : !1;
    },
    enqueueSetState: function (d, pe, gt) {
      d = d._reactInternals;
      var yt = $s(),
        At = yl(d),
        Lt = Ai(yt, At);
      (Lt.payload = pe),
        gt != null && (Lt.callback = gt),
        (pe = Bi(d, Lt, At)),
        pe !== null && (qo(pe, d, At, yt), gs(pe, d, At));
    },
    enqueueReplaceState: function (d, pe, gt) {
      d = d._reactInternals;
      var yt = $s(),
        At = yl(d),
        Lt = Ai(yt, At);
      (Lt.tag = 1),
        (Lt.payload = pe),
        gt != null && (Lt.callback = gt),
        (pe = Bi(d, Lt, At)),
        pe !== null && (qo(pe, d, At, yt), gs(pe, d, At));
    },
    enqueueForceUpdate: function (d, pe) {
      d = d._reactInternals;
      var gt = $s(),
        yt = yl(d),
        At = Ai(gt, yt);
      (At.tag = 2),
        pe != null && (At.callback = pe),
        (pe = Bi(d, At, yt)),
        pe !== null && (qo(pe, d, yt, gt), gs(pe, d, yt));
    },
  };
  function df(d, pe, gt, yt, At, Lt, Wt) {
    return (
      (d = d.stateNode),
      typeof d.shouldComponentUpdate == "function"
        ? d.shouldComponentUpdate(yt, Lt, Wt)
        : pe.prototype && pe.prototype.isPureReactComponent
        ? !ga(gt, yt) || !ga(At, Lt)
        : !0
    );
  }
  function Le(d, pe, gt) {
    var yt = !1,
      At = Fo,
      Lt = pe.contextType;
    return (
      typeof Lt == "object" && Lt !== null
        ? (Lt = Vs(Lt))
        : ((At = ms(pe) ? Do : ls.current),
          (yt = pe.contextTypes),
          (Lt = (yt = yt != null) ? Ea(d, At) : Fo)),
      (pe = new pe(gt, Lt)),
      (d.memoizedState =
        pe.state !== null && pe.state !== void 0 ? pe.state : null),
      (pe.updater = $c),
      (d.stateNode = pe),
      (pe._reactInternals = d),
      yt &&
        ((d = d.stateNode),
        (d.__reactInternalMemoizedUnmaskedChildContext = At),
        (d.__reactInternalMemoizedMaskedChildContext = Lt)),
      pe
    );
  }
  function tt(d, pe, gt, yt) {
    (d = pe.state),
      typeof pe.componentWillReceiveProps == "function" &&
        pe.componentWillReceiveProps(gt, yt),
      typeof pe.UNSAFE_componentWillReceiveProps == "function" &&
        pe.UNSAFE_componentWillReceiveProps(gt, yt),
      pe.state !== d && $c.enqueueReplaceState(pe, pe.state, null);
  }
  function _t(d, pe, gt, yt) {
    var At = d.stateNode;
    (At.props = gt), (At.state = d.memoizedState), (At.refs = {}), ui(d);
    var Lt = pe.contextType;
    typeof Lt == "object" && Lt !== null
      ? (At.context = Vs(Lt))
      : ((Lt = ms(pe) ? Do : ls.current), (At.context = Ea(d, Lt))),
      (At.state = d.memoizedState),
      (Lt = pe.getDerivedStateFromProps),
      typeof Lt == "function" &&
        (ec(d, pe, Lt, gt), (At.state = d.memoizedState)),
      typeof pe.getDerivedStateFromProps == "function" ||
        typeof At.getSnapshotBeforeUpdate == "function" ||
        (typeof At.UNSAFE_componentWillMount != "function" &&
          typeof At.componentWillMount != "function") ||
        ((pe = At.state),
        typeof At.componentWillMount == "function" && At.componentWillMount(),
        typeof At.UNSAFE_componentWillMount == "function" &&
          At.UNSAFE_componentWillMount(),
        pe !== At.state && $c.enqueueReplaceState(At, At.state, null),
        Hi(d, gt, At, yt),
        (At.state = d.memoizedState)),
      typeof At.componentDidMount == "function" && (d.flags |= 4194308);
  }
  function Et(d, pe) {
    try {
      var gt = "",
        yt = pe;
      do (gt += tn(yt)), (yt = yt.return);
      while (yt);
      var At = gt;
    } catch (Lt) {
      At =
        `
Error generating stack: ` +
        Lt.message +
        `
` +
        Lt.stack;
    }
    return { value: d, source: pe, stack: At, digest: null };
  }
  function Rt(d, pe, gt) {
    return { value: d, source: null, stack: gt ?? null, digest: pe ?? null };
  }
  function Nt(d, pe) {
    try {
      console.error(pe.value);
    } catch (gt) {
      setTimeout(function () {
        throw gt;
      });
    }
  }
  var Jt = typeof WeakMap == "function" ? WeakMap : Map;
  function vn(d, pe, gt) {
    (gt = Ai(-1, gt)), (gt.tag = 3), (gt.payload = { element: null });
    var yt = pe.value;
    return (
      (gt.callback = function () {
        xf || ((xf = !0), (qf = yt)), Nt(d, pe);
      }),
      gt
    );
  }
  function Wn(d, pe, gt) {
    (gt = Ai(-1, gt)), (gt.tag = 3);
    var yt = d.type.getDerivedStateFromError;
    if (typeof yt == "function") {
      var At = pe.value;
      (gt.payload = function () {
        return yt(At);
      }),
        (gt.callback = function () {
          Nt(d, pe);
        });
    }
    var Lt = d.stateNode;
    return (
      Lt !== null &&
        typeof Lt.componentDidCatch == "function" &&
        (gt.callback = function () {
          Nt(d, pe),
            typeof yt != "function" &&
              (vl === null ? (vl = new Set([this])) : vl.add(this));
          var Wt = pe.stack;
          this.componentDidCatch(pe.value, {
            componentStack: Wt !== null ? Wt : "",
          });
        }),
      gt
    );
  }
  function dr(d, pe, gt) {
    var yt = d.pingCache;
    if (yt === null) {
      yt = d.pingCache = new Jt();
      var At = new Set();
      yt.set(pe, At);
    } else
      (At = yt.get(pe)), At === void 0 && ((At = new Set()), yt.set(pe, At));
    At.has(gt) || (At.add(gt), (d = Kh.bind(null, d, pe, gt)), pe.then(d, d));
  }
  function kr(d) {
    do {
      var pe;
      if (
        ((pe = d.tag === 13) &&
          ((pe = d.memoizedState),
          (pe = pe !== null ? pe.dehydrated !== null : !0)),
        pe)
      )
        return d;
      d = d.return;
    } while (d !== null);
    return null;
  }
  function ii(d, pe, gt, yt, At) {
    return (d.mode & 1) === 0
      ? (d === pe
          ? (d.flags |= 65536)
          : ((d.flags |= 128),
            (gt.flags |= 131072),
            (gt.flags &= -52805),
            gt.tag === 1 &&
              (gt.alternate === null
                ? (gt.tag = 17)
                : ((pe = Ai(-1, 1)), (pe.tag = 2), Bi(gt, pe, 1))),
            (gt.lanes |= 1)),
        d)
      : ((d.flags |= 65536), (d.lanes = At), d);
  }
  var Zr = vt.ReactCurrentOwner,
    hi = !1;
  function Ar(d, pe, gt, yt) {
    pe.child = d === null ? Hl(pe, null, gt, yt) : Ca(pe, d.child, gt, yt);
  }
  function hs(d, pe, gt, yt, At) {
    gt = gt.render;
    var Lt = pe.ref;
    return (
      ia(pe, At),
      (yt = Yl(d, pe, gt, yt, Lt, At)),
      (gt = Au()),
      d !== null && !hi
        ? ((pe.updateQueue = d.updateQueue),
          (pe.flags &= -2053),
          (d.lanes &= ~At),
          Na(d, pe, At))
        : (Di && gt && Su(pe), (pe.flags |= 1), Ar(d, pe, yt, At), pe.child)
    );
  }
  function js(d, pe, gt, yt, At) {
    if (d === null) {
      var Lt = gt.type;
      return typeof Lt == "function" &&
        !eh(Lt) &&
        Lt.defaultProps === void 0 &&
        gt.compare === null &&
        gt.defaultProps === void 0
        ? ((pe.tag = 15), (pe.type = Lt), Pn(d, pe, Lt, yt, At))
        : ((d = Mf(gt.type, null, yt, pe, pe.mode, At)),
          (d.ref = pe.ref),
          (d.return = pe),
          (pe.child = d));
    }
    if (((Lt = d.child), (d.lanes & At) === 0)) {
      var Wt = Lt.memoizedProps;
      if (
        ((gt = gt.compare),
        (gt = gt !== null ? gt : ga),
        gt(Wt, yt) && d.ref === pe.ref)
      )
        return Na(d, pe, At);
    }
    return (
      (pe.flags |= 1),
      (d = Sl(Lt, yt)),
      (d.ref = pe.ref),
      (d.return = pe),
      (pe.child = d)
    );
  }
  function Pn(d, pe, gt, yt, At) {
    if (d !== null) {
      var Lt = d.memoizedProps;
      if (ga(Lt, yt) && d.ref === pe.ref)
        if (((hi = !1), (pe.pendingProps = yt = Lt), (d.lanes & At) !== 0))
          (d.flags & 131072) !== 0 && (hi = !0);
        else return (pe.lanes = d.lanes), Na(d, pe, At);
    }
    return br(d, pe, gt, yt, At);
  }
  function xn(d, pe, gt) {
    var yt = pe.pendingProps,
      At = yt.children,
      Lt = d !== null ? d.memoizedState : null;
    if (yt.mode === "hidden")
      if ((pe.mode & 1) === 0)
        (pe.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          Ri(Xc, ho),
          (ho |= gt);
      else {
        if ((gt & 1073741824) === 0)
          return (
            (d = Lt !== null ? Lt.baseLanes | gt : gt),
            (pe.lanes = pe.childLanes = 1073741824),
            (pe.memoizedState = {
              baseLanes: d,
              cachePool: null,
              transitions: null,
            }),
            (pe.updateQueue = null),
            Ri(Xc, ho),
            (ho |= d),
            null
          );
        (pe.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (yt = Lt !== null ? Lt.baseLanes : gt),
          Ri(Xc, ho),
          (ho |= yt);
      }
    else
      Lt !== null
        ? ((yt = Lt.baseLanes | gt), (pe.memoizedState = null))
        : (yt = gt),
        Ri(Xc, ho),
        (ho |= yt);
    return Ar(d, pe, At, gt), pe.child;
  }
  function Nn(d, pe) {
    var gt = pe.ref;
    ((d === null && gt !== null) || (d !== null && d.ref !== gt)) &&
      ((pe.flags |= 512), (pe.flags |= 2097152));
  }
  function br(d, pe, gt, yt, At) {
    var Lt = ms(gt) ? Do : ls.current;
    return (
      (Lt = Ea(pe, Lt)),
      ia(pe, At),
      (gt = Yl(d, pe, gt, yt, Lt, At)),
      (yt = Au()),
      d !== null && !hi
        ? ((pe.updateQueue = d.updateQueue),
          (pe.flags &= -2053),
          (d.lanes &= ~At),
          Na(d, pe, At))
        : (Di && yt && Su(pe), (pe.flags |= 1), Ar(d, pe, gt, At), pe.child)
    );
  }
  function Gr(d, pe, gt, yt, At) {
    if (ms(gt)) {
      var Lt = !0;
      Ta(pe);
    } else Lt = !1;
    if ((ia(pe, At), pe.stateNode === null))
      mf(d, pe), Le(pe, gt, yt), _t(pe, gt, yt, At), (yt = !0);
    else if (d === null) {
      var Wt = pe.stateNode,
        nn = pe.memoizedProps;
      Wt.props = nn;
      var dn = Wt.context,
        Dn = gt.contextType;
      typeof Dn == "object" && Dn !== null
        ? (Dn = Vs(Dn))
        : ((Dn = ms(gt) ? Do : ls.current), (Dn = Ea(pe, Dn)));
      var sr = gt.getDerivedStateFromProps,
        lr =
          typeof sr == "function" ||
          typeof Wt.getSnapshotBeforeUpdate == "function";
      lr ||
        (typeof Wt.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Wt.componentWillReceiveProps != "function") ||
        ((nn !== yt || dn !== Dn) && tt(pe, Wt, yt, Dn)),
        (Ci = !1);
      var ir = pe.memoizedState;
      (Wt.state = ir),
        Hi(pe, yt, Wt, At),
        (dn = pe.memoizedState),
        nn !== yt || ir !== dn || Es.current || Ci
          ? (typeof sr == "function" &&
              (ec(pe, gt, sr, yt), (dn = pe.memoizedState)),
            (nn = Ci || df(pe, gt, nn, yt, ir, dn, Dn))
              ? (lr ||
                  (typeof Wt.UNSAFE_componentWillMount != "function" &&
                    typeof Wt.componentWillMount != "function") ||
                  (typeof Wt.componentWillMount == "function" &&
                    Wt.componentWillMount(),
                  typeof Wt.UNSAFE_componentWillMount == "function" &&
                    Wt.UNSAFE_componentWillMount()),
                typeof Wt.componentDidMount == "function" &&
                  (pe.flags |= 4194308))
              : (typeof Wt.componentDidMount == "function" &&
                  (pe.flags |= 4194308),
                (pe.memoizedProps = yt),
                (pe.memoizedState = dn)),
            (Wt.props = yt),
            (Wt.state = dn),
            (Wt.context = Dn),
            (yt = nn))
          : (typeof Wt.componentDidMount == "function" && (pe.flags |= 4194308),
            (yt = !1));
    } else {
      (Wt = pe.stateNode),
        qi(d, pe),
        (nn = pe.memoizedProps),
        (Dn = pe.type === pe.elementType ? nn : eo(pe.type, nn)),
        (Wt.props = Dn),
        (lr = pe.pendingProps),
        (ir = Wt.context),
        (dn = gt.contextType),
        typeof dn == "object" && dn !== null
          ? (dn = Vs(dn))
          : ((dn = ms(gt) ? Do : ls.current), (dn = Ea(pe, dn)));
      var Lr = gt.getDerivedStateFromProps;
      (sr =
        typeof Lr == "function" ||
        typeof Wt.getSnapshotBeforeUpdate == "function") ||
        (typeof Wt.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Wt.componentWillReceiveProps != "function") ||
        ((nn !== lr || ir !== dn) && tt(pe, Wt, yt, dn)),
        (Ci = !1),
        (ir = pe.memoizedState),
        (Wt.state = ir),
        Hi(pe, yt, Wt, At);
      var Nr = pe.memoizedState;
      nn !== lr || ir !== Nr || Es.current || Ci
        ? (typeof Lr == "function" &&
            (ec(pe, gt, Lr, yt), (Nr = pe.memoizedState)),
          (Dn = Ci || df(pe, gt, Dn, yt, ir, Nr, dn) || !1)
            ? (sr ||
                (typeof Wt.UNSAFE_componentWillUpdate != "function" &&
                  typeof Wt.componentWillUpdate != "function") ||
                (typeof Wt.componentWillUpdate == "function" &&
                  Wt.componentWillUpdate(yt, Nr, dn),
                typeof Wt.UNSAFE_componentWillUpdate == "function" &&
                  Wt.UNSAFE_componentWillUpdate(yt, Nr, dn)),
              typeof Wt.componentDidUpdate == "function" && (pe.flags |= 4),
              typeof Wt.getSnapshotBeforeUpdate == "function" &&
                (pe.flags |= 1024))
            : (typeof Wt.componentDidUpdate != "function" ||
                (nn === d.memoizedProps && ir === d.memoizedState) ||
                (pe.flags |= 4),
              typeof Wt.getSnapshotBeforeUpdate != "function" ||
                (nn === d.memoizedProps && ir === d.memoizedState) ||
                (pe.flags |= 1024),
              (pe.memoizedProps = yt),
              (pe.memoizedState = Nr)),
          (Wt.props = yt),
          (Wt.state = Nr),
          (Wt.context = dn),
          (yt = Dn))
        : (typeof Wt.componentDidUpdate != "function" ||
            (nn === d.memoizedProps && ir === d.memoizedState) ||
            (pe.flags |= 4),
          typeof Wt.getSnapshotBeforeUpdate != "function" ||
            (nn === d.memoizedProps && ir === d.memoizedState) ||
            (pe.flags |= 1024),
          (yt = !1));
    }
    return li(d, pe, gt, yt, Lt, At);
  }
  function li(d, pe, gt, yt, At, Lt) {
    Nn(d, pe);
    var Wt = (pe.flags & 128) !== 0;
    if (!yt && !Wt) return At && yu(pe, gt, !1), Na(d, pe, Lt);
    (yt = pe.stateNode), (Zr.current = pe);
    var nn =
      Wt && typeof gt.getDerivedStateFromError != "function"
        ? null
        : yt.render();
    return (
      (pe.flags |= 1),
      d !== null && Wt
        ? ((pe.child = Ca(pe, d.child, null, Lt)),
          (pe.child = Ca(pe, null, nn, Lt)))
        : Ar(d, pe, nn, Lt),
      (pe.memoizedState = yt.state),
      At && yu(pe, gt, !0),
      pe.child
    );
  }
  function si(d) {
    var pe = d.stateNode;
    pe.pendingContext
      ? _u(d, pe.pendingContext, pe.pendingContext !== pe.context)
      : pe.context && _u(d, pe.context, !1),
      ql(d, pe.containerInfo);
  }
  function xi(d, pe, gt, yt, At) {
    return ra(), cl(At), (pe.flags |= 256), Ar(d, pe, gt, yt), pe.child;
  }
  var Yi = { dehydrated: null, treeContext: null, retryLane: 0 };
  function vi(d) {
    return { baseLanes: d, cachePool: null, transitions: null };
  }
  function Wo(d, pe, gt) {
    var yt = pe.pendingProps,
      At = Oi.current,
      Lt = !1,
      Wt = (pe.flags & 128) !== 0,
      nn;
    if (
      ((nn = Wt) ||
        (nn = d !== null && d.memoizedState === null ? !1 : (At & 2) !== 0),
      nn
        ? ((Lt = !0), (pe.flags &= -129))
        : (d === null || d.memoizedState !== null) && (At |= 1),
      Ri(Oi, At & 1),
      d === null)
    )
      return (
        Nc(pe),
        (d = pe.memoizedState),
        d !== null && ((d = d.dehydrated), d !== null)
          ? ((pe.mode & 1) === 0
              ? (pe.lanes = 1)
              : d.data === "$!"
              ? (pe.lanes = 8)
              : (pe.lanes = 1073741824),
            null)
          : ((Wt = yt.children),
            (d = yt.fallback),
            Lt
              ? ((yt = pe.mode),
                (Lt = pe.child),
                (Wt = { mode: "hidden", children: Wt }),
                (yt & 1) === 0 && Lt !== null
                  ? ((Lt.childLanes = 0), (Lt.pendingProps = Wt))
                  : (Lt = Cf(Wt, yt, 0, null)),
                (d = sc(d, yt, gt, null)),
                (Lt.return = pe),
                (d.return = pe),
                (Lt.sibling = d),
                (pe.child = Lt),
                (pe.child.memoizedState = vi(gt)),
                (pe.memoizedState = Yi),
                d)
              : Ou(pe, Wt))
      );
    if (
      ((At = d.memoizedState),
      At !== null && ((nn = At.dehydrated), nn !== null))
    )
      return Bh(d, pe, Wt, yt, nn, At, gt);
    if (Lt) {
      (Lt = yt.fallback), (Wt = pe.mode), (At = d.child), (nn = At.sibling);
      var dn = { mode: "hidden", children: yt.children };
      return (
        (Wt & 1) === 0 && pe.child !== At
          ? ((yt = pe.child),
            (yt.childLanes = 0),
            (yt.pendingProps = dn),
            (pe.deletions = null))
          : ((yt = Sl(At, dn)), (yt.subtreeFlags = At.subtreeFlags & 14680064)),
        nn !== null
          ? (Lt = Sl(nn, Lt))
          : ((Lt = sc(Lt, Wt, gt, null)), (Lt.flags |= 2)),
        (Lt.return = pe),
        (yt.return = pe),
        (yt.sibling = Lt),
        (pe.child = yt),
        (yt = Lt),
        (Lt = pe.child),
        (Wt = d.child.memoizedState),
        (Wt =
          Wt === null
            ? vi(gt)
            : {
                baseLanes: Wt.baseLanes | gt,
                cachePool: null,
                transitions: Wt.transitions,
              }),
        (Lt.memoizedState = Wt),
        (Lt.childLanes = d.childLanes & ~gt),
        (pe.memoizedState = Yi),
        yt
      );
    }
    return (
      (Lt = d.child),
      (d = Lt.sibling),
      (yt = Sl(Lt, { mode: "visible", children: yt.children })),
      (pe.mode & 1) === 0 && (yt.lanes = gt),
      (yt.return = pe),
      (yt.sibling = null),
      d !== null &&
        ((gt = pe.deletions),
        gt === null ? ((pe.deletions = [d]), (pe.flags |= 16)) : gt.push(d)),
      (pe.child = yt),
      (pe.memoizedState = null),
      yt
    );
  }
  function Ou(d, pe) {
    return (
      (pe = Cf({ mode: "visible", children: pe }, d.mode, 0, null)),
      (pe.return = d),
      (d.child = pe)
    );
  }
  function pf(d, pe, gt, yt) {
    return (
      yt !== null && cl(yt),
      Ca(pe, d.child, null, gt),
      (d = Ou(pe, pe.pendingProps.children)),
      (d.flags |= 2),
      (pe.memoizedState = null),
      d
    );
  }
  function Bh(d, pe, gt, yt, At, Lt, Wt) {
    if (gt)
      return pe.flags & 256
        ? ((pe.flags &= -257), (yt = Rt(Error(t(422)))), pf(d, pe, Wt, yt))
        : pe.memoizedState !== null
        ? ((pe.child = d.child), (pe.flags |= 128), null)
        : ((Lt = yt.fallback),
          (At = pe.mode),
          (yt = Cf({ mode: "visible", children: yt.children }, At, 0, null)),
          (Lt = sc(Lt, At, Wt, null)),
          (Lt.flags |= 2),
          (yt.return = pe),
          (Lt.return = pe),
          (yt.sibling = Lt),
          (pe.child = yt),
          (pe.mode & 1) !== 0 && Ca(pe, d.child, null, Wt),
          (pe.child.memoizedState = vi(Wt)),
          (pe.memoizedState = Yi),
          Lt);
    if ((pe.mode & 1) === 0) return pf(d, pe, Wt, null);
    if (At.data === "$!") {
      if (((yt = At.nextSibling && At.nextSibling.dataset), yt))
        var nn = yt.dgst;
      return (
        (yt = nn),
        (Lt = Error(t(419))),
        (yt = Rt(Lt, yt, void 0)),
        pf(d, pe, Wt, yt)
      );
    }
    if (((nn = (Wt & d.childLanes) !== 0), hi || nn)) {
      if (((yt = _s), yt !== null)) {
        switch (Wt & -Wt) {
          case 4:
            At = 2;
            break;
          case 16:
            At = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            At = 32;
            break;
          case 536870912:
            At = 268435456;
            break;
          default:
            At = 0;
        }
        (At = (At & (yt.suspendedLanes | Wt)) !== 0 ? 0 : At),
          At !== 0 &&
            At !== Lt.retryLane &&
            ((Lt.retryLane = At), lo(d, At), qo(yt, d, At, -1));
      }
      return Jf(), (yt = Rt(Error(t(421)))), pf(d, pe, Wt, yt);
    }
    return At.data === "$?"
      ? ((pe.flags |= 128),
        (pe.child = d.child),
        (pe = Zh.bind(null, d)),
        (At._reactRetry = pe),
        null)
      : ((d = Lt.treeContext),
        (bs = Lo(At.nextSibling)),
        (cs = pe),
        (Di = !0),
        (Js = null),
        d !== null &&
          ((Ts[ss++] = Er),
          (Ts[ss++] = Qs),
          (Ts[ss++] = Ma),
          (Er = d.id),
          (Qs = d.overflow),
          (Ma = pe)),
        (pe = Ou(pe, yt.children)),
        (pe.flags |= 4096),
        pe);
  }
  function ah(d, pe, gt) {
    d.lanes |= pe;
    var yt = d.alternate;
    yt !== null && (yt.lanes |= pe), jl(d.return, pe, gt);
  }
  function Bf(d, pe, gt, yt, At) {
    var Lt = d.memoizedState;
    Lt === null
      ? (d.memoizedState = {
          isBackwards: pe,
          rendering: null,
          renderingStartTime: 0,
          last: yt,
          tail: gt,
          tailMode: At,
        })
      : ((Lt.isBackwards = pe),
        (Lt.rendering = null),
        (Lt.renderingStartTime = 0),
        (Lt.last = yt),
        (Lt.tail = gt),
        (Lt.tailMode = At));
  }
  function lh(d, pe, gt) {
    var yt = pe.pendingProps,
      At = yt.revealOrder,
      Lt = yt.tail;
    if ((Ar(d, pe, yt.children, gt), (yt = Oi.current), (yt & 2) !== 0))
      (yt = (yt & 1) | 2), (pe.flags |= 128);
    else {
      if (d !== null && (d.flags & 128) !== 0)
        e: for (d = pe.child; d !== null; ) {
          if (d.tag === 13) d.memoizedState !== null && ah(d, gt, pe);
          else if (d.tag === 19) ah(d, gt, pe);
          else if (d.child !== null) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === pe) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === pe) break e;
            d = d.return;
          }
          (d.sibling.return = d.return), (d = d.sibling);
        }
      yt &= 1;
    }
    if ((Ri(Oi, yt), (pe.mode & 1) === 0)) pe.memoizedState = null;
    else
      switch (At) {
        case "forwards":
          for (gt = pe.child, At = null; gt !== null; )
            (d = gt.alternate),
              d !== null && co(d) === null && (At = gt),
              (gt = gt.sibling);
          (gt = At),
            gt === null
              ? ((At = pe.child), (pe.child = null))
              : ((At = gt.sibling), (gt.sibling = null)),
            Bf(pe, !1, At, gt, Lt);
          break;
        case "backwards":
          for (gt = null, At = pe.child, pe.child = null; At !== null; ) {
            if (((d = At.alternate), d !== null && co(d) === null)) {
              pe.child = At;
              break;
            }
            (d = At.sibling), (At.sibling = gt), (gt = At), (At = d);
          }
          Bf(pe, !0, gt, null, Lt);
          break;
        case "together":
          Bf(pe, !1, null, null, void 0);
          break;
        default:
          pe.memoizedState = null;
      }
    return pe.child;
  }
  function mf(d, pe) {
    (pe.mode & 1) === 0 &&
      d !== null &&
      ((d.alternate = null), (pe.alternate = null), (pe.flags |= 2));
  }
  function Na(d, pe, gt) {
    if (
      (d !== null && (pe.dependencies = d.dependencies),
      (tc |= pe.lanes),
      (gt & pe.childLanes) === 0)
    )
      return null;
    if (d !== null && pe.child !== d.child) throw Error(t(153));
    if (pe.child !== null) {
      for (
        d = pe.child, gt = Sl(d, d.pendingProps), pe.child = gt, gt.return = pe;
        d.sibling !== null;

      )
        (d = d.sibling),
          (gt = gt.sibling = Sl(d, d.pendingProps)),
          (gt.return = pe);
      gt.sibling = null;
    }
    return pe.child;
  }
  function Uh(d, pe, gt) {
    switch (pe.tag) {
      case 3:
        si(pe), ra();
        break;
      case 5:
        ka(pe);
        break;
      case 1:
        ms(pe.type) && Ta(pe);
        break;
      case 4:
        ql(pe, pe.stateNode.containerInfo);
        break;
      case 10:
        var yt = pe.type._context,
          At = pe.memoizedProps.value;
        Ri(Aa, yt._currentValue), (yt._currentValue = At);
        break;
      case 13:
        if (((yt = pe.memoizedState), yt !== null))
          return yt.dehydrated !== null
            ? (Ri(Oi, Oi.current & 1), (pe.flags |= 128), null)
            : (gt & pe.child.childLanes) !== 0
            ? Wo(d, pe, gt)
            : (Ri(Oi, Oi.current & 1),
              (d = Na(d, pe, gt)),
              d !== null ? d.sibling : null);
        Ri(Oi, Oi.current & 1);
        break;
      case 19:
        if (((yt = (gt & pe.childLanes) !== 0), (d.flags & 128) !== 0)) {
          if (yt) return lh(d, pe, gt);
          pe.flags |= 128;
        }
        if (
          ((At = pe.memoizedState),
          At !== null &&
            ((At.rendering = null), (At.tail = null), (At.lastEffect = null)),
          Ri(Oi, Oi.current),
          yt)
        )
          break;
        return null;
      case 22:
      case 23:
        return (pe.lanes = 0), xn(d, pe, gt);
    }
    return Na(d, pe, gt);
  }
  var ch, Uf, uh, fh;
  (ch = function (d, pe) {
    for (var gt = pe.child; gt !== null; ) {
      if (gt.tag === 5 || gt.tag === 6) d.appendChild(gt.stateNode);
      else if (gt.tag !== 4 && gt.child !== null) {
        (gt.child.return = gt), (gt = gt.child);
        continue;
      }
      if (gt === pe) break;
      for (; gt.sibling === null; ) {
        if (gt.return === null || gt.return === pe) return;
        gt = gt.return;
      }
      (gt.sibling.return = gt.return), (gt = gt.sibling);
    }
  }),
    (Uf = function () {}),
    (uh = function (d, pe, gt, yt) {
      var At = d.memoizedProps;
      if (At !== yt) {
        (d = pe.stateNode), Xi(Gs.current);
        var Lt = null;
        switch (gt) {
          case "input":
            (At = jt(d, At)), (yt = jt(d, yt)), (Lt = []);
            break;
          case "select":
            (At = It({}, At, { value: void 0 })),
              (yt = It({}, yt, { value: void 0 })),
              (Lt = []);
            break;
          case "textarea":
            (At = Gt(d, At)), (yt = Gt(d, yt)), (Lt = []);
            break;
          default:
            typeof At.onClick != "function" &&
              typeof yt.onClick == "function" &&
              (d.onclick = Ol);
        }
        Ur(gt, yt);
        var Wt;
        gt = null;
        for (Dn in At)
          if (!yt.hasOwnProperty(Dn) && At.hasOwnProperty(Dn) && At[Dn] != null)
            if (Dn === "style") {
              var nn = At[Dn];
              for (Wt in nn)
                nn.hasOwnProperty(Wt) && (gt || (gt = {}), (gt[Wt] = ""));
            } else
              Dn !== "dangerouslySetInnerHTML" &&
                Dn !== "children" &&
                Dn !== "suppressContentEditableWarning" &&
                Dn !== "suppressHydrationWarning" &&
                Dn !== "autoFocus" &&
                (s.hasOwnProperty(Dn)
                  ? Lt || (Lt = [])
                  : (Lt = Lt || []).push(Dn, null));
        for (Dn in yt) {
          var dn = yt[Dn];
          if (
            ((nn = At != null ? At[Dn] : void 0),
            yt.hasOwnProperty(Dn) && dn !== nn && (dn != null || nn != null))
          )
            if (Dn === "style")
              if (nn) {
                for (Wt in nn)
                  !nn.hasOwnProperty(Wt) ||
                    (dn && dn.hasOwnProperty(Wt)) ||
                    (gt || (gt = {}), (gt[Wt] = ""));
                for (Wt in dn)
                  dn.hasOwnProperty(Wt) &&
                    nn[Wt] !== dn[Wt] &&
                    (gt || (gt = {}), (gt[Wt] = dn[Wt]));
              } else gt || (Lt || (Lt = []), Lt.push(Dn, gt)), (gt = dn);
            else
              Dn === "dangerouslySetInnerHTML"
                ? ((dn = dn ? dn.__html : void 0),
                  (nn = nn ? nn.__html : void 0),
                  dn != null && nn !== dn && (Lt = Lt || []).push(Dn, dn))
                : Dn === "children"
                ? (typeof dn != "string" && typeof dn != "number") ||
                  (Lt = Lt || []).push(Dn, "" + dn)
                : Dn !== "suppressContentEditableWarning" &&
                  Dn !== "suppressHydrationWarning" &&
                  (s.hasOwnProperty(Dn)
                    ? (dn != null && Dn === "onScroll" && Li("scroll", d),
                      Lt || nn === dn || (Lt = []))
                    : (Lt = Lt || []).push(Dn, dn));
        }
        gt && (Lt = Lt || []).push("style", gt);
        var Dn = Lt;
        (pe.updateQueue = Dn) && (pe.flags |= 4);
      }
    }),
    (fh = function (d, pe, gt, yt) {
      gt !== yt && (pe.flags |= 4);
    });
  function Nu(d, pe) {
    if (!Di)
      switch (d.tailMode) {
        case "hidden":
          pe = d.tail;
          for (var gt = null; pe !== null; )
            pe.alternate !== null && (gt = pe), (pe = pe.sibling);
          gt === null ? (d.tail = null) : (gt.sibling = null);
          break;
        case "collapsed":
          gt = d.tail;
          for (var yt = null; gt !== null; )
            gt.alternate !== null && (yt = gt), (gt = gt.sibling);
          yt === null
            ? pe || d.tail === null
              ? (d.tail = null)
              : (d.tail.sibling = null)
            : (yt.sibling = null);
      }
  }
  function Ds(d) {
    var pe = d.alternate !== null && d.alternate.child === d.child,
      gt = 0,
      yt = 0;
    if (pe)
      for (var At = d.child; At !== null; )
        (gt |= At.lanes | At.childLanes),
          (yt |= At.subtreeFlags & 14680064),
          (yt |= At.flags & 14680064),
          (At.return = d),
          (At = At.sibling);
    else
      for (At = d.child; At !== null; )
        (gt |= At.lanes | At.childLanes),
          (yt |= At.subtreeFlags),
          (yt |= At.flags),
          (At.return = d),
          (At = At.sibling);
    return (d.subtreeFlags |= yt), (d.childLanes = gt), pe;
  }
  function zh(d, pe, gt) {
    var yt = pe.pendingProps;
    switch ((No(pe), pe.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ds(pe), null;
      case 1:
        return ms(pe.type) && Nl(), Ds(pe), null;
      case 3:
        return (
          (yt = pe.stateNode),
          sa(),
          ki(Es),
          ki(ls),
          yo(),
          yt.pendingContext &&
            ((yt.context = yt.pendingContext), (yt.pendingContext = null)),
          (d === null || d.child === null) &&
            (ll(pe)
              ? (pe.flags |= 4)
              : d === null ||
                (d.memoizedState.isDehydrated && (pe.flags & 256) === 0) ||
                ((pe.flags |= 1024), Js !== null && (Kf(Js), (Js = null)))),
          Uf(d, pe),
          Ds(pe),
          null
        );
      case 5:
        dl(pe);
        var At = Xi(zo.current);
        if (((gt = pe.type), d !== null && pe.stateNode != null))
          uh(d, pe, gt, yt, At),
            d.ref !== pe.ref && ((pe.flags |= 512), (pe.flags |= 2097152));
        else {
          if (!yt) {
            if (pe.stateNode === null) throw Error(t(166));
            return Ds(pe), null;
          }
          if (((d = Xi(Gs.current)), ll(pe))) {
            (yt = pe.stateNode), (gt = pe.type);
            var Lt = pe.memoizedProps;
            switch (
              ((yt[Qi] = pe), (yt[al] = Lt), (d = (pe.mode & 1) !== 0), gt)
            ) {
              case "dialog":
                Li("cancel", yt), Li("close", yt);
                break;
              case "iframe":
              case "object":
              case "embed":
                Li("load", yt);
                break;
              case "video":
              case "audio":
                for (At = 0; At < ta.length; At++) Li(ta[At], yt);
                break;
              case "source":
                Li("error", yt);
                break;
              case "img":
              case "image":
              case "link":
                Li("error", yt), Li("load", yt);
                break;
              case "details":
                Li("toggle", yt);
                break;
              case "input":
                Yn(yt, Lt), Li("invalid", yt);
                break;
              case "select":
                (yt._wrapperState = { wasMultiple: !!Lt.multiple }),
                  Li("invalid", yt);
                break;
              case "textarea":
                hn(yt, Lt), Li("invalid", yt);
            }
            Ur(gt, Lt), (At = null);
            for (var Wt in Lt)
              if (Lt.hasOwnProperty(Wt)) {
                var nn = Lt[Wt];
                Wt === "children"
                  ? typeof nn == "string"
                    ? yt.textContent !== nn &&
                      (Lt.suppressHydrationWarning !== !0 &&
                        Dl(yt.textContent, nn, d),
                      (At = ["children", nn]))
                    : typeof nn == "number" &&
                      yt.textContent !== "" + nn &&
                      (Lt.suppressHydrationWarning !== !0 &&
                        Dl(yt.textContent, nn, d),
                      (At = ["children", "" + nn]))
                  : s.hasOwnProperty(Wt) &&
                    nn != null &&
                    Wt === "onScroll" &&
                    Li("scroll", yt);
              }
            switch (gt) {
              case "input":
                ur(yt), In(yt, Lt, !0);
                break;
              case "textarea":
                ur(yt), Ln(yt);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof Lt.onClick == "function" && (yt.onclick = Ol);
            }
            (yt = At), (pe.updateQueue = yt), yt !== null && (pe.flags |= 4);
          } else {
            (Wt = At.nodeType === 9 ? At : At.ownerDocument),
              d === "http://www.w3.org/1999/xhtml" && (d = mn(gt)),
              d === "http://www.w3.org/1999/xhtml"
                ? gt === "script"
                  ? ((d = Wt.createElement("div")),
                    (d.innerHTML = "<script></script>"),
                    (d = d.removeChild(d.firstChild)))
                  : typeof yt.is == "string"
                  ? (d = Wt.createElement(gt, { is: yt.is }))
                  : ((d = Wt.createElement(gt)),
                    gt === "select" &&
                      ((Wt = d),
                      yt.multiple
                        ? (Wt.multiple = !0)
                        : yt.size && (Wt.size = yt.size)))
                : (d = Wt.createElementNS(d, gt)),
              (d[Qi] = pe),
              (d[al] = yt),
              ch(d, pe, !1, !1),
              (pe.stateNode = d);
            e: {
              switch (((Wt = Pr(gt, yt)), gt)) {
                case "dialog":
                  Li("cancel", d), Li("close", d), (At = yt);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Li("load", d), (At = yt);
                  break;
                case "video":
                case "audio":
                  for (At = 0; At < ta.length; At++) Li(ta[At], d);
                  At = yt;
                  break;
                case "source":
                  Li("error", d), (At = yt);
                  break;
                case "img":
                case "image":
                case "link":
                  Li("error", d), Li("load", d), (At = yt);
                  break;
                case "details":
                  Li("toggle", d), (At = yt);
                  break;
                case "input":
                  Yn(d, yt), (At = jt(d, yt)), Li("invalid", d);
                  break;
                case "option":
                  At = yt;
                  break;
                case "select":
                  (d._wrapperState = { wasMultiple: !!yt.multiple }),
                    (At = It({}, yt, { value: void 0 })),
                    Li("invalid", d);
                  break;
                case "textarea":
                  hn(d, yt), (At = Gt(d, yt)), Li("invalid", d);
                  break;
                default:
                  At = yt;
              }
              Ur(gt, At), (nn = At);
              for (Lt in nn)
                if (nn.hasOwnProperty(Lt)) {
                  var dn = nn[Lt];
                  Lt === "style"
                    ? mr(d, dn)
                    : Lt === "dangerouslySetInnerHTML"
                    ? ((dn = dn ? dn.__html : void 0), dn != null && nr(d, dn))
                    : Lt === "children"
                    ? typeof dn == "string"
                      ? (gt !== "textarea" || dn !== "") && yr(d, dn)
                      : typeof dn == "number" && yr(d, "" + dn)
                    : Lt !== "suppressContentEditableWarning" &&
                      Lt !== "suppressHydrationWarning" &&
                      Lt !== "autoFocus" &&
                      (s.hasOwnProperty(Lt)
                        ? dn != null && Lt === "onScroll" && Li("scroll", d)
                        : dn != null && st(d, Lt, dn, Wt));
                }
              switch (gt) {
                case "input":
                  ur(d), In(d, yt, !1);
                  break;
                case "textarea":
                  ur(d), Ln(d);
                  break;
                case "option":
                  yt.value != null &&
                    d.setAttribute("value", "" + bn(yt.value));
                  break;
                case "select":
                  (d.multiple = !!yt.multiple),
                    (Lt = yt.value),
                    Lt != null
                      ? Yt(d, !!yt.multiple, Lt, !1)
                      : yt.defaultValue != null &&
                        Yt(d, !!yt.multiple, yt.defaultValue, !0);
                  break;
                default:
                  typeof At.onClick == "function" && (d.onclick = Ol);
              }
              switch (gt) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  yt = !!yt.autoFocus;
                  break e;
                case "img":
                  yt = !0;
                  break e;
                default:
                  yt = !1;
              }
            }
            yt && (pe.flags |= 4);
          }
          pe.ref !== null && ((pe.flags |= 512), (pe.flags |= 2097152));
        }
        return Ds(pe), null;
      case 6:
        if (d && pe.stateNode != null) fh(d, pe, d.memoizedProps, yt);
        else {
          if (typeof yt != "string" && pe.stateNode === null)
            throw Error(t(166));
          if (((gt = Xi(zo.current)), Xi(Gs.current), ll(pe))) {
            if (
              ((yt = pe.stateNode),
              (gt = pe.memoizedProps),
              (yt[Qi] = pe),
              (Lt = yt.nodeValue !== gt) && ((d = cs), d !== null))
            )
              switch (d.tag) {
                case 3:
                  Dl(yt.nodeValue, gt, (d.mode & 1) !== 0);
                  break;
                case 5:
                  d.memoizedProps.suppressHydrationWarning !== !0 &&
                    Dl(yt.nodeValue, gt, (d.mode & 1) !== 0);
              }
            Lt && (pe.flags |= 4);
          } else
            (yt = (gt.nodeType === 9 ? gt : gt.ownerDocument).createTextNode(
              yt
            )),
              (yt[Qi] = pe),
              (pe.stateNode = yt);
        }
        return Ds(pe), null;
      case 13:
        if (
          (ki(Oi),
          (yt = pe.memoizedState),
          d === null ||
            (d.memoizedState !== null && d.memoizedState.dehydrated !== null))
        ) {
          if (
            Di &&
            bs !== null &&
            (pe.mode & 1) !== 0 &&
            (pe.flags & 128) === 0
          )
            Tu(), ra(), (pe.flags |= 98560), (Lt = !1);
          else if (((Lt = ll(pe)), yt !== null && yt.dehydrated !== null)) {
            if (d === null) {
              if (!Lt) throw Error(t(318));
              if (
                ((Lt = pe.memoizedState),
                (Lt = Lt !== null ? Lt.dehydrated : null),
                !Lt)
              )
                throw Error(t(317));
              Lt[Qi] = pe;
            } else
              ra(),
                (pe.flags & 128) === 0 && (pe.memoizedState = null),
                (pe.flags |= 4);
            Ds(pe), (Lt = !1);
          } else Js !== null && (Kf(Js), (Js = null)), (Lt = !0);
          if (!Lt) return pe.flags & 65536 ? pe : null;
        }
        return (pe.flags & 128) !== 0
          ? ((pe.lanes = gt), pe)
          : ((yt = yt !== null),
            yt !== (d !== null && d.memoizedState !== null) &&
              yt &&
              ((pe.child.flags |= 8192),
              (pe.mode & 1) !== 0 &&
                (d === null || (Oi.current & 1) !== 0
                  ? ds === 0 && (ds = 3)
                  : Jf())),
            pe.updateQueue !== null && (pe.flags |= 4),
            Ds(pe),
            null);
      case 4:
        return (
          sa(),
          Uf(d, pe),
          d === null && il(pe.stateNode.containerInfo),
          Ds(pe),
          null
        );
      case 10:
        return Wl(pe.type._context), Ds(pe), null;
      case 17:
        return ms(pe.type) && Nl(), Ds(pe), null;
      case 19:
        if ((ki(Oi), (Lt = pe.memoizedState), Lt === null)) return Ds(pe), null;
        if (((yt = (pe.flags & 128) !== 0), (Wt = Lt.rendering), Wt === null))
          if (yt) Nu(Lt, !1);
          else {
            if (ds !== 0 || (d !== null && (d.flags & 128) !== 0))
              for (d = pe.child; d !== null; ) {
                if (((Wt = co(d)), Wt !== null)) {
                  for (
                    pe.flags |= 128,
                      Nu(Lt, !1),
                      yt = Wt.updateQueue,
                      yt !== null && ((pe.updateQueue = yt), (pe.flags |= 4)),
                      pe.subtreeFlags = 0,
                      yt = gt,
                      gt = pe.child;
                    gt !== null;

                  )
                    (Lt = gt),
                      (d = yt),
                      (Lt.flags &= 14680066),
                      (Wt = Lt.alternate),
                      Wt === null
                        ? ((Lt.childLanes = 0),
                          (Lt.lanes = d),
                          (Lt.child = null),
                          (Lt.subtreeFlags = 0),
                          (Lt.memoizedProps = null),
                          (Lt.memoizedState = null),
                          (Lt.updateQueue = null),
                          (Lt.dependencies = null),
                          (Lt.stateNode = null))
                        : ((Lt.childLanes = Wt.childLanes),
                          (Lt.lanes = Wt.lanes),
                          (Lt.child = Wt.child),
                          (Lt.subtreeFlags = 0),
                          (Lt.deletions = null),
                          (Lt.memoizedProps = Wt.memoizedProps),
                          (Lt.memoizedState = Wt.memoizedState),
                          (Lt.updateQueue = Wt.updateQueue),
                          (Lt.type = Wt.type),
                          (d = Wt.dependencies),
                          (Lt.dependencies =
                            d === null
                              ? null
                              : {
                                  lanes: d.lanes,
                                  firstContext: d.firstContext,
                                })),
                      (gt = gt.sibling);
                  return Ri(Oi, (Oi.current & 1) | 2), pe.child;
                }
                d = d.sibling;
              }
            Lt.tail !== null &&
              Qt() > Yc &&
              ((pe.flags |= 128), (yt = !0), Nu(Lt, !1), (pe.lanes = 4194304));
          }
        else {
          if (!yt)
            if (((d = co(Wt)), d !== null)) {
              if (
                ((pe.flags |= 128),
                (yt = !0),
                (gt = d.updateQueue),
                gt !== null && ((pe.updateQueue = gt), (pe.flags |= 4)),
                Nu(Lt, !0),
                Lt.tail === null &&
                  Lt.tailMode === "hidden" &&
                  !Wt.alternate &&
                  !Di)
              )
                return Ds(pe), null;
            } else
              2 * Qt() - Lt.renderingStartTime > Yc &&
                gt !== 1073741824 &&
                ((pe.flags |= 128),
                (yt = !0),
                Nu(Lt, !1),
                (pe.lanes = 4194304));
          Lt.isBackwards
            ? ((Wt.sibling = pe.child), (pe.child = Wt))
            : ((gt = Lt.last),
              gt !== null ? (gt.sibling = Wt) : (pe.child = Wt),
              (Lt.last = Wt));
        }
        return Lt.tail !== null
          ? ((pe = Lt.tail),
            (Lt.rendering = pe),
            (Lt.tail = pe.sibling),
            (Lt.renderingStartTime = Qt()),
            (pe.sibling = null),
            (gt = Oi.current),
            Ri(Oi, yt ? (gt & 1) | 2 : gt & 1),
            pe)
          : (Ds(pe), null);
      case 22:
      case 23:
        return (
          Qf(),
          (yt = pe.memoizedState !== null),
          d !== null && (d.memoizedState !== null) !== yt && (pe.flags |= 8192),
          yt && (pe.mode & 1) !== 0
            ? (ho & 1073741824) !== 0 &&
              (Ds(pe), pe.subtreeFlags & 6 && (pe.flags |= 8192))
            : Ds(pe),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, pe.tag));
  }
  function Vh(d, pe) {
    switch ((No(pe), pe.tag)) {
      case 1:
        return (
          ms(pe.type) && Nl(),
          (d = pe.flags),
          d & 65536 ? ((pe.flags = (d & -65537) | 128), pe) : null
        );
      case 3:
        return (
          sa(),
          ki(Es),
          ki(ls),
          yo(),
          (d = pe.flags),
          (d & 65536) !== 0 && (d & 128) === 0
            ? ((pe.flags = (d & -65537) | 128), pe)
            : null
        );
      case 5:
        return dl(pe), null;
      case 13:
        if (
          (ki(Oi), (d = pe.memoizedState), d !== null && d.dehydrated !== null)
        ) {
          if (pe.alternate === null) throw Error(t(340));
          ra();
        }
        return (
          (d = pe.flags),
          d & 65536 ? ((pe.flags = (d & -65537) | 128), pe) : null
        );
      case 19:
        return ki(Oi), null;
      case 4:
        return sa(), null;
      case 10:
        return Wl(pe.type._context), null;
      case 22:
      case 23:
        return Qf(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var gf = !1,
    Os = !1,
    Gh = typeof WeakSet == "function" ? WeakSet : Set,
    Or = null;
  function qc(d, pe) {
    var gt = d.ref;
    if (gt !== null)
      if (typeof gt == "function")
        try {
          gt(null);
        } catch (yt) {
          Ki(d, pe, yt);
        }
      else gt.current = null;
  }
  function zf(d, pe, gt) {
    try {
      gt();
    } catch (yt) {
      Ki(d, pe, yt);
    }
  }
  var hh = !1;
  function Hh(d, pe) {
    if (((ol = yi), (d = Vi()), es(d))) {
      if ("selectionStart" in d)
        var gt = { start: d.selectionStart, end: d.selectionEnd };
      else
        e: {
          gt = ((gt = d.ownerDocument) && gt.defaultView) || window;
          var yt = gt.getSelection && gt.getSelection();
          if (yt && yt.rangeCount !== 0) {
            gt = yt.anchorNode;
            var At = yt.anchorOffset,
              Lt = yt.focusNode;
            yt = yt.focusOffset;
            try {
              gt.nodeType, Lt.nodeType;
            } catch {
              gt = null;
              break e;
            }
            var Wt = 0,
              nn = -1,
              dn = -1,
              Dn = 0,
              sr = 0,
              lr = d,
              ir = null;
            t: for (;;) {
              for (
                var Lr;
                lr !== gt || (At !== 0 && lr.nodeType !== 3) || (nn = Wt + At),
                  lr !== Lt ||
                    (yt !== 0 && lr.nodeType !== 3) ||
                    (dn = Wt + yt),
                  lr.nodeType === 3 && (Wt += lr.nodeValue.length),
                  (Lr = lr.firstChild) !== null;

              )
                (ir = lr), (lr = Lr);
              for (;;) {
                if (lr === d) break t;
                if (
                  (ir === gt && ++Dn === At && (nn = Wt),
                  ir === Lt && ++sr === yt && (dn = Wt),
                  (Lr = lr.nextSibling) !== null)
                )
                  break;
                (lr = ir), (ir = lr.parentNode);
              }
              lr = Lr;
            }
            gt = nn === -1 || dn === -1 ? null : { start: nn, end: dn };
          } else gt = null;
        }
      gt = gt || { start: 0, end: 0 };
    } else gt = null;
    for (
      hu = { focusedElem: d, selectionRange: gt }, yi = !1, Or = pe;
      Or !== null;

    )
      if (
        ((pe = Or),
        (d = pe.child),
        (pe.subtreeFlags & 1028) !== 0 && d !== null)
      )
        (d.return = pe), (Or = d);
      else
        for (; Or !== null; ) {
          pe = Or;
          try {
            var Nr = pe.alternate;
            if ((pe.flags & 1024) !== 0)
              switch (pe.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Nr !== null) {
                    var Vr = Nr.memoizedProps,
                      Ji = Nr.memoizedState,
                      Tn = pe.stateNode,
                      gn = Tn.getSnapshotBeforeUpdate(
                        pe.elementType === pe.type ? Vr : eo(pe.type, Vr),
                        Ji
                      );
                    Tn.__reactInternalSnapshotBeforeUpdate = gn;
                  }
                  break;
                case 3:
                  var Cn = pe.stateNode.containerInfo;
                  Cn.nodeType === 1
                    ? (Cn.textContent = "")
                    : Cn.nodeType === 9 &&
                      Cn.documentElement &&
                      Cn.removeChild(Cn.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (vr) {
            Ki(pe, pe.return, vr);
          }
          if (((d = pe.sibling), d !== null)) {
            (d.return = pe.return), (Or = d);
            break;
          }
          Or = pe.return;
        }
    return (Nr = hh), (hh = !1), Nr;
  }
  function Bu(d, pe, gt) {
    var yt = pe.updateQueue;
    if (((yt = yt !== null ? yt.lastEffect : null), yt !== null)) {
      var At = (yt = yt.next);
      do {
        if ((At.tag & d) === d) {
          var Lt = At.destroy;
          (At.destroy = void 0), Lt !== void 0 && zf(pe, gt, Lt);
        }
        At = At.next;
      } while (At !== yt);
    }
  }
  function vf(d, pe) {
    if (
      ((pe = pe.updateQueue),
      (pe = pe !== null ? pe.lastEffect : null),
      pe !== null)
    ) {
      var gt = (pe = pe.next);
      do {
        if ((gt.tag & d) === d) {
          var yt = gt.create;
          gt.destroy = yt();
        }
        gt = gt.next;
      } while (gt !== pe);
    }
  }
  function Vf(d) {
    var pe = d.ref;
    if (pe !== null) {
      var gt = d.stateNode;
      switch (d.tag) {
        case 5:
          d = gt;
          break;
        default:
          d = gt;
      }
      typeof pe == "function" ? pe(d) : (pe.current = d);
    }
  }
  function dh(d) {
    var pe = d.alternate;
    pe !== null && ((d.alternate = null), dh(pe)),
      (d.child = null),
      (d.deletions = null),
      (d.sibling = null),
      d.tag === 5 &&
        ((pe = d.stateNode),
        pe !== null &&
          (delete pe[Qi],
          delete pe[al],
          delete pe[wa],
          delete pe[Rc],
          delete pe[Ic])),
      (d.stateNode = null),
      (d.return = null),
      (d.dependencies = null),
      (d.memoizedProps = null),
      (d.memoizedState = null),
      (d.pendingProps = null),
      (d.stateNode = null),
      (d.updateQueue = null);
  }
  function ph(d) {
    return d.tag === 5 || d.tag === 3 || d.tag === 4;
  }
  function mh(d) {
    e: for (;;) {
      for (; d.sibling === null; ) {
        if (d.return === null || ph(d.return)) return null;
        d = d.return;
      }
      for (
        d.sibling.return = d.return, d = d.sibling;
        d.tag !== 5 && d.tag !== 6 && d.tag !== 18;

      ) {
        if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
        (d.child.return = d), (d = d.child);
      }
      if (!(d.flags & 2)) return d.stateNode;
    }
  }
  function Gf(d, pe, gt) {
    var yt = d.tag;
    if (yt === 5 || yt === 6)
      (d = d.stateNode),
        pe
          ? gt.nodeType === 8
            ? gt.parentNode.insertBefore(d, pe)
            : gt.insertBefore(d, pe)
          : (gt.nodeType === 8
              ? ((pe = gt.parentNode), pe.insertBefore(d, gt))
              : ((pe = gt), pe.appendChild(d)),
            (gt = gt._reactRootContainer),
            gt != null || pe.onclick !== null || (pe.onclick = Ol));
    else if (yt !== 4 && ((d = d.child), d !== null))
      for (Gf(d, pe, gt), d = d.sibling; d !== null; )
        Gf(d, pe, gt), (d = d.sibling);
  }
  function Hf(d, pe, gt) {
    var yt = d.tag;
    if (yt === 5 || yt === 6)
      (d = d.stateNode), pe ? gt.insertBefore(d, pe) : gt.appendChild(d);
    else if (yt !== 4 && ((d = d.child), d !== null))
      for (Hf(d, pe, gt), d = d.sibling; d !== null; )
        Hf(d, pe, gt), (d = d.sibling);
  }
  var Cs = null,
    jo = !1;
  function gl(d, pe, gt) {
    for (gt = gt.child; gt !== null; ) gh(d, pe, gt), (gt = gt.sibling);
  }
  function gh(d, pe, gt) {
    if (Qn && typeof Qn.onCommitFiberUnmount == "function")
      try {
        Qn.onCommitFiberUnmount(cr, gt);
      } catch {}
    switch (gt.tag) {
      case 5:
        Os || qc(gt, pe);
      case 6:
        var yt = Cs,
          At = jo;
        (Cs = null),
          gl(d, pe, gt),
          (Cs = yt),
          (jo = At),
          Cs !== null &&
            (jo
              ? ((d = Cs),
                (gt = gt.stateNode),
                d.nodeType === 8
                  ? d.parentNode.removeChild(gt)
                  : d.removeChild(gt))
              : Cs.removeChild(gt.stateNode));
        break;
      case 18:
        Cs !== null &&
          (jo
            ? ((d = Cs),
              (gt = gt.stateNode),
              d.nodeType === 8
                ? Pc(d.parentNode, gt)
                : d.nodeType === 1 && Pc(d, gt),
              rr(d))
            : Pc(Cs, gt.stateNode));
        break;
      case 4:
        (yt = Cs),
          (At = jo),
          (Cs = gt.stateNode.containerInfo),
          (jo = !0),
          gl(d, pe, gt),
          (Cs = yt),
          (jo = At);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !Os &&
          ((yt = gt.updateQueue),
          yt !== null && ((yt = yt.lastEffect), yt !== null))
        ) {
          At = yt = yt.next;
          do {
            var Lt = At,
              Wt = Lt.destroy;
            (Lt = Lt.tag),
              Wt !== void 0 &&
                ((Lt & 2) !== 0 || (Lt & 4) !== 0) &&
                zf(gt, pe, Wt),
              (At = At.next);
          } while (At !== yt);
        }
        gl(d, pe, gt);
        break;
      case 1:
        if (
          !Os &&
          (qc(gt, pe),
          (yt = gt.stateNode),
          typeof yt.componentWillUnmount == "function")
        )
          try {
            (yt.props = gt.memoizedProps),
              (yt.state = gt.memoizedState),
              yt.componentWillUnmount();
          } catch (nn) {
            Ki(gt, pe, nn);
          }
        gl(d, pe, gt);
        break;
      case 21:
        gl(d, pe, gt);
        break;
      case 22:
        gt.mode & 1
          ? ((Os = (yt = Os) || gt.memoizedState !== null),
            gl(d, pe, gt),
            (Os = yt))
          : gl(d, pe, gt);
        break;
      default:
        gl(d, pe, gt);
    }
  }
  function vh(d) {
    var pe = d.updateQueue;
    if (pe !== null) {
      d.updateQueue = null;
      var gt = d.stateNode;
      gt === null && (gt = d.stateNode = new Gh()),
        pe.forEach(function (yt) {
          var At = Qh.bind(null, d, yt);
          gt.has(yt) || (gt.add(yt), yt.then(At, At));
        });
    }
  }
  function $o(d, pe) {
    var gt = pe.deletions;
    if (gt !== null)
      for (var yt = 0; yt < gt.length; yt++) {
        var At = gt[yt];
        try {
          var Lt = d,
            Wt = pe,
            nn = Wt;
          e: for (; nn !== null; ) {
            switch (nn.tag) {
              case 5:
                (Cs = nn.stateNode), (jo = !1);
                break e;
              case 3:
                (Cs = nn.stateNode.containerInfo), (jo = !0);
                break e;
              case 4:
                (Cs = nn.stateNode.containerInfo), (jo = !0);
                break e;
            }
            nn = nn.return;
          }
          if (Cs === null) throw Error(t(160));
          gh(Lt, Wt, At), (Cs = null), (jo = !1);
          var dn = At.alternate;
          dn !== null && (dn.return = null), (At.return = null);
        } catch (Dn) {
          Ki(At, pe, Dn);
        }
      }
    if (pe.subtreeFlags & 12854)
      for (pe = pe.child; pe !== null; ) _h(pe, d), (pe = pe.sibling);
  }
  function _h(d, pe) {
    var gt = d.alternate,
      yt = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (($o(pe, d), aa(d), yt & 4)) {
          try {
            Bu(3, d, d.return), vf(3, d);
          } catch (Vr) {
            Ki(d, d.return, Vr);
          }
          try {
            Bu(5, d, d.return);
          } catch (Vr) {
            Ki(d, d.return, Vr);
          }
        }
        break;
      case 1:
        $o(pe, d), aa(d), yt & 512 && gt !== null && qc(gt, gt.return);
        break;
      case 5:
        if (
          ($o(pe, d),
          aa(d),
          yt & 512 && gt !== null && qc(gt, gt.return),
          d.flags & 32)
        ) {
          var At = d.stateNode;
          try {
            yr(At, "");
          } catch (Vr) {
            Ki(d, d.return, Vr);
          }
        }
        if (yt & 4 && ((At = d.stateNode), At != null)) {
          var Lt = d.memoizedProps,
            Wt = gt !== null ? gt.memoizedProps : Lt,
            nn = d.type,
            dn = d.updateQueue;
          if (((d.updateQueue = null), dn !== null))
            try {
              nn === "input" &&
                Lt.type === "radio" &&
                Lt.name != null &&
                zn(At, Lt),
                Pr(nn, Wt);
              var Dn = Pr(nn, Lt);
              for (Wt = 0; Wt < dn.length; Wt += 2) {
                var sr = dn[Wt],
                  lr = dn[Wt + 1];
                sr === "style"
                  ? mr(At, lr)
                  : sr === "dangerouslySetInnerHTML"
                  ? nr(At, lr)
                  : sr === "children"
                  ? yr(At, lr)
                  : st(At, sr, lr, Dn);
              }
              switch (nn) {
                case "input":
                  rn(At, Lt);
                  break;
                case "textarea":
                  En(At, Lt);
                  break;
                case "select":
                  var ir = At._wrapperState.wasMultiple;
                  At._wrapperState.wasMultiple = !!Lt.multiple;
                  var Lr = Lt.value;
                  Lr != null
                    ? Yt(At, !!Lt.multiple, Lr, !1)
                    : ir !== !!Lt.multiple &&
                      (Lt.defaultValue != null
                        ? Yt(At, !!Lt.multiple, Lt.defaultValue, !0)
                        : Yt(At, !!Lt.multiple, Lt.multiple ? [] : "", !1));
              }
              At[al] = Lt;
            } catch (Vr) {
              Ki(d, d.return, Vr);
            }
        }
        break;
      case 6:
        if (($o(pe, d), aa(d), yt & 4)) {
          if (d.stateNode === null) throw Error(t(162));
          (At = d.stateNode), (Lt = d.memoizedProps);
          try {
            At.nodeValue = Lt;
          } catch (Vr) {
            Ki(d, d.return, Vr);
          }
        }
        break;
      case 3:
        if (
          ($o(pe, d),
          aa(d),
          yt & 4 && gt !== null && gt.memoizedState.isDehydrated)
        )
          try {
            rr(pe.containerInfo);
          } catch (Vr) {
            Ki(d, d.return, Vr);
          }
        break;
      case 4:
        $o(pe, d), aa(d);
        break;
      case 13:
        $o(pe, d),
          aa(d),
          (At = d.child),
          At.flags & 8192 &&
            ((Lt = At.memoizedState !== null),
            (At.stateNode.isHidden = Lt),
            !Lt ||
              (At.alternate !== null && At.alternate.memoizedState !== null) ||
              ($f = Qt())),
          yt & 4 && vh(d);
        break;
      case 22:
        if (
          ((sr = gt !== null && gt.memoizedState !== null),
          d.mode & 1
            ? ((Os = (Dn = Os) || sr), $o(pe, d), (Os = Dn))
            : $o(pe, d),
          aa(d),
          yt & 8192)
        ) {
          if (
            ((Dn = d.memoizedState !== null),
            (d.stateNode.isHidden = Dn) && !sr && (d.mode & 1) !== 0)
          )
            for (Or = d, sr = d.child; sr !== null; ) {
              for (lr = Or = sr; Or !== null; ) {
                switch (((ir = Or), (Lr = ir.child), ir.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Bu(4, ir, ir.return);
                    break;
                  case 1:
                    qc(ir, ir.return);
                    var Nr = ir.stateNode;
                    if (typeof Nr.componentWillUnmount == "function") {
                      (yt = ir), (gt = ir.return);
                      try {
                        (pe = yt),
                          (Nr.props = pe.memoizedProps),
                          (Nr.state = pe.memoizedState),
                          Nr.componentWillUnmount();
                      } catch (Vr) {
                        Ki(yt, gt, Vr);
                      }
                    }
                    break;
                  case 5:
                    qc(ir, ir.return);
                    break;
                  case 22:
                    if (ir.memoizedState !== null) {
                      Sh(lr);
                      continue;
                    }
                }
                Lr !== null ? ((Lr.return = ir), (Or = Lr)) : Sh(lr);
              }
              sr = sr.sibling;
            }
          e: for (sr = null, lr = d; ; ) {
            if (lr.tag === 5) {
              if (sr === null) {
                sr = lr;
                try {
                  (At = lr.stateNode),
                    Dn
                      ? ((Lt = At.style),
                        typeof Lt.setProperty == "function"
                          ? Lt.setProperty("display", "none", "important")
                          : (Lt.display = "none"))
                      : ((nn = lr.stateNode),
                        (dn = lr.memoizedProps.style),
                        (Wt =
                          dn != null && dn.hasOwnProperty("display")
                            ? dn.display
                            : null),
                        (nn.style.display = Jn("display", Wt)));
                } catch (Vr) {
                  Ki(d, d.return, Vr);
                }
              }
            } else if (lr.tag === 6) {
              if (sr === null)
                try {
                  lr.stateNode.nodeValue = Dn ? "" : lr.memoizedProps;
                } catch (Vr) {
                  Ki(d, d.return, Vr);
                }
            } else if (
              ((lr.tag !== 22 && lr.tag !== 23) ||
                lr.memoizedState === null ||
                lr === d) &&
              lr.child !== null
            ) {
              (lr.child.return = lr), (lr = lr.child);
              continue;
            }
            if (lr === d) break e;
            for (; lr.sibling === null; ) {
              if (lr.return === null || lr.return === d) break e;
              sr === lr && (sr = null), (lr = lr.return);
            }
            sr === lr && (sr = null),
              (lr.sibling.return = lr.return),
              (lr = lr.sibling);
          }
        }
        break;
      case 19:
        $o(pe, d), aa(d), yt & 4 && vh(d);
        break;
      case 21:
        break;
      default:
        $o(pe, d), aa(d);
    }
  }
  function aa(d) {
    var pe = d.flags;
    if (pe & 2) {
      try {
        e: {
          for (var gt = d.return; gt !== null; ) {
            if (ph(gt)) {
              var yt = gt;
              break e;
            }
            gt = gt.return;
          }
          throw Error(t(160));
        }
        switch (yt.tag) {
          case 5:
            var At = yt.stateNode;
            yt.flags & 32 && (yr(At, ""), (yt.flags &= -33));
            var Lt = mh(d);
            Hf(d, Lt, At);
            break;
          case 3:
          case 4:
            var Wt = yt.stateNode.containerInfo,
              nn = mh(d);
            Gf(d, nn, Wt);
            break;
          default:
            throw Error(t(161));
        }
      } catch (dn) {
        Ki(d, d.return, dn);
      }
      d.flags &= -3;
    }
    pe & 4096 && (d.flags &= -4097);
  }
  function Wh(d, pe, gt) {
    (Or = d), yh(d);
  }
  function yh(d, pe, gt) {
    for (var yt = (d.mode & 1) !== 0; Or !== null; ) {
      var At = Or,
        Lt = At.child;
      if (At.tag === 22 && yt) {
        var Wt = At.memoizedState !== null || gf;
        if (!Wt) {
          var nn = At.alternate,
            dn = (nn !== null && nn.memoizedState !== null) || Os;
          nn = gf;
          var Dn = Os;
          if (((gf = Wt), (Os = dn) && !Dn))
            for (Or = At; Or !== null; )
              (Wt = Or),
                (dn = Wt.child),
                Wt.tag === 22 && Wt.memoizedState !== null
                  ? wh(At)
                  : dn !== null
                  ? ((dn.return = Wt), (Or = dn))
                  : wh(At);
          for (; Lt !== null; ) (Or = Lt), yh(Lt), (Lt = Lt.sibling);
          (Or = At), (gf = nn), (Os = Dn);
        }
        xh(d);
      } else
        (At.subtreeFlags & 8772) !== 0 && Lt !== null
          ? ((Lt.return = At), (Or = Lt))
          : xh(d);
    }
  }
  function xh(d) {
    for (; Or !== null; ) {
      var pe = Or;
      if ((pe.flags & 8772) !== 0) {
        var gt = pe.alternate;
        try {
          if ((pe.flags & 8772) !== 0)
            switch (pe.tag) {
              case 0:
              case 11:
              case 15:
                Os || vf(5, pe);
                break;
              case 1:
                var yt = pe.stateNode;
                if (pe.flags & 4 && !Os)
                  if (gt === null) yt.componentDidMount();
                  else {
                    var At =
                      pe.elementType === pe.type
                        ? gt.memoizedProps
                        : eo(pe.type, gt.memoizedProps);
                    yt.componentDidUpdate(
                      At,
                      gt.memoizedState,
                      yt.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var Lt = pe.updateQueue;
                Lt !== null && hl(pe, Lt, yt);
                break;
              case 3:
                var Wt = pe.updateQueue;
                if (Wt !== null) {
                  if (((gt = null), pe.child !== null))
                    switch (pe.child.tag) {
                      case 5:
                        gt = pe.child.stateNode;
                        break;
                      case 1:
                        gt = pe.child.stateNode;
                    }
                  hl(pe, Wt, gt);
                }
                break;
              case 5:
                var nn = pe.stateNode;
                if (gt === null && pe.flags & 4) {
                  gt = nn;
                  var dn = pe.memoizedProps;
                  switch (pe.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      dn.autoFocus && gt.focus();
                      break;
                    case "img":
                      dn.src && (gt.src = dn.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (pe.memoizedState === null) {
                  var Dn = pe.alternate;
                  if (Dn !== null) {
                    var sr = Dn.memoizedState;
                    if (sr !== null) {
                      var lr = sr.dehydrated;
                      lr !== null && rr(lr);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          Os || (pe.flags & 512 && Vf(pe));
        } catch (ir) {
          Ki(pe, pe.return, ir);
        }
      }
      if (pe === d) {
        Or = null;
        break;
      }
      if (((gt = pe.sibling), gt !== null)) {
        (gt.return = pe.return), (Or = gt);
        break;
      }
      Or = pe.return;
    }
  }
  function Sh(d) {
    for (; Or !== null; ) {
      var pe = Or;
      if (pe === d) {
        Or = null;
        break;
      }
      var gt = pe.sibling;
      if (gt !== null) {
        (gt.return = pe.return), (Or = gt);
        break;
      }
      Or = pe.return;
    }
  }
  function wh(d) {
    for (; Or !== null; ) {
      var pe = Or;
      try {
        switch (pe.tag) {
          case 0:
          case 11:
          case 15:
            var gt = pe.return;
            try {
              vf(4, pe);
            } catch (dn) {
              Ki(pe, gt, dn);
            }
            break;
          case 1:
            var yt = pe.stateNode;
            if (typeof yt.componentDidMount == "function") {
              var At = pe.return;
              try {
                yt.componentDidMount();
              } catch (dn) {
                Ki(pe, At, dn);
              }
            }
            var Lt = pe.return;
            try {
              Vf(pe);
            } catch (dn) {
              Ki(pe, Lt, dn);
            }
            break;
          case 5:
            var Wt = pe.return;
            try {
              Vf(pe);
            } catch (dn) {
              Ki(pe, Wt, dn);
            }
        }
      } catch (dn) {
        Ki(pe, pe.return, dn);
      }
      if (pe === d) {
        Or = null;
        break;
      }
      var nn = pe.sibling;
      if (nn !== null) {
        (nn.return = pe.return), (Or = nn);
        break;
      }
      Or = pe.return;
    }
  }
  var jh = Math.ceil,
    _f = vt.ReactCurrentDispatcher,
    Wf = vt.ReactCurrentOwner,
    So = vt.ReactCurrentBatchConfig,
    Ei = 0,
    _s = null,
    os = null,
    As = 0,
    ho = 0,
    Xc = Gi(0),
    ds = 0,
    Uu = null,
    tc = 0,
    yf = 0,
    jf = 0,
    zu = null,
    to = null,
    $f = 0,
    Yc = 1 / 0,
    Ba = null,
    xf = !1,
    qf = null,
    vl = null,
    Sf = !1,
    _l = null,
    wf = 0,
    Vu = 0,
    Xf = null,
    Ef = -1,
    Tf = 0;
  function $s() {
    return (Ei & 6) !== 0 ? Qt() : Ef !== -1 ? Ef : (Ef = Qt());
  }
  function yl(d) {
    return (d.mode & 1) === 0
      ? 1
      : (Ei & 2) !== 0 && As !== 0
      ? As & -As
      : Of.transition !== null
      ? (Tf === 0 && (Tf = Kr()), Tf)
      : ((d = di),
        d !== 0 || ((d = window.event), (d = d === void 0 ? 16 : Tl(d.type))),
        d);
  }
  function qo(d, pe, gt, yt) {
    if (50 < Vu) throw ((Vu = 0), (Xf = null), Error(t(185)));
    gi(d, gt, yt),
      ((Ei & 2) === 0 || d !== _s) &&
        (d === _s && ((Ei & 2) === 0 && (yf |= gt), ds === 4 && xl(d, As)),
        no(d, yt),
        gt === 1 &&
          Ei === 0 &&
          (pe.mode & 1) === 0 &&
          ((Yc = Qt() + 500), Ul && vo()));
  }
  function no(d, pe) {
    var gt = d.callbackNode;
    ni(d, pe);
    var yt = ti(d, d === _s ? As : 0);
    if (yt === 0)
      gt !== null && zt(gt), (d.callbackNode = null), (d.callbackPriority = 0);
    else if (((pe = yt & -yt), d.callbackPriority !== pe)) {
      if ((gt != null && zt(gt), pe === 1))
        d.tag === 0 ? nf(Th.bind(null, d)) : zl(Th.bind(null, d)),
          Df(function () {
            (Ei & 6) === 0 && vo();
          }),
          (gt = null);
      else {
        switch (ps(yt)) {
          case 1:
            gt = wn;
            break;
          case 4:
            gt = On;
            break;
          case 16:
            gt = Kn;
            break;
          case 536870912:
            gt = ar;
            break;
          default:
            gt = Kn;
        }
        gt = Lh(gt, Eh.bind(null, d));
      }
      (d.callbackPriority = pe), (d.callbackNode = gt);
    }
  }
  function Eh(d, pe) {
    if (((Ef = -1), (Tf = 0), (Ei & 6) !== 0)) throw Error(t(327));
    var gt = d.callbackNode;
    if (Kc() && d.callbackNode !== gt) return null;
    var yt = ti(d, d === _s ? As : 0);
    if (yt === 0) return null;
    if ((yt & 30) !== 0 || (yt & d.expiredLanes) !== 0 || pe) pe = bf(d, yt);
    else {
      pe = yt;
      var At = Ei;
      Ei |= 2;
      var Lt = Mh();
      (_s !== d || As !== pe) && ((Ba = null), (Yc = Qt() + 500), rc(d, pe));
      do
        try {
          Xh();
          break;
        } catch (nn) {
          bh(d, nn);
        }
      while (!0);
      Ra(),
        (_f.current = Lt),
        (Ei = At),
        os !== null ? (pe = 0) : ((_s = null), (As = 0), (pe = ds));
    }
    if (pe !== 0) {
      if (
        (pe === 2 && ((At = ai(d)), At !== 0 && ((yt = At), (pe = Yf(d, At)))),
        pe === 1)
      )
        throw ((gt = Uu), rc(d, 0), xl(d, yt), no(d, Qt()), gt);
      if (pe === 6) xl(d, yt);
      else {
        if (
          ((At = d.current.alternate),
          (yt & 30) === 0 &&
            !$h(At) &&
            ((pe = bf(d, yt)),
            pe === 2 &&
              ((Lt = ai(d)), Lt !== 0 && ((yt = Lt), (pe = Yf(d, Lt)))),
            pe === 1))
        )
          throw ((gt = Uu), rc(d, 0), xl(d, yt), no(d, Qt()), gt);
        switch (((d.finishedWork = At), (d.finishedLanes = yt), pe)) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            ic(d, to, Ba);
            break;
          case 3:
            if (
              (xl(d, yt),
              (yt & 130023424) === yt && ((pe = $f + 500 - Qt()), 10 < pe))
            ) {
              if (ti(d, 0) !== 0) break;
              if (((At = d.suspendedLanes), (At & yt) !== yt)) {
                $s(), (d.pingedLanes |= d.suspendedLanes & At);
                break;
              }
              d.timeoutHandle = pu(ic.bind(null, d, to, Ba), pe);
              break;
            }
            ic(d, to, Ba);
            break;
          case 4:
            if ((xl(d, yt), (yt & 4194240) === yt)) break;
            for (pe = d.eventTimes, At = -1; 0 < yt; ) {
              var Wt = 31 - Tr(yt);
              (Lt = 1 << Wt), (Wt = pe[Wt]), Wt > At && (At = Wt), (yt &= ~Lt);
            }
            if (
              ((yt = At),
              (yt = Qt() - yt),
              (yt =
                (120 > yt
                  ? 120
                  : 480 > yt
                  ? 480
                  : 1080 > yt
                  ? 1080
                  : 1920 > yt
                  ? 1920
                  : 3e3 > yt
                  ? 3e3
                  : 4320 > yt
                  ? 4320
                  : 1960 * jh(yt / 1960)) - yt),
              10 < yt)
            ) {
              d.timeoutHandle = pu(ic.bind(null, d, to, Ba), yt);
              break;
            }
            ic(d, to, Ba);
            break;
          case 5:
            ic(d, to, Ba);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return no(d, Qt()), d.callbackNode === gt ? Eh.bind(null, d) : null;
  }
  function Yf(d, pe) {
    var gt = zu;
    return (
      d.current.memoizedState.isDehydrated && (rc(d, pe).flags |= 256),
      (d = bf(d, pe)),
      d !== 2 && ((pe = to), (to = gt), pe !== null && Kf(pe)),
      d
    );
  }
  function Kf(d) {
    to === null ? (to = d) : to.push.apply(to, d);
  }
  function $h(d) {
    for (var pe = d; ; ) {
      if (pe.flags & 16384) {
        var gt = pe.updateQueue;
        if (gt !== null && ((gt = gt.stores), gt !== null))
          for (var yt = 0; yt < gt.length; yt++) {
            var At = gt[yt],
              Lt = At.getSnapshot;
            At = At.value;
            try {
              if (!Bs(Lt(), At)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((gt = pe.child), pe.subtreeFlags & 16384 && gt !== null))
        (gt.return = pe), (pe = gt);
      else {
        if (pe === d) break;
        for (; pe.sibling === null; ) {
          if (pe.return === null || pe.return === d) return !0;
          pe = pe.return;
        }
        (pe.sibling.return = pe.return), (pe = pe.sibling);
      }
    }
    return !0;
  }
  function xl(d, pe) {
    for (
      pe &= ~jf,
        pe &= ~yf,
        d.suspendedLanes |= pe,
        d.pingedLanes &= ~pe,
        d = d.expirationTimes;
      0 < pe;

    ) {
      var gt = 31 - Tr(pe),
        yt = 1 << gt;
      (d[gt] = -1), (pe &= ~yt);
    }
  }
  function Th(d) {
    if ((Ei & 6) !== 0) throw Error(t(327));
    Kc();
    var pe = ti(d, 0);
    if ((pe & 1) === 0) return no(d, Qt()), null;
    var gt = bf(d, pe);
    if (d.tag !== 0 && gt === 2) {
      var yt = ai(d);
      yt !== 0 && ((pe = yt), (gt = Yf(d, yt)));
    }
    if (gt === 1) throw ((gt = Uu), rc(d, 0), xl(d, pe), no(d, Qt()), gt);
    if (gt === 6) throw Error(t(345));
    return (
      (d.finishedWork = d.current.alternate),
      (d.finishedLanes = pe),
      ic(d, to, Ba),
      no(d, Qt()),
      null
    );
  }
  function Zf(d, pe) {
    var gt = Ei;
    Ei |= 1;
    try {
      return d(pe);
    } finally {
      (Ei = gt), Ei === 0 && ((Yc = Qt() + 500), Ul && vo());
    }
  }
  function nc(d) {
    _l !== null && _l.tag === 0 && (Ei & 6) === 0 && Kc();
    var pe = Ei;
    Ei |= 1;
    var gt = So.transition,
      yt = di;
    try {
      if (((So.transition = null), (di = 1), d)) return d();
    } finally {
      (di = yt), (So.transition = gt), (Ei = pe), (Ei & 6) === 0 && vo();
    }
  }
  function Qf() {
    (ho = Xc.current), ki(Xc);
  }
  function rc(d, pe) {
    (d.finishedWork = null), (d.finishedLanes = 0);
    var gt = d.timeoutHandle;
    if ((gt !== -1 && ((d.timeoutHandle = -1), mu(gt)), os !== null))
      for (gt = os.return; gt !== null; ) {
        var yt = gt;
        switch ((No(yt), yt.tag)) {
          case 1:
            (yt = yt.type.childContextTypes), yt != null && Nl();
            break;
          case 3:
            sa(), ki(Es), ki(ls), yo();
            break;
          case 5:
            dl(yt);
            break;
          case 4:
            sa();
            break;
          case 13:
            ki(Oi);
            break;
          case 19:
            ki(Oi);
            break;
          case 10:
            Wl(yt.type._context);
            break;
          case 22:
          case 23:
            Qf();
        }
        gt = gt.return;
      }
    if (
      ((_s = d),
      (os = d = Sl(d.current, null)),
      (As = ho = pe),
      (ds = 0),
      (Uu = null),
      (jf = yf = tc = 0),
      (to = zu = null),
      Uo !== null)
    ) {
      for (pe = 0; pe < Uo.length; pe++)
        if (((gt = Uo[pe]), (yt = gt.interleaved), yt !== null)) {
          gt.interleaved = null;
          var At = yt.next,
            Lt = gt.pending;
          if (Lt !== null) {
            var Wt = Lt.next;
            (Lt.next = At), (yt.next = Wt);
          }
          gt.pending = yt;
        }
      Uo = null;
    }
    return d;
  }
  function bh(d, pe) {
    do {
      var gt = os;
      try {
        if ((Ra(), (Fa.current = jc), uo)) {
          for (var yt = Fi.memoizedState; yt !== null; ) {
            var At = yt.queue;
            At !== null && (At.pending = null), (yt = yt.next);
          }
          uo = !1;
        }
        if (
          ((Vo = 0),
          (Si = Wi = Fi = null),
          (vs = !1),
          (oa = 0),
          (Wf.current = null),
          gt === null || gt.return === null)
        ) {
          (ds = 1), (Uu = pe), (os = null);
          break;
        }
        e: {
          var Lt = d,
            Wt = gt.return,
            nn = gt,
            dn = pe;
          if (
            ((pe = As),
            (nn.flags |= 32768),
            dn !== null &&
              typeof dn == "object" &&
              typeof dn.then == "function")
          ) {
            var Dn = dn,
              sr = nn,
              lr = sr.tag;
            if ((sr.mode & 1) === 0 && (lr === 0 || lr === 11 || lr === 15)) {
              var ir = sr.alternate;
              ir
                ? ((sr.updateQueue = ir.updateQueue),
                  (sr.memoizedState = ir.memoizedState),
                  (sr.lanes = ir.lanes))
                : ((sr.updateQueue = null), (sr.memoizedState = null));
            }
            var Lr = kr(Wt);
            if (Lr !== null) {
              (Lr.flags &= -257),
                ii(Lr, Wt, nn, Lt, pe),
                Lr.mode & 1 && dr(Lt, Dn, pe),
                (pe = Lr),
                (dn = Dn);
              var Nr = pe.updateQueue;
              if (Nr === null) {
                var Vr = new Set();
                Vr.add(dn), (pe.updateQueue = Vr);
              } else Nr.add(dn);
              break e;
            } else {
              if ((pe & 1) === 0) {
                dr(Lt, Dn, pe), Jf();
                break e;
              }
              dn = Error(t(426));
            }
          } else if (Di && nn.mode & 1) {
            var Ji = kr(Wt);
            if (Ji !== null) {
              (Ji.flags & 65536) === 0 && (Ji.flags |= 256),
                ii(Ji, Wt, nn, Lt, pe),
                cl(Et(dn, nn));
              break e;
            }
          }
          (Lt = dn = Et(dn, nn)),
            ds !== 4 && (ds = 2),
            zu === null ? (zu = [Lt]) : zu.push(Lt),
            (Lt = Wt);
          do {
            switch (Lt.tag) {
              case 3:
                (Lt.flags |= 65536), (pe &= -pe), (Lt.lanes |= pe);
                var Tn = vn(Lt, dn, pe);
                Ia(Lt, Tn);
                break e;
              case 1:
                nn = dn;
                var gn = Lt.type,
                  Cn = Lt.stateNode;
                if (
                  (Lt.flags & 128) === 0 &&
                  (typeof gn.getDerivedStateFromError == "function" ||
                    (Cn !== null &&
                      typeof Cn.componentDidCatch == "function" &&
                      (vl === null || !vl.has(Cn))))
                ) {
                  (Lt.flags |= 65536), (pe &= -pe), (Lt.lanes |= pe);
                  var vr = Wn(Lt, nn, pe);
                  Ia(Lt, vr);
                  break e;
                }
            }
            Lt = Lt.return;
          } while (Lt !== null);
        }
        Ah(gt);
      } catch (Wr) {
        (pe = Wr), os === gt && gt !== null && (os = gt = gt.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Mh() {
    var d = _f.current;
    return (_f.current = jc), d === null ? jc : d;
  }
  function Jf() {
    (ds === 0 || ds === 3 || ds === 2) && (ds = 4),
      _s === null ||
        ((tc & 268435455) === 0 && (yf & 268435455) === 0) ||
        xl(_s, As);
  }
  function bf(d, pe) {
    var gt = Ei;
    Ei |= 2;
    var yt = Mh();
    (_s !== d || As !== pe) && ((Ba = null), rc(d, pe));
    do
      try {
        qh();
        break;
      } catch (At) {
        bh(d, At);
      }
    while (!0);
    if ((Ra(), (Ei = gt), (_f.current = yt), os !== null)) throw Error(t(261));
    return (_s = null), (As = 0), ds;
  }
  function qh() {
    for (; os !== null; ) Ch(os);
  }
  function Xh() {
    for (; os !== null && !Zt(); ) Ch(os);
  }
  function Ch(d) {
    var pe = Ih(d.alternate, d, ho);
    (d.memoizedProps = d.pendingProps),
      pe === null ? Ah(d) : (os = pe),
      (Wf.current = null);
  }
  function Ah(d) {
    var pe = d;
    do {
      var gt = pe.alternate;
      if (((d = pe.return), (pe.flags & 32768) === 0)) {
        if (((gt = zh(gt, pe, ho)), gt !== null)) {
          os = gt;
          return;
        }
      } else {
        if (((gt = Vh(gt, pe)), gt !== null)) {
          (gt.flags &= 32767), (os = gt);
          return;
        }
        if (d !== null)
          (d.flags |= 32768), (d.subtreeFlags = 0), (d.deletions = null);
        else {
          (ds = 6), (os = null);
          return;
        }
      }
      if (((pe = pe.sibling), pe !== null)) {
        os = pe;
        return;
      }
      os = pe = d;
    } while (pe !== null);
    ds === 0 && (ds = 5);
  }
  function ic(d, pe, gt) {
    var yt = di,
      At = So.transition;
    try {
      (So.transition = null), (di = 1), Yh(d, pe, gt, yt);
    } finally {
      (So.transition = At), (di = yt);
    }
    return null;
  }
  function Yh(d, pe, gt, yt) {
    do Kc();
    while (_l !== null);
    if ((Ei & 6) !== 0) throw Error(t(327));
    gt = d.finishedWork;
    var At = d.finishedLanes;
    if (gt === null) return null;
    if (((d.finishedWork = null), (d.finishedLanes = 0), gt === d.current))
      throw Error(t(177));
    (d.callbackNode = null), (d.callbackPriority = 0);
    var Lt = gt.lanes | gt.childLanes;
    if (
      (Mi(d, Lt),
      d === _s && ((os = _s = null), (As = 0)),
      ((gt.subtreeFlags & 2064) === 0 && (gt.flags & 2064) === 0) ||
        Sf ||
        ((Sf = !0),
        Lh(Kn, function () {
          return Kc(), null;
        })),
      (Lt = (gt.flags & 15990) !== 0),
      (gt.subtreeFlags & 15990) !== 0 || Lt)
    ) {
      (Lt = So.transition), (So.transition = null);
      var Wt = di;
      di = 1;
      var nn = Ei;
      (Ei |= 4),
        (Wf.current = null),
        Hh(d, gt),
        _h(gt, d),
        ts(hu),
        (yi = !!ol),
        (hu = ol = null),
        (d.current = gt),
        Wh(gt),
        an(),
        (Ei = nn),
        (di = Wt),
        (So.transition = Lt);
    } else d.current = gt;
    if (
      (Sf && ((Sf = !1), (_l = d), (wf = At)),
      (Lt = d.pendingLanes),
      Lt === 0 && (vl = null),
      gr(gt.stateNode),
      no(d, Qt()),
      pe !== null)
    )
      for (yt = d.onRecoverableError, gt = 0; gt < pe.length; gt++)
        (At = pe[gt]),
          yt(At.value, { componentStack: At.stack, digest: At.digest });
    if (xf) throw ((xf = !1), (d = qf), (qf = null), d);
    return (
      (wf & 1) !== 0 && d.tag !== 0 && Kc(),
      (Lt = d.pendingLanes),
      (Lt & 1) !== 0 ? (d === Xf ? Vu++ : ((Vu = 0), (Xf = d))) : (Vu = 0),
      vo(),
      null
    );
  }
  function Kc() {
    if (_l !== null) {
      var d = ps(wf),
        pe = So.transition,
        gt = di;
      try {
        if (((So.transition = null), (di = 16 > d ? 16 : d), _l === null))
          var yt = !1;
        else {
          if (((d = _l), (_l = null), (wf = 0), (Ei & 6) !== 0))
            throw Error(t(331));
          var At = Ei;
          for (Ei |= 4, Or = d.current; Or !== null; ) {
            var Lt = Or,
              Wt = Lt.child;
            if ((Or.flags & 16) !== 0) {
              var nn = Lt.deletions;
              if (nn !== null) {
                for (var dn = 0; dn < nn.length; dn++) {
                  var Dn = nn[dn];
                  for (Or = Dn; Or !== null; ) {
                    var sr = Or;
                    switch (sr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Bu(8, sr, Lt);
                    }
                    var lr = sr.child;
                    if (lr !== null) (lr.return = sr), (Or = lr);
                    else
                      for (; Or !== null; ) {
                        sr = Or;
                        var ir = sr.sibling,
                          Lr = sr.return;
                        if ((dh(sr), sr === Dn)) {
                          Or = null;
                          break;
                        }
                        if (ir !== null) {
                          (ir.return = Lr), (Or = ir);
                          break;
                        }
                        Or = Lr;
                      }
                  }
                }
                var Nr = Lt.alternate;
                if (Nr !== null) {
                  var Vr = Nr.child;
                  if (Vr !== null) {
                    Nr.child = null;
                    do {
                      var Ji = Vr.sibling;
                      (Vr.sibling = null), (Vr = Ji);
                    } while (Vr !== null);
                  }
                }
                Or = Lt;
              }
            }
            if ((Lt.subtreeFlags & 2064) !== 0 && Wt !== null)
              (Wt.return = Lt), (Or = Wt);
            else
              e: for (; Or !== null; ) {
                if (((Lt = Or), (Lt.flags & 2048) !== 0))
                  switch (Lt.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Bu(9, Lt, Lt.return);
                  }
                var Tn = Lt.sibling;
                if (Tn !== null) {
                  (Tn.return = Lt.return), (Or = Tn);
                  break e;
                }
                Or = Lt.return;
              }
          }
          var gn = d.current;
          for (Or = gn; Or !== null; ) {
            Wt = Or;
            var Cn = Wt.child;
            if ((Wt.subtreeFlags & 2064) !== 0 && Cn !== null)
              (Cn.return = Wt), (Or = Cn);
            else
              e: for (Wt = gn; Or !== null; ) {
                if (((nn = Or), (nn.flags & 2048) !== 0))
                  try {
                    switch (nn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        vf(9, nn);
                    }
                  } catch (Wr) {
                    Ki(nn, nn.return, Wr);
                  }
                if (nn === Wt) {
                  Or = null;
                  break e;
                }
                var vr = nn.sibling;
                if (vr !== null) {
                  (vr.return = nn.return), (Or = vr);
                  break e;
                }
                Or = nn.return;
              }
          }
          if (
            ((Ei = At),
            vo(),
            Qn && typeof Qn.onPostCommitFiberRoot == "function")
          )
            try {
              Qn.onPostCommitFiberRoot(cr, d);
            } catch {}
          yt = !0;
        }
        return yt;
      } finally {
        (di = gt), (So.transition = pe);
      }
    }
    return !1;
  }
  function Ph(d, pe, gt) {
    (pe = Et(gt, pe)),
      (pe = vn(d, pe, 1)),
      (d = Bi(d, pe, 1)),
      (pe = $s()),
      d !== null && (gi(d, 1, pe), no(d, pe));
  }
  function Ki(d, pe, gt) {
    if (d.tag === 3) Ph(d, d, gt);
    else
      for (; pe !== null; ) {
        if (pe.tag === 3) {
          Ph(pe, d, gt);
          break;
        } else if (pe.tag === 1) {
          var yt = pe.stateNode;
          if (
            typeof pe.type.getDerivedStateFromError == "function" ||
            (typeof yt.componentDidCatch == "function" &&
              (vl === null || !vl.has(yt)))
          ) {
            (d = Et(gt, d)),
              (d = Wn(pe, d, 1)),
              (pe = Bi(pe, d, 1)),
              (d = $s()),
              pe !== null && (gi(pe, 1, d), no(pe, d));
            break;
          }
        }
        pe = pe.return;
      }
  }
  function Kh(d, pe, gt) {
    var yt = d.pingCache;
    yt !== null && yt.delete(pe),
      (pe = $s()),
      (d.pingedLanes |= d.suspendedLanes & gt),
      _s === d &&
        (As & gt) === gt &&
        (ds === 4 || (ds === 3 && (As & 130023424) === As && 500 > Qt() - $f)
          ? rc(d, 0)
          : (jf |= gt)),
      no(d, pe);
  }
  function Rh(d, pe) {
    pe === 0 &&
      ((d.mode & 1) === 0
        ? (pe = 1)
        : ((pe = oi), (oi <<= 1), (oi & 130023424) === 0 && (oi = 4194304)));
    var gt = $s();
    (d = lo(d, pe)), d !== null && (gi(d, pe, gt), no(d, gt));
  }
  function Zh(d) {
    var pe = d.memoizedState,
      gt = 0;
    pe !== null && (gt = pe.retryLane), Rh(d, gt);
  }
  function Qh(d, pe) {
    var gt = 0;
    switch (d.tag) {
      case 13:
        var yt = d.stateNode,
          At = d.memoizedState;
        At !== null && (gt = At.retryLane);
        break;
      case 19:
        yt = d.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    yt !== null && yt.delete(pe), Rh(d, gt);
  }
  var Ih;
  Ih = function (d, pe, gt) {
    if (d !== null)
      if (d.memoizedProps !== pe.pendingProps || Es.current) hi = !0;
      else {
        if ((d.lanes & gt) === 0 && (pe.flags & 128) === 0)
          return (hi = !1), Uh(d, pe, gt);
        hi = (d.flags & 131072) !== 0;
      }
    else (hi = !1), Di && (pe.flags & 1048576) !== 0 && xu(pe, Dc, pe.index);
    switch (((pe.lanes = 0), pe.tag)) {
      case 2:
        var yt = pe.type;
        mf(d, pe), (d = pe.pendingProps);
        var At = Ea(pe, ls.current);
        ia(pe, gt), (At = Yl(null, pe, yt, d, At, gt));
        var Lt = Au();
        return (
          (pe.flags |= 1),
          typeof At == "object" &&
          At !== null &&
          typeof At.render == "function" &&
          At.$$typeof === void 0
            ? ((pe.tag = 1),
              (pe.memoizedState = null),
              (pe.updateQueue = null),
              ms(yt) ? ((Lt = !0), Ta(pe)) : (Lt = !1),
              (pe.memoizedState =
                At.state !== null && At.state !== void 0 ? At.state : null),
              ui(pe),
              (At.updater = $c),
              (pe.stateNode = At),
              (At._reactInternals = pe),
              _t(pe, yt, d, gt),
              (pe = li(null, pe, yt, !0, Lt, gt)))
            : ((pe.tag = 0),
              Di && Lt && Su(pe),
              Ar(null, pe, At, gt),
              (pe = pe.child)),
          pe
        );
      case 16:
        yt = pe.elementType;
        e: {
          switch (
            (mf(d, pe),
            (d = pe.pendingProps),
            (At = yt._init),
            (yt = At(yt._payload)),
            (pe.type = yt),
            (At = pe.tag = ed(yt)),
            (d = eo(yt, d)),
            At)
          ) {
            case 0:
              pe = br(null, pe, yt, d, gt);
              break e;
            case 1:
              pe = Gr(null, pe, yt, d, gt);
              break e;
            case 11:
              pe = hs(null, pe, yt, d, gt);
              break e;
            case 14:
              pe = js(null, pe, yt, eo(yt.type, d), gt);
              break e;
          }
          throw Error(t(306, yt, ""));
        }
        return pe;
      case 0:
        return (
          (yt = pe.type),
          (At = pe.pendingProps),
          (At = pe.elementType === yt ? At : eo(yt, At)),
          br(d, pe, yt, At, gt)
        );
      case 1:
        return (
          (yt = pe.type),
          (At = pe.pendingProps),
          (At = pe.elementType === yt ? At : eo(yt, At)),
          Gr(d, pe, yt, At, gt)
        );
      case 3:
        e: {
          if ((si(pe), d === null)) throw Error(t(387));
          (yt = pe.pendingProps),
            (Lt = pe.memoizedState),
            (At = Lt.element),
            qi(d, pe),
            Hi(pe, yt, null, gt);
          var Wt = pe.memoizedState;
          if (((yt = Wt.element), Lt.isDehydrated))
            if (
              ((Lt = {
                element: yt,
                isDehydrated: !1,
                cache: Wt.cache,
                pendingSuspenseBoundaries: Wt.pendingSuspenseBoundaries,
                transitions: Wt.transitions,
              }),
              (pe.updateQueue.baseState = Lt),
              (pe.memoizedState = Lt),
              pe.flags & 256)
            ) {
              (At = Et(Error(t(423)), pe)), (pe = xi(d, pe, yt, gt, At));
              break e;
            } else if (yt !== At) {
              (At = Et(Error(t(424)), pe)), (pe = xi(d, pe, yt, gt, At));
              break e;
            } else
              for (
                bs = Lo(pe.stateNode.containerInfo.firstChild),
                  cs = pe,
                  Di = !0,
                  Js = null,
                  gt = Hl(pe, null, yt, gt),
                  pe.child = gt;
                gt;

              )
                (gt.flags = (gt.flags & -3) | 4096), (gt = gt.sibling);
          else {
            if ((ra(), yt === At)) {
              pe = Na(d, pe, gt);
              break e;
            }
            Ar(d, pe, yt, gt);
          }
          pe = pe.child;
        }
        return pe;
      case 5:
        return (
          ka(pe),
          d === null && Nc(pe),
          (yt = pe.type),
          (At = pe.pendingProps),
          (Lt = d !== null ? d.memoizedProps : null),
          (Wt = At.children),
          du(yt, At)
            ? (Wt = null)
            : Lt !== null && du(yt, Lt) && (pe.flags |= 32),
          Nn(d, pe),
          Ar(d, pe, Wt, gt),
          pe.child
        );
      case 6:
        return d === null && Nc(pe), null;
      case 13:
        return Wo(d, pe, gt);
      case 4:
        return (
          ql(pe, pe.stateNode.containerInfo),
          (yt = pe.pendingProps),
          d === null ? (pe.child = Ca(pe, null, yt, gt)) : Ar(d, pe, yt, gt),
          pe.child
        );
      case 11:
        return (
          (yt = pe.type),
          (At = pe.pendingProps),
          (At = pe.elementType === yt ? At : eo(yt, At)),
          hs(d, pe, yt, At, gt)
        );
      case 7:
        return Ar(d, pe, pe.pendingProps, gt), pe.child;
      case 8:
        return Ar(d, pe, pe.pendingProps.children, gt), pe.child;
      case 12:
        return Ar(d, pe, pe.pendingProps.children, gt), pe.child;
      case 10:
        e: {
          if (
            ((yt = pe.type._context),
            (At = pe.pendingProps),
            (Lt = pe.memoizedProps),
            (Wt = At.value),
            Ri(Aa, yt._currentValue),
            (yt._currentValue = Wt),
            Lt !== null)
          )
            if (Bs(Lt.value, Wt)) {
              if (Lt.children === At.children && !Es.current) {
                pe = Na(d, pe, gt);
                break e;
              }
            } else
              for (
                Lt = pe.child, Lt !== null && (Lt.return = pe);
                Lt !== null;

              ) {
                var nn = Lt.dependencies;
                if (nn !== null) {
                  Wt = Lt.child;
                  for (var dn = nn.firstContext; dn !== null; ) {
                    if (dn.context === yt) {
                      if (Lt.tag === 1) {
                        (dn = Ai(-1, gt & -gt)), (dn.tag = 2);
                        var Dn = Lt.updateQueue;
                        if (Dn !== null) {
                          Dn = Dn.shared;
                          var sr = Dn.pending;
                          sr === null
                            ? (dn.next = dn)
                            : ((dn.next = sr.next), (sr.next = dn)),
                            (Dn.pending = dn);
                        }
                      }
                      (Lt.lanes |= gt),
                        (dn = Lt.alternate),
                        dn !== null && (dn.lanes |= gt),
                        jl(Lt.return, gt, pe),
                        (nn.lanes |= gt);
                      break;
                    }
                    dn = dn.next;
                  }
                } else if (Lt.tag === 10)
                  Wt = Lt.type === pe.type ? null : Lt.child;
                else if (Lt.tag === 18) {
                  if (((Wt = Lt.return), Wt === null)) throw Error(t(341));
                  (Wt.lanes |= gt),
                    (nn = Wt.alternate),
                    nn !== null && (nn.lanes |= gt),
                    jl(Wt, gt, pe),
                    (Wt = Lt.sibling);
                } else Wt = Lt.child;
                if (Wt !== null) Wt.return = Lt;
                else
                  for (Wt = Lt; Wt !== null; ) {
                    if (Wt === pe) {
                      Wt = null;
                      break;
                    }
                    if (((Lt = Wt.sibling), Lt !== null)) {
                      (Lt.return = Wt.return), (Wt = Lt);
                      break;
                    }
                    Wt = Wt.return;
                  }
                Lt = Wt;
              }
          Ar(d, pe, At.children, gt), (pe = pe.child);
        }
        return pe;
      case 9:
        return (
          (At = pe.type),
          (yt = pe.pendingProps.children),
          ia(pe, gt),
          (At = Vs(At)),
          (yt = yt(At)),
          (pe.flags |= 1),
          Ar(d, pe, yt, gt),
          pe.child
        );
      case 14:
        return (
          (yt = pe.type),
          (At = eo(yt, pe.pendingProps)),
          (At = eo(yt.type, At)),
          js(d, pe, yt, At, gt)
        );
      case 15:
        return Pn(d, pe, pe.type, pe.pendingProps, gt);
      case 17:
        return (
          (yt = pe.type),
          (At = pe.pendingProps),
          (At = pe.elementType === yt ? At : eo(yt, At)),
          mf(d, pe),
          (pe.tag = 1),
          ms(yt) ? ((d = !0), Ta(pe)) : (d = !1),
          ia(pe, gt),
          Le(pe, yt, At),
          _t(pe, yt, At, gt),
          li(null, pe, yt, !0, d, gt)
        );
      case 19:
        return lh(d, pe, gt);
      case 22:
        return xn(d, pe, gt);
    }
    throw Error(t(156, pe.tag));
  };
  function Lh(d, pe) {
    return Xn(d, pe);
  }
  function Jh(d, pe, gt, yt) {
    (this.tag = d),
      (this.key = gt),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = pe),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = yt),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function wo(d, pe, gt, yt) {
    return new Jh(d, pe, gt, yt);
  }
  function eh(d) {
    return (d = d.prototype), !(!d || !d.isReactComponent);
  }
  function ed(d) {
    if (typeof d == "function") return eh(d) ? 1 : 0;
    if (d != null) {
      if (((d = d.$$typeof), d === Dt)) return 11;
      if (d === qt) return 14;
    }
    return 2;
  }
  function Sl(d, pe) {
    var gt = d.alternate;
    return (
      gt === null
        ? ((gt = wo(d.tag, pe, d.key, d.mode)),
          (gt.elementType = d.elementType),
          (gt.type = d.type),
          (gt.stateNode = d.stateNode),
          (gt.alternate = d),
          (d.alternate = gt))
        : ((gt.pendingProps = pe),
          (gt.type = d.type),
          (gt.flags = 0),
          (gt.subtreeFlags = 0),
          (gt.deletions = null)),
      (gt.flags = d.flags & 14680064),
      (gt.childLanes = d.childLanes),
      (gt.lanes = d.lanes),
      (gt.child = d.child),
      (gt.memoizedProps = d.memoizedProps),
      (gt.memoizedState = d.memoizedState),
      (gt.updateQueue = d.updateQueue),
      (pe = d.dependencies),
      (gt.dependencies =
        pe === null
          ? null
          : { lanes: pe.lanes, firstContext: pe.firstContext }),
      (gt.sibling = d.sibling),
      (gt.index = d.index),
      (gt.ref = d.ref),
      gt
    );
  }
  function Mf(d, pe, gt, yt, At, Lt) {
    var Wt = 2;
    if (((yt = d), typeof d == "function")) eh(d) && (Wt = 1);
    else if (typeof d == "string") Wt = 5;
    else
      e: switch (d) {
        case wt:
          return sc(gt.children, At, Lt, pe);
        case bt:
          (Wt = 8), (At |= 8);
          break;
        case Tt:
          return (
            (d = wo(12, gt, pe, At | 2)),
            (d.elementType = Tt),
            (d.lanes = Lt),
            d
          );
        case Vt:
          return (
            (d = wo(13, gt, pe, At)), (d.elementType = Vt), (d.lanes = Lt), d
          );
        case Ht:
          return (
            (d = wo(19, gt, pe, At)), (d.elementType = Ht), (d.lanes = Lt), d
          );
        case Bt:
          return Cf(gt, At, Lt, pe);
        default:
          if (typeof d == "object" && d !== null)
            switch (d.$$typeof) {
              case Ct:
                Wt = 10;
                break e;
              case kt:
                Wt = 9;
                break e;
              case Dt:
                Wt = 11;
                break e;
              case qt:
                Wt = 14;
                break e;
              case Ft:
                (Wt = 16), (yt = null);
                break e;
            }
          throw Error(t(130, d == null ? d : typeof d, ""));
      }
    return (
      (pe = wo(Wt, gt, pe, At)),
      (pe.elementType = d),
      (pe.type = yt),
      (pe.lanes = Lt),
      pe
    );
  }
  function sc(d, pe, gt, yt) {
    return (d = wo(7, d, yt, pe)), (d.lanes = gt), d;
  }
  function Cf(d, pe, gt, yt) {
    return (
      (d = wo(22, d, yt, pe)),
      (d.elementType = Bt),
      (d.lanes = gt),
      (d.stateNode = { isHidden: !1 }),
      d
    );
  }
  function th(d, pe, gt) {
    return (d = wo(6, d, null, pe)), (d.lanes = gt), d;
  }
  function nh(d, pe, gt) {
    return (
      (pe = wo(4, d.children !== null ? d.children : [], d.key, pe)),
      (pe.lanes = gt),
      (pe.stateNode = {
        containerInfo: d.containerInfo,
        pendingChildren: null,
        implementation: d.implementation,
      }),
      pe
    );
  }
  function nd(d, pe, gt, yt, At) {
    (this.tag = pe),
      (this.containerInfo = d),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Ii(0)),
      (this.expirationTimes = Ii(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Ii(0)),
      (this.identifierPrefix = yt),
      (this.onRecoverableError = At),
      (this.mutableSourceEagerHydrationData = null);
  }
  function rh(d, pe, gt, yt, At, Lt, Wt, nn, dn) {
    return (
      (d = new nd(d, pe, gt, nn, dn)),
      pe === 1 ? ((pe = 1), Lt === !0 && (pe |= 8)) : (pe = 0),
      (Lt = wo(3, null, null, pe)),
      (d.current = Lt),
      (Lt.stateNode = d),
      (Lt.memoizedState = {
        element: yt,
        isDehydrated: gt,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      ui(Lt),
      d
    );
  }
  function rd(d, pe, gt) {
    var yt =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: St,
      key: yt == null ? null : "" + yt,
      children: d,
      containerInfo: pe,
      implementation: gt,
    };
  }
  function kh(d) {
    if (!d) return Fo;
    d = d._reactInternals;
    e: {
      if ($t(d) !== d || d.tag !== 1) throw Error(t(170));
      var pe = d;
      do {
        switch (pe.tag) {
          case 3:
            pe = pe.stateNode.context;
            break e;
          case 1:
            if (ms(pe.type)) {
              pe = pe.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        pe = pe.return;
      } while (pe !== null);
      throw Error(t(171));
    }
    if (d.tag === 1) {
      var gt = d.type;
      if (ms(gt)) return Bl(d, gt, pe);
    }
    return pe;
  }
  function Fh(d, pe, gt, yt, At, Lt, Wt, nn, dn) {
    return (
      (d = rh(gt, yt, !0, d, At, Lt, Wt, nn, dn)),
      (d.context = kh(null)),
      (gt = d.current),
      (yt = $s()),
      (At = yl(gt)),
      (Lt = Ai(yt, At)),
      (Lt.callback = pe ?? null),
      Bi(gt, Lt, At),
      (d.current.lanes = At),
      gi(d, At, yt),
      no(d, yt),
      d
    );
  }
  function Af(d, pe, gt, yt) {
    var At = pe.current,
      Lt = $s(),
      Wt = yl(At);
    return (
      (gt = kh(gt)),
      pe.context === null ? (pe.context = gt) : (pe.pendingContext = gt),
      (pe = Ai(Lt, Wt)),
      (pe.payload = { element: d }),
      (yt = yt === void 0 ? null : yt),
      yt !== null && (pe.callback = yt),
      (d = Bi(At, pe, Wt)),
      d !== null && (qo(d, At, Wt, Lt), gs(d, At, Wt)),
      Wt
    );
  }
  function Pf(d) {
    if (((d = d.current), !d.child)) return null;
    switch (d.child.tag) {
      case 5:
        return d.child.stateNode;
      default:
        return d.child.stateNode;
    }
  }
  function Dh(d, pe) {
    if (((d = d.memoizedState), d !== null && d.dehydrated !== null)) {
      var gt = d.retryLane;
      d.retryLane = gt !== 0 && gt < pe ? gt : pe;
    }
  }
  function ih(d, pe) {
    Dh(d, pe), (d = d.alternate) && Dh(d, pe);
  }
  function id() {
    return null;
  }
  var Oh =
    typeof reportError == "function"
      ? reportError
      : function (d) {
          console.error(d);
        };
  function sh(d) {
    this._internalRoot = d;
  }
  (Rf.prototype.render = sh.prototype.render =
    function (d) {
      var pe = this._internalRoot;
      if (pe === null) throw Error(t(409));
      Af(d, pe, null, null);
    }),
    (Rf.prototype.unmount = sh.prototype.unmount =
      function () {
        var d = this._internalRoot;
        if (d !== null) {
          this._internalRoot = null;
          var pe = d.containerInfo;
          nc(function () {
            Af(null, d, null, null);
          }),
            (pe[zs] = null);
        }
      });
  function Rf(d) {
    this._internalRoot = d;
  }
  Rf.prototype.unstable_scheduleHydration = function (d) {
    if (d) {
      var pe = za();
      d = { blockedOn: null, target: d, priority: pe };
      for (
        var gt = 0;
        gt < po.length && pe !== 0 && pe < po[gt].priority;
        gt++
      );
      po.splice(gt, 0, d), gt === 0 && Ha(d);
    }
  };
  function oh(d) {
    return !(!d || (d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11));
  }
  function If(d) {
    return !(
      !d ||
      (d.nodeType !== 1 &&
        d.nodeType !== 9 &&
        d.nodeType !== 11 &&
        (d.nodeType !== 8 || d.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function Nh() {}
  function sd(d, pe, gt, yt, At) {
    if (At) {
      if (typeof yt == "function") {
        var Lt = yt;
        yt = function () {
          var Dn = Pf(Wt);
          Lt.call(Dn);
        };
      }
      var Wt = Fh(pe, yt, d, 0, null, !1, !1, "", Nh);
      return (
        (d._reactRootContainer = Wt),
        (d[zs] = Wt.current),
        il(d.nodeType === 8 ? d.parentNode : d),
        nc(),
        Wt
      );
    }
    for (; (At = d.lastChild); ) d.removeChild(At);
    if (typeof yt == "function") {
      var nn = yt;
      yt = function () {
        var Dn = Pf(dn);
        nn.call(Dn);
      };
    }
    var dn = rh(d, 0, !1, null, null, !1, !1, "", Nh);
    return (
      (d._reactRootContainer = dn),
      (d[zs] = dn.current),
      il(d.nodeType === 8 ? d.parentNode : d),
      nc(function () {
        Af(pe, dn, gt, yt);
      }),
      dn
    );
  }
  function Lf(d, pe, gt, yt, At) {
    var Lt = gt._reactRootContainer;
    if (Lt) {
      var Wt = Lt;
      if (typeof At == "function") {
        var nn = At;
        At = function () {
          var dn = Pf(Wt);
          nn.call(dn);
        };
      }
      Af(pe, Wt, d, At);
    } else Wt = sd(gt, pe, d, At, yt);
    return Pf(Wt);
  }
  (la = function (d) {
    switch (d.tag) {
      case 3:
        var pe = d.stateNode;
        if (pe.current.memoizedState.isDehydrated) {
          var gt = Xr(pe.pendingLanes);
          gt !== 0 &&
            (Ui(pe, gt | 1),
            no(pe, Qt()),
            (Ei & 6) === 0 && ((Yc = Qt() + 500), vo()));
        }
        break;
      case 13:
        nc(function () {
          var yt = lo(d, 1);
          if (yt !== null) {
            var At = $s();
            qo(yt, d, 1, At);
          }
        }),
          ih(d, 1);
    }
  }),
    (El = function (d) {
      if (d.tag === 13) {
        var pe = lo(d, 134217728);
        if (pe !== null) {
          var gt = $s();
          qo(pe, d, 134217728, gt);
        }
        ih(d, 134217728);
      }
    }),
    (oc = function (d) {
      if (d.tag === 13) {
        var pe = yl(d),
          gt = lo(d, pe);
        if (gt !== null) {
          var yt = $s();
          qo(gt, d, pe, yt);
        }
        ih(d, pe);
      }
    }),
    (za = function () {
      return di;
    }),
    (Va = function (d, pe) {
      var gt = di;
      try {
        return (di = d), pe();
      } finally {
        di = gt;
      }
    }),
    (An = function (d, pe, gt) {
      switch (pe) {
        case "input":
          if ((rn(d, gt), (pe = gt.name), gt.type === "radio" && pe != null)) {
            for (gt = d; gt.parentNode; ) gt = gt.parentNode;
            for (
              gt = gt.querySelectorAll(
                "input[name=" + JSON.stringify("" + pe) + '][type="radio"]'
              ),
                pe = 0;
              pe < gt.length;
              pe++
            ) {
              var yt = gt[pe];
              if (yt !== d && yt.form === d.form) {
                var At = Lc(yt);
                if (!At) throw Error(t(90));
                _r(yt), rn(yt, At);
              }
            }
          }
          break;
        case "textarea":
          En(d, gt);
          break;
        case "select":
          (pe = gt.value), pe != null && Yt(d, !!gt.multiple, pe, !1);
      }
    }),
    (fi = Zf),
    (wi = nc);
  var od = { usingClientEntryPoint: !1, Events: [ko, $i, Lc, pr, jr, Zf] },
    Gu = {
      findFiberByHostInstance: na,
      bundleType: 0,
      version: "18.3.1",
      rendererPackageName: "react-dom",
    },
    ad = {
      bundleType: Gu.bundleType,
      version: Gu.version,
      rendererPackageName: Gu.rendererPackageName,
      rendererConfig: Gu.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: vt.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (d) {
        return (d = kn(d)), d === null ? null : d.stateNode;
      },
      findFiberByHostInstance: Gu.findFiberByHostInstance || id,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var kf = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!kf.isDisabled && kf.supportsFiber)
      try {
        (cr = kf.inject(ad)), (Qn = kf);
      } catch {}
  }
  return (
    (reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED =
      od),
    (reactDom_production_min.createPortal = function (d, pe) {
      var gt =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!oh(pe)) throw Error(t(200));
      return rd(d, pe, null, gt);
    }),
    (reactDom_production_min.createRoot = function (d, pe) {
      if (!oh(d)) throw Error(t(299));
      var gt = !1,
        yt = "",
        At = Oh;
      return (
        pe != null &&
          (pe.unstable_strictMode === !0 && (gt = !0),
          pe.identifierPrefix !== void 0 && (yt = pe.identifierPrefix),
          pe.onRecoverableError !== void 0 && (At = pe.onRecoverableError)),
        (pe = rh(d, 1, !1, null, null, gt, !1, yt, At)),
        (d[zs] = pe.current),
        il(d.nodeType === 8 ? d.parentNode : d),
        new sh(pe)
      );
    }),
    (reactDom_production_min.findDOMNode = function (d) {
      if (d == null) return null;
      if (d.nodeType === 1) return d;
      var pe = d._reactInternals;
      if (pe === void 0)
        throw typeof d.render == "function"
          ? Error(t(188))
          : ((d = Object.keys(d).join(",")), Error(t(268, d)));
      return (d = kn(pe)), (d = d === null ? null : d.stateNode), d;
    }),
    (reactDom_production_min.flushSync = function (d) {
      return nc(d);
    }),
    (reactDom_production_min.hydrate = function (d, pe, gt) {
      if (!If(pe)) throw Error(t(200));
      return Lf(null, d, pe, !0, gt);
    }),
    (reactDom_production_min.hydrateRoot = function (d, pe, gt) {
      if (!oh(d)) throw Error(t(405));
      var yt = (gt != null && gt.hydratedSources) || null,
        At = !1,
        Lt = "",
        Wt = Oh;
      if (
        (gt != null &&
          (gt.unstable_strictMode === !0 && (At = !0),
          gt.identifierPrefix !== void 0 && (Lt = gt.identifierPrefix),
          gt.onRecoverableError !== void 0 && (Wt = gt.onRecoverableError)),
        (pe = Fh(pe, null, d, 1, gt ?? null, At, !1, Lt, Wt)),
        (d[zs] = pe.current),
        il(d),
        yt)
      )
        for (d = 0; d < yt.length; d++)
          (gt = yt[d]),
            (At = gt._getVersion),
            (At = At(gt._source)),
            pe.mutableSourceEagerHydrationData == null
              ? (pe.mutableSourceEagerHydrationData = [gt, At])
              : pe.mutableSourceEagerHydrationData.push(gt, At);
      return new Rf(pe);
    }),
    (reactDom_production_min.render = function (d, pe, gt) {
      if (!If(pe)) throw Error(t(200));
      return Lf(null, d, pe, !1, gt);
    }),
    (reactDom_production_min.unmountComponentAtNode = function (d) {
      if (!If(d)) throw Error(t(40));
      return d._reactRootContainer
        ? (nc(function () {
            Lf(null, null, d, !1, function () {
              (d._reactRootContainer = null), (d[zs] = null);
            });
          }),
          !0)
        : !1;
    }),
    (reactDom_production_min.unstable_batchedUpdates = Zf),
    (reactDom_production_min.unstable_renderSubtreeIntoContainer = function (
      d,
      pe,
      gt,
      yt
    ) {
      if (!If(gt)) throw Error(t(200));
      if (d == null || d._reactInternals === void 0) throw Error(t(38));
      return Lf(d, pe, gt, !1, yt);
    }),
    (reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426"),
    reactDom_production_min
  );
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
  }
  return (
    n(), (reactDom.exports = requireReactDom_production_min()), reactDom.exports
  );
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var n = requireReactDom();
  return (
    (client.createRoot = n.createRoot),
    (client.hydrateRoot = n.hydrateRoot),
    client
  );
}
var clientExports = requireClient(),
  __assign = function () {
    return (
      (__assign =
        Object.assign ||
        function (e) {
          for (var t, r = 1, s = arguments.length; r < s; r++) {
            t = arguments[r];
            for (var o in t)
              Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
          }
          return e;
        }),
      __assign.apply(this, arguments)
    );
  };
function __spreadArray(n, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, s = e.length, o; r < s; r++)
      (o || !(r in e)) &&
        (o || (o = Array.prototype.slice.call(e, 0, r)), (o[r] = e[r]));
  return n.concat(o || Array.prototype.slice.call(e));
}
typeof SuppressedError == "function" && SuppressedError;
var MS = "-ms-",
  MOZ = "-moz-",
  WEBKIT = "-webkit-",
  COMMENT = "comm",
  RULESET = "rule",
  DECLARATION = "decl",
  IMPORT = "@import",
  KEYFRAMES = "@keyframes",
  LAYER = "@layer",
  abs = Math.abs,
  from = String.fromCharCode,
  assign = Object.assign;
function hash(n, e) {
  return charat(n, 0) ^ 45
    ? (((((((e << 2) ^ charat(n, 0)) << 2) ^ charat(n, 1)) << 2) ^
        charat(n, 2)) <<
        2) ^
        charat(n, 3)
    : 0;
}
function trim(n) {
  return n.trim();
}
function match(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function replace(n, e, t) {
  return n.replace(e, t);
}
function indexof(n, e, t) {
  return n.indexOf(e, t);
}
function charat(n, e) {
  return n.charCodeAt(e) | 0;
}
function substr(n, e, t) {
  return n.slice(e, t);
}
function strlen(n) {
  return n.length;
}
function sizeof(n) {
  return n.length;
}
function append(n, e) {
  return e.push(n), n;
}
function combine(n, e) {
  return n.map(e).join("");
}
function filter(n, e) {
  return n.filter(function (t) {
    return !match(t, e);
  });
}
var line = 1,
  column = 1,
  length = 0,
  position = 0,
  character = 0,
  characters = "";
function node(n, e, t, r, s, o, a, l) {
  return {
    value: n,
    root: e,
    parent: t,
    type: r,
    props: s,
    children: o,
    line,
    column,
    length: a,
    return: "",
    siblings: l,
  };
}
function copy(n, e) {
  return assign(
    node("", null, null, "", null, null, 0, n.siblings),
    n,
    { length: -n.length },
    e
  );
}
function lift(n) {
  for (; n.root; ) n = copy(n.root, { children: [n] });
  append(n, n.siblings);
}
function char() {
  return character;
}
function prev() {
  return (
    (character = position > 0 ? charat(characters, --position) : 0),
    column--,
    character === 10 && ((column = 1), line--),
    character
  );
}
function next$1() {
  return (
    (character = position < length ? charat(characters, position++) : 0),
    column++,
    character === 10 && ((column = 1), line++),
    character
  );
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(n, e) {
  return substr(characters, n, e);
}
function token(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(n) {
  return (
    (line = column = 1), (length = strlen((characters = n))), (position = 0), []
  );
}
function dealloc(n) {
  return (characters = ""), n;
}
function delimit(n) {
  return trim(
    slice(position - 1, delimiter(n === 91 ? n + 2 : n === 40 ? n + 1 : n))
  );
}
function whitespace(n) {
  for (; (character = peek()) && character < 33; ) next$1();
  return token(n) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(n, e) {
  for (
    ;
    --e &&
    next$1() &&
    !(
      character < 48 ||
      character > 102 ||
      (character > 57 && character < 65) ||
      (character > 70 && character < 97)
    );

  );
  return slice(n, caret() + (e < 6 && peek() == 32 && next$1() == 32));
}
function delimiter(n) {
  for (; next$1(); )
    switch (character) {
      case n:
        return position;
      case 34:
      case 39:
        n !== 34 && n !== 39 && delimiter(character);
        break;
      case 40:
        n === 41 && delimiter(n);
        break;
      case 92:
        next$1();
        break;
    }
  return position;
}
function commenter(n, e) {
  for (; next$1() && n + character !== 57; )
    if (n + character === 84 && peek() === 47) break;
  return "/*" + slice(e, position - 1) + "*" + from(n === 47 ? n : next$1());
}
function identifier(n) {
  for (; !token(peek()); ) next$1();
  return slice(n, position);
}
function compile(n) {
  return dealloc(parse("", null, null, null, [""], (n = alloc(n)), 0, [0], n));
}
function parse(n, e, t, r, s, o, a, l, c) {
  for (
    var u = 0,
      p = 0,
      N = a,
      P = 0,
      de = 0,
      me = 0,
      Ye = 1,
      nt = 1,
      Be = 1,
      ot = 0,
      st = "",
      vt = s,
      xt = o,
      St = r,
      wt = st;
    nt;

  )
    switch (((me = ot), (ot = next$1()))) {
      case 40:
        if (me != 108 && charat(wt, N - 1) == 58) {
          indexof(
            (wt += replace(delimit(ot), "&", "&\f")),
            "&\f",
            abs(u ? l[u - 1] : 0)
          ) != -1 && (Be = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        wt += delimit(ot);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        wt += whitespace(me);
        break;
      case 92:
        wt += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next$1(), caret()), e, t, c), c);
            break;
          default:
            wt += "/";
        }
        break;
      case 123 * Ye:
        l[u++] = strlen(wt) * Be;
      case 125 * Ye:
      case 59:
      case 0:
        switch (ot) {
          case 0:
          case 125:
            nt = 0;
          case 59 + p:
            Be == -1 && (wt = replace(wt, /\f/g, "")),
              de > 0 &&
                strlen(wt) - N &&
                append(
                  de > 32
                    ? declaration(wt + ";", r, t, N - 1, c)
                    : declaration(replace(wt, " ", "") + ";", r, t, N - 2, c),
                  c
                );
            break;
          case 59:
            wt += ";";
          default:
            if (
              (append(
                (St = ruleset(
                  wt,
                  e,
                  t,
                  u,
                  p,
                  s,
                  l,
                  st,
                  (vt = []),
                  (xt = []),
                  N,
                  o
                )),
                o
              ),
              ot === 123)
            )
              if (p === 0) parse(wt, e, St, St, vt, o, N, l, xt);
              else
                switch (P === 99 && charat(wt, 3) === 110 ? 100 : P) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(
                      n,
                      St,
                      St,
                      r &&
                        append(
                          ruleset(
                            n,
                            St,
                            St,
                            0,
                            0,
                            s,
                            l,
                            st,
                            s,
                            (vt = []),
                            N,
                            xt
                          ),
                          xt
                        ),
                      s,
                      xt,
                      N,
                      l,
                      r ? vt : xt
                    );
                    break;
                  default:
                    parse(wt, St, St, St, [""], xt, 0, l, xt);
                }
        }
        (u = p = de = 0), (Ye = Be = 1), (st = wt = ""), (N = a);
        break;
      case 58:
        (N = 1 + strlen(wt)), (de = me);
      default:
        if (Ye < 1) {
          if (ot == 123) --Ye;
          else if (ot == 125 && Ye++ == 0 && prev() == 125) continue;
        }
        switch (((wt += from(ot)), ot * Ye)) {
          case 38:
            Be = p > 0 ? 1 : ((wt += "\f"), -1);
            break;
          case 44:
            (l[u++] = (strlen(wt) - 1) * Be), (Be = 1);
            break;
          case 64:
            peek() === 45 && (wt += delimit(next$1())),
              (P = peek()),
              (p = N = strlen((st = wt += identifier(caret())))),
              ot++;
            break;
          case 45:
            me === 45 && strlen(wt) == 2 && (Ye = 0);
        }
    }
  return o;
}
function ruleset(n, e, t, r, s, o, a, l, c, u, p, N) {
  for (
    var P = s - 1,
      de = s === 0 ? o : [""],
      me = sizeof(de),
      Ye = 0,
      nt = 0,
      Be = 0;
    Ye < r;
    ++Ye
  )
    for (
      var ot = 0, st = substr(n, P + 1, (P = abs((nt = a[Ye])))), vt = n;
      ot < me;
      ++ot
    )
      (vt = trim(nt > 0 ? de[ot] + " " + st : replace(st, /&\f/g, de[ot]))) &&
        (c[Be++] = vt);
  return node(n, e, t, s === 0 ? RULESET : l, c, u, p, N);
}
function comment(n, e, t, r) {
  return node(n, e, t, COMMENT, from(char()), substr(n, 2, -2), 0, r);
}
function declaration(n, e, t, r, s) {
  return node(
    n,
    e,
    t,
    DECLARATION,
    substr(n, 0, r),
    substr(n, r + 1, -1),
    r,
    s
  );
}
function prefix(n, e, t) {
  switch (hash(n, e)) {
    case 5103:
      return WEBKIT + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + n + n;
    case 4789:
      return MOZ + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + n + MOZ + n + MS + n + n;
    case 5936:
      switch (charat(n, e + 11)) {
        case 114:
          return WEBKIT + n + MS + replace(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return (
            WEBKIT + n + MS + replace(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n
          );
        case 45:
          return WEBKIT + n + MS + replace(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + n + MS + n + n;
    case 6165:
      return WEBKIT + n + MS + "flex-" + n + n;
    case 5187:
      return (
        WEBKIT +
        n +
        replace(n, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") +
        n
      );
    case 5443:
      return (
        WEBKIT +
        n +
        MS +
        "flex-item-" +
        replace(n, /flex-|-self/g, "") +
        (match(n, /flex-|baseline/)
          ? ""
          : MS + "grid-row-" + replace(n, /flex-|-self/g, "")) +
        n
      );
    case 4675:
      return (
        WEBKIT +
        n +
        MS +
        "flex-line-pack" +
        replace(n, /align-content|flex-|-self/g, "") +
        n
      );
    case 5548:
      return WEBKIT + n + MS + replace(n, "shrink", "negative") + n;
    case 5292:
      return WEBKIT + n + MS + replace(n, "basis", "preferred-size") + n;
    case 6060:
      return (
        WEBKIT +
        "box-" +
        replace(n, "-grow", "") +
        WEBKIT +
        n +
        MS +
        replace(n, "grow", "positive") +
        n
      );
    case 4554:
      return (
        WEBKIT + replace(n, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + n
      );
    case 6187:
      return (
        replace(
          replace(
            replace(n, /(zoom-|grab)/, WEBKIT + "$1"),
            /(image-set)/,
            WEBKIT + "$1"
          ),
          n,
          ""
        ) + n
      );
    case 5495:
    case 3959:
      return replace(n, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return (
        replace(
          replace(
            n,
            /(.+:)(flex-)?(.*)/,
            WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"
          ),
          /s.+-b[^;]+/,
          "justify"
        ) +
        WEBKIT +
        n +
        n
      );
    case 4200:
      if (!match(n, /flex-|baseline/))
        return MS + "grid-column-align" + substr(n, e) + n;
      break;
    case 2592:
    case 3360:
      return MS + replace(n, "template-", "") + n;
    case 4384:
    case 3616:
      return t &&
        t.some(function (r, s) {
          return (e = s), match(r.props, /grid-\w+-end/);
        })
        ? ~indexof(n + (t = t[e].value), "span", 0)
          ? n
          : MS +
            replace(n, "-start", "") +
            n +
            MS +
            "grid-row-span:" +
            (~indexof(t, "span", 0)
              ? match(t, /\d+/)
              : +match(t, /\d+/) - +match(n, /\d+/)) +
            ";"
        : MS + replace(n, "-start", "") + n;
    case 4896:
    case 4128:
      return t &&
        t.some(function (r) {
          return match(r.props, /grid-\w+-start/);
        })
        ? n
        : MS + replace(replace(n, "-end", "-span"), "span ", "") + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(n, /(.+)-inline(.+)/, WEBKIT + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(n) - 1 - e > 6)
        switch (charat(n, e + 1)) {
          case 109:
            if (charat(n, e + 4) !== 45) break;
          case 102:
            return (
              replace(
                n,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  WEBKIT +
                  "$2-$3$1" +
                  MOZ +
                  (charat(n, e + 3) == 108 ? "$3" : "$2-$3")
              ) + n
            );
          case 115:
            return ~indexof(n, "stretch", 0)
              ? prefix(replace(n, "stretch", "fill-available"), e, t) + n
              : n;
        }
      break;
    case 5152:
    case 5920:
      return replace(
        n,
        /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/,
        function (r, s, o, a, l, c, u) {
          return (
            MS +
            s +
            ":" +
            o +
            u +
            (a ? MS + s + "-span:" + (l ? c : +c - +o) + u : "") +
            n
          );
        }
      );
    case 4949:
      if (charat(n, e + 6) === 121) return replace(n, ":", ":" + WEBKIT) + n;
      break;
    case 6444:
      switch (charat(n, charat(n, 14) === 45 ? 18 : 11)) {
        case 120:
          return (
            replace(
              n,
              /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,
              "$1" +
                WEBKIT +
                (charat(n, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                WEBKIT +
                "$2$3$1" +
                MS +
                "$2box$3"
            ) + n
          );
        case 100:
          return replace(n, ":", ":" + MS) + n;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(n, "scroll-", "scroll-snap-") + n;
  }
  return n;
}
function serialize(n, e) {
  for (var t = "", r = 0; r < n.length; r++) t += e(n[r], r, n, e) || "";
  return t;
}
function stringify(n, e, t, r) {
  switch (n.type) {
    case LAYER:
      if (n.children.length) break;
    case IMPORT:
    case DECLARATION:
      return (n.return = n.return || n.value);
    case COMMENT:
      return "";
    case KEYFRAMES:
      return (n.return = n.value + "{" + serialize(n.children, r) + "}");
    case RULESET:
      if (!strlen((n.value = n.props.join(",")))) return "";
  }
  return strlen((t = serialize(n.children, r)))
    ? (n.return = n.value + "{" + t + "}")
    : "";
}
function middleware(n) {
  var e = sizeof(n);
  return function (t, r, s, o) {
    for (var a = "", l = 0; l < e; l++) a += n[l](t, r, s, o) || "";
    return a;
  };
}
function rulesheet(n) {
  return function (e) {
    e.root || ((e = e.return) && n(e));
  };
}
function prefixer(n, e, t, r) {
  if (n.length > -1 && !n.return)
    switch (n.type) {
      case DECLARATION:
        n.return = prefix(n.value, n.length, t);
        return;
      case KEYFRAMES:
        return serialize(
          [copy(n, { value: replace(n.value, "@", "@" + WEBKIT) })],
          r
        );
      case RULESET:
        if (n.length)
          return combine((t = n.props), function (s) {
            switch (match(s, (r = /(::plac\w+|:read-\w+)/))) {
              case ":read-only":
              case ":read-write":
                lift(
                  copy(n, {
                    props: [replace(s, /:(read-\w+)/, ":" + MOZ + "$1")],
                  })
                ),
                  lift(copy(n, { props: [s] })),
                  assign(n, { props: filter(t, r) });
                break;
              case "::placeholder":
                lift(
                  copy(n, {
                    props: [
                      replace(s, /:(plac\w+)/, ":" + WEBKIT + "input-$1"),
                    ],
                  })
                ),
                  lift(
                    copy(n, {
                      props: [replace(s, /:(plac\w+)/, ":" + MOZ + "$1")],
                    })
                  ),
                  lift(
                    copy(n, {
                      props: [replace(s, /:(plac\w+)/, MS + "input-$1")],
                    })
                  ),
                  lift(copy(n, { props: [s] })),
                  assign(n, { props: filter(t, r) });
                break;
            }
            return "";
          });
    }
}
var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  define_process_env_default = {},
  f =
    (typeof process < "u" &&
      define_process_env_default !== void 0 &&
      (define_process_env_default.REACT_APP_SC_ATTR ||
        define_process_env_default.SC_ATTR)) ||
    "data-styled",
  m = "active",
  y = "data-styled-version",
  v$1 = "6.1.18",
  g$1 = `/*!sc*/
`,
  S = typeof window < "u" && typeof document < "u",
  w$1 = !!(typeof SC_DISABLE_SPEEDY == "boolean"
    ? SC_DISABLE_SPEEDY
    : typeof process < "u" &&
      define_process_env_default !== void 0 &&
      define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY !== void 0 &&
      define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY !== ""
    ? define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY !== "false" &&
      define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY
    : typeof process < "u" &&
      define_process_env_default !== void 0 &&
      define_process_env_default.SC_DISABLE_SPEEDY !== void 0 &&
      define_process_env_default.SC_DISABLE_SPEEDY !== "" &&
      define_process_env_default.SC_DISABLE_SPEEDY !== "false" &&
      define_process_env_default.SC_DISABLE_SPEEDY),
  b = {},
  _ = Object.freeze([]),
  C = Object.freeze({});
function I(n, e, t) {
  return (
    t === void 0 && (t = C), (n.theme !== t.theme && n.theme) || e || t.theme
  );
}
var A = new Set([
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "u",
    "ul",
    "use",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "marker",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ]),
  O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
  D$1 = /(^-|-$)/g;
function R(n) {
  return n.replace(O, "-").replace(D$1, "");
}
var T = /(a)(d)/gi,
  k$1 = 52,
  j$1 = function (n) {
    return String.fromCharCode(n + (n > 25 ? 39 : 97));
  };
function x$1(n) {
  var e,
    t = "";
  for (e = Math.abs(n); e > k$1; e = (e / k$1) | 0) t = j$1(e % k$1) + t;
  return (j$1(e % k$1) + t).replace(T, "$1-$2");
}
var V,
  F = 5381,
  M = function (n, e) {
    for (var t = e.length; t; ) n = (33 * n) ^ e.charCodeAt(--t);
    return n;
  },
  z = function (n) {
    return M(F, n);
  };
function $(n) {
  return x$1(z(n) >>> 0);
}
function B(n) {
  return n.displayName || n.name || "Component";
}
function L(n) {
  return typeof n == "string" && !0;
}
var G = typeof Symbol == "function" && Symbol.for,
  Y = G ? Symbol.for("react.memo") : 60115,
  W$1 = G ? Symbol.for("react.forward_ref") : 60112,
  q = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0,
  },
  H = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0,
  },
  U = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  J =
    (((V = {})[W$1] = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
    }),
    (V[Y] = U),
    V);
function X$1(n) {
  return ("type" in (e = n) && e.type.$$typeof) === Y
    ? U
    : "$$typeof" in n
    ? J[n.$$typeof]
    : q;
  var e;
}
var Z = Object.defineProperty,
  K = Object.getOwnPropertyNames,
  Q = Object.getOwnPropertySymbols,
  ee = Object.getOwnPropertyDescriptor,
  te = Object.getPrototypeOf,
  ne = Object.prototype;
function oe(n, e, t) {
  if (typeof e != "string") {
    if (ne) {
      var r = te(e);
      r && r !== ne && oe(n, r, t);
    }
    var s = K(e);
    Q && (s = s.concat(Q(e)));
    for (var o = X$1(n), a = X$1(e), l = 0; l < s.length; ++l) {
      var c = s[l];
      if (!(c in H || (t && t[c]) || (a && c in a) || (o && c in o))) {
        var u = ee(e, c);
        try {
          Z(n, c, u);
        } catch {}
      }
    }
  }
  return n;
}
function re(n) {
  return typeof n == "function";
}
function se(n) {
  return typeof n == "object" && "styledComponentId" in n;
}
function ie(n, e) {
  return n && e ? "".concat(n, " ").concat(e) : n || e || "";
}
function ae(n, e) {
  if (n.length === 0) return "";
  for (var t = n[0], r = 1; r < n.length; r++) t += n[r];
  return t;
}
function ce(n) {
  return (
    n !== null &&
    typeof n == "object" &&
    n.constructor.name === Object.name &&
    !("props" in n && n.$$typeof)
  );
}
function le(n, e, t) {
  if ((t === void 0 && (t = !1), !t && !ce(n) && !Array.isArray(n))) return e;
  if (Array.isArray(e))
    for (var r = 0; r < e.length; r++) n[r] = le(n[r], e[r]);
  else if (ce(e)) for (var r in e) n[r] = le(n[r], e[r]);
  return n;
}
function ue(n, e) {
  Object.defineProperty(n, "toString", { value: e });
}
function he(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  return new Error(
    "An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#"
      .concat(n, " for more information.")
      .concat(e.length > 0 ? " Args: ".concat(e.join(", ")) : "")
  );
}
var fe = (function () {
    function n(e) {
      (this.groupSizes = new Uint32Array(512)),
        (this.length = 512),
        (this.tag = e);
    }
    return (
      (n.prototype.indexOfGroup = function (e) {
        for (var t = 0, r = 0; r < e; r++) t += this.groupSizes[r];
        return t;
      }),
      (n.prototype.insertRules = function (e, t) {
        if (e >= this.groupSizes.length) {
          for (var r = this.groupSizes, s = r.length, o = s; e >= o; )
            if ((o <<= 1) < 0) throw he(16, "".concat(e));
          (this.groupSizes = new Uint32Array(o)),
            this.groupSizes.set(r),
            (this.length = o);
          for (var a = s; a < o; a++) this.groupSizes[a] = 0;
        }
        for (
          var l = this.indexOfGroup(e + 1), c = ((a = 0), t.length);
          a < c;
          a++
        )
          this.tag.insertRule(l, t[a]) && (this.groupSizes[e]++, l++);
      }),
      (n.prototype.clearGroup = function (e) {
        if (e < this.length) {
          var t = this.groupSizes[e],
            r = this.indexOfGroup(e),
            s = r + t;
          this.groupSizes[e] = 0;
          for (var o = r; o < s; o++) this.tag.deleteRule(r);
        }
      }),
      (n.prototype.getGroup = function (e) {
        var t = "";
        if (e >= this.length || this.groupSizes[e] === 0) return t;
        for (
          var r = this.groupSizes[e],
            s = this.indexOfGroup(e),
            o = s + r,
            a = s;
          a < o;
          a++
        )
          t += "".concat(this.tag.getRule(a)).concat(g$1);
        return t;
      }),
      n
    );
  })(),
  ye = new Map(),
  ve = new Map(),
  ge = 1,
  Se = function (n) {
    if (ye.has(n)) return ye.get(n);
    for (; ve.has(ge); ) ge++;
    var e = ge++;
    return ye.set(n, e), ve.set(e, n), e;
  },
  we = function (n, e) {
    (ge = e + 1), ye.set(n, e), ve.set(e, n);
  },
  be = "style[".concat(f, "][").concat(y, '="').concat(v$1, '"]'),
  Ee = new RegExp(
    "^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')
  ),
  Ne = function (n, e, t) {
    for (var r, s = t.split(","), o = 0, a = s.length; o < a; o++)
      (r = s[o]) && n.registerName(e, r);
  },
  Pe = function (n, e) {
    for (
      var t,
        r = ((t = e.textContent) !== null && t !== void 0 ? t : "").split(g$1),
        s = [],
        o = 0,
        a = r.length;
      o < a;
      o++
    ) {
      var l = r[o].trim();
      if (l) {
        var c = l.match(Ee);
        if (c) {
          var u = 0 | parseInt(c[1], 10),
            p = c[2];
          u !== 0 && (we(p, u), Ne(n, p, c[3]), n.getTag().insertRules(u, s)),
            (s.length = 0);
        } else s.push(l);
      }
    }
  },
  _e = function (n) {
    for (
      var e = document.querySelectorAll(be), t = 0, r = e.length;
      t < r;
      t++
    ) {
      var s = e[t];
      s &&
        s.getAttribute(f) !== m &&
        (Pe(n, s), s.parentNode && s.parentNode.removeChild(s));
    }
  };
function Ce() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var Ie = function (n) {
    var e = document.head,
      t = n || e,
      r = document.createElement("style"),
      s = (function (l) {
        var c = Array.from(l.querySelectorAll("style[".concat(f, "]")));
        return c[c.length - 1];
      })(t),
      o = s !== void 0 ? s.nextSibling : null;
    r.setAttribute(f, m), r.setAttribute(y, v$1);
    var a = Ce();
    return a && r.setAttribute("nonce", a), t.insertBefore(r, o), r;
  },
  Ae = (function () {
    function n(e) {
      (this.element = Ie(e)),
        this.element.appendChild(document.createTextNode("")),
        (this.sheet = (function (t) {
          if (t.sheet) return t.sheet;
          for (var r = document.styleSheets, s = 0, o = r.length; s < o; s++) {
            var a = r[s];
            if (a.ownerNode === t) return a;
          }
          throw he(17);
        })(this.element)),
        (this.length = 0);
    }
    return (
      (n.prototype.insertRule = function (e, t) {
        try {
          return this.sheet.insertRule(t, e), this.length++, !0;
        } catch {
          return !1;
        }
      }),
      (n.prototype.deleteRule = function (e) {
        this.sheet.deleteRule(e), this.length--;
      }),
      (n.prototype.getRule = function (e) {
        var t = this.sheet.cssRules[e];
        return t && t.cssText ? t.cssText : "";
      }),
      n
    );
  })(),
  Oe = (function () {
    function n(e) {
      (this.element = Ie(e)),
        (this.nodes = this.element.childNodes),
        (this.length = 0);
    }
    return (
      (n.prototype.insertRule = function (e, t) {
        if (e <= this.length && e >= 0) {
          var r = document.createTextNode(t);
          return (
            this.element.insertBefore(r, this.nodes[e] || null),
            this.length++,
            !0
          );
        }
        return !1;
      }),
      (n.prototype.deleteRule = function (e) {
        this.element.removeChild(this.nodes[e]), this.length--;
      }),
      (n.prototype.getRule = function (e) {
        return e < this.length ? this.nodes[e].textContent : "";
      }),
      n
    );
  })(),
  De = (function () {
    function n(e) {
      (this.rules = []), (this.length = 0);
    }
    return (
      (n.prototype.insertRule = function (e, t) {
        return (
          e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0)
        );
      }),
      (n.prototype.deleteRule = function (e) {
        this.rules.splice(e, 1), this.length--;
      }),
      (n.prototype.getRule = function (e) {
        return e < this.length ? this.rules[e] : "";
      }),
      n
    );
  })(),
  Re = S,
  Te = { isServer: !S, useCSSOMInjection: !w$1 },
  ke = (function () {
    function n(e, t, r) {
      e === void 0 && (e = C), t === void 0 && (t = {});
      var s = this;
      (this.options = __assign(__assign({}, Te), e)),
        (this.gs = t),
        (this.names = new Map(r)),
        (this.server = !!e.isServer),
        !this.server && S && Re && ((Re = !1), _e(this)),
        ue(this, function () {
          return (function (o) {
            for (
              var a = o.getTag(),
                l = a.length,
                c = "",
                u = function (N) {
                  var P = (function (Be) {
                    return ve.get(Be);
                  })(N);
                  if (P === void 0) return "continue";
                  var de = o.names.get(P),
                    me = a.getGroup(N);
                  if (de === void 0 || !de.size || me.length === 0)
                    return "continue";
                  var Ye = ""
                      .concat(f, ".g")
                      .concat(N, '[id="')
                      .concat(P, '"]'),
                    nt = "";
                  de !== void 0 &&
                    de.forEach(function (Be) {
                      Be.length > 0 && (nt += "".concat(Be, ","));
                    }),
                    (c += ""
                      .concat(me)
                      .concat(Ye, '{content:"')
                      .concat(nt, '"}')
                      .concat(g$1));
                },
                p = 0;
              p < l;
              p++
            )
              u(p);
            return c;
          })(s);
        });
    }
    return (
      (n.registerId = function (e) {
        return Se(e);
      }),
      (n.prototype.rehydrate = function () {
        !this.server && S && _e(this);
      }),
      (n.prototype.reconstructWithOptions = function (e, t) {
        return (
          t === void 0 && (t = !0),
          new n(
            __assign(__assign({}, this.options), e),
            this.gs,
            (t && this.names) || void 0
          )
        );
      }),
      (n.prototype.allocateGSInstance = function (e) {
        return (this.gs[e] = (this.gs[e] || 0) + 1);
      }),
      (n.prototype.getTag = function () {
        return (
          this.tag ||
          (this.tag =
            ((e = (function (t) {
              var r = t.useCSSOMInjection,
                s = t.target;
              return t.isServer ? new De(s) : r ? new Ae(s) : new Oe(s);
            })(this.options)),
            new fe(e)))
        );
        var e;
      }),
      (n.prototype.hasNameForId = function (e, t) {
        return this.names.has(e) && this.names.get(e).has(t);
      }),
      (n.prototype.registerName = function (e, t) {
        if ((Se(e), this.names.has(e))) this.names.get(e).add(t);
        else {
          var r = new Set();
          r.add(t), this.names.set(e, r);
        }
      }),
      (n.prototype.insertRules = function (e, t, r) {
        this.registerName(e, t), this.getTag().insertRules(Se(e), r);
      }),
      (n.prototype.clearNames = function (e) {
        this.names.has(e) && this.names.get(e).clear();
      }),
      (n.prototype.clearRules = function (e) {
        this.getTag().clearGroup(Se(e)), this.clearNames(e);
      }),
      (n.prototype.clearTag = function () {
        this.tag = void 0;
      }),
      n
    );
  })(),
  je = /&/g,
  xe = /^\s*\/\/.*$/gm;
function Ve(n, e) {
  return n.map(function (t) {
    return (
      t.type === "rule" &&
        ((t.value = "".concat(e, " ").concat(t.value)),
        (t.value = t.value.replaceAll(",", ",".concat(e, " "))),
        (t.props = t.props.map(function (r) {
          return "".concat(e, " ").concat(r);
        }))),
      Array.isArray(t.children) &&
        t.type !== "@keyframes" &&
        (t.children = Ve(t.children, e)),
      t
    );
  });
}
function Fe(n) {
  var e,
    t,
    r,
    s = C,
    o = s.options,
    a = o === void 0 ? C : o,
    l = s.plugins,
    c = l === void 0 ? _ : l,
    u = function (P, de, me) {
      return me.startsWith(t) &&
        me.endsWith(t) &&
        me.replaceAll(t, "").length > 0
        ? ".".concat(e)
        : P;
    },
    p = c.slice();
  p.push(function (P) {
    P.type === RULESET &&
      P.value.includes("&") &&
      (P.props[0] = P.props[0].replace(je, t).replace(r, u));
  }),
    a.prefix && p.push(prefixer),
    p.push(stringify);
  var N = function (P, de, me, Ye) {
    de === void 0 && (de = ""),
      me === void 0 && (me = ""),
      Ye === void 0 && (Ye = "&"),
      (e = Ye),
      (t = de),
      (r = new RegExp("\\".concat(t, "\\b"), "g"));
    var nt = P.replace(xe, ""),
      Be = compile(
        me || de ? "".concat(me, " ").concat(de, " { ").concat(nt, " }") : nt
      );
    a.namespace && (Be = Ve(Be, a.namespace));
    var ot = [];
    return (
      serialize(
        Be,
        middleware(
          p.concat(
            rulesheet(function (st) {
              return ot.push(st);
            })
          )
        )
      ),
      ot
    );
  };
  return (
    (N.hash = c.length
      ? c
          .reduce(function (P, de) {
            return de.name || he(15), M(P, de.name);
          }, F)
          .toString()
      : ""),
    N
  );
}
var Me = new ke(),
  ze = Fe(),
  $e = React.createContext({
    shouldForwardProp: void 0,
    styleSheet: Me,
    stylis: ze,
  });
$e.Consumer;
React.createContext(void 0);
function Ge() {
  return reactExports.useContext($e);
}
var We = (function () {
    function n(e, t) {
      var r = this;
      (this.inject = function (s, o) {
        o === void 0 && (o = ze);
        var a = r.name + o.hash;
        s.hasNameForId(r.id, a) ||
          s.insertRules(r.id, a, o(r.rules, a, "@keyframes"));
      }),
        (this.name = e),
        (this.id = "sc-keyframes-".concat(e)),
        (this.rules = t),
        ue(this, function () {
          throw he(12, String(r.name));
        });
    }
    return (
      (n.prototype.getName = function (e) {
        return e === void 0 && (e = ze), this.name + e.hash;
      }),
      n
    );
  })(),
  qe = function (n) {
    return n >= "A" && n <= "Z";
  };
function He(n) {
  for (var e = "", t = 0; t < n.length; t++) {
    var r = n[t];
    if (t === 1 && r === "-" && n[0] === "-") return n;
    qe(r) ? (e += "-" + r.toLowerCase()) : (e += r);
  }
  return e.startsWith("ms-") ? "-" + e : e;
}
var Ue = function (n) {
    return n == null || n === !1 || n === "";
  },
  Je = function (n) {
    var e,
      t,
      r = [];
    for (var s in n) {
      var o = n[s];
      n.hasOwnProperty(s) &&
        !Ue(o) &&
        ((Array.isArray(o) && o.isCss) || re(o)
          ? r.push("".concat(He(s), ":"), o, ";")
          : ce(o)
          ? r.push.apply(
              r,
              __spreadArray(
                __spreadArray(["".concat(s, " {")], Je(o), !1),
                ["}"],
                !1
              )
            )
          : r.push(
              ""
                .concat(He(s), ": ")
                .concat(
                  ((e = s),
                  (t = o) == null || typeof t == "boolean" || t === ""
                    ? ""
                    : typeof t != "number" ||
                      t === 0 ||
                      e in unitlessKeys ||
                      e.startsWith("--")
                    ? String(t).trim()
                    : "".concat(t, "px")),
                  ";"
                )
            ));
    }
    return r;
  };
function Xe(n, e, t, r) {
  if (Ue(n)) return [];
  if (se(n)) return [".".concat(n.styledComponentId)];
  if (re(n)) {
    if (!re((o = n)) || (o.prototype && o.prototype.isReactComponent) || !e)
      return [n];
    var s = n(e);
    return Xe(s, e, t, r);
  }
  var o;
  return n instanceof We
    ? t
      ? (n.inject(t, r), [n.getName(r)])
      : [n]
    : ce(n)
    ? Je(n)
    : Array.isArray(n)
    ? Array.prototype.concat.apply(
        _,
        n.map(function (a) {
          return Xe(a, e, t, r);
        })
      )
    : [n.toString()];
}
function Ze(n) {
  for (var e = 0; e < n.length; e += 1) {
    var t = n[e];
    if (re(t) && !se(t)) return !1;
  }
  return !0;
}
var Ke = z(v$1),
  Qe = (function () {
    function n(e, t, r) {
      (this.rules = e),
        (this.staticRulesId = ""),
        (this.isStatic = (r === void 0 || r.isStatic) && Ze(e)),
        (this.componentId = t),
        (this.baseHash = M(Ke, t)),
        (this.baseStyle = r),
        ke.registerId(t);
    }
    return (
      (n.prototype.generateAndInjectStyles = function (e, t, r) {
        var s = this.baseStyle
          ? this.baseStyle.generateAndInjectStyles(e, t, r)
          : "";
        if (this.isStatic && !r.hash)
          if (
            this.staticRulesId &&
            t.hasNameForId(this.componentId, this.staticRulesId)
          )
            s = ie(s, this.staticRulesId);
          else {
            var o = ae(Xe(this.rules, e, t, r)),
              a = x$1(M(this.baseHash, o) >>> 0);
            if (!t.hasNameForId(this.componentId, a)) {
              var l = r(o, ".".concat(a), void 0, this.componentId);
              t.insertRules(this.componentId, a, l);
            }
            (s = ie(s, a)), (this.staticRulesId = a);
          }
        else {
          for (
            var c = M(this.baseHash, r.hash), u = "", p = 0;
            p < this.rules.length;
            p++
          ) {
            var N = this.rules[p];
            if (typeof N == "string") u += N;
            else if (N) {
              var P = ae(Xe(N, e, t, r));
              (c = M(c, P + p)), (u += P);
            }
          }
          if (u) {
            var de = x$1(c >>> 0);
            t.hasNameForId(this.componentId, de) ||
              t.insertRules(
                this.componentId,
                de,
                r(u, ".".concat(de), void 0, this.componentId)
              ),
              (s = ie(s, de));
          }
        }
        return s;
      }),
      n
    );
  })(),
  et$1 = React.createContext(void 0);
et$1.Consumer;
var rt = {};
function it(n, e, t) {
  var r = se(n),
    s = n,
    o = !L(n),
    a = e.attrs,
    l = a === void 0 ? _ : a,
    c = e.componentId,
    u =
      c === void 0
        ? (function (vt, xt) {
            var St = typeof vt != "string" ? "sc" : R(vt);
            rt[St] = (rt[St] || 0) + 1;
            var wt = "".concat(St, "-").concat($(v$1 + St + rt[St]));
            return xt ? "".concat(xt, "-").concat(wt) : wt;
          })(e.displayName, e.parentComponentId)
        : c,
    p = e.displayName,
    N =
      p === void 0
        ? (function (vt) {
            return L(vt) ? "styled.".concat(vt) : "Styled(".concat(B(vt), ")");
          })(n)
        : p,
    P =
      e.displayName && e.componentId
        ? "".concat(R(e.displayName), "-").concat(e.componentId)
        : e.componentId || u,
    de = r && s.attrs ? s.attrs.concat(l).filter(Boolean) : l,
    me = e.shouldForwardProp;
  if (r && s.shouldForwardProp) {
    var Ye = s.shouldForwardProp;
    if (e.shouldForwardProp) {
      var nt = e.shouldForwardProp;
      me = function (vt, xt) {
        return Ye(vt, xt) && nt(vt, xt);
      };
    } else me = Ye;
  }
  var Be = new Qe(t, P, r ? s.componentStyle : void 0);
  function ot(vt, xt) {
    return (function (St, wt, bt) {
      var Tt = St.attrs,
        Ct = St.componentStyle,
        kt = St.defaultProps,
        Dt = St.foldedComponentIds,
        Vt = St.styledComponentId,
        Ht = St.target,
        qt = React.useContext(et$1),
        Ft = Ge(),
        Bt = St.shouldForwardProp || Ft.shouldForwardProp,
        Mt = I(wt, qt, kt) || C,
        Pt = (function (tn, pn, _n) {
          for (
            var bn,
              $n = __assign(__assign({}, pn), { className: void 0, theme: _n }),
              tr = 0;
            tr < tn.length;
            tr += 1
          ) {
            var ur = re((bn = tn[tr])) ? bn($n) : bn;
            for (var _r in ur)
              $n[_r] =
                _r === "className"
                  ? ie($n[_r], ur[_r])
                  : _r === "style"
                  ? __assign(__assign({}, $n[_r]), ur[_r])
                  : ur[_r];
          }
          return (
            pn.className && ($n.className = ie($n.className, pn.className)), $n
          );
        })(Tt, wt, Mt),
        It = Pt.as || Ht,
        Ot = {};
      for (var Xt in Pt)
        Pt[Xt] === void 0 ||
          Xt[0] === "$" ||
          Xt === "as" ||
          (Xt === "theme" && Pt.theme === Mt) ||
          (Xt === "forwardedAs"
            ? (Ot.as = Pt.forwardedAs)
            : (Bt && !Bt(Xt, It)) || (Ot[Xt] = Pt[Xt]));
      var sn = (function (tn, pn) {
          var _n = Ge(),
            bn = tn.generateAndInjectStyles(pn, _n.styleSheet, _n.stylis);
          return bn;
        })(Ct, Pt),
        Kt = ie(Dt, Vt);
      return (
        sn && (Kt += " " + sn),
        Pt.className && (Kt += " " + Pt.className),
        (Ot[L(It) && !A.has(It) ? "class" : "className"] = Kt),
        bt && (Ot.ref = bt),
        reactExports.createElement(It, Ot)
      );
    })(st, vt, xt);
  }
  ot.displayName = N;
  var st = React.forwardRef(ot);
  return (
    (st.attrs = de),
    (st.componentStyle = Be),
    (st.displayName = N),
    (st.shouldForwardProp = me),
    (st.foldedComponentIds = r
      ? ie(s.foldedComponentIds, s.styledComponentId)
      : ""),
    (st.styledComponentId = P),
    (st.target = r ? s.target : n),
    Object.defineProperty(st, "defaultProps", {
      get: function () {
        return this._foldedDefaultProps;
      },
      set: function (vt) {
        this._foldedDefaultProps = r
          ? (function (xt) {
              for (var St = [], wt = 1; wt < arguments.length; wt++)
                St[wt - 1] = arguments[wt];
              for (var bt = 0, Tt = St; bt < Tt.length; bt++)
                le(xt, Tt[bt], !0);
              return xt;
            })({}, s.defaultProps, vt)
          : vt;
      },
    }),
    ue(st, function () {
      return ".".concat(st.styledComponentId);
    }),
    o &&
      oe(st, n, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0,
      }),
    st
  );
}
function at(n, e) {
  for (var t = [n[0]], r = 0, s = e.length; r < s; r += 1)
    t.push(e[r], n[r + 1]);
  return t;
}
var ct = function (n) {
  return Object.assign(n, { isCss: !0 });
};
function lt(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  if (re(n) || ce(n)) return ct(Xe(at(_, __spreadArray([n], e, !0))));
  var r = n;
  return e.length === 0 && r.length === 1 && typeof r[0] == "string"
    ? Xe(r)
    : ct(Xe(at(r, e)));
}
function ut(n, e, t) {
  if ((t === void 0 && (t = C), !e)) throw he(1, e);
  var r = function (s) {
    for (var o = [], a = 1; a < arguments.length; a++) o[a - 1] = arguments[a];
    return n(e, t, lt.apply(void 0, __spreadArray([s], o, !1)));
  };
  return (
    (r.attrs = function (s) {
      return ut(
        n,
        e,
        __assign(__assign({}, t), {
          attrs: Array.prototype.concat(t.attrs, s).filter(Boolean),
        })
      );
    }),
    (r.withConfig = function (s) {
      return ut(n, e, __assign(__assign({}, t), s));
    }),
    r
  );
}
var pt = function (n) {
    return ut(it, n);
  },
  dt = pt;
A.forEach(function (n) {
  dt[n] = pt(n);
});
var ht = (function () {
  function n(e, t) {
    (this.rules = e),
      (this.componentId = t),
      (this.isStatic = Ze(e)),
      ke.registerId(this.componentId + 1);
  }
  return (
    (n.prototype.createStyles = function (e, t, r, s) {
      var o = s(ae(Xe(this.rules, t, r, s)), ""),
        a = this.componentId + e;
      r.insertRules(a, a, o);
    }),
    (n.prototype.removeStyles = function (e, t) {
      t.clearRules(this.componentId + e);
    }),
    (n.prototype.renderStyles = function (e, t, r, s) {
      e > 2 && ke.registerId(this.componentId + e),
        this.removeStyles(e, r),
        this.createStyles(e, t, r, s);
    }),
    n
  );
})();
function ft(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  var r = lt.apply(void 0, __spreadArray([n], e, !1)),
    s = "sc-global-".concat($(JSON.stringify(r))),
    o = new ht(r, s),
    a = function (c) {
      var u = Ge(),
        p = React.useContext(et$1),
        N = React.useRef(u.styleSheet.allocateGSInstance(s)).current;
      return (
        u.styleSheet.server && l(N, c, u.styleSheet, p, u.stylis),
        React.useLayoutEffect(
          function () {
            if (!u.styleSheet.server)
              return (
                l(N, c, u.styleSheet, p, u.stylis),
                function () {
                  return o.removeStyles(N, u.styleSheet);
                }
              );
          },
          [N, c, u.styleSheet, p, u.stylis]
        ),
        null
      );
    };
  function l(c, u, p, N, P) {
    if (o.isStatic) o.renderStyles(c, b, p, P);
    else {
      var de = __assign(__assign({}, u), { theme: I(u, N, a.defaultProps) });
      o.renderStyles(c, de, p, P);
    }
  }
  return React.memo(a);
}
function mt(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  var r = ae(lt.apply(void 0, __spreadArray([n], e, !1))),
    s = $(r);
  return new We(s, r);
}
const LegendBlock = dt.div`
  width: 100vw;
  height: 100vh;
`,
  Content$6 = dt.div`
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  padding: 5.8125rem 0 2.75rem 0;
  justify-content: space-between;
  @media (min-width: 768px) {
    padding: 5.8125rem 0 3.1875rem 0;
  }
`;
dt.div`
  width: 100%;
  height: 2.375rem;
  display: flex;
  align-items: center;
  gap: 0.8125rem;
  @media (min-width: 48rem) {
    height: 4.1vh;
  }
`;
dt.div`
  cursor: pointer;
  width: 1.5rem;
  height: 1.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    width: 1.125rem;
    height: 1rem;
  }
`;
dt.div`
  height: 100%;
  width: 100%;
  display: flex;
  background: #4a3c841a;
  align-items: center;
  justify-content: center;
  border: 0.0313rem solid #7f64f240;
  font-size: 0.875rem;
  font-weight: 400;
  line-height: 114%;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  @media (min-width: 48rem) {
    width: auto;
    padding: 0 1rem;
  }
`;
dt.h4`
  font-weight: 400;
  font-size: 1rem;
  line-height: 130%;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  position: relative;
  @media (min-width: 48rem) {
    font-size: 1.375rem;
  }
`;
dt.p`
  font-weight: 400;
  font-size: 0.75rem;
  line-height: 183%;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: #000;
`;
dt.div`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  border: 0.5px solid var(--tertiary-color);
  width: 3.5rem;
  height: 3.5rem;
  position: relative;
`;
const SwiperContent = dt.div`
  position: relative;
  display: flex;
  height: 100%;
  width: 100%;
  cursor: pointer;
  justify-content: flex-start;
  letter-spacing: 0.2rem;

  @media (min-width: 48rem) {
    justify-content: center;
  }
`,
  GradientContainer = dt.div`
  position: absolute;
  z-index: 20;
  width: 100%;
  height: 100%;
`,
  colors = {
    primaryColor3DScene: "#9700fb",
    sceneLight3D_Direction_Second: "#fde1ad",
    primaryColor: "#7f64f2",
    secondaryColor: "#d8f34f",
    tertiaryColor: "#271f4e",
    fourthColor: "#D8F34F",
    textInactiveColor: "#808084",
    blackColor: "#02030b",
    whiteColor: "#fff",
    transperent: "#FFFFFF00",
    gradient: "linear-gradient(180deg, #433581 0%, #02030B 61.47%)",
  },
  PersonalityIcon = ({
    color: n = "#fff",
    width: e,
    height: t,
    size: r = 2,
    ...s
  }) =>
    jsxRuntimeExports.jsx("svg", {
      width: r + "rem",
      height: r + "rem",
      viewBox: "0 0 34 34",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...s,
      children: jsxRuntimeExports.jsx("path", {
        d: "M30.3733 15.5022L21.8977 12.42C21.8247 12.3936 21.7584 12.3514 21.7035 12.2966C21.6486 12.2417 21.6065 12.1754 21.58 12.1024L18.498 3.62689C18.3862 3.31946 18.1825 3.05388 17.9145 2.86622C17.6466 2.67855 17.3273 2.57788 17.0002 2.57788C16.6731 2.57788 16.3539 2.67855 16.0859 2.86622C15.818 3.05388 15.6143 3.31946 15.5024 3.62689L12.4203 12.1025C12.3938 12.1755 12.3517 12.2418 12.2968 12.2967C12.2419 12.3516 12.1756 12.3937 12.1026 12.4201L3.62714 15.5022C3.3197 15.614 3.05413 15.8177 2.86646 16.0857C2.67879 16.3536 2.57812 16.6728 2.57812 17C2.57812 17.3271 2.67879 17.6463 2.86646 17.9143C3.05413 18.1822 3.3197 18.3859 3.62714 18.4977L12.1028 21.5799C12.1757 21.6063 12.242 21.6485 12.2969 21.7034C12.3518 21.7583 12.394 21.8246 12.4204 21.8976L15.5024 30.373C15.6143 30.6805 15.818 30.9461 16.0859 31.1337C16.3539 31.3214 16.6731 31.4221 17.0002 31.4221C17.3273 31.4221 17.6466 31.3214 17.9145 31.1337C18.1825 30.9461 18.3862 30.6805 18.498 30.373L21.58 21.8976L21.5802 21.8974C21.6066 21.8244 21.6487 21.7581 21.7036 21.7033C21.7585 21.6484 21.8248 21.6062 21.8978 21.5798L30.3733 18.4977C30.6807 18.3859 30.9463 18.1822 31.134 17.9143C31.3216 17.6463 31.4223 17.3271 31.4223 17C31.4223 16.6728 31.3216 16.3536 31.134 16.0857C30.9463 15.8177 30.6807 15.614 30.3733 15.5022ZM30.0101 17.4993L21.5348 20.5812C21.3158 20.6606 21.1168 20.7871 20.9521 20.9518C20.7874 21.1165 20.6609 21.3154 20.5816 21.5344L17.4996 30.0099C17.4623 30.1124 17.3943 30.2009 17.305 30.2634C17.2157 30.326 17.1093 30.3595 17.0002 30.3595C16.8912 30.3595 16.7847 30.326 16.6954 30.2634C16.6061 30.2009 16.5382 30.1124 16.5009 30.0099L13.4189 21.5345C13.3396 21.3155 13.2132 21.1166 13.0484 20.9519C12.8837 20.7872 12.6848 20.6607 12.4658 20.5814L3.9903 17.4993C3.88782 17.462 3.7993 17.3941 3.73674 17.3048C3.67419 17.2154 3.64064 17.109 3.64064 17C3.64064 16.8909 3.67419 16.7845 3.73674 16.6952C3.7993 16.6058 3.88782 16.5379 3.9903 16.5006L12.4657 13.4187C12.6847 13.3394 12.8836 13.2129 13.0483 13.0482C13.213 12.8835 13.3395 12.6846 13.4188 12.4655L16.5009 3.99005C16.5382 3.88757 16.6061 3.79905 16.6954 3.7365C16.7847 3.67394 16.8912 3.64039 17.0002 3.64039C17.1093 3.64039 17.2157 3.67394 17.305 3.7365C17.3943 3.79905 17.4623 3.88757 17.4996 3.99005L20.5815 12.4654C20.6608 12.6844 20.7873 12.8834 20.952 13.0481C21.1167 13.2128 21.3156 13.3393 21.5346 13.4186L30.0101 16.5006C30.1126 16.5379 30.2011 16.6058 30.2637 16.6952C30.3262 16.7845 30.3598 16.8909 30.3598 17C30.3598 17.109 30.3262 17.2154 30.2637 17.3048C30.2011 17.3941 30.1126 17.462 30.0101 17.4993Z",
        fill: n,
      }),
    }),
  CrossPlatformIcon = ({
    color: n = "#fff",
    width: e,
    height: t,
    size: r = 2,
    ...s
  }) =>
    jsxRuntimeExports.jsxs("svg", {
      width: r + "rem",
      height: r + "rem",
      viewBox: "0 0 34 34",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...s,
      children: [
        jsxRuntimeExports.jsx("path", {
          d: "M14.1668 24.0122H8.79766C4.0235 24.0122 2.8335 22.8222 2.8335 18.048V9.54803C2.8335 4.77386 4.0235 3.58386 8.79766 3.58386H23.7152C28.4893 3.58386 29.6793 4.77386 29.6793 9.54803",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M14.1665 30.4161V24.0128",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M2.8335 18.3461H14.1668",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M9.54883 30.4161H14.1671",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M31.1673 18.133V26.2222C31.1673 29.5797 30.3315 30.4155 26.974 30.4155H21.9448C18.5873 30.4155 17.7515 29.5797 17.7515 26.2222V18.133C17.7515 14.7755 18.5873 13.9398 21.9448 13.9398H26.974C30.3315 13.9398 31.1673 14.7755 31.1673 18.133Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M24.4297 25.8542H24.4424",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      ],
    }),
  IntelligenceIcon = ({
    color: n = "#fff",
    width: e,
    height: t,
    size: r = 2,
    ...s
  }) =>
    jsxRuntimeExports.jsxs("svg", {
      width: r + "rem",
      height: r + "rem",
      viewBox: "0 0 34 34",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...s,
      children: [
        jsxRuntimeExports.jsx("path", {
          d: "M17.2275 15.3992C17.0859 15.385 16.9159 15.385 16.76 15.3992C13.3884 15.2858 10.7109 12.5233 10.7109 9.12334C10.7109 5.65251 13.5159 2.83334 17.0009 2.83334C20.4717 2.83334 23.2909 5.65251 23.2909 9.12334C23.2767 12.5233 20.5992 15.2858 17.2275 15.3992Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M10.1445 20.6267C6.71616 22.9217 6.71616 26.6617 10.1445 28.9425C14.0403 31.5492 20.4295 31.5492 24.3253 28.9425C27.7537 26.6475 27.7537 22.9075 24.3253 20.6267C20.4437 18.0342 14.0545 18.0342 10.1445 20.6267Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      ],
    }),
  CommunityIcon = ({
    color: n = "#fff",
    width: e,
    height: t,
    size: r = 2,
    ...s
  }) =>
    jsxRuntimeExports.jsxs("svg", {
      width: r + "rem",
      height: r + "rem",
      viewBox: "0 0 34 34",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...s,
      children: [
        jsxRuntimeExports.jsx("path", {
          d: "M25.4973 10.1433C25.4123 10.1292 25.3132 10.1292 25.2282 10.1433C23.2732 10.0725 21.7148 8.47168 21.7148 6.48834C21.7148 4.46251 23.344 2.83334 25.3698 2.83334C27.3957 2.83334 29.0248 4.47668 29.0248 6.48834C29.0107 8.47168 27.4523 10.0725 25.4973 10.1433Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M24.0371 20.4569C25.978 20.7828 28.1171 20.4428 29.6188 19.4369C31.6163 18.1053 31.6163 15.9236 29.6188 14.5919C28.103 13.586 25.9355 13.246 23.9946 13.586",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M8.45279 10.1433C8.53779 10.1292 8.63696 10.1292 8.72196 10.1433C10.677 10.0725 12.2353 8.47168 12.2353 6.48834C12.2353 4.46251 10.6061 2.83334 8.58029 2.83334C6.55446 2.83334 4.92529 4.47668 4.92529 6.48834C4.93946 8.47168 6.49779 10.0725 8.45279 10.1433Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M9.91329 20.4569C7.97245 20.7828 5.83329 20.4428 4.33162 19.4369C2.33412 18.1053 2.33412 15.9236 4.33162 14.5919C5.84745 13.586 8.01495 13.246 9.95579 13.586",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M17.0003 20.7261C16.9153 20.712 16.8161 20.712 16.7311 20.7261C14.7761 20.6553 13.2178 19.0545 13.2178 17.0711C13.2178 15.0453 14.847 13.4161 16.8728 13.4161C18.8986 13.4161 20.5278 15.0595 20.5278 17.0711C20.5136 19.0545 18.9553 20.6695 17.0003 20.7261Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M12.8785 25.1889C10.881 26.5205 10.881 28.7021 12.8785 30.0337C15.1452 31.5496 18.8568 31.5496 21.1235 30.0337C23.121 28.7021 23.121 26.5205 21.1235 25.1889C18.871 23.6872 15.1452 23.6872 12.8785 25.1889Z",
          stroke: n,
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      ],
    });
dt.div`
  font-family: Titillium Web;
  color: var(--white-color);
  font-size: 14px;
  font-weight: 400;
  line-height: 19.6px;
  text-transform: uppercase;

  text-underline-position: from-font;
  text-decoration-skip-ink: none;
`;
const BorderIcon = ({
    color: n = "#7F64F2",
    width: e = 4,
    height: t = 42,
    ...r
  }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 4 42",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      preserveAspectRatio: "none",
      ...r,
      children: jsxRuntimeExports.jsx("path", {
        d: "M0 0H4V42H0V32.875L2 31.75V9.25L0 8.125V0Z",
        fill: n,
        style: { width: e, height: t },
      }),
    }),
  ProfileIcon = ({ color: n = "#fff", width: e = 24, height: t = 24, ...r }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: jsxRuntimeExports.jsx("path", {
        d: "M10.7857 19.4282H5V18.7312C5.01024 17.7512 5.26868 16.7898 5.75121 15.9368C6.23373 15.0838 6.92459 14.367 7.75924 13.8533C8.59389 13.3397 9.54511 13.046 10.524 12.9996C10.6113 12.9955 10.6986 12.9934 10.7857 12.9932C10.8729 12.9934 10.9601 12.9955 11.0474 12.9996C12.0263 13.046 12.9775 13.3397 13.8122 13.8533C14.2922 14.1487 14.7246 14.5112 15.0972 14.9282M21.7143 14.2856L16.5714 20.7142L14 18.7856M13.9999 7.21429C13.9999 8.98949 12.5608 10.4286 10.7856 10.4286C9.01037 10.4286 7.57129 8.98949 7.57129 7.21429C7.57129 5.43908 9.01037 4 10.7856 4C12.5608 4 13.9999 5.43908 13.9999 7.21429Z",
        stroke: "white",
        strokeLinecap: "round",
        strokeLinejoin: "round",
      }),
    }),
  CloseIcon = ({ color: n = "#ffffff", width: e = 16, height: t = 16, ...r }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      preserveAspectRatio: "none",
      ...r,
      children: jsxRuntimeExports.jsx("path", {
        d: "M19.0152 18.4849C19.05 18.5197 19.0776 18.561 19.0965 18.6065C19.1153 18.652 19.125 18.7008 19.125 18.75C19.125 18.7993 19.1153 18.848 19.0964 18.8935C19.0776 18.939 19.05 18.9804 19.0151 19.0152C18.9803 19.05 18.939 19.0776 18.8935 19.0965C18.848 19.1153 18.7992 19.125 18.75 19.125C18.7007 19.125 18.652 19.1153 18.6065 19.0964C18.561 19.0776 18.5196 19.05 18.4848 19.0151L12 12.5304L5.51517 19.0151C5.44486 19.0855 5.34948 19.125 5.25002 19.125C5.15057 19.125 5.05519 19.0855 4.98486 19.0152C4.91452 18.9449 4.87501 18.8495 4.875 18.75C4.87499 18.6506 4.91449 18.5552 4.98481 18.4849L11.4696 12L4.98481 5.51513C4.91449 5.4448 4.87499 5.34941 4.875 5.24996C4.875 5.20071 4.88471 5.15195 4.90356 5.10646C4.92241 5.06096 4.95003 5.01963 4.98486 4.98481C5.01968 4.94999 5.06102 4.92237 5.10652 4.90353C5.15202 4.88469 5.20078 4.875 5.25002 4.875C5.34948 4.87501 5.44486 4.91452 5.51517 4.98486L12 11.4696L18.4848 4.98486C18.5196 4.95003 18.561 4.92241 18.6065 4.90356C18.652 4.88471 18.7007 4.875 18.75 4.875C18.7992 4.875 18.848 4.88469 18.8935 4.90353C18.939 4.92237 18.9803 4.94999 19.0151 4.98481C19.05 5.01963 19.0776 5.06096 19.0964 5.10646C19.1153 5.15195 19.125 5.20071 19.125 5.24996C19.125 5.2992 19.1153 5.34797 19.0965 5.39346C19.0776 5.43896 19.05 5.4803 19.0152 5.51513L12.5303 12L19.0152 18.4849Z",
        fill: n,
      }),
    }),
  ToolIcon = ({ color: n = "#fff", width: e = 24, height: t = 24, ...r }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: jsxRuntimeExports.jsx("path", {
        xmlns: "http://www.w3.org/2000/svg",
        d: "M11.7518 6.24359C12.983 5.01246 14.782 4.69543 16.3057 5.29249L13.5532 8.04496C13.2216 8.37659 13.2216 8.91425 13.5532 9.24588L14.7541 10.4468C15.0857 10.7784 15.6234 10.7784 15.955 10.4468L18.7075 7.69432C19.3046 9.21796 18.9875 11.017 17.7564 12.2482C16.5253 13.4793 14.7262 13.7963 13.2026 13.1993L7.89927 18.5026C7.23602 19.1658 6.16068 19.1658 5.49744 18.5026C4.83419 17.8393 4.83419 16.764 5.49744 16.1007L10.8007 10.7974C10.2037 9.2738 10.5207 7.47472 11.7518 6.24359Z",
        stroke: n,
        strokeLinecap: "round",
        strokeLinejoin: "round",
      }),
    }),
  PenIcon = ({ color: n = "#fff", width: e = 24, height: t = 24, ...r }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: jsxRuntimeExports.jsx("path", {
        xmlns: "http://www.w3.org/2000/svg",
        d: "M10.3544 11.4347L10.0029 11.0792C9.9247 11.1565 9.87418 11.2574 9.85913 11.3663L10.3544 11.4347ZM12.481 13.6337L12.5541 14.1283C12.6634 14.1122 12.7643 14.0603 12.841 13.9807L12.481 13.6337ZM10 14.0002L9.5047 13.9318C9.48316 14.0877 9.53629 14.2446 9.64811 14.3554C9.75992 14.4662 9.91736 14.5178 10.0731 14.4948L10 14.0002ZM8 16.5002C8.27614 16.5002 8.5 16.2763 8.5 16.0002C8.5 15.724 8.27614 15.5002 8 15.5002V16.5002ZM20 20.5002C20.2761 20.5002 20.5 20.2763 20.5 20.0002C20.5 19.724 20.2761 19.5002 20 19.5002V20.5002ZM10.706 11.7903L17.2945 5.27579L16.5914 4.5647L10.0029 11.0792L10.706 11.7903ZM18.6 6.56472L12.121 13.2867L12.841 13.9807L19.32 7.25869L18.6 6.56472ZM12.4079 13.1391L9.92693 13.5056L10.0731 14.4948L12.5541 14.1283L12.4079 13.1391ZM10.4953 14.0686L10.8497 11.5032L9.85913 11.3663L9.5047 13.9318L10.4953 14.0686ZM18.5383 5.23316C18.9373 5.577 18.9655 6.18547 18.6 6.56472L19.32 7.25869C20.084 6.46603 20.0251 5.19426 19.1911 4.47561L18.5383 5.23316ZM17.2945 5.27579C17.6346 4.93951 18.176 4.92095 18.5383 5.23316L19.1911 4.47561C18.4338 3.82306 17.3022 3.86184 16.5914 4.5647L17.2945 5.27579ZM8 15.5002H6V16.5002H8V15.5002ZM6 20.5002H20V19.5002H6V20.5002ZM3.5 18.0002C3.5 19.3809 4.61929 20.5002 6 20.5002V19.5002C5.17157 19.5002 4.5 18.8286 4.5 18.0002H3.5ZM6 15.5002C4.61929 15.5002 3.5 16.6195 3.5 18.0002H4.5C4.5 17.1718 5.17157 16.5002 6 16.5002V15.5002Z",
        fill: n,
      }),
    }),
  QuarterIcon = ({ color: n = "#fff", width: e = 24, height: t = 24, ...r }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...r,
      children: jsxRuntimeExports.jsxs("g", {
        xmlns: "http://www.w3.org/2000/svg",
        clipPath: "url(#clip0_4780_53013)",
        children: [
          jsxRuntimeExports.jsx("path", {
            d: "M20.377 5.51441C18.1253 4.21778 15.1503 3.50366 12 3.50366C8.84972 3.50366 5.87472 4.21778 3.62301 5.51441C1.28667 6.85975 0 8.67081 0 10.6139V13.4399C0 15.3808 1.28746 17.1827 3.62519 18.5137C5.87061 19.7922 8.84486 20.4963 12 20.4963C15.1552 20.4963 18.1294 19.7922 20.3749 18.5137C22.7126 17.1827 24 15.3808 24 13.4399V10.6139C24 8.67081 22.7134 6.85975 20.377 5.51441ZM4.14225 6.41613C6.23852 5.20903 9.02909 4.54422 12 4.54422C14.9709 4.54422 17.7615 5.20898 19.8577 6.41613C21.8579 7.56792 22.9594 9.05869 22.9594 10.6139C22.9594 12.1603 21.8594 13.6311 19.8621 14.7553C17.7764 15.9293 14.9842 16.5759 11.9999 16.5759C9.01561 16.5759 6.22356 15.9294 4.13784 14.7553C2.14052 13.6311 1.04055 12.1603 1.04055 10.6139C1.04055 9.05874 2.14206 7.56792 4.14225 6.41613ZM11.4797 17.6098V19.4488C10.2457 19.4169 9.04951 19.2717 7.92843 19.0223V17.2125C9.05714 17.4451 10.2517 17.58 11.4797 17.6098ZM12.5203 17.6098C13.7483 17.58 14.9429 17.445 16.0716 17.2125V19.0223C14.9505 19.2717 13.7544 19.4169 12.5203 19.4488V17.6098ZM1.04219 13.5133C1.38146 13.9571 1.801 14.3788 2.29596 14.7727V16.2141C1.49662 15.3837 1.06345 14.4624 1.04219 13.5133ZM3.33646 17.0991V15.4919C3.4318 15.5494 3.52832 15.6063 3.62742 15.6621C4.59236 16.2052 5.69392 16.6429 6.88783 16.9655V18.7543C5.88523 18.4594 4.95879 18.0756 4.14002 17.6095C3.85332 17.4463 3.5857 17.2757 3.33646 17.0991ZM19.86 17.6095C19.0413 18.0756 18.1148 18.4594 17.1122 18.7542V16.9655C18.3061 16.6429 19.4077 16.2052 20.3726 15.662C20.4717 15.6063 20.5682 15.5493 20.6635 15.4918V17.0991C20.4143 17.2757 20.1467 17.4463 19.86 17.6095ZM21.7041 16.2142V14.7727C22.199 14.3788 22.6186 13.9571 22.9579 13.5133C22.9366 14.4624 22.5034 15.3837 21.7041 16.2142Z",
            fill: n,
          }),
          jsxRuntimeExports.jsx("path", {
            d: "M13.1599 15.2569C17.5682 15.2569 21.0214 13.2075 21.0214 10.5913C21.0214 10.304 20.7884 10.071 20.5011 10.071C20.2137 10.071 19.9808 10.304 19.9808 10.5913C19.9808 11.5095 19.3113 12.392 18.0957 13.0763C16.7896 13.8115 15.0366 14.2164 13.1599 14.2164C12.8726 14.2164 12.6396 14.4493 12.6396 14.7366C12.6396 15.024 12.8726 15.2569 13.1599 15.2569Z",
            fill: n,
          }),
          jsxRuntimeExports.jsx("path", {
            d: "M3.85719 11.1112C4.14453 11.1112 4.37747 10.8783 4.37747 10.5909C4.37747 8.39156 7.87586 6.53347 12.0168 6.53347C12.3042 6.53347 12.5371 6.30054 12.5371 6.0132C12.5371 5.72586 12.3042 5.49292 12.0168 5.49292C9.75347 5.49292 7.61379 5.99556 5.99191 6.90832C4.27981 7.87183 3.33691 9.1797 3.33691 10.5909C3.33691 10.8783 3.56985 11.1112 3.85719 11.1112Z",
            fill: n,
          }),
        ],
      }),
    });
var observerMap = new Map(),
  RootIds = new WeakMap(),
  rootId = 0,
  unsupportedValue = void 0;
function getRootId(n) {
  return n
    ? (RootIds.has(n) || ((rootId += 1), RootIds.set(n, rootId.toString())),
      RootIds.get(n))
    : "0";
}
function optionsToId(n) {
  return Object.keys(n)
    .sort()
    .filter((e) => n[e] !== void 0)
    .map((e) => `${e}_${e === "root" ? getRootId(n.root) : n[e]}`)
    .toString();
}
function createObserver(n) {
  const e = optionsToId(n);
  let t = observerMap.get(e);
  if (!t) {
    const r = new Map();
    let s;
    const o = new IntersectionObserver((a) => {
      a.forEach((l) => {
        var c;
        const u = l.isIntersecting && s.some((p) => l.intersectionRatio >= p);
        n.trackVisibility && typeof l.isVisible > "u" && (l.isVisible = u),
          (c = r.get(l.target)) == null ||
            c.forEach((p) => {
              p(u, l);
            });
      });
    }, n);
    (s =
      o.thresholds ||
      (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0])),
      (t = { id: e, observer: o, elements: r }),
      observerMap.set(e, t);
  }
  return t;
}
function observe(n, e, t = {}, r = unsupportedValue) {
  if (typeof window.IntersectionObserver > "u" && r !== void 0) {
    const c = n.getBoundingClientRect();
    return (
      e(r, {
        isIntersecting: r,
        target: n,
        intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0,
        time: 0,
        boundingClientRect: c,
        intersectionRect: c,
        rootBounds: c,
      }),
      () => {}
    );
  }
  const { id: s, observer: o, elements: a } = createObserver(t),
    l = a.get(n) || [];
  return (
    a.has(n) || a.set(n, l),
    l.push(e),
    o.observe(n),
    function () {
      l.splice(l.indexOf(e), 1),
        l.length === 0 && (a.delete(n), o.unobserve(n)),
        a.size === 0 && (o.disconnect(), observerMap.delete(s));
    }
  );
}
function useInView({
  threshold: n,
  delay: e,
  trackVisibility: t,
  rootMargin: r,
  root: s,
  triggerOnce: o,
  skip: a,
  initialInView: l,
  fallbackInView: c,
  onChange: u,
} = {}) {
  var p;
  const [N, P] = reactExports.useState(null),
    de = reactExports.useRef(u),
    [me, Ye] = reactExports.useState({ inView: !!l, entry: void 0 });
  (de.current = u),
    reactExports.useEffect(() => {
      if (a || !N) return;
      let st;
      return (
        (st = observe(
          N,
          (vt, xt) => {
            Ye({ inView: vt, entry: xt }),
              de.current && de.current(vt, xt),
              xt.isIntersecting && o && st && (st(), (st = void 0));
          },
          {
            root: s,
            rootMargin: r,
            threshold: n,
            trackVisibility: t,
            delay: e,
          },
          c
        )),
        () => {
          st && st();
        }
      );
    }, [Array.isArray(n) ? n.toString() : n, N, s, r, o, a, t, c, e]);
  const nt = (p = me.entry) == null ? void 0 : p.target,
    Be = reactExports.useRef(void 0);
  !N &&
    nt &&
    !o &&
    !a &&
    Be.current !== nt &&
    ((Be.current = nt), Ye({ inView: !!l, entry: void 0 }));
  const ot = [P, me.inView, me.entry];
  return (ot.ref = ot[0]), (ot.inView = ot[1]), (ot.entry = ot[2]), ot;
}
const expandAnimation$1 = mt`
  0% {
    transform: scaleY(0.3);
    opacity: 0;
  }
  100% {
    transform: scaleY(1);
    opacity: 1;
  }
`,
  DecorContainer = dt.div`
height: 20rem; 
position: relative;
overflow: hidden;
opacity: 0;
  &.expandDecor {
    will-change: transform, opacity;
    transform-origin: center;
    animation: ${expandAnimation$1} 1s ease-out;
  }
  &.visible {
    opacity: 1;
  }
  svg {
    width: 100%;
    height: 100%;
  }
`,
  moveUpTitle$3 = mt`
  0% {
    transform: translateY(12px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
`,
  moveUpDescr$3 = mt`
  0% {
    transform: translateY(10px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
`,
  TextBlock = dt.div`
  display: flex;
  position: relative;
  flex-direction: column;
  color: var(--white-color);
  width: 50%;

  @media (min-width: 48rem) {
    align-items: center;
    flex-direction: row;
    width: 38.59vw;
    gap: 1.25rem;
  }
`,
  TextTitle$1 = dt.h2`
  display: flex;
  font-weight: 400;
  font-size: 1.5rem;
  letter-spacing: 0.16rem;
  line-height: 130%;
  text-transform: uppercase;
  @media (min-width: 48rem) {
    font-size: 2rem;
    opacity: 0;
    &.animateTitle {
      animation: ${moveUpTitle$3} 1.4s ease-out;
    }
    &.visible {
      opacity: 1;
    }
  }
`,
  TextDescr$2 = dt.p`
  display: flex;
  margin-top: 2rem;
  font-weight: 400;
  font-size: 0.75rem;
  line-height: 183%;
  letter-spacing: 0.12rem;
  text-transform: uppercase;
  @media (min-width: 48rem) {
    margin-top: 2.25rem;
    opacity: 0;
    &.animateDescr {
      animation: ${moveUpDescr$3} 1s ease-out;
    }
    &.visible {
      opacity: 1;
    }
  }
`,
  DivDecoration = ({
    color: n = colors.whiteColor,
    width: e = 35,
    height: t = 397,
    isReverse: r = !1,
    opacity: s = 1,
    ...o
  }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 35 397",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      preserveAspectRatio: "none",
      style: {
        transform: r ? "rotate(180deg)" : "none",
        display: "block",
        opacity: s,
      },
      ...o,
      children: jsxRuntimeExports.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.05538 77.9236V197.873V198.244V318.194V318.313L9.00179 318.419L1 334.281V352.928L34.5787 395.498L33.7935 396.117L0.107427 353.411L0 353.275V353.101V334.162V334.043L0.0535848 333.937L8.05538 318.075V198.244V197.873V78.0426L0.0535847 62.1803L0 62.0741V61.9551V43.0158V42.8423L0.107427 42.7061L33.7935 -0.000244141L34.5787 0.61908L1 43.1892V61.8362L9.00179 77.6984L9.05538 77.8046V77.9236Z",
        fill: n,
        fillOpacity: "0.25",
      }),
    }),
  useIsSmallScreen = (n = 767.98) => {
    const [e, t] = reactExports.useState(window.innerWidth <= n);
    return (
      reactExports.useEffect(() => {
        const r = () => {
          t(window.innerWidth <= n);
        };
        return (
          r(),
          window.addEventListener("resize", r),
          () => {
            window.removeEventListener("resize", r);
          }
        );
      }, [n]),
      e
    );
  },
  TextBlockAnimate = ({ children: n }) => {
    const e = useIsSmallScreen(),
      { ref: t, inView: r } = useInView({ triggerOnce: !1, threshold: 0 }),
      s = reactExports.useMemo(() => (r ? "expandDecor visible" : ""), [r]);
    return jsxRuntimeExports.jsxs(TextBlock, {
      children: [
        !e &&
          jsxRuntimeExports.jsx(DecorContainer, {
            ref: t,
            className: s,
            children: jsxRuntimeExports.jsx(DivDecoration, {}),
          }),
        jsxRuntimeExports.jsx("div", {
          style: {
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
          },
          children: n,
        }),
      ],
    });
  };
function isObject$2(n) {
  return (
    n !== null &&
    typeof n == "object" &&
    "constructor" in n &&
    n.constructor === Object
  );
}
function extend$3(n, e) {
  n === void 0 && (n = {}), e === void 0 && (e = {});
  const t = ["__proto__", "constructor", "prototype"];
  Object.keys(e)
    .filter((r) => t.indexOf(r) < 0)
    .forEach((r) => {
      typeof n[r] > "u"
        ? (n[r] = e[r])
        : isObject$2(e[r]) &&
          isObject$2(n[r]) &&
          Object.keys(e[r]).length > 0 &&
          extend$3(n[r], e[r]);
    });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: { blur() {}, nodeName: "" },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return { initEvent() {} };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      },
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: "",
  },
};
function getDocument() {
  const n = typeof document < "u" ? document : {};
  return extend$3(n, ssrDocument), n;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: { userAgent: "" },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: "",
  },
  history: { replaceState() {}, pushState() {}, go() {}, back() {} },
  CustomEvent: function () {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      },
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(n) {
    return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0);
  },
  cancelAnimationFrame(n) {
    typeof setTimeout > "u" || clearTimeout(n);
  },
};
function getWindow() {
  const n = typeof window < "u" ? window : {};
  return extend$3(n, ssrWindow), n;
}
function classesToTokens(n) {
  return (
    n === void 0 && (n = ""),
    n
      .trim()
      .split(" ")
      .filter((e) => !!e.trim())
  );
}
function deleteProps(n) {
  const e = n;
  Object.keys(e).forEach((t) => {
    try {
      e[t] = null;
    } catch {}
    try {
      delete e[t];
    } catch {}
  });
}
function nextTick(n, e) {
  return e === void 0 && (e = 0), setTimeout(n, e);
}
function now$1() {
  return Date.now();
}
function getComputedStyle$1(n) {
  const e = getWindow();
  let t;
  return (
    e.getComputedStyle && (t = e.getComputedStyle(n, null)),
    !t && n.currentStyle && (t = n.currentStyle),
    t || (t = n.style),
    t
  );
}
function getTranslate(n, e) {
  e === void 0 && (e = "x");
  const t = getWindow();
  let r, s, o;
  const a = getComputedStyle$1(n);
  return (
    t.WebKitCSSMatrix
      ? ((s = a.transform || a.webkitTransform),
        s.split(",").length > 6 &&
          (s = s
            .split(", ")
            .map((l) => l.replace(",", "."))
            .join(", ")),
        (o = new t.WebKitCSSMatrix(s === "none" ? "" : s)))
      : ((o =
          a.MozTransform ||
          a.OTransform ||
          a.MsTransform ||
          a.msTransform ||
          a.transform ||
          a
            .getPropertyValue("transform")
            .replace("translate(", "matrix(1, 0, 0, 1,")),
        (r = o.toString().split(","))),
    e === "x" &&
      (t.WebKitCSSMatrix
        ? (s = o.m41)
        : r.length === 16
        ? (s = parseFloat(r[12]))
        : (s = parseFloat(r[4]))),
    e === "y" &&
      (t.WebKitCSSMatrix
        ? (s = o.m42)
        : r.length === 16
        ? (s = parseFloat(r[13]))
        : (s = parseFloat(r[5]))),
    s || 0
  );
}
function isObject$1(n) {
  return (
    typeof n == "object" &&
    n !== null &&
    n.constructor &&
    Object.prototype.toString.call(n).slice(8, -1) === "Object"
  );
}
function isNode(n) {
  return typeof window < "u" && typeof window.HTMLElement < "u"
    ? n instanceof HTMLElement
    : n && (n.nodeType === 1 || n.nodeType === 11);
}
function extend$2() {
  const n = Object(arguments.length <= 0 ? void 0 : arguments[0]),
    e = ["__proto__", "constructor", "prototype"];
  for (let t = 1; t < arguments.length; t += 1) {
    const r = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (r != null && !isNode(r)) {
      const s = Object.keys(Object(r)).filter((o) => e.indexOf(o) < 0);
      for (let o = 0, a = s.length; o < a; o += 1) {
        const l = s[o],
          c = Object.getOwnPropertyDescriptor(r, l);
        c !== void 0 &&
          c.enumerable &&
          (isObject$1(n[l]) && isObject$1(r[l])
            ? r[l].__swiper__
              ? (n[l] = r[l])
              : extend$2(n[l], r[l])
            : !isObject$1(n[l]) && isObject$1(r[l])
            ? ((n[l] = {}),
              r[l].__swiper__ ? (n[l] = r[l]) : extend$2(n[l], r[l]))
            : (n[l] = r[l]));
      }
    }
  }
  return n;
}
function setCSSProperty(n, e, t) {
  n.style.setProperty(e, t);
}
function animateCSSModeScroll(n) {
  let { swiper: e, targetPosition: t, side: r } = n;
  const s = getWindow(),
    o = -e.translate;
  let a = null,
    l;
  const c = e.params.speed;
  (e.wrapperEl.style.scrollSnapType = "none"),
    s.cancelAnimationFrame(e.cssModeFrameID);
  const u = t > o ? "next" : "prev",
    p = (P, de) => (u === "next" && P >= de) || (u === "prev" && P <= de),
    N = () => {
      (l = new Date().getTime()), a === null && (a = l);
      const P = Math.max(Math.min((l - a) / c, 1), 0),
        de = 0.5 - Math.cos(P * Math.PI) / 2;
      let me = o + de * (t - o);
      if ((p(me, t) && (me = t), e.wrapperEl.scrollTo({ [r]: me }), p(me, t))) {
        (e.wrapperEl.style.overflow = "hidden"),
          (e.wrapperEl.style.scrollSnapType = ""),
          setTimeout(() => {
            (e.wrapperEl.style.overflow = ""),
              e.wrapperEl.scrollTo({ [r]: me });
          }),
          s.cancelAnimationFrame(e.cssModeFrameID);
        return;
      }
      e.cssModeFrameID = s.requestAnimationFrame(N);
    };
  N();
}
function elementChildren(n, e) {
  e === void 0 && (e = "");
  const t = getWindow(),
    r = [...n.children];
  return (
    t.HTMLSlotElement &&
      n instanceof HTMLSlotElement &&
      r.push(...n.assignedElements()),
    e ? r.filter((s) => s.matches(e)) : r
  );
}
function elementIsChildOfSlot(n, e) {
  const t = [e];
  for (; t.length > 0; ) {
    const r = t.shift();
    if (n === r) return !0;
    t.push(
      ...r.children,
      ...(r.shadowRoot ? r.shadowRoot.children : []),
      ...(r.assignedElements ? r.assignedElements() : [])
    );
  }
}
function elementIsChildOf(n, e) {
  const t = getWindow();
  let r = e.contains(n);
  return (
    !r &&
      t.HTMLSlotElement &&
      e instanceof HTMLSlotElement &&
      ((r = [...e.assignedElements()].includes(n)),
      r || (r = elementIsChildOfSlot(n, e))),
    r
  );
}
function showWarning(n) {
  try {
    console.warn(n);
    return;
  } catch {}
}
function createElement(n, e) {
  e === void 0 && (e = []);
  const t = document.createElement(n);
  return t.classList.add(...(Array.isArray(e) ? e : classesToTokens(e))), t;
}
function elementPrevAll(n, e) {
  const t = [];
  for (; n.previousElementSibling; ) {
    const r = n.previousElementSibling;
    e ? r.matches(e) && t.push(r) : t.push(r), (n = r);
  }
  return t;
}
function elementNextAll(n, e) {
  const t = [];
  for (; n.nextElementSibling; ) {
    const r = n.nextElementSibling;
    e ? r.matches(e) && t.push(r) : t.push(r), (n = r);
  }
  return t;
}
function elementStyle(n, e) {
  return getWindow().getComputedStyle(n, null).getPropertyValue(e);
}
function elementIndex(n) {
  let e = n,
    t;
  if (e) {
    for (t = 0; (e = e.previousSibling) !== null; )
      e.nodeType === 1 && (t += 1);
    return t;
  }
}
function elementParents(n, e) {
  const t = [];
  let r = n.parentElement;
  for (; r; ) t.push(r), (r = r.parentElement);
  return t;
}
function elementOuterSize(n, e, t) {
  const r = getWindow();
  return (
    n[e === "width" ? "offsetWidth" : "offsetHeight"] +
    parseFloat(
      r
        .getComputedStyle(n, null)
        .getPropertyValue(e === "width" ? "margin-right" : "margin-top")
    ) +
    parseFloat(
      r
        .getComputedStyle(n, null)
        .getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")
    )
  );
}
function makeElementsArray(n) {
  return (Array.isArray(n) ? n : [n]).filter((e) => !!e);
}
function setInnerHTML(n, e) {
  e === void 0 && (e = ""),
    typeof trustedTypes < "u"
      ? (n.innerHTML = trustedTypes
          .createPolicy("html", { createHTML: (t) => t })
          .createHTML(e))
      : (n.innerHTML = e);
}
let support;
function calcSupport() {
  const n = getWindow(),
    e = getDocument();
  return {
    smoothScroll:
      e.documentElement &&
      e.documentElement.style &&
      "scrollBehavior" in e.documentElement.style,
    touch: !!(
      "ontouchstart" in n ||
      (n.DocumentTouch && e instanceof n.DocumentTouch)
    ),
  };
}
function getSupport() {
  return support || (support = calcSupport()), support;
}
let deviceCached;
function calcDevice(n) {
  let { userAgent: e } = n === void 0 ? {} : n;
  const t = getSupport(),
    r = getWindow(),
    s = r.navigator.platform,
    o = e || r.navigator.userAgent,
    a = { ios: !1, android: !1 },
    l = r.screen.width,
    c = r.screen.height,
    u = o.match(/(Android);?[\s\/]+([\d.]+)?/);
  let p = o.match(/(iPad).*OS\s([\d_]+)/);
  const N = o.match(/(iPod)(.*OS\s([\d_]+))?/),
    P = !p && o.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
    de = s === "Win32";
  let me = s === "MacIntel";
  const Ye = [
    "1024x1366",
    "1366x1024",
    "834x1194",
    "1194x834",
    "834x1112",
    "1112x834",
    "768x1024",
    "1024x768",
    "820x1180",
    "1180x820",
    "810x1080",
    "1080x810",
  ];
  return (
    !p &&
      me &&
      t.touch &&
      Ye.indexOf(`${l}x${c}`) >= 0 &&
      ((p = o.match(/(Version)\/([\d.]+)/)),
      p || (p = [0, 1, "13_0_0"]),
      (me = !1)),
    u && !de && ((a.os = "android"), (a.android = !0)),
    (p || P || N) && ((a.os = "ios"), (a.ios = !0)),
    a
  );
}
function getDevice(n) {
  return (
    n === void 0 && (n = {}),
    deviceCached || (deviceCached = calcDevice(n)),
    deviceCached
  );
}
let browser;
function calcBrowser() {
  const n = getWindow(),
    e = getDevice();
  let t = !1;
  function r() {
    const l = n.navigator.userAgent.toLowerCase();
    return (
      l.indexOf("safari") >= 0 &&
      l.indexOf("chrome") < 0 &&
      l.indexOf("android") < 0
    );
  }
  if (r()) {
    const l = String(n.navigator.userAgent);
    if (l.includes("Version/")) {
      const [c, u] = l
        .split("Version/")[1]
        .split(" ")[0]
        .split(".")
        .map((p) => Number(p));
      t = c < 16 || (c === 16 && u < 2);
    }
  }
  const s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
      n.navigator.userAgent
    ),
    o = r(),
    a = o || (s && e.ios);
  return {
    isSafari: t || o,
    needPerspectiveFix: t,
    need3dFix: a,
    isWebView: s,
  };
}
function getBrowser() {
  return browser || (browser = calcBrowser()), browser;
}
function Resize(n) {
  let { swiper: e, on: t, emit: r } = n;
  const s = getWindow();
  let o = null,
    a = null;
  const l = () => {
      !e || e.destroyed || !e.initialized || (r("beforeResize"), r("resize"));
    },
    c = () => {
      !e ||
        e.destroyed ||
        !e.initialized ||
        ((o = new ResizeObserver((N) => {
          a = s.requestAnimationFrame(() => {
            const { width: P, height: de } = e;
            let me = P,
              Ye = de;
            N.forEach((nt) => {
              let { contentBoxSize: Be, contentRect: ot, target: st } = nt;
              (st && st !== e.el) ||
                ((me = ot ? ot.width : (Be[0] || Be).inlineSize),
                (Ye = ot ? ot.height : (Be[0] || Be).blockSize));
            }),
              (me !== P || Ye !== de) && l();
          });
        })),
        o.observe(e.el));
    },
    u = () => {
      a && s.cancelAnimationFrame(a),
        o && o.unobserve && e.el && (o.unobserve(e.el), (o = null));
    },
    p = () => {
      !e || e.destroyed || !e.initialized || r("orientationchange");
    };
  t("init", () => {
    if (e.params.resizeObserver && typeof s.ResizeObserver < "u") {
      c();
      return;
    }
    s.addEventListener("resize", l), s.addEventListener("orientationchange", p);
  }),
    t("destroy", () => {
      u(),
        s.removeEventListener("resize", l),
        s.removeEventListener("orientationchange", p);
    });
}
function Observer$1(n) {
  let { swiper: e, extendParams: t, on: r, emit: s } = n;
  const o = [],
    a = getWindow(),
    l = function (p, N) {
      N === void 0 && (N = {});
      const P = a.MutationObserver || a.WebkitMutationObserver,
        de = new P((me) => {
          if (e.__preventObserver__) return;
          if (me.length === 1) {
            s("observerUpdate", me[0]);
            return;
          }
          const Ye = function () {
            s("observerUpdate", me[0]);
          };
          a.requestAnimationFrame
            ? a.requestAnimationFrame(Ye)
            : a.setTimeout(Ye, 0);
        });
      de.observe(p, {
        attributes: typeof N.attributes > "u" ? !0 : N.attributes,
        childList: e.isElement || (typeof N.childList > "u" ? !0 : N).childList,
        characterData: typeof N.characterData > "u" ? !0 : N.characterData,
      }),
        o.push(de);
    },
    c = () => {
      if (e.params.observer) {
        if (e.params.observeParents) {
          const p = elementParents(e.hostEl);
          for (let N = 0; N < p.length; N += 1) l(p[N]);
        }
        l(e.hostEl, { childList: e.params.observeSlideChildren }),
          l(e.wrapperEl, { attributes: !1 });
      }
    },
    u = () => {
      o.forEach((p) => {
        p.disconnect();
      }),
        o.splice(0, o.length);
    };
  t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
    r("init", c),
    r("destroy", u);
}
var eventsEmitter = {
  on(n, e, t) {
    const r = this;
    if (!r.eventsListeners || r.destroyed || typeof e != "function") return r;
    const s = t ? "unshift" : "push";
    return (
      n.split(" ").forEach((o) => {
        r.eventsListeners[o] || (r.eventsListeners[o] = []),
          r.eventsListeners[o][s](e);
      }),
      r
    );
  },
  once(n, e, t) {
    const r = this;
    if (!r.eventsListeners || r.destroyed || typeof e != "function") return r;
    function s() {
      r.off(n, s), s.__emitterProxy && delete s.__emitterProxy;
      for (var o = arguments.length, a = new Array(o), l = 0; l < o; l++)
        a[l] = arguments[l];
      e.apply(r, a);
    }
    return (s.__emitterProxy = e), r.on(n, s, t);
  },
  onAny(n, e) {
    const t = this;
    if (!t.eventsListeners || t.destroyed || typeof n != "function") return t;
    const r = e ? "unshift" : "push";
    return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[r](n), t;
  },
  offAny(n) {
    const e = this;
    if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
    const t = e.eventsAnyListeners.indexOf(n);
    return t >= 0 && e.eventsAnyListeners.splice(t, 1), e;
  },
  off(n, e) {
    const t = this;
    return (
      !t.eventsListeners ||
        t.destroyed ||
        !t.eventsListeners ||
        n.split(" ").forEach((r) => {
          typeof e > "u"
            ? (t.eventsListeners[r] = [])
            : t.eventsListeners[r] &&
              t.eventsListeners[r].forEach((s, o) => {
                (s === e || (s.__emitterProxy && s.__emitterProxy === e)) &&
                  t.eventsListeners[r].splice(o, 1);
              });
        }),
      t
    );
  },
  emit() {
    const n = this;
    if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n;
    let e, t, r;
    for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
      o[a] = arguments[a];
    return (
      typeof o[0] == "string" || Array.isArray(o[0])
        ? ((e = o[0]), (t = o.slice(1, o.length)), (r = n))
        : ((e = o[0].events), (t = o[0].data), (r = o[0].context || n)),
      t.unshift(r),
      (Array.isArray(e) ? e : e.split(" ")).forEach((c) => {
        n.eventsAnyListeners &&
          n.eventsAnyListeners.length &&
          n.eventsAnyListeners.forEach((u) => {
            u.apply(r, [c, ...t]);
          }),
          n.eventsListeners &&
            n.eventsListeners[c] &&
            n.eventsListeners[c].forEach((u) => {
              u.apply(r, t);
            });
      }),
      n
    );
  },
};
function updateSize() {
  const n = this;
  let e, t;
  const r = n.el;
  typeof n.params.width < "u" && n.params.width !== null
    ? (e = n.params.width)
    : (e = r.clientWidth),
    typeof n.params.height < "u" && n.params.height !== null
      ? (t = n.params.height)
      : (t = r.clientHeight),
    !((e === 0 && n.isHorizontal()) || (t === 0 && n.isVertical())) &&
      ((e =
        e -
        parseInt(elementStyle(r, "padding-left") || 0, 10) -
        parseInt(elementStyle(r, "padding-right") || 0, 10)),
      (t =
        t -
        parseInt(elementStyle(r, "padding-top") || 0, 10) -
        parseInt(elementStyle(r, "padding-bottom") || 0, 10)),
      Number.isNaN(e) && (e = 0),
      Number.isNaN(t) && (t = 0),
      Object.assign(n, {
        width: e,
        height: t,
        size: n.isHorizontal() ? e : t,
      }));
}
function updateSlides() {
  const n = this;
  function e(Ct, kt) {
    return parseFloat(Ct.getPropertyValue(n.getDirectionLabel(kt)) || 0);
  }
  const t = n.params,
    { wrapperEl: r, slidesEl: s, size: o, rtlTranslate: a, wrongRTL: l } = n,
    c = n.virtual && t.virtual.enabled,
    u = c ? n.virtual.slides.length : n.slides.length,
    p = elementChildren(s, `.${n.params.slideClass}, swiper-slide`),
    N = c ? n.virtual.slides.length : p.length;
  let P = [];
  const de = [],
    me = [];
  let Ye = t.slidesOffsetBefore;
  typeof Ye == "function" && (Ye = t.slidesOffsetBefore.call(n));
  let nt = t.slidesOffsetAfter;
  typeof nt == "function" && (nt = t.slidesOffsetAfter.call(n));
  const Be = n.snapGrid.length,
    ot = n.slidesGrid.length;
  let st = t.spaceBetween,
    vt = -Ye,
    xt = 0,
    St = 0;
  if (typeof o > "u") return;
  typeof st == "string" && st.indexOf("%") >= 0
    ? (st = (parseFloat(st.replace("%", "")) / 100) * o)
    : typeof st == "string" && (st = parseFloat(st)),
    (n.virtualSize = -st),
    p.forEach((Ct) => {
      a ? (Ct.style.marginLeft = "") : (Ct.style.marginRight = ""),
        (Ct.style.marginBottom = ""),
        (Ct.style.marginTop = "");
    }),
    t.centeredSlides &&
      t.cssMode &&
      (setCSSProperty(r, "--swiper-centered-offset-before", ""),
      setCSSProperty(r, "--swiper-centered-offset-after", ""));
  const wt = t.grid && t.grid.rows > 1 && n.grid;
  wt ? n.grid.initSlides(p) : n.grid && n.grid.unsetSlides();
  let bt;
  const Tt =
    t.slidesPerView === "auto" &&
    t.breakpoints &&
    Object.keys(t.breakpoints).filter(
      (Ct) => typeof t.breakpoints[Ct].slidesPerView < "u"
    ).length > 0;
  for (let Ct = 0; Ct < N; Ct += 1) {
    bt = 0;
    let kt;
    if (
      (p[Ct] && (kt = p[Ct]),
      wt && n.grid.updateSlide(Ct, kt, p),
      !(p[Ct] && elementStyle(kt, "display") === "none"))
    ) {
      if (t.slidesPerView === "auto") {
        Tt && (p[Ct].style[n.getDirectionLabel("width")] = "");
        const Dt = getComputedStyle(kt),
          Vt = kt.style.transform,
          Ht = kt.style.webkitTransform;
        if (
          (Vt && (kt.style.transform = "none"),
          Ht && (kt.style.webkitTransform = "none"),
          t.roundLengths)
        )
          bt = n.isHorizontal()
            ? elementOuterSize(kt, "width")
            : elementOuterSize(kt, "height");
        else {
          const qt = e(Dt, "width"),
            Ft = e(Dt, "padding-left"),
            Bt = e(Dt, "padding-right"),
            Mt = e(Dt, "margin-left"),
            Pt = e(Dt, "margin-right"),
            It = Dt.getPropertyValue("box-sizing");
          if (It && It === "border-box") bt = qt + Mt + Pt;
          else {
            const { clientWidth: Ot, offsetWidth: Xt } = kt;
            bt = qt + Ft + Bt + Mt + Pt + (Xt - Ot);
          }
        }
        Vt && (kt.style.transform = Vt),
          Ht && (kt.style.webkitTransform = Ht),
          t.roundLengths && (bt = Math.floor(bt));
      } else
        (bt = (o - (t.slidesPerView - 1) * st) / t.slidesPerView),
          t.roundLengths && (bt = Math.floor(bt)),
          p[Ct] && (p[Ct].style[n.getDirectionLabel("width")] = `${bt}px`);
      p[Ct] && (p[Ct].swiperSlideSize = bt),
        me.push(bt),
        t.centeredSlides
          ? ((vt = vt + bt / 2 + xt / 2 + st),
            xt === 0 && Ct !== 0 && (vt = vt - o / 2 - st),
            Ct === 0 && (vt = vt - o / 2 - st),
            Math.abs(vt) < 1 / 1e3 && (vt = 0),
            t.roundLengths && (vt = Math.floor(vt)),
            St % t.slidesPerGroup === 0 && P.push(vt),
            de.push(vt))
          : (t.roundLengths && (vt = Math.floor(vt)),
            (St - Math.min(n.params.slidesPerGroupSkip, St)) %
              n.params.slidesPerGroup ===
              0 && P.push(vt),
            de.push(vt),
            (vt = vt + bt + st)),
        (n.virtualSize += bt + st),
        (xt = bt),
        (St += 1);
    }
  }
  if (
    ((n.virtualSize = Math.max(n.virtualSize, o) + nt),
    a &&
      l &&
      (t.effect === "slide" || t.effect === "coverflow") &&
      (r.style.width = `${n.virtualSize + st}px`),
    t.setWrapperSize &&
      (r.style[n.getDirectionLabel("width")] = `${n.virtualSize + st}px`),
    wt && n.grid.updateWrapperSize(bt, P),
    !t.centeredSlides)
  ) {
    const Ct = [];
    for (let kt = 0; kt < P.length; kt += 1) {
      let Dt = P[kt];
      t.roundLengths && (Dt = Math.floor(Dt)),
        P[kt] <= n.virtualSize - o && Ct.push(Dt);
    }
    (P = Ct),
      Math.floor(n.virtualSize - o) - Math.floor(P[P.length - 1]) > 1 &&
        P.push(n.virtualSize - o);
  }
  if (c && t.loop) {
    const Ct = me[0] + st;
    if (t.slidesPerGroup > 1) {
      const kt = Math.ceil(
          (n.virtual.slidesBefore + n.virtual.slidesAfter) / t.slidesPerGroup
        ),
        Dt = Ct * t.slidesPerGroup;
      for (let Vt = 0; Vt < kt; Vt += 1) P.push(P[P.length - 1] + Dt);
    }
    for (
      let kt = 0;
      kt < n.virtual.slidesBefore + n.virtual.slidesAfter;
      kt += 1
    )
      t.slidesPerGroup === 1 && P.push(P[P.length - 1] + Ct),
        de.push(de[de.length - 1] + Ct),
        (n.virtualSize += Ct);
  }
  if ((P.length === 0 && (P = [0]), st !== 0)) {
    const Ct =
      n.isHorizontal() && a ? "marginLeft" : n.getDirectionLabel("marginRight");
    p.filter((kt, Dt) =>
      !t.cssMode || t.loop ? !0 : Dt !== p.length - 1
    ).forEach((kt) => {
      kt.style[Ct] = `${st}px`;
    });
  }
  if (t.centeredSlides && t.centeredSlidesBounds) {
    let Ct = 0;
    me.forEach((Dt) => {
      Ct += Dt + (st || 0);
    }),
      (Ct -= st);
    const kt = Ct > o ? Ct - o : 0;
    P = P.map((Dt) => (Dt <= 0 ? -Ye : Dt > kt ? kt + nt : Dt));
  }
  if (t.centerInsufficientSlides) {
    let Ct = 0;
    me.forEach((Dt) => {
      Ct += Dt + (st || 0);
    }),
      (Ct -= st);
    const kt = (t.slidesOffsetBefore || 0) + (t.slidesOffsetAfter || 0);
    if (Ct + kt < o) {
      const Dt = (o - Ct - kt) / 2;
      P.forEach((Vt, Ht) => {
        P[Ht] = Vt - Dt;
      }),
        de.forEach((Vt, Ht) => {
          de[Ht] = Vt + Dt;
        });
    }
  }
  if (
    (Object.assign(n, {
      slides: p,
      snapGrid: P,
      slidesGrid: de,
      slidesSizesGrid: me,
    }),
    t.centeredSlides && t.cssMode && !t.centeredSlidesBounds)
  ) {
    setCSSProperty(r, "--swiper-centered-offset-before", `${-P[0]}px`),
      setCSSProperty(
        r,
        "--swiper-centered-offset-after",
        `${n.size / 2 - me[me.length - 1] / 2}px`
      );
    const Ct = -n.snapGrid[0],
      kt = -n.slidesGrid[0];
    (n.snapGrid = n.snapGrid.map((Dt) => Dt + Ct)),
      (n.slidesGrid = n.slidesGrid.map((Dt) => Dt + kt));
  }
  if (
    (N !== u && n.emit("slidesLengthChange"),
    P.length !== Be &&
      (n.params.watchOverflow && n.checkOverflow(),
      n.emit("snapGridLengthChange")),
    de.length !== ot && n.emit("slidesGridLengthChange"),
    t.watchSlidesProgress && n.updateSlidesOffset(),
    n.emit("slidesUpdated"),
    !c && !t.cssMode && (t.effect === "slide" || t.effect === "fade"))
  ) {
    const Ct = `${t.containerModifierClass}backface-hidden`,
      kt = n.el.classList.contains(Ct);
    N <= t.maxBackfaceHiddenSlides
      ? kt || n.el.classList.add(Ct)
      : kt && n.el.classList.remove(Ct);
  }
}
function updateAutoHeight(n) {
  const e = this,
    t = [],
    r = e.virtual && e.params.virtual.enabled;
  let s = 0,
    o;
  typeof n == "number"
    ? e.setTransition(n)
    : n === !0 && e.setTransition(e.params.speed);
  const a = (l) => (r ? e.slides[e.getSlideIndexByData(l)] : e.slides[l]);
  if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
    if (e.params.centeredSlides)
      (e.visibleSlides || []).forEach((l) => {
        t.push(l);
      });
    else
      for (o = 0; o < Math.ceil(e.params.slidesPerView); o += 1) {
        const l = e.activeIndex + o;
        if (l > e.slides.length && !r) break;
        t.push(a(l));
      }
  else t.push(a(e.activeIndex));
  for (o = 0; o < t.length; o += 1)
    if (typeof t[o] < "u") {
      const l = t[o].offsetHeight;
      s = l > s ? l : s;
    }
  (s || s === 0) && (e.wrapperEl.style.height = `${s}px`);
}
function updateSlidesOffset() {
  const n = this,
    e = n.slides,
    t = n.isElement
      ? n.isHorizontal()
        ? n.wrapperEl.offsetLeft
        : n.wrapperEl.offsetTop
      : 0;
  for (let r = 0; r < e.length; r += 1)
    e[r].swiperSlideOffset =
      (n.isHorizontal() ? e[r].offsetLeft : e[r].offsetTop) -
      t -
      n.cssOverflowAdjustment();
}
const toggleSlideClasses$1 = (n, e, t) => {
  e && !n.classList.contains(t)
    ? n.classList.add(t)
    : !e && n.classList.contains(t) && n.classList.remove(t);
};
function updateSlidesProgress(n) {
  n === void 0 && (n = (this && this.translate) || 0);
  const e = this,
    t = e.params,
    { slides: r, rtlTranslate: s, snapGrid: o } = e;
  if (r.length === 0) return;
  typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
  let a = -n;
  s && (a = n), (e.visibleSlidesIndexes = []), (e.visibleSlides = []);
  let l = t.spaceBetween;
  typeof l == "string" && l.indexOf("%") >= 0
    ? (l = (parseFloat(l.replace("%", "")) / 100) * e.size)
    : typeof l == "string" && (l = parseFloat(l));
  for (let c = 0; c < r.length; c += 1) {
    const u = r[c];
    let p = u.swiperSlideOffset;
    t.cssMode && t.centeredSlides && (p -= r[0].swiperSlideOffset);
    const N =
        (a + (t.centeredSlides ? e.minTranslate() : 0) - p) /
        (u.swiperSlideSize + l),
      P =
        (a - o[0] + (t.centeredSlides ? e.minTranslate() : 0) - p) /
        (u.swiperSlideSize + l),
      de = -(a - p),
      me = de + e.slidesSizesGrid[c],
      Ye = de >= 0 && de <= e.size - e.slidesSizesGrid[c],
      nt =
        (de >= 0 && de < e.size - 1) ||
        (me > 1 && me <= e.size) ||
        (de <= 0 && me >= e.size);
    nt && (e.visibleSlides.push(u), e.visibleSlidesIndexes.push(c)),
      toggleSlideClasses$1(u, nt, t.slideVisibleClass),
      toggleSlideClasses$1(u, Ye, t.slideFullyVisibleClass),
      (u.progress = s ? -N : N),
      (u.originalProgress = s ? -P : P);
  }
}
function updateProgress(n) {
  const e = this;
  if (typeof n > "u") {
    const p = e.rtlTranslate ? -1 : 1;
    n = (e && e.translate && e.translate * p) || 0;
  }
  const t = e.params,
    r = e.maxTranslate() - e.minTranslate();
  let { progress: s, isBeginning: o, isEnd: a, progressLoop: l } = e;
  const c = o,
    u = a;
  if (r === 0) (s = 0), (o = !0), (a = !0);
  else {
    s = (n - e.minTranslate()) / r;
    const p = Math.abs(n - e.minTranslate()) < 1,
      N = Math.abs(n - e.maxTranslate()) < 1;
    (o = p || s <= 0), (a = N || s >= 1), p && (s = 0), N && (s = 1);
  }
  if (t.loop) {
    const p = e.getSlideIndexByData(0),
      N = e.getSlideIndexByData(e.slides.length - 1),
      P = e.slidesGrid[p],
      de = e.slidesGrid[N],
      me = e.slidesGrid[e.slidesGrid.length - 1],
      Ye = Math.abs(n);
    Ye >= P ? (l = (Ye - P) / me) : (l = (Ye + me - de) / me),
      l > 1 && (l -= 1);
  }
  Object.assign(e, { progress: s, progressLoop: l, isBeginning: o, isEnd: a }),
    (t.watchSlidesProgress || (t.centeredSlides && t.autoHeight)) &&
      e.updateSlidesProgress(n),
    o && !c && e.emit("reachBeginning toEdge"),
    a && !u && e.emit("reachEnd toEdge"),
    ((c && !o) || (u && !a)) && e.emit("fromEdge"),
    e.emit("progress", s);
}
const toggleSlideClasses = (n, e, t) => {
  e && !n.classList.contains(t)
    ? n.classList.add(t)
    : !e && n.classList.contains(t) && n.classList.remove(t);
};
function updateSlidesClasses() {
  const n = this,
    { slides: e, params: t, slidesEl: r, activeIndex: s } = n,
    o = n.virtual && t.virtual.enabled,
    a = n.grid && t.grid && t.grid.rows > 1,
    l = (N) => elementChildren(r, `.${t.slideClass}${N}, swiper-slide${N}`)[0];
  let c, u, p;
  if (o)
    if (t.loop) {
      let N = s - n.virtual.slidesBefore;
      N < 0 && (N = n.virtual.slides.length + N),
        N >= n.virtual.slides.length && (N -= n.virtual.slides.length),
        (c = l(`[data-swiper-slide-index="${N}"]`));
    } else c = l(`[data-swiper-slide-index="${s}"]`);
  else
    a
      ? ((c = e.find((N) => N.column === s)),
        (p = e.find((N) => N.column === s + 1)),
        (u = e.find((N) => N.column === s - 1)))
      : (c = e[s]);
  c &&
    (a ||
      ((p = elementNextAll(c, `.${t.slideClass}, swiper-slide`)[0]),
      t.loop && !p && (p = e[0]),
      (u = elementPrevAll(c, `.${t.slideClass}, swiper-slide`)[0]),
      t.loop && !u === 0 && (u = e[e.length - 1]))),
    e.forEach((N) => {
      toggleSlideClasses(N, N === c, t.slideActiveClass),
        toggleSlideClasses(N, N === p, t.slideNextClass),
        toggleSlideClasses(N, N === u, t.slidePrevClass);
    }),
    n.emitSlidesClasses();
}
const processLazyPreloader = (n, e) => {
    if (!n || n.destroyed || !n.params) return;
    const t = () => (n.isElement ? "swiper-slide" : `.${n.params.slideClass}`),
      r = e.closest(t());
    if (r) {
      let s = r.querySelector(`.${n.params.lazyPreloaderClass}`);
      !s &&
        n.isElement &&
        (r.shadowRoot
          ? (s = r.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`))
          : requestAnimationFrame(() => {
              r.shadowRoot &&
                ((s = r.shadowRoot.querySelector(
                  `.${n.params.lazyPreloaderClass}`
                )),
                s && s.remove());
            })),
        s && s.remove();
    }
  },
  unlazy = (n, e) => {
    if (!n.slides[e]) return;
    const t = n.slides[e].querySelector('[loading="lazy"]');
    t && t.removeAttribute("loading");
  },
  preload$1 = (n) => {
    if (!n || n.destroyed || !n.params) return;
    let e = n.params.lazyPreloadPrevNext;
    const t = n.slides.length;
    if (!t || !e || e < 0) return;
    e = Math.min(e, t);
    const r =
        n.params.slidesPerView === "auto"
          ? n.slidesPerViewDynamic()
          : Math.ceil(n.params.slidesPerView),
      s = n.activeIndex;
    if (n.params.grid && n.params.grid.rows > 1) {
      const a = s,
        l = [a - e];
      l.push(...Array.from({ length: e }).map((c, u) => a + r + u)),
        n.slides.forEach((c, u) => {
          l.includes(c.column) && unlazy(n, u);
        });
      return;
    }
    const o = s + r - 1;
    if (n.params.rewind || n.params.loop)
      for (let a = s - e; a <= o + e; a += 1) {
        const l = ((a % t) + t) % t;
        (l < s || l > o) && unlazy(n, l);
      }
    else
      for (let a = Math.max(s - e, 0); a <= Math.min(o + e, t - 1); a += 1)
        a !== s && (a > o || a < s) && unlazy(n, a);
  };
function getActiveIndexByTranslate(n) {
  const { slidesGrid: e, params: t } = n,
    r = n.rtlTranslate ? n.translate : -n.translate;
  let s;
  for (let o = 0; o < e.length; o += 1)
    typeof e[o + 1] < "u"
      ? r >= e[o] && r < e[o + 1] - (e[o + 1] - e[o]) / 2
        ? (s = o)
        : r >= e[o] && r < e[o + 1] && (s = o + 1)
      : r >= e[o] && (s = o);
  return t.normalizeSlideIndex && (s < 0 || typeof s > "u") && (s = 0), s;
}
function updateActiveIndex(n) {
  const e = this,
    t = e.rtlTranslate ? e.translate : -e.translate,
    { snapGrid: r, params: s, activeIndex: o, realIndex: a, snapIndex: l } = e;
  let c = n,
    u;
  const p = (de) => {
    let me = de - e.virtual.slidesBefore;
    return (
      me < 0 && (me = e.virtual.slides.length + me),
      me >= e.virtual.slides.length && (me -= e.virtual.slides.length),
      me
    );
  };
  if ((typeof c > "u" && (c = getActiveIndexByTranslate(e)), r.indexOf(t) >= 0))
    u = r.indexOf(t);
  else {
    const de = Math.min(s.slidesPerGroupSkip, c);
    u = de + Math.floor((c - de) / s.slidesPerGroup);
  }
  if ((u >= r.length && (u = r.length - 1), c === o && !e.params.loop)) {
    u !== l && ((e.snapIndex = u), e.emit("snapIndexChange"));
    return;
  }
  if (c === o && e.params.loop && e.virtual && e.params.virtual.enabled) {
    e.realIndex = p(c);
    return;
  }
  const N = e.grid && s.grid && s.grid.rows > 1;
  let P;
  if (e.virtual && s.virtual.enabled && s.loop) P = p(c);
  else if (N) {
    const de = e.slides.find((Ye) => Ye.column === c);
    let me = parseInt(de.getAttribute("data-swiper-slide-index"), 10);
    Number.isNaN(me) && (me = Math.max(e.slides.indexOf(de), 0)),
      (P = Math.floor(me / s.grid.rows));
  } else if (e.slides[c]) {
    const de = e.slides[c].getAttribute("data-swiper-slide-index");
    de ? (P = parseInt(de, 10)) : (P = c);
  } else P = c;
  Object.assign(e, {
    previousSnapIndex: l,
    snapIndex: u,
    previousRealIndex: a,
    realIndex: P,
    previousIndex: o,
    activeIndex: c,
  }),
    e.initialized && preload$1(e),
    e.emit("activeIndexChange"),
    e.emit("snapIndexChange"),
    (e.initialized || e.params.runCallbacksOnInit) &&
      (a !== P && e.emit("realIndexChange"), e.emit("slideChange"));
}
function updateClickedSlide(n, e) {
  const t = this,
    r = t.params;
  let s = n.closest(`.${r.slideClass}, swiper-slide`);
  !s &&
    t.isElement &&
    e &&
    e.length > 1 &&
    e.includes(n) &&
    [...e.slice(e.indexOf(n) + 1, e.length)].forEach((l) => {
      !s && l.matches && l.matches(`.${r.slideClass}, swiper-slide`) && (s = l);
    });
  let o = !1,
    a;
  if (s) {
    for (let l = 0; l < t.slides.length; l += 1)
      if (t.slides[l] === s) {
        (o = !0), (a = l);
        break;
      }
  }
  if (s && o)
    (t.clickedSlide = s),
      t.virtual && t.params.virtual.enabled
        ? (t.clickedIndex = parseInt(
            s.getAttribute("data-swiper-slide-index"),
            10
          ))
        : (t.clickedIndex = a);
  else {
    (t.clickedSlide = void 0), (t.clickedIndex = void 0);
    return;
  }
  r.slideToClickedSlide &&
    t.clickedIndex !== void 0 &&
    t.clickedIndex !== t.activeIndex &&
    t.slideToClickedSlide();
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};
function getSwiperTranslate(n) {
  n === void 0 && (n = this.isHorizontal() ? "x" : "y");
  const e = this,
    { params: t, rtlTranslate: r, translate: s, wrapperEl: o } = e;
  if (t.virtualTranslate) return r ? -s : s;
  if (t.cssMode) return s;
  let a = getTranslate(o, n);
  return (a += e.cssOverflowAdjustment()), r && (a = -a), a || 0;
}
function setTranslate(n, e) {
  const t = this,
    { rtlTranslate: r, params: s, wrapperEl: o, progress: a } = t;
  let l = 0,
    c = 0;
  const u = 0;
  t.isHorizontal() ? (l = r ? -n : n) : (c = n),
    s.roundLengths && ((l = Math.floor(l)), (c = Math.floor(c))),
    (t.previousTranslate = t.translate),
    (t.translate = t.isHorizontal() ? l : c),
    s.cssMode
      ? (o[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal()
          ? -l
          : -c)
      : s.virtualTranslate ||
        (t.isHorizontal()
          ? (l -= t.cssOverflowAdjustment())
          : (c -= t.cssOverflowAdjustment()),
        (o.style.transform = `translate3d(${l}px, ${c}px, ${u}px)`));
  let p;
  const N = t.maxTranslate() - t.minTranslate();
  N === 0 ? (p = 0) : (p = (n - t.minTranslate()) / N),
    p !== a && t.updateProgress(n),
    t.emit("setTranslate", t.translate, e);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(n, e, t, r, s) {
  n === void 0 && (n = 0),
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0),
    r === void 0 && (r = !0);
  const o = this,
    { params: a, wrapperEl: l } = o;
  if (o.animating && a.preventInteractionOnTransition) return !1;
  const c = o.minTranslate(),
    u = o.maxTranslate();
  let p;
  if (
    (r && n > c ? (p = c) : r && n < u ? (p = u) : (p = n),
    o.updateProgress(p),
    a.cssMode)
  ) {
    const N = o.isHorizontal();
    if (e === 0) l[N ? "scrollLeft" : "scrollTop"] = -p;
    else {
      if (!o.support.smoothScroll)
        return (
          animateCSSModeScroll({
            swiper: o,
            targetPosition: -p,
            side: N ? "left" : "top",
          }),
          !0
        );
      l.scrollTo({ [N ? "left" : "top"]: -p, behavior: "smooth" });
    }
    return !0;
  }
  return (
    e === 0
      ? (o.setTransition(0),
        o.setTranslate(p),
        t && (o.emit("beforeTransitionStart", e, s), o.emit("transitionEnd")))
      : (o.setTransition(e),
        o.setTranslate(p),
        t && (o.emit("beforeTransitionStart", e, s), o.emit("transitionStart")),
        o.animating ||
          ((o.animating = !0),
          o.onTranslateToWrapperTransitionEnd ||
            (o.onTranslateToWrapperTransitionEnd = function (P) {
              !o ||
                o.destroyed ||
                (P.target === this &&
                  (o.wrapperEl.removeEventListener(
                    "transitionend",
                    o.onTranslateToWrapperTransitionEnd
                  ),
                  (o.onTranslateToWrapperTransitionEnd = null),
                  delete o.onTranslateToWrapperTransitionEnd,
                  (o.animating = !1),
                  t && o.emit("transitionEnd")));
            }),
          o.wrapperEl.addEventListener(
            "transitionend",
            o.onTranslateToWrapperTransitionEnd
          ))),
    !0
  );
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo,
};
function setTransition(n, e) {
  const t = this;
  t.params.cssMode ||
    ((t.wrapperEl.style.transitionDuration = `${n}ms`),
    (t.wrapperEl.style.transitionDelay = n === 0 ? "0ms" : "")),
    t.emit("setTransition", n, e);
}
function transitionEmit(n) {
  let { swiper: e, runCallbacks: t, direction: r, step: s } = n;
  const { activeIndex: o, previousIndex: a } = e;
  let l = r;
  l || (o > a ? (l = "next") : o < a ? (l = "prev") : (l = "reset")),
    e.emit(`transition${s}`),
    t && l === "reset"
      ? e.emit(`slideResetTransition${s}`)
      : t &&
        o !== a &&
        (e.emit(`slideChangeTransition${s}`),
        l === "next"
          ? e.emit(`slideNextTransition${s}`)
          : e.emit(`slidePrevTransition${s}`));
}
function transitionStart(n, e) {
  n === void 0 && (n = !0);
  const t = this,
    { params: r } = t;
  r.cssMode ||
    (r.autoHeight && t.updateAutoHeight(),
    transitionEmit({
      swiper: t,
      runCallbacks: n,
      direction: e,
      step: "Start",
    }));
}
function transitionEnd(n, e) {
  n === void 0 && (n = !0);
  const t = this,
    { params: r } = t;
  (t.animating = !1),
    !r.cssMode &&
      (t.setTransition(0),
      transitionEmit({
        swiper: t,
        runCallbacks: n,
        direction: e,
        step: "End",
      }));
}
var transition = { setTransition, transitionStart, transitionEnd };
function slideTo(n, e, t, r, s) {
  n === void 0 && (n = 0),
    t === void 0 && (t = !0),
    typeof n == "string" && (n = parseInt(n, 10));
  const o = this;
  let a = n;
  a < 0 && (a = 0);
  const {
    params: l,
    snapGrid: c,
    slidesGrid: u,
    previousIndex: p,
    activeIndex: N,
    rtlTranslate: P,
    wrapperEl: de,
    enabled: me,
  } = o;
  if (
    (!me && !r && !s) ||
    o.destroyed ||
    (o.animating && l.preventInteractionOnTransition)
  )
    return !1;
  typeof e > "u" && (e = o.params.speed);
  const Ye = Math.min(o.params.slidesPerGroupSkip, a);
  let nt = Ye + Math.floor((a - Ye) / o.params.slidesPerGroup);
  nt >= c.length && (nt = c.length - 1);
  const Be = -c[nt];
  if (l.normalizeSlideIndex)
    for (let wt = 0; wt < u.length; wt += 1) {
      const bt = -Math.floor(Be * 100),
        Tt = Math.floor(u[wt] * 100),
        Ct = Math.floor(u[wt + 1] * 100);
      typeof u[wt + 1] < "u"
        ? bt >= Tt && bt < Ct - (Ct - Tt) / 2
          ? (a = wt)
          : bt >= Tt && bt < Ct && (a = wt + 1)
        : bt >= Tt && (a = wt);
    }
  if (
    o.initialized &&
    a !== N &&
    ((!o.allowSlideNext &&
      (P
        ? Be > o.translate && Be > o.minTranslate()
        : Be < o.translate && Be < o.minTranslate())) ||
      (!o.allowSlidePrev &&
        Be > o.translate &&
        Be > o.maxTranslate() &&
        (N || 0) !== a))
  )
    return !1;
  a !== (p || 0) && t && o.emit("beforeSlideChangeStart"), o.updateProgress(Be);
  let ot;
  a > N ? (ot = "next") : a < N ? (ot = "prev") : (ot = "reset");
  const st = o.virtual && o.params.virtual.enabled;
  if (!(st && s) && ((P && -Be === o.translate) || (!P && Be === o.translate)))
    return (
      o.updateActiveIndex(a),
      l.autoHeight && o.updateAutoHeight(),
      o.updateSlidesClasses(),
      l.effect !== "slide" && o.setTranslate(Be),
      ot !== "reset" && (o.transitionStart(t, ot), o.transitionEnd(t, ot)),
      !1
    );
  if (l.cssMode) {
    const wt = o.isHorizontal(),
      bt = P ? Be : -Be;
    if (e === 0)
      st &&
        ((o.wrapperEl.style.scrollSnapType = "none"),
        (o._immediateVirtual = !0)),
        st && !o._cssModeVirtualInitialSet && o.params.initialSlide > 0
          ? ((o._cssModeVirtualInitialSet = !0),
            requestAnimationFrame(() => {
              de[wt ? "scrollLeft" : "scrollTop"] = bt;
            }))
          : (de[wt ? "scrollLeft" : "scrollTop"] = bt),
        st &&
          requestAnimationFrame(() => {
            (o.wrapperEl.style.scrollSnapType = ""), (o._immediateVirtual = !1);
          });
    else {
      if (!o.support.smoothScroll)
        return (
          animateCSSModeScroll({
            swiper: o,
            targetPosition: bt,
            side: wt ? "left" : "top",
          }),
          !0
        );
      de.scrollTo({ [wt ? "left" : "top"]: bt, behavior: "smooth" });
    }
    return !0;
  }
  const St = getBrowser().isSafari;
  return (
    st && !s && St && o.isElement && o.virtual.update(!1, !1, a),
    o.setTransition(e),
    o.setTranslate(Be),
    o.updateActiveIndex(a),
    o.updateSlidesClasses(),
    o.emit("beforeTransitionStart", e, r),
    o.transitionStart(t, ot),
    e === 0
      ? o.transitionEnd(t, ot)
      : o.animating ||
        ((o.animating = !0),
        o.onSlideToWrapperTransitionEnd ||
          (o.onSlideToWrapperTransitionEnd = function (bt) {
            !o ||
              o.destroyed ||
              (bt.target === this &&
                (o.wrapperEl.removeEventListener(
                  "transitionend",
                  o.onSlideToWrapperTransitionEnd
                ),
                (o.onSlideToWrapperTransitionEnd = null),
                delete o.onSlideToWrapperTransitionEnd,
                o.transitionEnd(t, ot)));
          }),
        o.wrapperEl.addEventListener(
          "transitionend",
          o.onSlideToWrapperTransitionEnd
        )),
    !0
  );
}
function slideToLoop(n, e, t, r) {
  n === void 0 && (n = 0),
    t === void 0 && (t = !0),
    typeof n == "string" && (n = parseInt(n, 10));
  const s = this;
  if (s.destroyed) return;
  typeof e > "u" && (e = s.params.speed);
  const o = s.grid && s.params.grid && s.params.grid.rows > 1;
  let a = n;
  if (s.params.loop)
    if (s.virtual && s.params.virtual.enabled) a = a + s.virtual.slidesBefore;
    else {
      let l;
      if (o) {
        const P = a * s.params.grid.rows;
        l = s.slides.find(
          (de) => de.getAttribute("data-swiper-slide-index") * 1 === P
        ).column;
      } else l = s.getSlideIndexByData(a);
      const c = o
          ? Math.ceil(s.slides.length / s.params.grid.rows)
          : s.slides.length,
        { centeredSlides: u } = s.params;
      let p = s.params.slidesPerView;
      p === "auto"
        ? (p = s.slidesPerViewDynamic())
        : ((p = Math.ceil(parseFloat(s.params.slidesPerView, 10))),
          u && p % 2 === 0 && (p = p + 1));
      let N = c - l < p;
      if (
        (u && (N = N || l < Math.ceil(p / 2)),
        r && u && s.params.slidesPerView !== "auto" && !o && (N = !1),
        N)
      ) {
        const P = u
          ? l < s.activeIndex
            ? "prev"
            : "next"
          : l - s.activeIndex - 1 < s.params.slidesPerView
          ? "next"
          : "prev";
        s.loopFix({
          direction: P,
          slideTo: !0,
          activeSlideIndex: P === "next" ? l + 1 : l - c + 1,
          slideRealIndex: P === "next" ? s.realIndex : void 0,
        });
      }
      if (o) {
        const P = a * s.params.grid.rows;
        a = s.slides.find(
          (de) => de.getAttribute("data-swiper-slide-index") * 1 === P
        ).column;
      } else a = s.getSlideIndexByData(a);
    }
  return (
    requestAnimationFrame(() => {
      s.slideTo(a, e, t, r);
    }),
    s
  );
}
function slideNext(n, e, t) {
  e === void 0 && (e = !0);
  const r = this,
    { enabled: s, params: o, animating: a } = r;
  if (!s || r.destroyed) return r;
  typeof n > "u" && (n = r.params.speed);
  let l = o.slidesPerGroup;
  o.slidesPerView === "auto" &&
    o.slidesPerGroup === 1 &&
    o.slidesPerGroupAuto &&
    (l = Math.max(r.slidesPerViewDynamic("current", !0), 1));
  const c = r.activeIndex < o.slidesPerGroupSkip ? 1 : l,
    u = r.virtual && o.virtual.enabled;
  if (o.loop) {
    if (a && !u && o.loopPreventsSliding) return !1;
    if (
      (r.loopFix({ direction: "next" }),
      (r._clientLeft = r.wrapperEl.clientLeft),
      r.activeIndex === r.slides.length - 1 && o.cssMode)
    )
      return (
        requestAnimationFrame(() => {
          r.slideTo(r.activeIndex + c, n, e, t);
        }),
        !0
      );
  }
  return o.rewind && r.isEnd
    ? r.slideTo(0, n, e, t)
    : r.slideTo(r.activeIndex + c, n, e, t);
}
function slidePrev(n, e, t) {
  e === void 0 && (e = !0);
  const r = this,
    {
      params: s,
      snapGrid: o,
      slidesGrid: a,
      rtlTranslate: l,
      enabled: c,
      animating: u,
    } = r;
  if (!c || r.destroyed) return r;
  typeof n > "u" && (n = r.params.speed);
  const p = r.virtual && s.virtual.enabled;
  if (s.loop) {
    if (u && !p && s.loopPreventsSliding) return !1;
    r.loopFix({ direction: "prev" }), (r._clientLeft = r.wrapperEl.clientLeft);
  }
  const N = l ? r.translate : -r.translate;
  function P(ot) {
    return ot < 0 ? -Math.floor(Math.abs(ot)) : Math.floor(ot);
  }
  const de = P(N),
    me = o.map((ot) => P(ot)),
    Ye = s.freeMode && s.freeMode.enabled;
  let nt = o[me.indexOf(de) - 1];
  if (typeof nt > "u" && (s.cssMode || Ye)) {
    let ot;
    o.forEach((st, vt) => {
      de >= st && (ot = vt);
    }),
      typeof ot < "u" && (nt = Ye ? o[ot] : o[ot > 0 ? ot - 1 : ot]);
  }
  let Be = 0;
  if (
    (typeof nt < "u" &&
      ((Be = a.indexOf(nt)),
      Be < 0 && (Be = r.activeIndex - 1),
      s.slidesPerView === "auto" &&
        s.slidesPerGroup === 1 &&
        s.slidesPerGroupAuto &&
        ((Be = Be - r.slidesPerViewDynamic("previous", !0) + 1),
        (Be = Math.max(Be, 0)))),
    s.rewind && r.isBeginning)
  ) {
    const ot =
      r.params.virtual && r.params.virtual.enabled && r.virtual
        ? r.virtual.slides.length - 1
        : r.slides.length - 1;
    return r.slideTo(ot, n, e, t);
  } else if (s.loop && r.activeIndex === 0 && s.cssMode)
    return (
      requestAnimationFrame(() => {
        r.slideTo(Be, n, e, t);
      }),
      !0
    );
  return r.slideTo(Be, n, e, t);
}
function slideReset(n, e, t) {
  e === void 0 && (e = !0);
  const r = this;
  if (!r.destroyed)
    return (
      typeof n > "u" && (n = r.params.speed), r.slideTo(r.activeIndex, n, e, t)
    );
}
function slideToClosest(n, e, t, r) {
  e === void 0 && (e = !0), r === void 0 && (r = 0.5);
  const s = this;
  if (s.destroyed) return;
  typeof n > "u" && (n = s.params.speed);
  let o = s.activeIndex;
  const a = Math.min(s.params.slidesPerGroupSkip, o),
    l = a + Math.floor((o - a) / s.params.slidesPerGroup),
    c = s.rtlTranslate ? s.translate : -s.translate;
  if (c >= s.snapGrid[l]) {
    const u = s.snapGrid[l],
      p = s.snapGrid[l + 1];
    c - u > (p - u) * r && (o += s.params.slidesPerGroup);
  } else {
    const u = s.snapGrid[l - 1],
      p = s.snapGrid[l];
    c - u <= (p - u) * r && (o -= s.params.slidesPerGroup);
  }
  return (
    (o = Math.max(o, 0)),
    (o = Math.min(o, s.slidesGrid.length - 1)),
    s.slideTo(o, n, e, t)
  );
}
function slideToClickedSlide() {
  const n = this;
  if (n.destroyed) return;
  const { params: e, slidesEl: t } = n,
    r = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView;
  let s = n.clickedIndex,
    o;
  const a = n.isElement ? "swiper-slide" : `.${e.slideClass}`;
  if (e.loop) {
    if (n.animating) return;
    (o = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10)),
      e.centeredSlides
        ? s < n.loopedSlides - r / 2 ||
          s > n.slides.length - n.loopedSlides + r / 2
          ? (n.loopFix(),
            (s = n.getSlideIndex(
              elementChildren(t, `${a}[data-swiper-slide-index="${o}"]`)[0]
            )),
            nextTick(() => {
              n.slideTo(s);
            }))
          : n.slideTo(s)
        : s > n.slides.length - r
        ? (n.loopFix(),
          (s = n.getSlideIndex(
            elementChildren(t, `${a}[data-swiper-slide-index="${o}"]`)[0]
          )),
          nextTick(() => {
            n.slideTo(s);
          }))
        : n.slideTo(s);
  } else n.slideTo(s);
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};
function loopCreate(n, e) {
  const t = this,
    { params: r, slidesEl: s } = t;
  if (!r.loop || (t.virtual && t.params.virtual.enabled)) return;
  const o = () => {
      elementChildren(s, `.${r.slideClass}, swiper-slide`).forEach((P, de) => {
        P.setAttribute("data-swiper-slide-index", de);
      });
    },
    a = t.grid && r.grid && r.grid.rows > 1,
    l = r.slidesPerGroup * (a ? r.grid.rows : 1),
    c = t.slides.length % l !== 0,
    u = a && t.slides.length % r.grid.rows !== 0,
    p = (N) => {
      for (let P = 0; P < N; P += 1) {
        const de = t.isElement
          ? createElement("swiper-slide", [r.slideBlankClass])
          : createElement("div", [r.slideClass, r.slideBlankClass]);
        t.slidesEl.append(de);
      }
    };
  if (c) {
    if (r.loopAddBlankSlides) {
      const N = l - (t.slides.length % l);
      p(N), t.recalcSlides(), t.updateSlides();
    } else
      showWarning(
        "Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"
      );
    o();
  } else if (u) {
    if (r.loopAddBlankSlides) {
      const N = r.grid.rows - (t.slides.length % r.grid.rows);
      p(N), t.recalcSlides(), t.updateSlides();
    } else
      showWarning(
        "Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"
      );
    o();
  } else o();
  t.loopFix({
    slideRealIndex: n,
    direction: r.centeredSlides ? void 0 : "next",
    initial: e,
  });
}
function loopFix(n) {
  let {
    slideRealIndex: e,
    slideTo: t = !0,
    direction: r,
    setTranslate: s,
    activeSlideIndex: o,
    initial: a,
    byController: l,
    byMousewheel: c,
  } = n === void 0 ? {} : n;
  const u = this;
  if (!u.params.loop) return;
  u.emit("beforeLoopFix");
  const {
      slides: p,
      allowSlidePrev: N,
      allowSlideNext: P,
      slidesEl: de,
      params: me,
    } = u,
    { centeredSlides: Ye, initialSlide: nt } = me;
  if (
    ((u.allowSlidePrev = !0),
    (u.allowSlideNext = !0),
    u.virtual && me.virtual.enabled)
  ) {
    t &&
      (!me.centeredSlides && u.snapIndex === 0
        ? u.slideTo(u.virtual.slides.length, 0, !1, !0)
        : me.centeredSlides && u.snapIndex < me.slidesPerView
        ? u.slideTo(u.virtual.slides.length + u.snapIndex, 0, !1, !0)
        : u.snapIndex === u.snapGrid.length - 1 &&
          u.slideTo(u.virtual.slidesBefore, 0, !1, !0)),
      (u.allowSlidePrev = N),
      (u.allowSlideNext = P),
      u.emit("loopFix");
    return;
  }
  let Be = me.slidesPerView;
  Be === "auto"
    ? (Be = u.slidesPerViewDynamic())
    : ((Be = Math.ceil(parseFloat(me.slidesPerView, 10))),
      Ye && Be % 2 === 0 && (Be = Be + 1));
  const ot = me.slidesPerGroupAuto ? Be : me.slidesPerGroup;
  let st = ot;
  st % ot !== 0 && (st += ot - (st % ot)),
    (st += me.loopAdditionalSlides),
    (u.loopedSlides = st);
  const vt = u.grid && me.grid && me.grid.rows > 1;
  p.length < Be + st || (u.params.effect === "cards" && p.length < Be + st * 2)
    ? showWarning(
        "Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"
      )
    : vt &&
      me.grid.fill === "row" &&
      showWarning(
        "Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"
      );
  const xt = [],
    St = [],
    wt = vt ? Math.ceil(p.length / me.grid.rows) : p.length,
    bt = a && wt - nt < Be && !Ye;
  let Tt = bt ? nt : u.activeIndex;
  typeof o > "u"
    ? (o = u.getSlideIndex(
        p.find((Ft) => Ft.classList.contains(me.slideActiveClass))
      ))
    : (Tt = o);
  const Ct = r === "next" || !r,
    kt = r === "prev" || !r;
  let Dt = 0,
    Vt = 0;
  const qt =
    (vt ? p[o].column : o) + (Ye && typeof s > "u" ? -Be / 2 + 0.5 : 0);
  if (qt < st) {
    Dt = Math.max(st - qt, ot);
    for (let Ft = 0; Ft < st - qt; Ft += 1) {
      const Bt = Ft - Math.floor(Ft / wt) * wt;
      if (vt) {
        const Mt = wt - Bt - 1;
        for (let Pt = p.length - 1; Pt >= 0; Pt -= 1)
          p[Pt].column === Mt && xt.push(Pt);
      } else xt.push(wt - Bt - 1);
    }
  } else if (qt + Be > wt - st) {
    (Vt = Math.max(qt - (wt - st * 2), ot)),
      bt && (Vt = Math.max(Vt, Be - wt + nt + 1));
    for (let Ft = 0; Ft < Vt; Ft += 1) {
      const Bt = Ft - Math.floor(Ft / wt) * wt;
      vt
        ? p.forEach((Mt, Pt) => {
            Mt.column === Bt && St.push(Pt);
          })
        : St.push(Bt);
    }
  }
  if (
    ((u.__preventObserver__ = !0),
    requestAnimationFrame(() => {
      u.__preventObserver__ = !1;
    }),
    u.params.effect === "cards" &&
      p.length < Be + st * 2 &&
      (St.includes(o) && St.splice(St.indexOf(o), 1),
      xt.includes(o) && xt.splice(xt.indexOf(o), 1)),
    kt &&
      xt.forEach((Ft) => {
        (p[Ft].swiperLoopMoveDOM = !0),
          de.prepend(p[Ft]),
          (p[Ft].swiperLoopMoveDOM = !1);
      }),
    Ct &&
      St.forEach((Ft) => {
        (p[Ft].swiperLoopMoveDOM = !0),
          de.append(p[Ft]),
          (p[Ft].swiperLoopMoveDOM = !1);
      }),
    u.recalcSlides(),
    me.slidesPerView === "auto"
      ? u.updateSlides()
      : vt &&
        ((xt.length > 0 && kt) || (St.length > 0 && Ct)) &&
        u.slides.forEach((Ft, Bt) => {
          u.grid.updateSlide(Bt, Ft, u.slides);
        }),
    me.watchSlidesProgress && u.updateSlidesOffset(),
    t)
  ) {
    if (xt.length > 0 && kt) {
      if (typeof e > "u") {
        const Ft = u.slidesGrid[Tt],
          Mt = u.slidesGrid[Tt + Dt] - Ft;
        c
          ? u.setTranslate(u.translate - Mt)
          : (u.slideTo(Tt + Math.ceil(Dt), 0, !1, !0),
            s &&
              ((u.touchEventsData.startTranslate =
                u.touchEventsData.startTranslate - Mt),
              (u.touchEventsData.currentTranslate =
                u.touchEventsData.currentTranslate - Mt)));
      } else if (s) {
        const Ft = vt ? xt.length / me.grid.rows : xt.length;
        u.slideTo(u.activeIndex + Ft, 0, !1, !0),
          (u.touchEventsData.currentTranslate = u.translate);
      }
    } else if (St.length > 0 && Ct)
      if (typeof e > "u") {
        const Ft = u.slidesGrid[Tt],
          Mt = u.slidesGrid[Tt - Vt] - Ft;
        c
          ? u.setTranslate(u.translate - Mt)
          : (u.slideTo(Tt - Vt, 0, !1, !0),
            s &&
              ((u.touchEventsData.startTranslate =
                u.touchEventsData.startTranslate - Mt),
              (u.touchEventsData.currentTranslate =
                u.touchEventsData.currentTranslate - Mt)));
      } else {
        const Ft = vt ? St.length / me.grid.rows : St.length;
        u.slideTo(u.activeIndex - Ft, 0, !1, !0);
      }
  }
  if (
    ((u.allowSlidePrev = N),
    (u.allowSlideNext = P),
    u.controller && u.controller.control && !l)
  ) {
    const Ft = {
      slideRealIndex: e,
      direction: r,
      setTranslate: s,
      activeSlideIndex: o,
      byController: !0,
    };
    Array.isArray(u.controller.control)
      ? u.controller.control.forEach((Bt) => {
          !Bt.destroyed &&
            Bt.params.loop &&
            Bt.loopFix({
              ...Ft,
              slideTo: Bt.params.slidesPerView === me.slidesPerView ? t : !1,
            });
        })
      : u.controller.control instanceof u.constructor &&
        u.controller.control.params.loop &&
        u.controller.control.loopFix({
          ...Ft,
          slideTo:
            u.controller.control.params.slidesPerView === me.slidesPerView
              ? t
              : !1,
        });
  }
  u.emit("loopFix");
}
function loopDestroy() {
  const n = this,
    { params: e, slidesEl: t } = n;
  if (!e.loop || !t || (n.virtual && n.params.virtual.enabled)) return;
  n.recalcSlides();
  const r = [];
  n.slides.forEach((s) => {
    const o =
      typeof s.swiperSlideIndex > "u"
        ? s.getAttribute("data-swiper-slide-index") * 1
        : s.swiperSlideIndex;
    r[o] = s;
  }),
    n.slides.forEach((s) => {
      s.removeAttribute("data-swiper-slide-index");
    }),
    r.forEach((s) => {
      t.append(s);
    }),
    n.recalcSlides(),
    n.slideTo(n.realIndex, 0);
}
var loop = { loopCreate, loopFix, loopDestroy };
function setGrabCursor(n) {
  const e = this;
  if (
    !e.params.simulateTouch ||
    (e.params.watchOverflow && e.isLocked) ||
    e.params.cssMode
  )
    return;
  const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
  e.isElement && (e.__preventObserver__ = !0),
    (t.style.cursor = "move"),
    (t.style.cursor = n ? "grabbing" : "grab"),
    e.isElement &&
      requestAnimationFrame(() => {
        e.__preventObserver__ = !1;
      });
}
function unsetGrabCursor() {
  const n = this;
  (n.params.watchOverflow && n.isLocked) ||
    n.params.cssMode ||
    (n.isElement && (n.__preventObserver__ = !0),
    (n[
      n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"
    ].style.cursor = ""),
    n.isElement &&
      requestAnimationFrame(() => {
        n.__preventObserver__ = !1;
      }));
}
var grabCursor = { setGrabCursor, unsetGrabCursor };
function closestElement(n, e) {
  e === void 0 && (e = this);
  function t(r) {
    if (!r || r === getDocument() || r === getWindow()) return null;
    r.assignedSlot && (r = r.assignedSlot);
    const s = r.closest(n);
    return !s && !r.getRootNode ? null : s || t(r.getRootNode().host);
  }
  return t(e);
}
function preventEdgeSwipe(n, e, t) {
  const r = getWindow(),
    { params: s } = n,
    o = s.edgeSwipeDetection,
    a = s.edgeSwipeThreshold;
  return o && (t <= a || t >= r.innerWidth - a)
    ? o === "prevent"
      ? (e.preventDefault(), !0)
      : !1
    : !0;
}
function onTouchStart(n) {
  const e = this,
    t = getDocument();
  let r = n;
  r.originalEvent && (r = r.originalEvent);
  const s = e.touchEventsData;
  if (r.type === "pointerdown") {
    if (s.pointerId !== null && s.pointerId !== r.pointerId) return;
    s.pointerId = r.pointerId;
  } else
    r.type === "touchstart" &&
      r.targetTouches.length === 1 &&
      (s.touchId = r.targetTouches[0].identifier);
  if (r.type === "touchstart") {
    preventEdgeSwipe(e, r, r.targetTouches[0].pageX);
    return;
  }
  const { params: o, touches: a, enabled: l } = e;
  if (
    !l ||
    (!o.simulateTouch && r.pointerType === "mouse") ||
    (e.animating && o.preventInteractionOnTransition)
  )
    return;
  !e.animating && o.cssMode && o.loop && e.loopFix();
  let c = r.target;
  if (
    (o.touchEventsTarget === "wrapper" && !elementIsChildOf(c, e.wrapperEl)) ||
    ("which" in r && r.which === 3) ||
    ("button" in r && r.button > 0) ||
    (s.isTouched && s.isMoved)
  )
    return;
  const u = !!o.noSwipingClass && o.noSwipingClass !== "",
    p = r.composedPath ? r.composedPath() : r.path;
  u && r.target && r.target.shadowRoot && p && (c = p[0]);
  const N = o.noSwipingSelector ? o.noSwipingSelector : `.${o.noSwipingClass}`,
    P = !!(r.target && r.target.shadowRoot);
  if (o.noSwiping && (P ? closestElement(N, c) : c.closest(N))) {
    e.allowClick = !0;
    return;
  }
  if (o.swipeHandler && !c.closest(o.swipeHandler)) return;
  (a.currentX = r.pageX), (a.currentY = r.pageY);
  const de = a.currentX,
    me = a.currentY;
  if (!preventEdgeSwipe(e, r, de)) return;
  Object.assign(s, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0,
  }),
    (a.startX = de),
    (a.startY = me),
    (s.touchStartTime = now$1()),
    (e.allowClick = !0),
    e.updateSize(),
    (e.swipeDirection = void 0),
    o.threshold > 0 && (s.allowThresholdMove = !1);
  let Ye = !0;
  c.matches(s.focusableElements) &&
    ((Ye = !1), c.nodeName === "SELECT" && (s.isTouched = !1)),
    t.activeElement &&
      t.activeElement.matches(s.focusableElements) &&
      t.activeElement !== c &&
      (r.pointerType === "mouse" ||
        (r.pointerType !== "mouse" && !c.matches(s.focusableElements))) &&
      t.activeElement.blur();
  const nt = Ye && e.allowTouchMove && o.touchStartPreventDefault;
  (o.touchStartForcePreventDefault || nt) &&
    !c.isContentEditable &&
    r.preventDefault(),
    o.freeMode &&
      o.freeMode.enabled &&
      e.freeMode &&
      e.animating &&
      !o.cssMode &&
      e.freeMode.onTouchStart(),
    e.emit("touchStart", r);
}
function onTouchMove(n) {
  const e = getDocument(),
    t = this,
    r = t.touchEventsData,
    { params: s, touches: o, rtlTranslate: a, enabled: l } = t;
  if (!l || (!s.simulateTouch && n.pointerType === "mouse")) return;
  let c = n;
  if (
    (c.originalEvent && (c = c.originalEvent),
    c.type === "pointermove" &&
      (r.touchId !== null || c.pointerId !== r.pointerId))
  )
    return;
  let u;
  if (c.type === "touchmove") {
    if (
      ((u = [...c.changedTouches].find((xt) => xt.identifier === r.touchId)),
      !u || u.identifier !== r.touchId)
    )
      return;
  } else u = c;
  if (!r.isTouched) {
    r.startMoving && r.isScrolling && t.emit("touchMoveOpposite", c);
    return;
  }
  const p = u.pageX,
    N = u.pageY;
  if (c.preventedByNestedSwiper) {
    (o.startX = p), (o.startY = N);
    return;
  }
  if (!t.allowTouchMove) {
    c.target.matches(r.focusableElements) || (t.allowClick = !1),
      r.isTouched &&
        (Object.assign(o, { startX: p, startY: N, currentX: p, currentY: N }),
        (r.touchStartTime = now$1()));
    return;
  }
  if (s.touchReleaseOnEdges && !s.loop)
    if (t.isVertical()) {
      if (
        (N < o.startY && t.translate <= t.maxTranslate()) ||
        (N > o.startY && t.translate >= t.minTranslate())
      ) {
        (r.isTouched = !1), (r.isMoved = !1);
        return;
      }
    } else {
      if (
        a &&
        ((p > o.startX && -t.translate <= t.maxTranslate()) ||
          (p < o.startX && -t.translate >= t.minTranslate()))
      )
        return;
      if (
        !a &&
        ((p < o.startX && t.translate <= t.maxTranslate()) ||
          (p > o.startX && t.translate >= t.minTranslate()))
      )
        return;
    }
  if (
    (e.activeElement &&
      e.activeElement.matches(r.focusableElements) &&
      e.activeElement !== c.target &&
      c.pointerType !== "mouse" &&
      e.activeElement.blur(),
    e.activeElement &&
      c.target === e.activeElement &&
      c.target.matches(r.focusableElements))
  ) {
    (r.isMoved = !0), (t.allowClick = !1);
    return;
  }
  r.allowTouchCallbacks && t.emit("touchMove", c),
    (o.previousX = o.currentX),
    (o.previousY = o.currentY),
    (o.currentX = p),
    (o.currentY = N);
  const P = o.currentX - o.startX,
    de = o.currentY - o.startY;
  if (t.params.threshold && Math.sqrt(P ** 2 + de ** 2) < t.params.threshold)
    return;
  if (typeof r.isScrolling > "u") {
    let xt;
    (t.isHorizontal() && o.currentY === o.startY) ||
    (t.isVertical() && o.currentX === o.startX)
      ? (r.isScrolling = !1)
      : P * P + de * de >= 25 &&
        ((xt = (Math.atan2(Math.abs(de), Math.abs(P)) * 180) / Math.PI),
        (r.isScrolling = t.isHorizontal()
          ? xt > s.touchAngle
          : 90 - xt > s.touchAngle));
  }
  if (
    (r.isScrolling && t.emit("touchMoveOpposite", c),
    typeof r.startMoving > "u" &&
      (o.currentX !== o.startX || o.currentY !== o.startY) &&
      (r.startMoving = !0),
    r.isScrolling ||
      (c.type === "touchmove" && r.preventTouchMoveFromPointerMove))
  ) {
    r.isTouched = !1;
    return;
  }
  if (!r.startMoving) return;
  (t.allowClick = !1),
    !s.cssMode && c.cancelable && c.preventDefault(),
    s.touchMoveStopPropagation && !s.nested && c.stopPropagation();
  let me = t.isHorizontal() ? P : de,
    Ye = t.isHorizontal() ? o.currentX - o.previousX : o.currentY - o.previousY;
  s.oneWayMovement &&
    ((me = Math.abs(me) * (a ? 1 : -1)), (Ye = Math.abs(Ye) * (a ? 1 : -1))),
    (o.diff = me),
    (me *= s.touchRatio),
    a && ((me = -me), (Ye = -Ye));
  const nt = t.touchesDirection;
  (t.swipeDirection = me > 0 ? "prev" : "next"),
    (t.touchesDirection = Ye > 0 ? "prev" : "next");
  const Be = t.params.loop && !s.cssMode,
    ot =
      (t.touchesDirection === "next" && t.allowSlideNext) ||
      (t.touchesDirection === "prev" && t.allowSlidePrev);
  if (!r.isMoved) {
    if (
      (Be && ot && t.loopFix({ direction: t.swipeDirection }),
      (r.startTranslate = t.getTranslate()),
      t.setTransition(0),
      t.animating)
    ) {
      const xt = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0,
        detail: { bySwiperTouchMove: !0 },
      });
      t.wrapperEl.dispatchEvent(xt);
    }
    (r.allowMomentumBounce = !1),
      s.grabCursor &&
        (t.allowSlideNext === !0 || t.allowSlidePrev === !0) &&
        t.setGrabCursor(!0),
      t.emit("sliderFirstMove", c);
  }
  if (
    (new Date().getTime(),
    s._loopSwapReset !== !1 &&
      r.isMoved &&
      r.allowThresholdMove &&
      nt !== t.touchesDirection &&
      Be &&
      ot &&
      Math.abs(me) >= 1)
  ) {
    Object.assign(o, {
      startX: p,
      startY: N,
      currentX: p,
      currentY: N,
      startTranslate: r.currentTranslate,
    }),
      (r.loopSwapReset = !0),
      (r.startTranslate = r.currentTranslate);
    return;
  }
  t.emit("sliderMove", c),
    (r.isMoved = !0),
    (r.currentTranslate = me + r.startTranslate);
  let st = !0,
    vt = s.resistanceRatio;
  if (
    (s.touchReleaseOnEdges && (vt = 0),
    me > 0
      ? (Be &&
          ot &&
          r.allowThresholdMove &&
          r.currentTranslate >
            (s.centeredSlides
              ? t.minTranslate() -
                t.slidesSizesGrid[t.activeIndex + 1] -
                (s.slidesPerView !== "auto" &&
                t.slides.length - s.slidesPerView >= 2
                  ? t.slidesSizesGrid[t.activeIndex + 1] + t.params.spaceBetween
                  : 0) -
                t.params.spaceBetween
              : t.minTranslate()) &&
          t.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0,
          }),
        r.currentTranslate > t.minTranslate() &&
          ((st = !1),
          s.resistance &&
            (r.currentTranslate =
              t.minTranslate() -
              1 +
              (-t.minTranslate() + r.startTranslate + me) ** vt)))
      : me < 0 &&
        (Be &&
          ot &&
          r.allowThresholdMove &&
          r.currentTranslate <
            (s.centeredSlides
              ? t.maxTranslate() +
                t.slidesSizesGrid[t.slidesSizesGrid.length - 1] +
                t.params.spaceBetween +
                (s.slidesPerView !== "auto" &&
                t.slides.length - s.slidesPerView >= 2
                  ? t.slidesSizesGrid[t.slidesSizesGrid.length - 1] +
                    t.params.spaceBetween
                  : 0)
              : t.maxTranslate()) &&
          t.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex:
              t.slides.length -
              (s.slidesPerView === "auto"
                ? t.slidesPerViewDynamic()
                : Math.ceil(parseFloat(s.slidesPerView, 10))),
          }),
        r.currentTranslate < t.maxTranslate() &&
          ((st = !1),
          s.resistance &&
            (r.currentTranslate =
              t.maxTranslate() +
              1 -
              (t.maxTranslate() - r.startTranslate - me) ** vt))),
    st && (c.preventedByNestedSwiper = !0),
    !t.allowSlideNext &&
      t.swipeDirection === "next" &&
      r.currentTranslate < r.startTranslate &&
      (r.currentTranslate = r.startTranslate),
    !t.allowSlidePrev &&
      t.swipeDirection === "prev" &&
      r.currentTranslate > r.startTranslate &&
      (r.currentTranslate = r.startTranslate),
    !t.allowSlidePrev &&
      !t.allowSlideNext &&
      (r.currentTranslate = r.startTranslate),
    s.threshold > 0)
  )
    if (Math.abs(me) > s.threshold || r.allowThresholdMove) {
      if (!r.allowThresholdMove) {
        (r.allowThresholdMove = !0),
          (o.startX = o.currentX),
          (o.startY = o.currentY),
          (r.currentTranslate = r.startTranslate),
          (o.diff = t.isHorizontal()
            ? o.currentX - o.startX
            : o.currentY - o.startY);
        return;
      }
    } else {
      r.currentTranslate = r.startTranslate;
      return;
    }
  !s.followFinger ||
    s.cssMode ||
    (((s.freeMode && s.freeMode.enabled && t.freeMode) ||
      s.watchSlidesProgress) &&
      (t.updateActiveIndex(), t.updateSlidesClasses()),
    s.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(),
    t.updateProgress(r.currentTranslate),
    t.setTranslate(r.currentTranslate));
}
function onTouchEnd(n) {
  const e = this,
    t = e.touchEventsData;
  let r = n;
  r.originalEvent && (r = r.originalEvent);
  let s;
  if (r.type === "touchend" || r.type === "touchcancel") {
    if (
      ((s = [...r.changedTouches].find((xt) => xt.identifier === t.touchId)),
      !s || s.identifier !== t.touchId)
    )
      return;
  } else {
    if (t.touchId !== null || r.pointerId !== t.pointerId) return;
    s = r;
  }
  if (
    ["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(
      r.type
    ) &&
    !(
      ["pointercancel", "contextmenu"].includes(r.type) &&
      (e.browser.isSafari || e.browser.isWebView)
    )
  )
    return;
  (t.pointerId = null), (t.touchId = null);
  const {
    params: a,
    touches: l,
    rtlTranslate: c,
    slidesGrid: u,
    enabled: p,
  } = e;
  if (!p || (!a.simulateTouch && r.pointerType === "mouse")) return;
  if (
    (t.allowTouchCallbacks && e.emit("touchEnd", r),
    (t.allowTouchCallbacks = !1),
    !t.isTouched)
  ) {
    t.isMoved && a.grabCursor && e.setGrabCursor(!1),
      (t.isMoved = !1),
      (t.startMoving = !1);
    return;
  }
  a.grabCursor &&
    t.isMoved &&
    t.isTouched &&
    (e.allowSlideNext === !0 || e.allowSlidePrev === !0) &&
    e.setGrabCursor(!1);
  const N = now$1(),
    P = N - t.touchStartTime;
  if (e.allowClick) {
    const xt = r.path || (r.composedPath && r.composedPath());
    e.updateClickedSlide((xt && xt[0]) || r.target, xt),
      e.emit("tap click", r),
      P < 300 &&
        N - t.lastClickTime < 300 &&
        e.emit("doubleTap doubleClick", r);
  }
  if (
    ((t.lastClickTime = now$1()),
    nextTick(() => {
      e.destroyed || (e.allowClick = !0);
    }),
    !t.isTouched ||
      !t.isMoved ||
      !e.swipeDirection ||
      (l.diff === 0 && !t.loopSwapReset) ||
      (t.currentTranslate === t.startTranslate && !t.loopSwapReset))
  ) {
    (t.isTouched = !1), (t.isMoved = !1), (t.startMoving = !1);
    return;
  }
  (t.isTouched = !1), (t.isMoved = !1), (t.startMoving = !1);
  let de;
  if (
    (a.followFinger
      ? (de = c ? e.translate : -e.translate)
      : (de = -t.currentTranslate),
    a.cssMode)
  )
    return;
  if (a.freeMode && a.freeMode.enabled) {
    e.freeMode.onTouchEnd({ currentPos: de });
    return;
  }
  const me = de >= -e.maxTranslate() && !e.params.loop;
  let Ye = 0,
    nt = e.slidesSizesGrid[0];
  for (
    let xt = 0;
    xt < u.length;
    xt += xt < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup
  ) {
    const St = xt < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
    typeof u[xt + St] < "u"
      ? (me || (de >= u[xt] && de < u[xt + St])) &&
        ((Ye = xt), (nt = u[xt + St] - u[xt]))
      : (me || de >= u[xt]) &&
        ((Ye = xt), (nt = u[u.length - 1] - u[u.length - 2]));
  }
  let Be = null,
    ot = null;
  a.rewind &&
    (e.isBeginning
      ? (ot =
          a.virtual && a.virtual.enabled && e.virtual
            ? e.virtual.slides.length - 1
            : e.slides.length - 1)
      : e.isEnd && (Be = 0));
  const st = (de - u[Ye]) / nt,
    vt = Ye < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
  if (P > a.longSwipesMs) {
    if (!a.longSwipes) {
      e.slideTo(e.activeIndex);
      return;
    }
    e.swipeDirection === "next" &&
      (st >= a.longSwipesRatio
        ? e.slideTo(a.rewind && e.isEnd ? Be : Ye + vt)
        : e.slideTo(Ye)),
      e.swipeDirection === "prev" &&
        (st > 1 - a.longSwipesRatio
          ? e.slideTo(Ye + vt)
          : ot !== null && st < 0 && Math.abs(st) > a.longSwipesRatio
          ? e.slideTo(ot)
          : e.slideTo(Ye));
  } else {
    if (!a.shortSwipes) {
      e.slideTo(e.activeIndex);
      return;
    }
    e.navigation &&
    (r.target === e.navigation.nextEl || r.target === e.navigation.prevEl)
      ? r.target === e.navigation.nextEl
        ? e.slideTo(Ye + vt)
        : e.slideTo(Ye)
      : (e.swipeDirection === "next" && e.slideTo(Be !== null ? Be : Ye + vt),
        e.swipeDirection === "prev" && e.slideTo(ot !== null ? ot : Ye));
  }
}
function onResize() {
  const n = this,
    { params: e, el: t } = n;
  if (t && t.offsetWidth === 0) return;
  e.breakpoints && n.setBreakpoint();
  const { allowSlideNext: r, allowSlidePrev: s, snapGrid: o } = n,
    a = n.virtual && n.params.virtual.enabled;
  (n.allowSlideNext = !0),
    (n.allowSlidePrev = !0),
    n.updateSize(),
    n.updateSlides(),
    n.updateSlidesClasses();
  const l = a && e.loop;
  (e.slidesPerView === "auto" || e.slidesPerView > 1) &&
  n.isEnd &&
  !n.isBeginning &&
  !n.params.centeredSlides &&
  !l
    ? n.slideTo(n.slides.length - 1, 0, !1, !0)
    : n.params.loop && !a
    ? n.slideToLoop(n.realIndex, 0, !1, !0)
    : n.slideTo(n.activeIndex, 0, !1, !0),
    n.autoplay &&
      n.autoplay.running &&
      n.autoplay.paused &&
      (clearTimeout(n.autoplay.resizeTimeout),
      (n.autoplay.resizeTimeout = setTimeout(() => {
        n.autoplay &&
          n.autoplay.running &&
          n.autoplay.paused &&
          n.autoplay.resume();
      }, 500))),
    (n.allowSlidePrev = s),
    (n.allowSlideNext = r),
    n.params.watchOverflow && o !== n.snapGrid && n.checkOverflow();
}
function onClick(n) {
  const e = this;
  e.enabled &&
    (e.allowClick ||
      (e.params.preventClicks && n.preventDefault(),
      e.params.preventClicksPropagation &&
        e.animating &&
        (n.stopPropagation(), n.stopImmediatePropagation())));
}
function onScroll() {
  const n = this,
    { wrapperEl: e, rtlTranslate: t, enabled: r } = n;
  if (!r) return;
  (n.previousTranslate = n.translate),
    n.isHorizontal()
      ? (n.translate = -e.scrollLeft)
      : (n.translate = -e.scrollTop),
    n.translate === 0 && (n.translate = 0),
    n.updateActiveIndex(),
    n.updateSlidesClasses();
  let s;
  const o = n.maxTranslate() - n.minTranslate();
  o === 0 ? (s = 0) : (s = (n.translate - n.minTranslate()) / o),
    s !== n.progress && n.updateProgress(t ? -n.translate : n.translate),
    n.emit("setTranslate", n.translate, !1);
}
function onLoad(n) {
  const e = this;
  processLazyPreloader(e, n.target),
    !(
      e.params.cssMode ||
      (e.params.slidesPerView !== "auto" && !e.params.autoHeight)
    ) && e.update();
}
function onDocumentTouchStart() {
  const n = this;
  n.documentTouchHandlerProceeded ||
    ((n.documentTouchHandlerProceeded = !0),
    n.params.touchReleaseOnEdges && (n.el.style.touchAction = "auto"));
}
const events = (n, e) => {
  const t = getDocument(),
    { params: r, el: s, wrapperEl: o, device: a } = n,
    l = !!r.nested,
    c = e === "on" ? "addEventListener" : "removeEventListener",
    u = e;
  !s ||
    typeof s == "string" ||
    (t[c]("touchstart", n.onDocumentTouchStart, { passive: !1, capture: l }),
    s[c]("touchstart", n.onTouchStart, { passive: !1 }),
    s[c]("pointerdown", n.onTouchStart, { passive: !1 }),
    t[c]("touchmove", n.onTouchMove, { passive: !1, capture: l }),
    t[c]("pointermove", n.onTouchMove, { passive: !1, capture: l }),
    t[c]("touchend", n.onTouchEnd, { passive: !0 }),
    t[c]("pointerup", n.onTouchEnd, { passive: !0 }),
    t[c]("pointercancel", n.onTouchEnd, { passive: !0 }),
    t[c]("touchcancel", n.onTouchEnd, { passive: !0 }),
    t[c]("pointerout", n.onTouchEnd, { passive: !0 }),
    t[c]("pointerleave", n.onTouchEnd, { passive: !0 }),
    t[c]("contextmenu", n.onTouchEnd, { passive: !0 }),
    (r.preventClicks || r.preventClicksPropagation) &&
      s[c]("click", n.onClick, !0),
    r.cssMode && o[c]("scroll", n.onScroll),
    r.updateOnWindowResize
      ? n[u](
          a.ios || a.android
            ? "resize orientationchange observerUpdate"
            : "resize observerUpdate",
          onResize,
          !0
        )
      : n[u]("observerUpdate", onResize, !0),
    s[c]("load", n.onLoad, { capture: !0 }));
};
function attachEvents() {
  const n = this,
    { params: e } = n;
  (n.onTouchStart = onTouchStart.bind(n)),
    (n.onTouchMove = onTouchMove.bind(n)),
    (n.onTouchEnd = onTouchEnd.bind(n)),
    (n.onDocumentTouchStart = onDocumentTouchStart.bind(n)),
    e.cssMode && (n.onScroll = onScroll.bind(n)),
    (n.onClick = onClick.bind(n)),
    (n.onLoad = onLoad.bind(n)),
    events(n, "on");
}
function detachEvents() {
  events(this, "off");
}
var events$1 = { attachEvents, detachEvents };
const isGridEnabled = (n, e) => n.grid && e.grid && e.grid.rows > 1;
function setBreakpoint() {
  const n = this,
    { realIndex: e, initialized: t, params: r, el: s } = n,
    o = r.breakpoints;
  if (!o || (o && Object.keys(o).length === 0)) return;
  const a = getDocument(),
    l =
      r.breakpointsBase === "window" || !r.breakpointsBase
        ? r.breakpointsBase
        : "container",
    c =
      ["window", "container"].includes(r.breakpointsBase) || !r.breakpointsBase
        ? n.el
        : a.querySelector(r.breakpointsBase),
    u = n.getBreakpoint(o, l, c);
  if (!u || n.currentBreakpoint === u) return;
  const N = (u in o ? o[u] : void 0) || n.originalParams,
    P = isGridEnabled(n, r),
    de = isGridEnabled(n, N),
    me = n.params.grabCursor,
    Ye = N.grabCursor,
    nt = r.enabled;
  P && !de
    ? (s.classList.remove(
        `${r.containerModifierClass}grid`,
        `${r.containerModifierClass}grid-column`
      ),
      n.emitContainerClasses())
    : !P &&
      de &&
      (s.classList.add(`${r.containerModifierClass}grid`),
      ((N.grid.fill && N.grid.fill === "column") ||
        (!N.grid.fill && r.grid.fill === "column")) &&
        s.classList.add(`${r.containerModifierClass}grid-column`),
      n.emitContainerClasses()),
    me && !Ye ? n.unsetGrabCursor() : !me && Ye && n.setGrabCursor(),
    ["navigation", "pagination", "scrollbar"].forEach((St) => {
      if (typeof N[St] > "u") return;
      const wt = r[St] && r[St].enabled,
        bt = N[St] && N[St].enabled;
      wt && !bt && n[St].disable(), !wt && bt && n[St].enable();
    });
  const Be = N.direction && N.direction !== r.direction,
    ot = r.loop && (N.slidesPerView !== r.slidesPerView || Be),
    st = r.loop;
  Be && t && n.changeDirection(), extend$2(n.params, N);
  const vt = n.params.enabled,
    xt = n.params.loop;
  Object.assign(n, {
    allowTouchMove: n.params.allowTouchMove,
    allowSlideNext: n.params.allowSlideNext,
    allowSlidePrev: n.params.allowSlidePrev,
  }),
    nt && !vt ? n.disable() : !nt && vt && n.enable(),
    (n.currentBreakpoint = u),
    n.emit("_beforeBreakpoint", N),
    t &&
      (ot
        ? (n.loopDestroy(), n.loopCreate(e), n.updateSlides())
        : !st && xt
        ? (n.loopCreate(e), n.updateSlides())
        : st && !xt && n.loopDestroy()),
    n.emit("breakpoint", N);
}
function getBreakpoint(n, e, t) {
  if ((e === void 0 && (e = "window"), !n || (e === "container" && !t))) return;
  let r = !1;
  const s = getWindow(),
    o = e === "window" ? s.innerHeight : t.clientHeight,
    a = Object.keys(n).map((l) => {
      if (typeof l == "string" && l.indexOf("@") === 0) {
        const c = parseFloat(l.substr(1));
        return { value: o * c, point: l };
      }
      return { value: l, point: l };
    });
  a.sort((l, c) => parseInt(l.value, 10) - parseInt(c.value, 10));
  for (let l = 0; l < a.length; l += 1) {
    const { point: c, value: u } = a[l];
    e === "window"
      ? s.matchMedia(`(min-width: ${u}px)`).matches && (r = c)
      : u <= t.clientWidth && (r = c);
  }
  return r || "max";
}
var breakpoints = { setBreakpoint, getBreakpoint };
function prepareClasses(n, e) {
  const t = [];
  return (
    n.forEach((r) => {
      typeof r == "object"
        ? Object.keys(r).forEach((s) => {
            r[s] && t.push(e + s);
          })
        : typeof r == "string" && t.push(e + r);
    }),
    t
  );
}
function addClasses() {
  const n = this,
    { classNames: e, params: t, rtl: r, el: s, device: o } = n,
    a = prepareClasses(
      [
        "initialized",
        t.direction,
        { "free-mode": n.params.freeMode && t.freeMode.enabled },
        { autoheight: t.autoHeight },
        { rtl: r },
        { grid: t.grid && t.grid.rows > 1 },
        {
          "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column",
        },
        { android: o.android },
        { ios: o.ios },
        { "css-mode": t.cssMode },
        { centered: t.cssMode && t.centeredSlides },
        { "watch-progress": t.watchSlidesProgress },
      ],
      t.containerModifierClass
    );
  e.push(...a), s.classList.add(...e), n.emitContainerClasses();
}
function removeClasses() {
  const n = this,
    { el: e, classNames: t } = n;
  !e ||
    typeof e == "string" ||
    (e.classList.remove(...t), n.emitContainerClasses());
}
var classes = { addClasses, removeClasses };
function checkOverflow() {
  const n = this,
    { isLocked: e, params: t } = n,
    { slidesOffsetBefore: r } = t;
  if (r) {
    const s = n.slides.length - 1,
      o = n.slidesGrid[s] + n.slidesSizesGrid[s] + r * 2;
    n.isLocked = n.size > o;
  } else n.isLocked = n.snapGrid.length === 1;
  t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked),
    t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked),
    e && e !== n.isLocked && (n.isEnd = !1),
    e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock");
}
var checkOverflow$1 = { checkOverflow },
  defaults = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: 0.85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1,
  };
function moduleExtendParams(n, e) {
  return function (r) {
    r === void 0 && (r = {});
    const s = Object.keys(r)[0],
      o = r[s];
    if (typeof o != "object" || o === null) {
      extend$2(e, r);
      return;
    }
    if (
      (n[s] === !0 && (n[s] = { enabled: !0 }),
      s === "navigation" &&
        n[s] &&
        n[s].enabled &&
        !n[s].prevEl &&
        !n[s].nextEl &&
        (n[s].auto = !0),
      ["pagination", "scrollbar"].indexOf(s) >= 0 &&
        n[s] &&
        n[s].enabled &&
        !n[s].el &&
        (n[s].auto = !0),
      !(s in n && "enabled" in o))
    ) {
      extend$2(e, r);
      return;
    }
    typeof n[s] == "object" && !("enabled" in n[s]) && (n[s].enabled = !0),
      n[s] || (n[s] = { enabled: !1 }),
      extend$2(e, r);
  };
}
const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes,
  },
  extendedDefaults = {};
let Swiper$1 = class Ua {
  constructor() {
    let e, t;
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    s.length === 1 &&
    s[0].constructor &&
    Object.prototype.toString.call(s[0]).slice(8, -1) === "Object"
      ? (t = s[0])
      : ([e, t] = s),
      t || (t = {}),
      (t = extend$2({}, t)),
      e && !t.el && (t.el = e);
    const a = getDocument();
    if (
      t.el &&
      typeof t.el == "string" &&
      a.querySelectorAll(t.el).length > 1
    ) {
      const p = [];
      return (
        a.querySelectorAll(t.el).forEach((N) => {
          const P = extend$2({}, t, { el: N });
          p.push(new Ua(P));
        }),
        p
      );
    }
    const l = this;
    (l.__swiper__ = !0),
      (l.support = getSupport()),
      (l.device = getDevice({ userAgent: t.userAgent })),
      (l.browser = getBrowser()),
      (l.eventsListeners = {}),
      (l.eventsAnyListeners = []),
      (l.modules = [...l.__modules__]),
      t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
    const c = {};
    l.modules.forEach((p) => {
      p({
        params: t,
        swiper: l,
        extendParams: moduleExtendParams(t, c),
        on: l.on.bind(l),
        once: l.once.bind(l),
        off: l.off.bind(l),
        emit: l.emit.bind(l),
      });
    });
    const u = extend$2({}, defaults, c);
    return (
      (l.params = extend$2({}, u, extendedDefaults, t)),
      (l.originalParams = extend$2({}, l.params)),
      (l.passedParams = extend$2({}, t)),
      l.params &&
        l.params.on &&
        Object.keys(l.params.on).forEach((p) => {
          l.on(p, l.params.on[p]);
        }),
      l.params && l.params.onAny && l.onAny(l.params.onAny),
      Object.assign(l, {
        enabled: l.params.enabled,
        el: e,
        classNames: [],
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal() {
          return l.params.direction === "horizontal";
        },
        isVertical() {
          return l.params.direction === "vertical";
        },
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        allowSlideNext: l.params.allowSlideNext,
        allowSlidePrev: l.params.allowSlidePrev,
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: l.params.focusableElements,
          lastClickTime: 0,
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null,
        },
        allowClick: !0,
        allowTouchMove: l.params.allowTouchMove,
        touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 },
        imagesToLoad: [],
        imagesLoaded: 0,
      }),
      l.emit("_swiper"),
      l.params.init && l.init(),
      l
    );
  }
  getDirectionLabel(e) {
    return this.isHorizontal()
      ? e
      : {
          width: "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          marginRight: "marginBottom",
        }[e];
  }
  getSlideIndex(e) {
    const { slidesEl: t, params: r } = this,
      s = elementChildren(t, `.${r.slideClass}, swiper-slide`),
      o = elementIndex(s[0]);
    return elementIndex(e) - o;
  }
  getSlideIndexByData(e) {
    return this.getSlideIndex(
      this.slides.find(
        (t) => t.getAttribute("data-swiper-slide-index") * 1 === e
      )
    );
  }
  recalcSlides() {
    const e = this,
      { slidesEl: t, params: r } = e;
    e.slides = elementChildren(t, `.${r.slideClass}, swiper-slide`);
  }
  enable() {
    const e = this;
    e.enabled ||
      ((e.enabled = !0),
      e.params.grabCursor && e.setGrabCursor(),
      e.emit("enable"));
  }
  disable() {
    const e = this;
    e.enabled &&
      ((e.enabled = !1),
      e.params.grabCursor && e.unsetGrabCursor(),
      e.emit("disable"));
  }
  setProgress(e, t) {
    const r = this;
    e = Math.min(Math.max(e, 0), 1);
    const s = r.minTranslate(),
      a = (r.maxTranslate() - s) * e + s;
    r.translateTo(a, typeof t > "u" ? 0 : t),
      r.updateActiveIndex(),
      r.updateSlidesClasses();
  }
  emitContainerClasses() {
    const e = this;
    if (!e.params._emitClasses || !e.el) return;
    const t = e.el.className
      .split(" ")
      .filter(
        (r) =>
          r.indexOf("swiper") === 0 ||
          r.indexOf(e.params.containerModifierClass) === 0
      );
    e.emit("_containerClasses", t.join(" "));
  }
  getSlideClasses(e) {
    const t = this;
    return t.destroyed
      ? ""
      : e.className
          .split(" ")
          .filter(
            (r) =>
              r.indexOf("swiper-slide") === 0 ||
              r.indexOf(t.params.slideClass) === 0
          )
          .join(" ");
  }
  emitSlidesClasses() {
    const e = this;
    if (!e.params._emitClasses || !e.el) return;
    const t = [];
    e.slides.forEach((r) => {
      const s = e.getSlideClasses(r);
      t.push({ slideEl: r, classNames: s }), e.emit("_slideClass", r, s);
    }),
      e.emit("_slideClasses", t);
  }
  slidesPerViewDynamic(e, t) {
    e === void 0 && (e = "current"), t === void 0 && (t = !1);
    const r = this,
      {
        params: s,
        slides: o,
        slidesGrid: a,
        slidesSizesGrid: l,
        size: c,
        activeIndex: u,
      } = r;
    let p = 1;
    if (typeof s.slidesPerView == "number") return s.slidesPerView;
    if (s.centeredSlides) {
      let N = o[u] ? Math.ceil(o[u].swiperSlideSize) : 0,
        P;
      for (let de = u + 1; de < o.length; de += 1)
        o[de] &&
          !P &&
          ((N += Math.ceil(o[de].swiperSlideSize)),
          (p += 1),
          N > c && (P = !0));
      for (let de = u - 1; de >= 0; de -= 1)
        o[de] &&
          !P &&
          ((N += o[de].swiperSlideSize), (p += 1), N > c && (P = !0));
    } else if (e === "current")
      for (let N = u + 1; N < o.length; N += 1)
        (t ? a[N] + l[N] - a[u] < c : a[N] - a[u] < c) && (p += 1);
    else for (let N = u - 1; N >= 0; N -= 1) a[u] - a[N] < c && (p += 1);
    return p;
  }
  update() {
    const e = this;
    if (!e || e.destroyed) return;
    const { snapGrid: t, params: r } = e;
    r.breakpoints && e.setBreakpoint(),
      [...e.el.querySelectorAll('[loading="lazy"]')].forEach((a) => {
        a.complete && processLazyPreloader(e, a);
      }),
      e.updateSize(),
      e.updateSlides(),
      e.updateProgress(),
      e.updateSlidesClasses();
    function s() {
      const a = e.rtlTranslate ? e.translate * -1 : e.translate,
        l = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate());
      e.setTranslate(l), e.updateActiveIndex(), e.updateSlidesClasses();
    }
    let o;
    if (r.freeMode && r.freeMode.enabled && !r.cssMode)
      s(), r.autoHeight && e.updateAutoHeight();
    else {
      if (
        (r.slidesPerView === "auto" || r.slidesPerView > 1) &&
        e.isEnd &&
        !r.centeredSlides
      ) {
        const a = e.virtual && r.virtual.enabled ? e.virtual.slides : e.slides;
        o = e.slideTo(a.length - 1, 0, !1, !0);
      } else o = e.slideTo(e.activeIndex, 0, !1, !0);
      o || s();
    }
    r.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
  }
  changeDirection(e, t) {
    t === void 0 && (t = !0);
    const r = this,
      s = r.params.direction;
    return (
      e || (e = s === "horizontal" ? "vertical" : "horizontal"),
      e === s ||
        (e !== "horizontal" && e !== "vertical") ||
        (r.el.classList.remove(`${r.params.containerModifierClass}${s}`),
        r.el.classList.add(`${r.params.containerModifierClass}${e}`),
        r.emitContainerClasses(),
        (r.params.direction = e),
        r.slides.forEach((o) => {
          e === "vertical" ? (o.style.width = "") : (o.style.height = "");
        }),
        r.emit("changeDirection"),
        t && r.update()),
      r
    );
  }
  changeLanguageDirection(e) {
    const t = this;
    (t.rtl && e === "rtl") ||
      (!t.rtl && e === "ltr") ||
      ((t.rtl = e === "rtl"),
      (t.rtlTranslate = t.params.direction === "horizontal" && t.rtl),
      t.rtl
        ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
          (t.el.dir = "rtl"))
        : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
          (t.el.dir = "ltr")),
      t.update());
  }
  mount(e) {
    const t = this;
    if (t.mounted) return !0;
    let r = e || t.params.el;
    if ((typeof r == "string" && (r = document.querySelector(r)), !r))
      return !1;
    (r.swiper = t),
      r.parentNode &&
        r.parentNode.host &&
        r.parentNode.host.nodeName ===
          t.params.swiperElementNodeName.toUpperCase() &&
        (t.isElement = !0);
    const s = () =>
      `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
    let a =
      r && r.shadowRoot && r.shadowRoot.querySelector
        ? r.shadowRoot.querySelector(s())
        : elementChildren(r, s())[0];
    return (
      !a &&
        t.params.createElements &&
        ((a = createElement("div", t.params.wrapperClass)),
        r.append(a),
        elementChildren(r, `.${t.params.slideClass}`).forEach((l) => {
          a.append(l);
        })),
      Object.assign(t, {
        el: r,
        wrapperEl: a,
        slidesEl:
          t.isElement && !r.parentNode.host.slideSlots ? r.parentNode.host : a,
        hostEl: t.isElement ? r.parentNode.host : r,
        mounted: !0,
        rtl:
          r.dir.toLowerCase() === "rtl" ||
          elementStyle(r, "direction") === "rtl",
        rtlTranslate:
          t.params.direction === "horizontal" &&
          (r.dir.toLowerCase() === "rtl" ||
            elementStyle(r, "direction") === "rtl"),
        wrongRTL: elementStyle(a, "display") === "-webkit-box",
      }),
      !0
    );
  }
  init(e) {
    const t = this;
    if (t.initialized || t.mount(e) === !1) return t;
    t.emit("beforeInit"),
      t.params.breakpoints && t.setBreakpoint(),
      t.addClasses(),
      t.updateSize(),
      t.updateSlides(),
      t.params.watchOverflow && t.checkOverflow(),
      t.params.grabCursor && t.enabled && t.setGrabCursor(),
      t.params.loop && t.virtual && t.params.virtual.enabled
        ? t.slideTo(
            t.params.initialSlide + t.virtual.slidesBefore,
            0,
            t.params.runCallbacksOnInit,
            !1,
            !0
          )
        : t.slideTo(
            t.params.initialSlide,
            0,
            t.params.runCallbacksOnInit,
            !1,
            !0
          ),
      t.params.loop && t.loopCreate(void 0, !0),
      t.attachEvents();
    const s = [...t.el.querySelectorAll('[loading="lazy"]')];
    return (
      t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
      s.forEach((o) => {
        o.complete
          ? processLazyPreloader(t, o)
          : o.addEventListener("load", (a) => {
              processLazyPreloader(t, a.target);
            });
      }),
      preload$1(t),
      (t.initialized = !0),
      preload$1(t),
      t.emit("init"),
      t.emit("afterInit"),
      t
    );
  }
  destroy(e, t) {
    e === void 0 && (e = !0), t === void 0 && (t = !0);
    const r = this,
      { params: s, el: o, wrapperEl: a, slides: l } = r;
    return (
      typeof r.params > "u" ||
        r.destroyed ||
        (r.emit("beforeDestroy"),
        (r.initialized = !1),
        r.detachEvents(),
        s.loop && r.loopDestroy(),
        t &&
          (r.removeClasses(),
          o && typeof o != "string" && o.removeAttribute("style"),
          a && a.removeAttribute("style"),
          l &&
            l.length &&
            l.forEach((c) => {
              c.classList.remove(
                s.slideVisibleClass,
                s.slideFullyVisibleClass,
                s.slideActiveClass,
                s.slideNextClass,
                s.slidePrevClass
              ),
                c.removeAttribute("style"),
                c.removeAttribute("data-swiper-slide-index");
            })),
        r.emit("destroy"),
        Object.keys(r.eventsListeners).forEach((c) => {
          r.off(c);
        }),
        e !== !1 &&
          (r.el && typeof r.el != "string" && (r.el.swiper = null),
          deleteProps(r)),
        (r.destroyed = !0)),
      null
    );
  }
  static extendDefaults(e) {
    extend$2(extendedDefaults, e);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(e) {
    Ua.prototype.__modules__ || (Ua.prototype.__modules__ = []);
    const t = Ua.prototype.__modules__;
    typeof e == "function" && t.indexOf(e) < 0 && t.push(e);
  }
  static use(e) {
    return Array.isArray(e)
      ? (e.forEach((t) => Ua.installModule(t)), Ua)
      : (Ua.installModule(e), Ua);
  }
};
Object.keys(prototypes).forEach((n) => {
  Object.keys(prototypes[n]).forEach((e) => {
    Swiper$1.prototype[e] = prototypes[n][e];
  });
});
Swiper$1.use([Resize, Observer$1]);
const paramsList = [
  "eventsPrefix",
  "injectStyles",
  "injectStylesUrls",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "swiperElementNodeName",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "breakpointsBase",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopAdditionalSlides",
  "loopAddBlankSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideFullyVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "slideBlankClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control",
];
function isObject(n) {
  return (
    typeof n == "object" &&
    n !== null &&
    n.constructor &&
    Object.prototype.toString.call(n).slice(8, -1) === "Object" &&
    !n.__swiper__
  );
}
function extend$1(n, e) {
  const t = ["__proto__", "constructor", "prototype"];
  Object.keys(e)
    .filter((r) => t.indexOf(r) < 0)
    .forEach((r) => {
      typeof n[r] > "u"
        ? (n[r] = e[r])
        : isObject(e[r]) && isObject(n[r]) && Object.keys(e[r]).length > 0
        ? e[r].__swiper__
          ? (n[r] = e[r])
          : extend$1(n[r], e[r])
        : (n[r] = e[r]);
    });
}
function needsNavigation(n) {
  return (
    n === void 0 && (n = {}),
    n.navigation &&
      typeof n.navigation.nextEl > "u" &&
      typeof n.navigation.prevEl > "u"
  );
}
function needsPagination(n) {
  return n === void 0 && (n = {}), n.pagination && typeof n.pagination.el > "u";
}
function needsScrollbar(n) {
  return n === void 0 && (n = {}), n.scrollbar && typeof n.scrollbar.el > "u";
}
function uniqueClasses(n) {
  n === void 0 && (n = "");
  const e = n
      .split(" ")
      .map((r) => r.trim())
      .filter((r) => !!r),
    t = [];
  return (
    e.forEach((r) => {
      t.indexOf(r) < 0 && t.push(r);
    }),
    t.join(" ")
  );
}
function wrapperClass(n) {
  return (
    n === void 0 && (n = ""),
    n
      ? n.includes("swiper-wrapper")
        ? n
        : `swiper-wrapper ${n}`
      : "swiper-wrapper"
  );
}
function updateSwiper(n) {
  let {
    swiper: e,
    slides: t,
    passedParams: r,
    changedParams: s,
    nextEl: o,
    prevEl: a,
    scrollbarEl: l,
    paginationEl: c,
  } = n;
  const u = s.filter(
      (Tt) => Tt !== "children" && Tt !== "direction" && Tt !== "wrapperClass"
    ),
    {
      params: p,
      pagination: N,
      navigation: P,
      scrollbar: de,
      virtual: me,
      thumbs: Ye,
    } = e;
  let nt, Be, ot, st, vt, xt, St, wt;
  s.includes("thumbs") &&
    r.thumbs &&
    r.thumbs.swiper &&
    !r.thumbs.swiper.destroyed &&
    p.thumbs &&
    (!p.thumbs.swiper || p.thumbs.swiper.destroyed) &&
    (nt = !0),
    s.includes("controller") &&
      r.controller &&
      r.controller.control &&
      p.controller &&
      !p.controller.control &&
      (Be = !0),
    s.includes("pagination") &&
      r.pagination &&
      (r.pagination.el || c) &&
      (p.pagination || p.pagination === !1) &&
      N &&
      !N.el &&
      (ot = !0),
    s.includes("scrollbar") &&
      r.scrollbar &&
      (r.scrollbar.el || l) &&
      (p.scrollbar || p.scrollbar === !1) &&
      de &&
      !de.el &&
      (st = !0),
    s.includes("navigation") &&
      r.navigation &&
      (r.navigation.prevEl || a) &&
      (r.navigation.nextEl || o) &&
      (p.navigation || p.navigation === !1) &&
      P &&
      !P.prevEl &&
      !P.nextEl &&
      (vt = !0);
  const bt = (Tt) => {
    e[Tt] &&
      (e[Tt].destroy(),
      Tt === "navigation"
        ? (e.isElement && (e[Tt].prevEl.remove(), e[Tt].nextEl.remove()),
          (p[Tt].prevEl = void 0),
          (p[Tt].nextEl = void 0),
          (e[Tt].prevEl = void 0),
          (e[Tt].nextEl = void 0))
        : (e.isElement && e[Tt].el.remove(),
          (p[Tt].el = void 0),
          (e[Tt].el = void 0)));
  };
  s.includes("loop") &&
    e.isElement &&
    (p.loop && !r.loop ? (xt = !0) : !p.loop && r.loop ? (St = !0) : (wt = !0)),
    u.forEach((Tt) => {
      if (isObject(p[Tt]) && isObject(r[Tt]))
        Object.assign(p[Tt], r[Tt]),
          (Tt === "navigation" || Tt === "pagination" || Tt === "scrollbar") &&
            "enabled" in r[Tt] &&
            !r[Tt].enabled &&
            bt(Tt);
      else {
        const Ct = r[Tt];
        (Ct === !0 || Ct === !1) &&
        (Tt === "navigation" || Tt === "pagination" || Tt === "scrollbar")
          ? Ct === !1 && bt(Tt)
          : (p[Tt] = r[Tt]);
      }
    }),
    u.includes("controller") &&
      !Be &&
      e.controller &&
      e.controller.control &&
      p.controller &&
      p.controller.control &&
      (e.controller.control = p.controller.control),
    s.includes("children") && t && me && p.virtual.enabled
      ? ((me.slides = t), me.update(!0))
      : s.includes("virtual") &&
        me &&
        p.virtual.enabled &&
        (t && (me.slides = t), me.update(!0)),
    s.includes("children") && t && p.loop && (wt = !0),
    nt && Ye.init() && Ye.update(!0),
    Be && (e.controller.control = p.controller.control),
    ot &&
      (e.isElement &&
        (!c || typeof c == "string") &&
        ((c = document.createElement("div")),
        c.classList.add("swiper-pagination"),
        c.part.add("pagination"),
        e.el.appendChild(c)),
      c && (p.pagination.el = c),
      N.init(),
      N.render(),
      N.update()),
    st &&
      (e.isElement &&
        (!l || typeof l == "string") &&
        ((l = document.createElement("div")),
        l.classList.add("swiper-scrollbar"),
        l.part.add("scrollbar"),
        e.el.appendChild(l)),
      l && (p.scrollbar.el = l),
      de.init(),
      de.updateSize(),
      de.setTranslate()),
    vt &&
      (e.isElement &&
        ((!o || typeof o == "string") &&
          ((o = document.createElement("div")),
          o.classList.add("swiper-button-next"),
          setInnerHTML(o, e.hostEl.constructor.nextButtonSvg),
          o.part.add("button-next"),
          e.el.appendChild(o)),
        (!a || typeof a == "string") &&
          ((a = document.createElement("div")),
          a.classList.add("swiper-button-prev"),
          setInnerHTML(a, e.hostEl.constructor.prevButtonSvg),
          a.part.add("button-prev"),
          e.el.appendChild(a))),
      o && (p.navigation.nextEl = o),
      a && (p.navigation.prevEl = a),
      P.init(),
      P.update()),
    s.includes("allowSlideNext") && (e.allowSlideNext = r.allowSlideNext),
    s.includes("allowSlidePrev") && (e.allowSlidePrev = r.allowSlidePrev),
    s.includes("direction") && e.changeDirection(r.direction, !1),
    (xt || wt) && e.loopDestroy(),
    (St || wt) && e.loopCreate(),
    e.update();
}
function getParams(n, e) {
  n === void 0 && (n = {}), e === void 0 && (e = !0);
  const t = { on: {} },
    r = {},
    s = {};
  extend$1(t, defaults), (t._emitClasses = !0), (t.init = !1);
  const o = {},
    a = paramsList.map((c) => c.replace(/_/, "")),
    l = Object.assign({}, n);
  return (
    Object.keys(l).forEach((c) => {
      typeof n[c] > "u" ||
        (a.indexOf(c) >= 0
          ? isObject(n[c])
            ? ((t[c] = {}),
              (s[c] = {}),
              extend$1(t[c], n[c]),
              extend$1(s[c], n[c]))
            : ((t[c] = n[c]), (s[c] = n[c]))
          : c.search(/on[A-Z]/) === 0 && typeof n[c] == "function"
          ? e
            ? (r[`${c[2].toLowerCase()}${c.substr(3)}`] = n[c])
            : (t.on[`${c[2].toLowerCase()}${c.substr(3)}`] = n[c])
          : (o[c] = n[c]));
    }),
    ["navigation", "pagination", "scrollbar"].forEach((c) => {
      t[c] === !0 && (t[c] = {}), t[c] === !1 && delete t[c];
    }),
    { params: t, passedParams: s, rest: o, events: r }
  );
}
function mountSwiper(n, e) {
  let {
    el: t,
    nextEl: r,
    prevEl: s,
    paginationEl: o,
    scrollbarEl: a,
    swiper: l,
  } = n;
  needsNavigation(e) &&
    r &&
    s &&
    ((l.params.navigation.nextEl = r),
    (l.originalParams.navigation.nextEl = r),
    (l.params.navigation.prevEl = s),
    (l.originalParams.navigation.prevEl = s)),
    needsPagination(e) &&
      o &&
      ((l.params.pagination.el = o), (l.originalParams.pagination.el = o)),
    needsScrollbar(e) &&
      a &&
      ((l.params.scrollbar.el = a), (l.originalParams.scrollbar.el = a)),
    l.init(t);
}
function getChangedParams(n, e, t, r, s) {
  const o = [];
  if (!e) return o;
  const a = (c) => {
    o.indexOf(c) < 0 && o.push(c);
  };
  if (t && r) {
    const c = r.map(s),
      u = t.map(s);
    c.join("") !== u.join("") && a("children"),
      r.length !== t.length && a("children");
  }
  return (
    paramsList
      .filter((c) => c[0] === "_")
      .map((c) => c.replace(/_/, ""))
      .forEach((c) => {
        if (c in n && c in e)
          if (isObject(n[c]) && isObject(e[c])) {
            const u = Object.keys(n[c]),
              p = Object.keys(e[c]);
            u.length !== p.length
              ? a(c)
              : (u.forEach((N) => {
                  n[c][N] !== e[c][N] && a(c);
                }),
                p.forEach((N) => {
                  n[c][N] !== e[c][N] && a(c);
                }));
          } else n[c] !== e[c] && a(c);
      }),
    o
  );
}
const updateOnVirtualData = (n) => {
  !n ||
    n.destroyed ||
    !n.params.virtual ||
    (n.params.virtual && !n.params.virtual.enabled) ||
    (n.updateSlides(),
    n.updateProgress(),
    n.updateSlidesClasses(),
    n.emit("_virtualUpdated"),
    n.parallax &&
      n.params.parallax &&
      n.params.parallax.enabled &&
      n.parallax.setTranslate());
};
function _extends$1() {
  return (
    (_extends$1 = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    _extends$1.apply(this, arguments)
  );
}
function isChildSwiperSlide(n) {
  return (
    n.type && n.type.displayName && n.type.displayName.includes("SwiperSlide")
  );
}
function processChildren(n) {
  const e = [];
  return (
    React.Children.toArray(n).forEach((t) => {
      isChildSwiperSlide(t)
        ? e.push(t)
        : t.props &&
          t.props.children &&
          processChildren(t.props.children).forEach((r) => e.push(r));
    }),
    e
  );
}
function getChildren(n) {
  const e = [],
    t = {
      "container-start": [],
      "container-end": [],
      "wrapper-start": [],
      "wrapper-end": [],
    };
  return (
    React.Children.toArray(n).forEach((r) => {
      if (isChildSwiperSlide(r)) e.push(r);
      else if (r.props && r.props.slot && t[r.props.slot])
        t[r.props.slot].push(r);
      else if (r.props && r.props.children) {
        const s = processChildren(r.props.children);
        s.length > 0 ? s.forEach((o) => e.push(o)) : t["container-end"].push(r);
      } else t["container-end"].push(r);
    }),
    { slides: e, slots: t }
  );
}
function renderVirtual(n, e, t) {
  if (!t) return null;
  const r = (p) => {
      let N = p;
      return (
        p < 0 ? (N = e.length + p) : N >= e.length && (N = N - e.length), N
      );
    },
    s = n.isHorizontal()
      ? { [n.rtlTranslate ? "right" : "left"]: `${t.offset}px` }
      : { top: `${t.offset}px` },
    { from: o, to: a } = t,
    l = n.params.loop ? -e.length : 0,
    c = n.params.loop ? e.length * 2 : e.length,
    u = [];
  for (let p = l; p < c; p += 1) p >= o && p <= a && u.push(e[r(p)]);
  return u.map((p, N) =>
    React.cloneElement(p, {
      swiper: n,
      style: s,
      key: p.props.virtualIndex || p.key || `slide-${N}`,
    })
  );
}
function useIsomorphicLayoutEffect$2(n, e) {
  return typeof window > "u"
    ? reactExports.useEffect(n, e)
    : reactExports.useLayoutEffect(n, e);
}
const SwiperSlideContext = reactExports.createContext(null),
  SwiperContext = reactExports.createContext(null),
  Swiper = reactExports.forwardRef(function (n, e) {
    let {
        className: t,
        tag: r = "div",
        wrapperTag: s = "div",
        children: o,
        onSwiper: a,
        ...l
      } = n === void 0 ? {} : n,
      c = !1;
    const [u, p] = reactExports.useState("swiper"),
      [N, P] = reactExports.useState(null),
      [de, me] = reactExports.useState(!1),
      Ye = reactExports.useRef(!1),
      nt = reactExports.useRef(null),
      Be = reactExports.useRef(null),
      ot = reactExports.useRef(null),
      st = reactExports.useRef(null),
      vt = reactExports.useRef(null),
      xt = reactExports.useRef(null),
      St = reactExports.useRef(null),
      wt = reactExports.useRef(null),
      { params: bt, passedParams: Tt, rest: Ct, events: kt } = getParams(l),
      { slides: Dt, slots: Vt } = getChildren(o),
      Ht = () => {
        me(!de);
      };
    Object.assign(bt.on, {
      _containerClasses(Pt, It) {
        p(It);
      },
    });
    const qt = () => {
      Object.assign(bt.on, kt), (c = !0);
      const Pt = { ...bt };
      if (
        (delete Pt.wrapperClass,
        (Be.current = new Swiper$1(Pt)),
        Be.current.virtual && Be.current.params.virtual.enabled)
      ) {
        Be.current.virtual.slides = Dt;
        const It = {
          cache: !1,
          slides: Dt,
          renderExternal: P,
          renderExternalUpdate: !1,
        };
        extend$1(Be.current.params.virtual, It),
          extend$1(Be.current.originalParams.virtual, It);
      }
    };
    nt.current || qt(), Be.current && Be.current.on("_beforeBreakpoint", Ht);
    const Ft = () => {
        c ||
          !kt ||
          !Be.current ||
          Object.keys(kt).forEach((Pt) => {
            Be.current.on(Pt, kt[Pt]);
          });
      },
      Bt = () => {
        !kt ||
          !Be.current ||
          Object.keys(kt).forEach((Pt) => {
            Be.current.off(Pt, kt[Pt]);
          });
      };
    reactExports.useEffect(() => () => {
      Be.current && Be.current.off("_beforeBreakpoint", Ht);
    }),
      reactExports.useEffect(() => {
        !Ye.current &&
          Be.current &&
          (Be.current.emitSlidesClasses(), (Ye.current = !0));
      }),
      useIsomorphicLayoutEffect$2(() => {
        if ((e && (e.current = nt.current), !!nt.current))
          return (
            Be.current.destroyed && qt(),
            mountSwiper(
              {
                el: nt.current,
                nextEl: vt.current,
                prevEl: xt.current,
                paginationEl: St.current,
                scrollbarEl: wt.current,
                swiper: Be.current,
              },
              bt
            ),
            a && !Be.current.destroyed && a(Be.current),
            () => {
              Be.current && !Be.current.destroyed && Be.current.destroy(!0, !1);
            }
          );
      }, []),
      useIsomorphicLayoutEffect$2(() => {
        Ft();
        const Pt = getChangedParams(
          Tt,
          ot.current,
          Dt,
          st.current,
          (It) => It.key
        );
        return (
          (ot.current = Tt),
          (st.current = Dt),
          Pt.length &&
            Be.current &&
            !Be.current.destroyed &&
            updateSwiper({
              swiper: Be.current,
              slides: Dt,
              passedParams: Tt,
              changedParams: Pt,
              nextEl: vt.current,
              prevEl: xt.current,
              scrollbarEl: wt.current,
              paginationEl: St.current,
            }),
          () => {
            Bt();
          }
        );
      }),
      useIsomorphicLayoutEffect$2(() => {
        updateOnVirtualData(Be.current);
      }, [N]);
    function Mt() {
      return bt.virtual
        ? renderVirtual(Be.current, Dt, N)
        : Dt.map((Pt, It) =>
            React.cloneElement(Pt, { swiper: Be.current, swiperSlideIndex: It })
          );
    }
    return React.createElement(
      r,
      _extends$1(
        { ref: nt, className: uniqueClasses(`${u}${t ? ` ${t}` : ""}`) },
        Ct
      ),
      React.createElement(
        SwiperContext.Provider,
        { value: Be.current },
        Vt["container-start"],
        React.createElement(
          s,
          { className: wrapperClass(bt.wrapperClass) },
          Vt["wrapper-start"],
          Mt(),
          Vt["wrapper-end"]
        ),
        needsNavigation(bt) &&
          React.createElement(
            React.Fragment,
            null,
            React.createElement("div", {
              ref: xt,
              className: "swiper-button-prev",
            }),
            React.createElement("div", {
              ref: vt,
              className: "swiper-button-next",
            })
          ),
        needsScrollbar(bt) &&
          React.createElement("div", {
            ref: wt,
            className: "swiper-scrollbar",
          }),
        needsPagination(bt) &&
          React.createElement("div", {
            ref: St,
            className: "swiper-pagination",
          }),
        Vt["container-end"]
      )
    );
  });
Swiper.displayName = "Swiper";
const SwiperSlide = reactExports.forwardRef(function (n, e) {
  let {
    tag: t = "div",
    children: r,
    className: s = "",
    swiper: o,
    zoom: a,
    lazy: l,
    virtualIndex: c,
    swiperSlideIndex: u,
    ...p
  } = n === void 0 ? {} : n;
  const N = reactExports.useRef(null),
    [P, de] = reactExports.useState("swiper-slide"),
    [me, Ye] = reactExports.useState(!1);
  function nt(vt, xt, St) {
    xt === N.current && de(St);
  }
  useIsomorphicLayoutEffect$2(() => {
    if (
      (typeof u < "u" && (N.current.swiperSlideIndex = u),
      e && (e.current = N.current),
      !(!N.current || !o))
    ) {
      if (o.destroyed) {
        P !== "swiper-slide" && de("swiper-slide");
        return;
      }
      return (
        o.on("_slideClass", nt),
        () => {
          o && o.off("_slideClass", nt);
        }
      );
    }
  }),
    useIsomorphicLayoutEffect$2(() => {
      o && N.current && !o.destroyed && de(o.getSlideClasses(N.current));
    }, [o]);
  const Be = {
      isActive: P.indexOf("swiper-slide-active") >= 0,
      isVisible: P.indexOf("swiper-slide-visible") >= 0,
      isPrev: P.indexOf("swiper-slide-prev") >= 0,
      isNext: P.indexOf("swiper-slide-next") >= 0,
    },
    ot = () => (typeof r == "function" ? r(Be) : r),
    st = () => {
      Ye(!0);
    };
  return React.createElement(
    t,
    _extends$1(
      {
        ref: N,
        className: uniqueClasses(`${P}${s ? ` ${s}` : ""}`),
        "data-swiper-slide-index": c,
        onLoad: st,
      },
      p
    ),
    a &&
      React.createElement(
        SwiperSlideContext.Provider,
        { value: Be },
        React.createElement(
          "div",
          {
            className: "swiper-zoom-container",
            "data-swiper-zoom": typeof a == "number" ? a : void 0,
          },
          ot(),
          l &&
            !me &&
            React.createElement("div", { className: "swiper-lazy-preloader" })
        )
      ),
    !a &&
      React.createElement(
        SwiperSlideContext.Provider,
        { value: Be },
        ot(),
        l &&
          !me &&
          React.createElement("div", { className: "swiper-lazy-preloader" })
      )
  );
});
SwiperSlide.displayName = "SwiperSlide";
function createElementIfNotDefined(n, e, t, r) {
  return (
    n.params.createElements &&
      Object.keys(r).forEach((s) => {
        if (!t[s] && t.auto === !0) {
          let o = elementChildren(n.el, `.${r[s]}`)[0];
          o ||
            ((o = createElement("div", r[s])),
            (o.className = r[s]),
            n.el.append(o)),
            (t[s] = o),
            (e[s] = o);
        }
      }),
    t
  );
}
function Navigation(n) {
  let { swiper: e, extendParams: t, on: r, emit: s } = n;
  t({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: !1,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled",
    },
  }),
    (e.navigation = { nextEl: null, prevEl: null });
  function o(me) {
    let Ye;
    return me &&
      typeof me == "string" &&
      e.isElement &&
      ((Ye = e.el.querySelector(me) || e.hostEl.querySelector(me)), Ye)
      ? Ye
      : (me &&
          (typeof me == "string" && (Ye = [...document.querySelectorAll(me)]),
          e.params.uniqueNavElements &&
          typeof me == "string" &&
          Ye &&
          Ye.length > 1 &&
          e.el.querySelectorAll(me).length === 1
            ? (Ye = e.el.querySelector(me))
            : Ye && Ye.length === 1 && (Ye = Ye[0])),
        me && !Ye ? me : Ye);
  }
  function a(me, Ye) {
    const nt = e.params.navigation;
    (me = makeElementsArray(me)),
      me.forEach((Be) => {
        Be &&
          (Be.classList[Ye ? "add" : "remove"](...nt.disabledClass.split(" ")),
          Be.tagName === "BUTTON" && (Be.disabled = Ye),
          e.params.watchOverflow &&
            e.enabled &&
            Be.classList[e.isLocked ? "add" : "remove"](nt.lockClass));
      });
  }
  function l() {
    const { nextEl: me, prevEl: Ye } = e.navigation;
    if (e.params.loop) {
      a(Ye, !1), a(me, !1);
      return;
    }
    a(Ye, e.isBeginning && !e.params.rewind),
      a(me, e.isEnd && !e.params.rewind);
  }
  function c(me) {
    me.preventDefault(),
      !(e.isBeginning && !e.params.loop && !e.params.rewind) &&
        (e.slidePrev(), s("navigationPrev"));
  }
  function u(me) {
    me.preventDefault(),
      !(e.isEnd && !e.params.loop && !e.params.rewind) &&
        (e.slideNext(), s("navigationNext"));
  }
  function p() {
    const me = e.params.navigation;
    if (
      ((e.params.navigation = createElementIfNotDefined(
        e,
        e.originalParams.navigation,
        e.params.navigation,
        { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }
      )),
      !(me.nextEl || me.prevEl))
    )
      return;
    let Ye = o(me.nextEl),
      nt = o(me.prevEl);
    Object.assign(e.navigation, { nextEl: Ye, prevEl: nt }),
      (Ye = makeElementsArray(Ye)),
      (nt = makeElementsArray(nt));
    const Be = (ot, st) => {
      ot && ot.addEventListener("click", st === "next" ? u : c),
        !e.enabled && ot && ot.classList.add(...me.lockClass.split(" "));
    };
    Ye.forEach((ot) => Be(ot, "next")), nt.forEach((ot) => Be(ot, "prev"));
  }
  function N() {
    let { nextEl: me, prevEl: Ye } = e.navigation;
    (me = makeElementsArray(me)), (Ye = makeElementsArray(Ye));
    const nt = (Be, ot) => {
      Be.removeEventListener("click", ot === "next" ? u : c),
        Be.classList.remove(...e.params.navigation.disabledClass.split(" "));
    };
    me.forEach((Be) => nt(Be, "next")), Ye.forEach((Be) => nt(Be, "prev"));
  }
  r("init", () => {
    e.params.navigation.enabled === !1 ? de() : (p(), l());
  }),
    r("toEdge fromEdge lock unlock", () => {
      l();
    }),
    r("destroy", () => {
      N();
    }),
    r("enable disable", () => {
      let { nextEl: me, prevEl: Ye } = e.navigation;
      if (
        ((me = makeElementsArray(me)), (Ye = makeElementsArray(Ye)), e.enabled)
      ) {
        l();
        return;
      }
      [...me, ...Ye]
        .filter((nt) => !!nt)
        .forEach((nt) => nt.classList.add(e.params.navigation.lockClass));
    }),
    r("click", (me, Ye) => {
      let { nextEl: nt, prevEl: Be } = e.navigation;
      (nt = makeElementsArray(nt)), (Be = makeElementsArray(Be));
      const ot = Ye.target;
      let st = Be.includes(ot) || nt.includes(ot);
      if (e.isElement && !st) {
        const vt = Ye.path || (Ye.composedPath && Ye.composedPath());
        vt && (st = vt.find((xt) => nt.includes(xt) || Be.includes(xt)));
      }
      if (e.params.navigation.hideOnClick && !st) {
        if (
          e.pagination &&
          e.params.pagination &&
          e.params.pagination.clickable &&
          (e.pagination.el === ot || e.pagination.el.contains(ot))
        )
          return;
        let vt;
        nt.length
          ? (vt = nt[0].classList.contains(e.params.navigation.hiddenClass))
          : Be.length &&
            (vt = Be[0].classList.contains(e.params.navigation.hiddenClass)),
          s(vt === !0 ? "navigationShow" : "navigationHide"),
          [...nt, ...Be]
            .filter((xt) => !!xt)
            .forEach((xt) =>
              xt.classList.toggle(e.params.navigation.hiddenClass)
            );
      }
    });
  const P = () => {
      e.el.classList.remove(
        ...e.params.navigation.navigationDisabledClass.split(" ")
      ),
        p(),
        l();
    },
    de = () => {
      e.el.classList.add(
        ...e.params.navigation.navigationDisabledClass.split(" ")
      ),
        N();
    };
  Object.assign(e.navigation, {
    enable: P,
    disable: de,
    update: l,
    init: p,
    destroy: N,
  });
}
dt.div`
  height: 100vh;
  background: grey;
  display: flex;
  align-items: center;
  justify-content: center;
`;
const rotateAnimation = (n) => mt`
  0% {
    transform: rotateY(${n}deg); //     
  }
  100% {
    transform: rotateY(0deg); //    0
  }
`;
dt.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 10rem;
  font-family: 'Dune Rise', sans-serif;

  //    
  background: linear-gradient(to right, #c7acff 0%, #ffffff 87%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;

  //  
  text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8),
    0 2px 2px rgba(199, 172, 255, 0.9), 0 3px 3px rgba(127, 100, 242, 0.8);
`;
dt.span`
  display: inline-block;
  font-size: 14rem;
  font-weight: bold;
  margin: 0 0.3rem;

  perspective: 80px;

  &.animateGradientText {
    animation: ${({ angle: n }) => rotateAnimation(n)}
      ${({ duration: n }) => n}s ease-in-out ${({ delay: n }) => n}s
      forwards;
    transform-origin: center;
  }

  outline: none;

  span {
    display: inline-block;
  }
`;
dt.div`
  display: inline-block;
  width: 6rem;
  height: 6rem;
  margin: 0 0.5rem;

  & svg {
    width: 100%;
    height: 100%;
    animation: ${({ angle: n }) => rotateAnimation(n)}
      ${({ duration: n }) => n}s ease-in-out ${({ delay: n }) => n}s
      forwards;
    transform-origin: center;
  }
`;
const SliderNavigation = dt.div`
  width: 100%;
  height: 2.375rem;
  display: flex;
  align-items: center;
  gap: 0.8125rem;
  @media (min-width: 48rem) {
    height: 4.1vh;
  }
`,
  ButtonNavigation = dt.div`
  cursor: pointer;
  width: 1.5rem;
  height: 1.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    width: 1.125rem;
    height: 1rem;
  }
`,
  NumberNavigation = dt.div`
  height: 100%;
  width: 100%;
  display: flex;
  background: #4a3c841a;
  align-items: center;
  justify-content: center;
  border: 0.0313rem solid #7f64f240;
  font-size: 0.875rem;
  font-weight: 400;
  line-height: 114%;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  @media (min-width: 48rem) {
    width: auto;
    padding: 0 1rem;
  }
`,
  TitleText = dt.h4`
  font-weight: 400;
  font-size: 1.375rem;
  line-height: 130%;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  @media (min-width: 48rem) {
    font-size: 1.375rem
  }
`,
  DescrText = dt.p`
  font-weight: 400;
  font-size: 0.75rem;
  line-height: 183%;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: #000;
`,
  IconContainer$1 = dt.div`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  border: 0.5px solid var(--tertiary-color);
  width: 3.5rem;
  height: 3.5rem;
  position: relative;
`,
  BackIcon = ({
    color: n = "#fff",
    width: e = 24,
    height: t = 24,
    size: r = 24,
    isReverse: s = !1,
    ...o
  }) => {
    const [a, l] = reactExports.useState(!1),
      [c, u] = reactExports.useState(!1);
    return (
      reactExports.useEffect(() => {
        const p = () => {
          u(window.innerWidth >= 768);
        };
        return (
          p(),
          window.addEventListener("resize", p),
          () => {
            window.removeEventListener("resize", p);
          }
        );
      }, []),
      jsxRuntimeExports.jsx("svg", {
        width: r || e,
        height: r || t,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
          transform: s ? "rotate(180deg)" : "none",
          display: "block",
          transition: "fill 0.3s ease-in-out",
        },
        onMouseEnter: () => c && l(!0),
        onMouseLeave: () => c && l(!1),
        ...o,
        children: jsxRuntimeExports.jsx("path", {
          d: "M10.7651 4.9849C10.8 5.01971 10.8276 5.06105 10.8464 5.10654C10.8653 5.15203 10.875 5.2008 10.875 5.25004C10.875 5.29928 10.8653 5.34805 10.8464 5.39354C10.8276 5.43903 10.8 5.48036 10.7651 5.51518L4.65537 11.625L20.25 11.625C20.3495 11.625 20.4448 11.6645 20.5152 11.7349C20.5855 11.8052 20.625 11.9006 20.625 12C20.625 12.0995 20.5855 12.1949 20.5152 12.2652C20.4448 12.3355 20.3495 12.375 20.25 12.375L4.65537 12.375L10.7651 18.4849C10.8355 18.5552 10.875 18.6506 10.875 18.75C10.875 18.8495 10.8355 18.9449 10.7651 19.0152C10.6948 19.0855 10.5994 19.125 10.5 19.125C10.4006 19.125 10.3052 19.0855 10.2349 19.0152L3.48486 12.2652C3.45003 12.2304 3.4224 12.189 3.40355 12.1435C3.3847 12.098 3.375 12.0493 3.375 12C3.375 11.9508 3.3847 11.902 3.40355 11.8565C3.4224 11.811 3.45003 11.7697 3.48486 11.7349L10.2349 4.9849C10.2697 4.95007 10.311 4.92244 10.3565 4.90359C10.402 4.88474 10.4508 4.87504 10.5 4.87504C10.5492 4.87504 10.598 4.88474 10.6435 4.90359C10.689 4.92244 10.7303 4.95007 10.7651 4.9849Z",
          fill: a ? "#7F64F2" : n,
          style: { transition: "fill 0.3s ease-in-out" },
        }),
      })
    );
  },
  Gradient = dt.div`
  ${({
    color: n = colors.primaryColor,
    isFull: e = !0,
    displayed: t = !0,
  }) => lt`
    ${
      t &&
      lt`
      background: radial-gradient(
        50% ${e ? "50%" : "35%"} at 50% 50%,
        ${n}6b 30%,
        ${n}45 60%,
        ${n}00 105%
      );
    `
    }
    border-radius: inherit;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
  `}
`,
  SwiperSlider = ({ cards: n }) => {
    const [e, t] = reactExports.useState(1),
      [r, s] = reactExports.useState(window.innerWidth < 768),
      [o, a] = reactExports.useState({}),
      l = reactExports.useRef(null),
      c = n.length,
      u = (de) => {
        a((me) => ({ ...me, [de]: !0 }));
      },
      p = (de) => {
        a((me) => ({ ...me, [de]: !1 }));
      },
      N = () => {
        if (l.current && e > 1)
          if (window.innerWidth >= 1280) {
            const de = e - 1;
            l.current.slideTo(de - 1), t(de);
          } else if (window.innerWidth >= 768) {
            const de = e - 1;
            de % 2 === 0 && l.current.slideTo(de - 2), t(de);
          } else l.current.slidePrev();
      },
      P = () => {
        if (l.current && e < c)
          if (window.innerWidth >= 1280) {
            const de = e + 1;
            l.current.slideTo(de - 1), t(de);
            return;
          } else if (window.innerWidth >= 768) {
            const de = e + 1;
            de % 2 === 1 && l.current.slideTo(de - 1), t(de);
            return;
          } else {
            l.current.slideNext();
            return;
          }
      };
    return (
      reactExports.useEffect(() => {
        const de = () => {
          s(window.innerWidth < 768);
        };
        return (
          window.addEventListener("resize", de),
          () => window.removeEventListener("resize", de)
        );
      }, []),
      jsxRuntimeExports.jsxs("div", {
        style: { width: "100%", position: "relative" },
        children: [
          jsxRuntimeExports.jsx(Swiper, {
            modules: [Navigation],
            onSwiper: (de) => (l.current = de),
            onSlideChange: (de) => {
              const me = de.realIndex + 1;
              me !== e && t(me);
            },
            spaceBetween: 9.5,
            loop: !1,
            breakpoints: {
              0: { slidesPerView: 1, allowTouchMove: !0 },
              768: { slidesPerView: 2, allowTouchMove: !0 },
              1280: { slidesPerView: 4, allowTouchMove: !1 },
            },
            children: n.map((de, me) =>
              jsxRuntimeExports.jsx(
                SwiperSlide,
                {
                  onMouseEnter: () => u(me),
                  onMouseLeave: () => p(me),
                  onClick: () => {
                    var Ye;
                    (Ye = l.current) == null || Ye.slideTo(me), t(me + 1);
                  },
                  className: `${
                    me + 1 === e ? "active-slide" : "inactive-slide"
                  }`,
                  style: {
                    background: me + 1 === e ? "#fff" : "#262241",
                    clipPath:
                      me + 1 === e
                        ? "polygon(0 0, calc(100% - 2.0625rem) 0, 100% 2.0625rem, 100% 100%, 0% 100%)"
                        : "none",
                    alignSelf: "flex-end",
                    transition:
                      "flex 0.1s ease, height 0.1s ease, opacity 0.1s ease, maxWidth 0.1s ease, color 0.1s ease, backgroundColor 0.1s ease",
                    color: me + 1 === e ? "#fff" : "#000",
                    opacity: r && me + 1 !== e ? "0" : "1",
                  },
                  children: jsxRuntimeExports.jsxs(SwiperContent, {
                    style: {
                      background:
                        me + 1 === e
                          ? `linear-gradient(
                  90deg,
                  rgba(199, 172, 255, 0.6),
                  rgba(255, 255, 255, 0.6)
                ), url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.3' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")`
                          : "#262241",
                      flexDirection: me + 1 === e ? "column" : "row",
                      padding:
                        me + 1 === e
                          ? r
                            ? "1.1875rem 0.9375rem 0 1.1875rem"
                            : "0 3.6875rem 0 2.125rem"
                          : "0",
                    },
                    children: [
                      window.innerWidth >= 48 * 16 &&
                        me + 1 !== e &&
                        jsxRuntimeExports.jsx(GradientContainer, {
                          style: {
                            transition: "opacity 0.3s ease",
                            opacity: o[me] ? 1 : 0,
                            pointerEvents: o[me] ? "auto" : "none",
                          },
                          children: jsxRuntimeExports.jsx(Gradient, {
                            color: colors.primaryColor,
                          }),
                        }),
                      me + 1 !== e &&
                        jsxRuntimeExports.jsx(BorderIcon, {
                          color: "#ffffff",
                          style: {
                            position: "absolute",
                            left: "0",
                            transform: "rotate(180deg)",
                            height: "100%",
                          },
                        }),
                      me + 1 === e &&
                        jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                          children: [
                            jsxRuntimeExports.jsx(TitleText, {
                              style: {
                                color: "#271F4E",
                                transition:
                                  "font-size 0.1s ease, color 0.1s ease",
                              },
                              children: de.title,
                            }),
                            jsxRuntimeExports.jsxs("div", {
                              style: {
                                display: "flex",
                                alignItems: r ? "flex-start" : "center",
                                marginTop: r ? "0.9375rem" : "1.75rem",
                              },
                              children: [
                                jsxRuntimeExports.jsxs(IconContainer$1, {
                                  children: [
                                    jsxRuntimeExports.jsx(BorderIcon, {
                                      color: "#271F4E",
                                      style: {
                                        position: "absolute",
                                        left: "0",
                                        transform: "rotate(180deg)",
                                        height: "100%",
                                      },
                                    }),
                                    jsxRuntimeExports.jsx(de.icon, {
                                      color: "black",
                                      size: 2,
                                      style: {
                                        overflow: "visible",
                                        alignSelf: "center",
                                      },
                                    }),
                                    jsxRuntimeExports.jsx(BorderIcon, {
                                      color: "#271F4E",
                                      style: {
                                        position: "absolute",
                                        right: "0",
                                        height: "100%",
                                      },
                                    }),
                                  ],
                                }),
                                jsxRuntimeExports.jsx(DescrText, {
                                  style: {
                                    marginLeft: "1.375rem",
                                    width: "27.125rem",
                                    transition:
                                      "font-size 0.1s ease, color 0.1s ease",
                                  },
                                  children: de.descr,
                                }),
                              ],
                            }),
                          ],
                        }),
                      me + 1 !== e &&
                        jsxRuntimeExports.jsxs("div", {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            width: "100%",
                            height: "100%",
                            position: "relative",
                            zIndex: "30",
                          },
                          children: [
                            jsxRuntimeExports.jsx(de.icon, {
                              style: {
                                width: "2rem",
                                height: "2rem",
                                overflow: "visible",
                                alignSelf: "center",
                                marginRight: "0.75rem",
                              },
                            }),
                            jsxRuntimeExports.jsx(TitleText, {
                              style: { color: "#ffffff", fontSize: "1rem" },
                              children: de.title,
                            }),
                          ],
                        }),
                      me + 1 !== e &&
                        jsxRuntimeExports.jsx(BorderIcon, {
                          color: "#ffffff",
                          style: {
                            position: "absolute",
                            right: "0",
                            top: "0",
                            height: "100%",
                          },
                        }),
                    ],
                  }),
                },
                me
              )
            ),
          }),
          jsxRuntimeExports.jsxs(SliderNavigation, {
            style: { marginTop: r ? "1.0625rem" : "2.75rem" },
            children: [
              jsxRuntimeExports.jsx(ButtonNavigation, {
                onClick: N,
                children: jsxRuntimeExports.jsx(BackIcon, {}),
              }),
              jsxRuntimeExports.jsxs(NumberNavigation, {
                style: { color: "#ffffff" },
                children: [
                  jsxRuntimeExports.jsx("span", {
                    style: { opacity: 1 },
                    children: e,
                  }),
                  jsxRuntimeExports.jsx("span", {
                    style: { opacity: 0.5 },
                    children: "/",
                  }),
                  jsxRuntimeExports.jsx("span", {
                    style: { opacity: 0.5 },
                    children: c,
                  }),
                ],
              }),
              jsxRuntimeExports.jsx(ButtonNavigation, {
                onClick: P,
                children: jsxRuntimeExports.jsx(BackIcon, { isReverse: !0 }),
              }),
            ],
          }),
        ],
      })
    );
  },
  Wrapper$1 = dt.div`
  min-height: auto !important;
  overflow: hidden !important;
  position: relative;
  display: flex;
  flex-direction: column;
  user-select: none;
  background: transparent;
`,
  Main$1 = dt.div`
    flex: 1 1 auto;
    width: 100%;

    height: 100%;
    scroll-snap-type: initial;
    overflow-y: auto;
    
    @media (min-width: 48rem) {
        scroll-snap-type: y mandatory !important;
        overflow-y: scroll !important;
        overflow-x: hidden;
        height: 100vh;
    }
`,
  Container = dt.div`
  width: 100%;
  height: 100%;
  padding: 0 1rem;
  @media (min-width: 48rem) {
    padding: 0 6.35vw;
  }
`,
  GradientBackground = dt.div.withConfig({
    shouldForwardProp: (n) =>
      !["width", "height", "opacity", "position"].includes(n),
  })`
    position: absolute;
    width: ${(n) => n.width};
    height: ${(n) => n.height};
    opacity: ${(n) => n.opacity};
    z-index: -1;
    ${(n) => n.position};
`,
  GradientBGComponent = ({
    width: n = "20%",
    height: e = "20%",
    opacity: t = 0.5,
    position: r = "top: 50%; left: 50%; transform: translate(-50%, -50%);",
    children: s,
  }) =>
    jsxRuntimeExports.jsx(GradientBackground, {
      width: n,
      height: e,
      opacity: t,
      position: r,
      children: s,
    }),
  GradientBG = reactExports.memo(GradientBGComponent),
  OrbitContainer = dt.div`
  position: absolute;
  width: ${({ width: n }) => (n !== void 0 ? `${n}rem` : "auto")};
  height: ${({ height: n }) => (n !== void 0 ? `${n}rem` : "auto")};
  top: ${({ top: n }) => (n !== void 0 ? `${n}` : "auto")};
  left: ${({ left: n }) => (n !== void 0 ? `${n}` : "auto")};
  right: ${({ right: n }) => (n !== void 0 ? `${n}` : "auto")};
  bottom: ${({ bottom: n }) => (n !== void 0 ? `${n}` : "auto")};
  overflow: visible;
  transform-origin: center;
  transform: rotate(${({ angle: n }) => n}deg);
  will-change: transform;
`,
  generateVisibilityAnimation = (n, e, t, r) => mt`
  0%, ${n * 100}% {
    opacity: 1;
  }
  ${e * 100}%, ${t * 100}% {
    opacity: 0;
  }
  ${r * 100}%, 100% {
    opacity: 1;
  }
`,
  OrbitPath = dt.svg`
  position: absolute;
  will-change: transform;
`,
  OrbitDot = dt.circle.withConfig({
    shouldForwardProp: (n) => !["keyframesConfig", "duration"].includes(n),
  })`
will-change: opacity, transform;
    ${({ keyframesConfig: n, duration: e }) => lt`
                animation: ${generateVisibilityAnimation(
                  n.startVisible,
                  n.startHidden,
                  n.endHidden,
                  n.endVisible
                )}
                ${e}s linear infinite;
            `}
`;
var lib$1 = {},
  uaParser_min$1 = { exports: {} },
  uaParser_min = uaParser_min$1.exports,
  hasRequiredUaParser_min;
function requireUaParser_min() {
  return (
    hasRequiredUaParser_min ||
      ((hasRequiredUaParser_min = 1),
      (function (n, e) {
        (function (t, r) {
          var s = "1.0.40",
            o = "",
            a = "?",
            l = "function",
            c = "undefined",
            u = "object",
            p = "string",
            N = "major",
            P = "model",
            de = "name",
            me = "type",
            Ye = "vendor",
            nt = "version",
            Be = "architecture",
            ot = "console",
            st = "mobile",
            vt = "tablet",
            xt = "smarttv",
            St = "wearable",
            wt = "embedded",
            bt = 500,
            Tt = "Amazon",
            Ct = "Apple",
            kt = "ASUS",
            Dt = "BlackBerry",
            Vt = "Browser",
            Ht = "Chrome",
            qt = "Edge",
            Ft = "Firefox",
            Bt = "Google",
            Mt = "Huawei",
            Pt = "LG",
            It = "Microsoft",
            Ot = "Motorola",
            Xt = "Opera",
            sn = "Samsung",
            Kt = "Sharp",
            tn = "Sony",
            pn = "Xiaomi",
            _n = "Zebra",
            bn = "Facebook",
            $n = "Chromium OS",
            tr = "Mac OS",
            ur = " Browser",
            _r = function (mn, Vn) {
              var Fn = {};
              for (var nr in mn)
                Vn[nr] && Vn[nr].length % 2 === 0
                  ? (Fn[nr] = Vn[nr].concat(mn[nr]))
                  : (Fn[nr] = mn[nr]);
              return Fn;
            },
            Bn = function (mn) {
              for (var Vn = {}, Fn = 0; Fn < mn.length; Fn++)
                Vn[mn[Fn].toUpperCase()] = mn[Fn];
              return Vn;
            },
            jt = function (mn, Vn) {
              return typeof mn === p ? Yn(Vn).indexOf(Yn(mn)) !== -1 : !1;
            },
            Yn = function (mn) {
              return mn.toLowerCase();
            },
            zn = function (mn) {
              return typeof mn === p
                ? mn.replace(/[^\d\.]/g, o).split(".")[0]
                : r;
            },
            rn = function (mn, Vn) {
              if (typeof mn === p)
                return (
                  (mn = mn.replace(/^\s\s*/, o)),
                  typeof Vn === c ? mn : mn.substring(0, bt)
                );
            },
            In = function (mn, Vn) {
              for (
                var Fn = 0, nr, yr, qn, jn, Jn, mr;
                Fn < Vn.length && !Jn;

              ) {
                var Sr = Vn[Fn],
                  Ur = Vn[Fn + 1];
                for (nr = yr = 0; nr < Sr.length && !Jn && Sr[nr]; )
                  if (((Jn = Sr[nr++].exec(mn)), Jn))
                    for (qn = 0; qn < Ur.length; qn++)
                      (mr = Jn[++yr]),
                        (jn = Ur[qn]),
                        typeof jn === u && jn.length > 0
                          ? jn.length === 2
                            ? typeof jn[1] == l
                              ? (this[jn[0]] = jn[1].call(this, mr))
                              : (this[jn[0]] = jn[1])
                            : jn.length === 3
                            ? typeof jn[1] === l && !(jn[1].exec && jn[1].test)
                              ? (this[jn[0]] = mr
                                  ? jn[1].call(this, mr, jn[2])
                                  : r)
                              : (this[jn[0]] = mr
                                  ? mr.replace(jn[1], jn[2])
                                  : r)
                            : jn.length === 4 &&
                              (this[jn[0]] = mr
                                ? jn[3].call(this, mr.replace(jn[1], jn[2]))
                                : r)
                          : (this[jn] = mr || r);
                Fn += 2;
              }
            },
            or = function (mn, Vn) {
              for (var Fn in Vn)
                if (typeof Vn[Fn] === u && Vn[Fn].length > 0) {
                  for (var nr = 0; nr < Vn[Fn].length; nr++)
                    if (jt(Vn[Fn][nr], mn)) return Fn === a ? r : Fn;
                } else if (jt(Vn[Fn], mn)) return Fn === a ? r : Fn;
              return Vn.hasOwnProperty("*") ? Vn["*"] : mn;
            },
            Gn = {
              "1.0": "/8",
              1.2: "/1",
              1.3: "/3",
              "2.0": "/412",
              "2.0.2": "/416",
              "2.0.3": "/417",
              "2.0.4": "/419",
              "?": "/",
            },
            Yt = {
              ME: "4.90",
              "NT 3.11": "NT3.51",
              "NT 4.0": "NT4.0",
              2e3: "NT 5.0",
              XP: ["NT 5.1", "NT 5.2"],
              Vista: "NT 6.0",
              7: "NT 6.1",
              8: "NT 6.2",
              8.1: "NT 6.3",
              10: ["NT 6.4", "NT 10.0"],
              RT: "ARM",
            },
            Gt = {
              browser: [
                [/\b(?:crmo|crios)\/([\w\.]+)/i],
                [nt, [de, "Chrome"]],
                [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                [nt, [de, "Edge"]],
                [
                  /(opera mini)\/([-\w\.]+)/i,
                  /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                  /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i,
                ],
                [de, nt],
                [/opios[\/ ]+([\w\.]+)/i],
                [nt, [de, Xt + " Mini"]],
                [/\bop(?:rg)?x\/([\w\.]+)/i],
                [nt, [de, Xt + " GX"]],
                [/\bopr\/([\w\.]+)/i],
                [nt, [de, Xt]],
                [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i],
                [nt, [de, "Baidu"]],
                [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i],
                [nt, [de, "Maxthon"]],
                [
                  /(kindle)\/([\w\.]+)/i,
                  /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
                  /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
                  /(?:ms|\()(ie) ([\w\.]+)/i,
                  /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
                  /(heytap|ovi|115)browser\/([\d\.]+)/i,
                  /(weibo)__([\d\.]+)/i,
                ],
                [de, nt],
                [/quark(?:pc)?\/([-\w\.]+)/i],
                [nt, [de, "Quark"]],
                [/\bddg\/([\w\.]+)/i],
                [nt, [de, "DuckDuckGo"]],
                [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                [nt, [de, "UC" + Vt]],
                [
                  /microm.+\bqbcore\/([\w\.]+)/i,
                  /\bqbcore\/([\w\.]+).+microm/i,
                  /micromessenger\/([\w\.]+)/i,
                ],
                [nt, [de, "WeChat"]],
                [/konqueror\/([\w\.]+)/i],
                [nt, [de, "Konqueror"]],
                [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                [nt, [de, "IE"]],
                [/ya(?:search)?browser\/([\w\.]+)/i],
                [nt, [de, "Yandex"]],
                [/slbrowser\/([\w\.]+)/i],
                [nt, [de, "Smart Lenovo " + Vt]],
                [/(avast|avg)\/([\w\.]+)/i],
                [[de, /(.+)/, "$1 Secure " + Vt], nt],
                [/\bfocus\/([\w\.]+)/i],
                [nt, [de, Ft + " Focus"]],
                [/\bopt\/([\w\.]+)/i],
                [nt, [de, Xt + " Touch"]],
                [/coc_coc\w+\/([\w\.]+)/i],
                [nt, [de, "Coc Coc"]],
                [/dolfin\/([\w\.]+)/i],
                [nt, [de, "Dolphin"]],
                [/coast\/([\w\.]+)/i],
                [nt, [de, Xt + " Coast"]],
                [/miuibrowser\/([\w\.]+)/i],
                [nt, [de, "MIUI" + ur]],
                [/fxios\/([\w\.-]+)/i],
                [nt, [de, Ft]],
                [/\bqihoobrowser\/?([\w\.]*)/i],
                [nt, [de, "360"]],
                [/\b(qq)\/([\w\.]+)/i],
                [[de, /(.+)/, "$1Browser"], nt],
                [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i],
                [[de, /(.+)/, "$1" + ur], nt],
                [/samsungbrowser\/([\w\.]+)/i],
                [nt, [de, sn + " Internet"]],
                [/metasr[\/ ]?([\d\.]+)/i],
                [nt, [de, "Sogou Explorer"]],
                [/(sogou)mo\w+\/([\d\.]+)/i],
                [[de, "Sogou Mobile"], nt],
                [
                  /(electron)\/([\w\.]+) safari/i,
                  /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                  /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i,
                ],
                [de, nt],
                [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i],
                [de],
                [
                  /ome\/([\w\.]+) \w* ?(iron) saf/i,
                  /ome\/([\w\.]+).+qihu (360)[es]e/i,
                ],
                [nt, de],
                [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                [[de, bn], nt],
                [
                  /(Klarna)\/([\w\.]+)/i,
                  /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
                  /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
                  /safari (line)\/([\w\.]+)/i,
                  /\b(line)\/([\w\.]+)\/iab/i,
                  /(alipay)client\/([\w\.]+)/i,
                  /(twitter)(?:and| f.+e\/([\w\.]+))/i,
                  /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i,
                ],
                [de, nt],
                [/\bgsa\/([\w\.]+) .*safari\//i],
                [nt, [de, "GSA"]],
                [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],
                [nt, [de, "TikTok"]],
                [/headlesschrome(?:\/([\w\.]+)| )/i],
                [nt, [de, Ht + " Headless"]],
                [/ wv\).+(chrome)\/([\w\.]+)/i],
                [[de, Ht + " WebView"], nt],
                [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                [nt, [de, "Android " + Vt]],
                [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                [de, nt],
                [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                [nt, [de, "Mobile Safari"]],
                [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                [nt, de],
                [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                [de, [nt, or, Gn]],
                [/(webkit|khtml)\/([\w\.]+)/i],
                [de, nt],
                [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                [[de, "Netscape"], nt],
                [/(wolvic|librewolf)\/([\w\.]+)/i],
                [de, nt],
                [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                [nt, [de, Ft + " Reality"]],
                [
                  /ekiohf.+(flow)\/([\w\.]+)/i,
                  /(swiftfox)/i,
                  /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
                  /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                  /(firefox)\/([\w\.]+)/i,
                  /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                  /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                  /(links) \(([\w\.]+)/i,
                ],
                [de, [nt, /_/g, "."]],
                [/(cobalt)\/([\w\.]+)/i],
                [de, [nt, /master.|lts./, ""]],
              ],
              cpu: [
                [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                [[Be, "amd64"]],
                [/(ia32(?=;))/i],
                [[Be, Yn]],
                [/((?:i[346]|x)86)[;\)]/i],
                [[Be, "ia32"]],
                [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                [[Be, "arm64"]],
                [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                [[Be, "armhf"]],
                [/windows (ce|mobile); ppc;/i],
                [[Be, "arm"]],
                [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                [[Be, /ower/, o, Yn]],
                [/(sun4\w)[;\)]/i],
                [[Be, "sparc"]],
                [
                  /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i,
                ],
                [[Be, Yn]],
              ],
              device: [
                [
                  /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i,
                ],
                [P, [Ye, sn], [me, vt]],
                [
                  /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
                  /samsung[- ]((?!sm-[lr])[-\w]+)/i,
                  /sec-(sgh\w+)/i,
                ],
                [P, [Ye, sn], [me, st]],
                [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],
                [P, [Ye, Ct], [me, st]],
                [
                  /\((ipad);[-\w\),; ]+apple/i,
                  /applecoremedia\/[\w\.]+ \((ipad)/i,
                  /\b(ipad)\d\d?,\d\d?[;\]].+ios/i,
                ],
                [P, [Ye, Ct], [me, vt]],
                [/(macintosh);/i],
                [P, [Ye, Ct]],
                [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                [P, [Ye, Kt], [me, st]],
                [/(?:honor)([-\w ]+)[;\)]/i],
                [P, [Ye, "Honor"], [me, st]],
                [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                [P, [Ye, Mt], [me, vt]],
                [
                  /(?:huawei)([-\w ]+)[;\)]/i,
                  /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i,
                ],
                [P, [Ye, Mt], [me, st]],
                [
                  /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
                  /\b; (\w+) build\/hm\1/i,
                  /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                  /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                  /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
                  /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i,
                ],
                [
                  [P, /_/g, " "],
                  [Ye, pn],
                  [me, st],
                ],
                [
                  /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
                  /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i,
                ],
                [
                  [P, /_/g, " "],
                  [Ye, pn],
                  [me, vt],
                ],
                [
                  /; (\w+) bui.+ oppo/i,
                  /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i,
                ],
                [P, [Ye, "OPPO"], [me, st]],
                [/\b(opd2\d{3}a?) bui/i],
                [P, [Ye, "OPPO"], [me, vt]],
                [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
                [P, [Ye, "Vivo"], [me, st]],
                [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i],
                [P, [Ye, "Realme"], [me, st]],
                [
                  /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                  /\bmot(?:orola)?[- ](\w*)/i,
                  /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i,
                ],
                [P, [Ye, Ot], [me, st]],
                [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                [P, [Ye, Ot], [me, vt]],
                [
                  /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i,
                ],
                [P, [Ye, Pt], [me, vt]],
                [
                  /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                  /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                  /\blg-?([\d\w]+) bui/i,
                ],
                [P, [Ye, Pt], [me, st]],
                [
                  /(ideatab[-\w ]+)/i,
                  /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i,
                ],
                [P, [Ye, "Lenovo"], [me, vt]],
                [
                  /(?:maemo|nokia).*(n900|lumia \d+)/i,
                  /nokia[-_ ]?([-\w\.]*)/i,
                ],
                [
                  [P, /_/g, " "],
                  [Ye, "Nokia"],
                  [me, st],
                ],
                [/(pixel c)\b/i],
                [P, [Ye, Bt], [me, vt]],
                [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                [P, [Ye, Bt], [me, st]],
                [
                  /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i,
                ],
                [P, [Ye, tn], [me, st]],
                [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                [
                  [P, "Xperia Tablet"],
                  [Ye, tn],
                  [me, vt],
                ],
                [
                  / (kb2005|in20[12]5|be20[12][59])\b/i,
                  /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i,
                ],
                [P, [Ye, "OnePlus"], [me, st]],
                [
                  /(alexa)webm/i,
                  /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
                  /(kf[a-z]+)( bui|\)).+silk\//i,
                ],
                [P, [Ye, Tt], [me, vt]],
                [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                [
                  [P, /(.+)/g, "Fire Phone $1"],
                  [Ye, Tt],
                  [me, st],
                ],
                [/(playbook);[-\w\),; ]+(rim)/i],
                [P, Ye, [me, vt]],
                [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                [P, [Ye, Dt], [me, st]],
                [
                  /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i,
                ],
                [P, [Ye, kt], [me, vt]],
                [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                [P, [Ye, kt], [me, st]],
                [/(nexus 9)/i],
                [P, [Ye, "HTC"], [me, vt]],
                [
                  /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                  /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                  /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i,
                ],
                [Ye, [P, /_/g, " "], [me, st]],
                [
                  /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i,
                ],
                [P, [Ye, "TCL"], [me, vt]],
                [/(itel) ((\w+))/i],
                [
                  [Ye, Yn],
                  P,
                  [me, or, { tablet: ["p10001l", "w7001"], "*": "mobile" }],
                ],
                [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                [P, [Ye, "Acer"], [me, vt]],
                [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                [P, [Ye, "Meizu"], [me, st]],
                [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i],
                [P, [Ye, "Ulefone"], [me, st]],
                [
                  /; (energy ?\w+)(?: bui|\))/i,
                  /; energizer ([\w ]+)(?: bui|\))/i,
                ],
                [P, [Ye, "Energizer"], [me, st]],
                [
                  /; cat (b35);/i,
                  /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i,
                ],
                [P, [Ye, "Cat"], [me, st]],
                [/((?:new )?andromax[\w- ]+)(?: bui|\))/i],
                [P, [Ye, "Smartfren"], [me, st]],
                [/droid.+; (a(?:015|06[35]|142p?))/i],
                [P, [Ye, "Nothing"], [me, st]],
                [
                  /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
                  /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i,
                  /(hp) ([\w ]+\w)/i,
                  /(asus)-?(\w+)/i,
                  /(microsoft); (lumia[\w ]+)/i,
                  /(lenovo)[-_ ]?([-\w]+)/i,
                  /(jolla)/i,
                  /(oppo) ?([\w ]+) bui/i,
                ],
                [Ye, P, [me, st]],
                [
                  /(imo) (tab \w+)/i,
                  /(kobo)\s(ereader|touch)/i,
                  /(archos) (gamepad2?)/i,
                  /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                  /(kindle)\/([\w\.]+)/i,
                  /(nook)[\w ]+build\/(\w+)/i,
                  /(dell) (strea[kpr\d ]*[\dko])/i,
                  /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                  /(trinity)[- ]*(t\d{3}) bui/i,
                  /(gigaset)[- ]+(q\w{1,9}) bui/i,
                  /(vodafone) ([\w ]+)(?:\)| bui)/i,
                ],
                [Ye, P, [me, vt]],
                [/(surface duo)/i],
                [P, [Ye, It], [me, vt]],
                [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                [P, [Ye, "Fairphone"], [me, st]],
                [/(u304aa)/i],
                [P, [Ye, "AT&T"], [me, st]],
                [/\bsie-(\w*)/i],
                [P, [Ye, "Siemens"], [me, st]],
                [/\b(rct\w+) b/i],
                [P, [Ye, "RCA"], [me, vt]],
                [/\b(venue[\d ]{2,7}) b/i],
                [P, [Ye, "Dell"], [me, vt]],
                [/\b(q(?:mv|ta)\w+) b/i],
                [P, [Ye, "Verizon"], [me, vt]],
                [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                [P, [Ye, "Barnes & Noble"], [me, vt]],
                [/\b(tm\d{3}\w+) b/i],
                [P, [Ye, "NuVision"], [me, vt]],
                [/\b(k88) b/i],
                [P, [Ye, "ZTE"], [me, vt]],
                [/\b(nx\d{3}j) b/i],
                [P, [Ye, "ZTE"], [me, st]],
                [/\b(gen\d{3}) b.+49h/i],
                [P, [Ye, "Swiss"], [me, st]],
                [/\b(zur\d{3}) b/i],
                [P, [Ye, "Swiss"], [me, vt]],
                [/\b((zeki)?tb.*\b) b/i],
                [P, [Ye, "Zeki"], [me, vt]],
                [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                [[Ye, "Dragon Touch"], P, [me, vt]],
                [/\b(ns-?\w{0,9}) b/i],
                [P, [Ye, "Insignia"], [me, vt]],
                [/\b((nxa|next)-?\w{0,9}) b/i],
                [P, [Ye, "NextBook"], [me, vt]],
                [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                [[Ye, "Voice"], P, [me, st]],
                [/\b(lvtel\-)?(v1[12]) b/i],
                [[Ye, "LvTel"], P, [me, st]],
                [/\b(ph-1) /i],
                [P, [Ye, "Essential"], [me, st]],
                [/\b(v(100md|700na|7011|917g).*\b) b/i],
                [P, [Ye, "Envizen"], [me, vt]],
                [/\b(trio[-\w\. ]+) b/i],
                [P, [Ye, "MachSpeed"], [me, vt]],
                [/\btu_(1491) b/i],
                [P, [Ye, "Rotor"], [me, vt]],
                [/(shield[\w ]+) b/i],
                [P, [Ye, "Nvidia"], [me, vt]],
                [/(sprint) (\w+)/i],
                [Ye, P, [me, st]],
                [/(kin\.[onetw]{3})/i],
                [
                  [P, /\./g, " "],
                  [Ye, It],
                  [me, st],
                ],
                [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                [P, [Ye, _n], [me, vt]],
                [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                [P, [Ye, _n], [me, st]],
                [/smart-tv.+(samsung)/i],
                [Ye, [me, xt]],
                [/hbbtv.+maple;(\d+)/i],
                [
                  [P, /^/, "SmartTV"],
                  [Ye, sn],
                  [me, xt],
                ],
                [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                [
                  [Ye, Pt],
                  [me, xt],
                ],
                [/(apple) ?tv/i],
                [Ye, [P, Ct + " TV"], [me, xt]],
                [/crkey/i],
                [
                  [P, Ht + "cast"],
                  [Ye, Bt],
                  [me, xt],
                ],
                [/droid.+aft(\w+)( bui|\))/i],
                [P, [Ye, Tt], [me, xt]],
                [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                [P, [Ye, Kt], [me, xt]],
                [/(bravia[\w ]+)( bui|\))/i],
                [P, [Ye, tn], [me, xt]],
                [/(mitv-\w{5}) bui/i],
                [P, [Ye, pn], [me, xt]],
                [/Hbbtv.*(technisat) (.*);/i],
                [Ye, P, [me, xt]],
                [
                  /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                  /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i,
                ],
                [
                  [Ye, rn],
                  [P, rn],
                  [me, xt],
                ],
                [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                [[me, xt]],
                [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                [Ye, P, [me, ot]],
                [/droid.+; (shield) bui/i],
                [P, [Ye, "Nvidia"], [me, ot]],
                [/(playstation [345portablevi]+)/i],
                [P, [Ye, tn], [me, ot]],
                [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                [P, [Ye, It], [me, ot]],
                [/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i],
                [P, [Ye, sn], [me, St]],
                [/((pebble))app/i],
                [Ye, P, [me, St]],
                [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],
                [P, [Ye, Ct], [me, St]],
                [/droid.+; (glass) \d/i],
                [P, [Ye, Bt], [me, St]],
                [/droid.+; (wt63?0{2,3})\)/i],
                [P, [Ye, _n], [me, St]],
                [/droid.+; (glass) \d/i],
                [P, [Ye, Bt], [me, St]],
                [/(pico) (4|neo3(?: link|pro)?)/i],
                [Ye, P, [me, St]],
                [/; (quest( \d| pro)?)/i],
                [P, [Ye, bn], [me, St]],
                [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                [Ye, [me, wt]],
                [/(aeobc)\b/i],
                [P, [Ye, Tt], [me, wt]],
                [
                  /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i,
                ],
                [P, [me, st]],
                [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                [P, [me, vt]],
                [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                [[me, vt]],
                [
                  /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i,
                ],
                [[me, st]],
                [/(android[-\w\. ]{0,9});.+buil/i],
                [P, [Ye, "Generic"]],
              ],
              engine: [
                [/windows.+ edge\/([\w\.]+)/i],
                [nt, [de, qt + "HTML"]],
                [/(arkweb)\/([\w\.]+)/i],
                [de, nt],
                [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                [nt, [de, "Blink"]],
                [
                  /(presto)\/([\w\.]+)/i,
                  /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
                  /ekioh(flow)\/([\w\.]+)/i,
                  /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                  /(icab)[\/ ]([23]\.[\d\.]+)/i,
                  /\b(libweb)/i,
                ],
                [de, nt],
                [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                [nt, de],
              ],
              os: [
                [/microsoft (windows) (vista|xp)/i],
                [de, nt],
                [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i],
                [de, [nt, or, Yt]],
                [
                  /windows nt 6\.2; (arm)/i,
                  /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
                  /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i,
                ],
                [
                  [nt, or, Yt],
                  [de, "Windows"],
                ],
                [
                  /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                  /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
                  /cfnetwork\/.+darwin/i,
                ],
                [
                  [nt, /_/g, "."],
                  [de, "iOS"],
                ],
                [
                  /(mac os x) ?([\w\. ]*)/i,
                  /(macintosh|mac_powerpc\b)(?!.+haiku)/i,
                ],
                [
                  [de, tr],
                  [nt, /_/g, "."],
                ],
                [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                [nt, de],
                [
                  /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i,
                  /(blackberry)\w*\/([\w\.]*)/i,
                  /(tizen|kaios)[\/ ]([\w\.]+)/i,
                  /\((series40);/i,
                ],
                [de, nt],
                [/\(bb(10);/i],
                [nt, [de, Dt]],
                [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                [nt, [de, "Symbian"]],
                [
                  /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i,
                ],
                [nt, [de, Ft + " OS"]],
                [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                [nt, [de, "webOS"]],
                [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],
                [nt, [de, "watchOS"]],
                [/crkey\/([\d\.]+)/i],
                [nt, [de, Ht + "cast"]],
                [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],
                [[de, $n], nt],
                [
                  /panasonic;(viera)/i,
                  /(netrange)mmh/i,
                  /(nettv)\/(\d+\.[\w\.]+)/i,
                  /(nintendo|playstation) ([wids345portablevuch]+)/i,
                  /(xbox); +xbox ([^\);]+)/i,
                  /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                  /(mint)[\/\(\) ]?(\w*)/i,
                  /(mageia|vectorlinux)[; ]/i,
                  /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                  /(hurd|linux) ?([\w\.]*)/i,
                  /(gnu) ?([\w\.]*)/i,
                  /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                  /(haiku) (\w+)/i,
                ],
                [de, nt],
                [/(sunos) ?([\w\.\d]*)/i],
                [[de, "Solaris"], nt],
                [
                  /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                  /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                  /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
                  /(unix) ?([\w\.]*)/i,
                ],
                [de, nt],
              ],
            },
            hn = function (mn, Vn) {
              if (
                (typeof mn === u && ((Vn = mn), (mn = r)),
                !(this instanceof hn))
              )
                return new hn(mn, Vn).getResult();
              var Fn = typeof t !== c && t.navigator ? t.navigator : r,
                nr = mn || (Fn && Fn.userAgent ? Fn.userAgent : o),
                yr = Fn && Fn.userAgentData ? Fn.userAgentData : r,
                qn = Vn ? _r(Gt, Vn) : Gt,
                jn = Fn && Fn.userAgent == nr;
              return (
                (this.getBrowser = function () {
                  var Jn = {};
                  return (
                    (Jn[de] = r),
                    (Jn[nt] = r),
                    In.call(Jn, nr, qn.browser),
                    (Jn[N] = zn(Jn[nt])),
                    jn &&
                      Fn &&
                      Fn.brave &&
                      typeof Fn.brave.isBrave == l &&
                      (Jn[de] = "Brave"),
                    Jn
                  );
                }),
                (this.getCPU = function () {
                  var Jn = {};
                  return (Jn[Be] = r), In.call(Jn, nr, qn.cpu), Jn;
                }),
                (this.getDevice = function () {
                  var Jn = {};
                  return (
                    (Jn[Ye] = r),
                    (Jn[P] = r),
                    (Jn[me] = r),
                    In.call(Jn, nr, qn.device),
                    jn && !Jn[me] && yr && yr.mobile && (Jn[me] = st),
                    jn &&
                      Jn[P] == "Macintosh" &&
                      Fn &&
                      typeof Fn.standalone !== c &&
                      Fn.maxTouchPoints &&
                      Fn.maxTouchPoints > 2 &&
                      ((Jn[P] = "iPad"), (Jn[me] = vt)),
                    Jn
                  );
                }),
                (this.getEngine = function () {
                  var Jn = {};
                  return (
                    (Jn[de] = r), (Jn[nt] = r), In.call(Jn, nr, qn.engine), Jn
                  );
                }),
                (this.getOS = function () {
                  var Jn = {};
                  return (
                    (Jn[de] = r),
                    (Jn[nt] = r),
                    In.call(Jn, nr, qn.os),
                    jn &&
                      !Jn[de] &&
                      yr &&
                      yr.platform &&
                      yr.platform != "Unknown" &&
                      (Jn[de] = yr.platform
                        .replace(/chrome os/i, $n)
                        .replace(/macos/i, tr)),
                    Jn
                  );
                }),
                (this.getResult = function () {
                  return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU(),
                  };
                }),
                (this.getUA = function () {
                  return nr;
                }),
                (this.setUA = function (Jn) {
                  return (
                    (nr = typeof Jn === p && Jn.length > bt ? rn(Jn, bt) : Jn),
                    this
                  );
                }),
                this.setUA(nr),
                this
              );
            };
          (hn.VERSION = s),
            (hn.BROWSER = Bn([de, nt, N])),
            (hn.CPU = Bn([Be])),
            (hn.DEVICE = Bn([P, Ye, me, ot, st, xt, vt, St, wt])),
            (hn.ENGINE = hn.OS = Bn([de, nt])),
            n.exports && (e = n.exports = hn),
            (e.UAParser = hn);
          var En = typeof t !== c && (t.jQuery || t.Zepto);
          if (En && !En.ua) {
            var Ln = new hn();
            (En.ua = Ln.getResult()),
              (En.ua.get = function () {
                return Ln.getUA();
              }),
              (En.ua.set = function (mn) {
                Ln.setUA(mn);
                var Vn = Ln.getResult();
                for (var Fn in Vn) En.ua[Fn] = Vn[Fn];
              });
          }
        })(typeof window == "object" ? window : uaParser_min);
      })(uaParser_min$1, uaParser_min$1.exports)),
    uaParser_min$1.exports
  );
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  (hasRequiredLib$1 = 1),
    Object.defineProperty(lib$1, "__esModule", { value: !0 });
  function n(Sn) {
    return Sn && typeof Sn == "object" && "default" in Sn ? Sn.default : Sn;
  }
  var e = requireReact(),
    t = n(e),
    r = requireUaParser_min(),
    s = new r(),
    o = s.getBrowser(),
    a = s.getCPU(),
    l = s.getDevice(),
    c = s.getEngine(),
    u = s.getOS(),
    p = s.getUA(),
    N = function (en) {
      return s.setUA(en);
    },
    P = function (en) {
      if (!en) {
        console.error("No userAgent string was provided");
        return;
      }
      var ln = new r(en);
      return {
        UA: ln,
        browser: ln.getBrowser(),
        cpu: ln.getCPU(),
        device: ln.getDevice(),
        engine: ln.getEngine(),
        os: ln.getOS(),
        ua: ln.getUA(),
        setUserAgent: function (rr) {
          return ln.setUA(rr);
        },
      };
    },
    de = Object.freeze({
      ClientUAInstance: s,
      browser: o,
      cpu: a,
      device: l,
      engine: c,
      os: u,
      ua: p,
      setUa: N,
      parseUserAgent: P,
    });
  function me(Sn, en) {
    var ln = Object.keys(Sn);
    if (Object.getOwnPropertySymbols) {
      var Un = Object.getOwnPropertySymbols(Sn);
      en &&
        (Un = Un.filter(function (rr) {
          return Object.getOwnPropertyDescriptor(Sn, rr).enumerable;
        })),
        ln.push.apply(ln, Un);
    }
    return ln;
  }
  function Ye(Sn) {
    for (var en = 1; en < arguments.length; en++) {
      var ln = arguments[en] != null ? arguments[en] : {};
      en % 2
        ? me(Object(ln), !0).forEach(function (Un) {
            vt(Sn, Un, ln[Un]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(Sn, Object.getOwnPropertyDescriptors(ln))
        : me(Object(ln)).forEach(function (Un) {
            Object.defineProperty(
              Sn,
              Un,
              Object.getOwnPropertyDescriptor(ln, Un)
            );
          });
    }
    return Sn;
  }
  function nt(Sn) {
    "@babel/helpers - typeof";
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (nt = function (en) {
            return typeof en;
          })
        : (nt = function (en) {
            return en &&
              typeof Symbol == "function" &&
              en.constructor === Symbol &&
              en !== Symbol.prototype
              ? "symbol"
              : typeof en;
          }),
      nt(Sn)
    );
  }
  function Be(Sn, en) {
    if (!(Sn instanceof en))
      throw new TypeError("Cannot call a class as a function");
  }
  function ot(Sn, en) {
    for (var ln = 0; ln < en.length; ln++) {
      var Un = en[ln];
      (Un.enumerable = Un.enumerable || !1),
        (Un.configurable = !0),
        "value" in Un && (Un.writable = !0),
        Object.defineProperty(Sn, Un.key, Un);
    }
  }
  function st(Sn, en, ln) {
    return en && ot(Sn.prototype, en), Sn;
  }
  function vt(Sn, en, ln) {
    return (
      en in Sn
        ? Object.defineProperty(Sn, en, {
            value: ln,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (Sn[en] = ln),
      Sn
    );
  }
  function xt() {
    return (
      (xt =
        Object.assign ||
        function (Sn) {
          for (var en = 1; en < arguments.length; en++) {
            var ln = arguments[en];
            for (var Un in ln)
              Object.prototype.hasOwnProperty.call(ln, Un) && (Sn[Un] = ln[Un]);
          }
          return Sn;
        }),
      xt.apply(this, arguments)
    );
  }
  function St(Sn, en) {
    if (typeof en != "function" && en !== null)
      throw new TypeError("Super expression must either be null or a function");
    (Sn.prototype = Object.create(en && en.prototype, {
      constructor: { value: Sn, writable: !0, configurable: !0 },
    })),
      en && bt(Sn, en);
  }
  function wt(Sn) {
    return (
      (wt = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (ln) {
            return ln.__proto__ || Object.getPrototypeOf(ln);
          }),
      wt(Sn)
    );
  }
  function bt(Sn, en) {
    return (
      (bt =
        Object.setPrototypeOf ||
        function (Un, rr) {
          return (Un.__proto__ = rr), Un;
        }),
      bt(Sn, en)
    );
  }
  function Tt(Sn, en) {
    if (Sn == null) return {};
    var ln = {},
      Un = Object.keys(Sn),
      rr,
      Yr;
    for (Yr = 0; Yr < Un.length; Yr++)
      (rr = Un[Yr]), !(en.indexOf(rr) >= 0) && (ln[rr] = Sn[rr]);
    return ln;
  }
  function Ct(Sn, en) {
    if (Sn == null) return {};
    var ln = Tt(Sn, en),
      Un,
      rr;
    if (Object.getOwnPropertySymbols) {
      var Yr = Object.getOwnPropertySymbols(Sn);
      for (rr = 0; rr < Yr.length; rr++)
        (Un = Yr[rr]),
          !(en.indexOf(Un) >= 0) &&
            Object.prototype.propertyIsEnumerable.call(Sn, Un) &&
            (ln[Un] = Sn[Un]);
    }
    return ln;
  }
  function kt(Sn) {
    if (Sn === void 0)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return Sn;
  }
  function Dt(Sn, en) {
    if (en && (typeof en == "object" || typeof en == "function")) return en;
    if (en !== void 0)
      throw new TypeError(
        "Derived constructors may only return object or undefined"
      );
    return kt(Sn);
  }
  function Vt(Sn, en) {
    return Ht(Sn) || qt(Sn, en) || Ft(Sn, en) || Mt();
  }
  function Ht(Sn) {
    if (Array.isArray(Sn)) return Sn;
  }
  function qt(Sn, en) {
    var ln =
      Sn == null
        ? null
        : (typeof Symbol < "u" && Sn[Symbol.iterator]) || Sn["@@iterator"];
    if (ln != null) {
      var Un = [],
        rr = !0,
        Yr = !1,
        yi,
        Zi;
      try {
        for (
          ln = ln.call(Sn);
          !(rr = (yi = ln.next()).done) &&
          (Un.push(yi.value), !(en && Un.length === en));
          rr = !0
        );
      } catch (Yo) {
        (Yr = !0), (Zi = Yo);
      } finally {
        try {
          !rr && ln.return != null && ln.return();
        } finally {
          if (Yr) throw Zi;
        }
      }
      return Un;
    }
  }
  function Ft(Sn, en) {
    if (Sn) {
      if (typeof Sn == "string") return Bt(Sn, en);
      var ln = Object.prototype.toString.call(Sn).slice(8, -1);
      if (
        (ln === "Object" && Sn.constructor && (ln = Sn.constructor.name),
        ln === "Map" || ln === "Set")
      )
        return Array.from(Sn);
      if (
        ln === "Arguments" ||
        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ln)
      )
        return Bt(Sn, en);
    }
  }
  function Bt(Sn, en) {
    (en == null || en > Sn.length) && (en = Sn.length);
    for (var ln = 0, Un = new Array(en); ln < en; ln++) Un[ln] = Sn[ln];
    return Un;
  }
  function Mt() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var Pt = {
      Mobile: "mobile",
      Tablet: "tablet",
      SmartTv: "smarttv",
      Console: "console",
      Wearable: "wearable",
      Embedded: "embedded",
      Browser: void 0,
    },
    It = {
      Chrome: "Chrome",
      Firefox: "Firefox",
      Opera: "Opera",
      Yandex: "Yandex",
      Safari: "Safari",
      InternetExplorer: "Internet Explorer",
      Edge: "Edge",
      Chromium: "Chromium",
      Ie: "IE",
      MobileSafari: "Mobile Safari",
      EdgeChromium: "Edge Chromium",
      MIUI: "MIUI Browser",
      SamsungBrowser: "Samsung Browser",
    },
    Ot = {
      IOS: "iOS",
      Android: "Android",
      WindowsPhone: "Windows Phone",
      Windows: "Windows",
      MAC_OS: "Mac OS",
    },
    Xt = {
      isMobile: !1,
      isTablet: !1,
      isBrowser: !1,
      isSmartTV: !1,
      isConsole: !1,
      isWearable: !1,
    },
    sn = function (en) {
      switch (en) {
        case Pt.Mobile:
          return { isMobile: !0 };
        case Pt.Tablet:
          return { isTablet: !0 };
        case Pt.SmartTv:
          return { isSmartTV: !0 };
        case Pt.Console:
          return { isConsole: !0 };
        case Pt.Wearable:
          return { isWearable: !0 };
        case Pt.Browser:
          return { isBrowser: !0 };
        case Pt.Embedded:
          return { isEmbedded: !0 };
        default:
          return Xt;
      }
    },
    Kt = function (en) {
      return N(en);
    },
    tn = function (en) {
      var ln =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
      return en || ln;
    },
    pn = function () {
      return typeof window < "u" && (window.navigator || navigator)
        ? window.navigator || navigator
        : !1;
    },
    _n = function (en) {
      var ln = pn();
      return (
        ln &&
        ln.platform &&
        (ln.platform.indexOf(en) !== -1 ||
          (ln.platform === "MacIntel" &&
            ln.maxTouchPoints > 1 &&
            !window.MSStream))
      );
    },
    bn = function (en, ln, Un, rr, Yr) {
      return {
        isBrowser: en,
        browserMajorVersion: tn(ln.major),
        browserFullVersion: tn(ln.version),
        browserName: tn(ln.name),
        engineName: tn(Un.name),
        engineVersion: tn(Un.version),
        osName: tn(rr.name),
        osVersion: tn(rr.version),
        userAgent: tn(Yr),
      };
    },
    $n = function (en, ln, Un, rr) {
      return Ye({}, en, {
        vendor: tn(ln.vendor),
        model: tn(ln.model),
        os: tn(Un.name),
        osVersion: tn(Un.version),
        ua: tn(rr),
      });
    },
    tr = function (en, ln, Un, rr) {
      return {
        isSmartTV: en,
        engineName: tn(ln.name),
        engineVersion: tn(ln.version),
        osName: tn(Un.name),
        osVersion: tn(Un.version),
        userAgent: tn(rr),
      };
    },
    ur = function (en, ln, Un, rr) {
      return {
        isConsole: en,
        engineName: tn(ln.name),
        engineVersion: tn(ln.version),
        osName: tn(Un.name),
        osVersion: tn(Un.version),
        userAgent: tn(rr),
      };
    },
    _r = function (en, ln, Un, rr) {
      return {
        isWearable: en,
        engineName: tn(ln.name),
        engineVersion: tn(ln.version),
        osName: tn(Un.name),
        osVersion: tn(Un.version),
        userAgent: tn(rr),
      };
    },
    Bn = function (en, ln, Un, rr, Yr) {
      return {
        isEmbedded: en,
        vendor: tn(ln.vendor),
        model: tn(ln.model),
        engineName: tn(Un.name),
        engineVersion: tn(Un.version),
        osName: tn(rr.name),
        osVersion: tn(rr.version),
        userAgent: tn(Yr),
      };
    };
  function jt(Sn) {
    var en = Sn ? P(Sn) : de,
      ln = en.device,
      Un = en.browser,
      rr = en.engine,
      Yr = en.os,
      yi = en.ua,
      Zi = sn(ln.type),
      Yo = Zi.isBrowser,
      Wa = Zi.isMobile,
      ja = Zi.isTablet,
      xs = Zi.isSmartTV,
      Tl = Zi.isConsole,
      Ps = Zi.isWearable,
      $a = Zi.isEmbedded;
    if (Yo) return bn(Yo, Un, rr, Yr, yi);
    if (xs) return tr(xs, rr, Yr, yi);
    if (Tl) return ur(Tl, rr, Yr, yi);
    if (Wa || ja) return $n(Zi, ln, Yr, yi);
    if (Ps) return _r(Ps, rr, Yr, yi);
    if ($a) return Bn($a, ln, rr, Yr, yi);
  }
  var Yn = function (en) {
      var ln = en.type;
      return ln === Pt.Mobile;
    },
    zn = function (en) {
      var ln = en.type;
      return ln === Pt.Tablet;
    },
    rn = function (en) {
      var ln = en.type;
      return ln === Pt.Mobile || ln === Pt.Tablet;
    },
    In = function (en) {
      var ln = en.type;
      return ln === Pt.SmartTv;
    },
    or = function (en) {
      var ln = en.type;
      return ln === Pt.Browser;
    },
    Gn = function (en) {
      var ln = en.type;
      return ln === Pt.Wearable;
    },
    Yt = function (en) {
      var ln = en.type;
      return ln === Pt.Console;
    },
    Gt = function (en) {
      var ln = en.type;
      return ln === Pt.Embedded;
    },
    hn = function (en) {
      var ln = en.vendor;
      return tn(ln);
    },
    En = function (en) {
      var ln = en.model;
      return tn(ln);
    },
    Ln = function (en) {
      var ln = en.type;
      return tn(ln, "browser");
    },
    mn = function (en) {
      var ln = en.name;
      return ln === Ot.Android;
    },
    Vn = function (en) {
      var ln = en.name;
      return ln === Ot.Windows;
    },
    Fn = function (en) {
      var ln = en.name;
      return ln === Ot.MAC_OS;
    },
    nr = function (en) {
      var ln = en.name;
      return ln === Ot.WindowsPhone;
    },
    yr = function (en) {
      var ln = en.name;
      return ln === Ot.IOS;
    },
    qn = function (en) {
      var ln = en.version;
      return tn(ln);
    },
    jn = function (en) {
      var ln = en.name;
      return tn(ln);
    },
    Jn = function (en) {
      var ln = en.name;
      return ln === It.Chrome;
    },
    mr = function (en) {
      var ln = en.name;
      return ln === It.Firefox;
    },
    Sr = function (en) {
      var ln = en.name;
      return ln === It.Chromium;
    },
    Ur = function (en) {
      var ln = en.name;
      return ln === It.Edge;
    },
    Pr = function (en) {
      var ln = en.name;
      return ln === It.Yandex;
    },
    Hr = function (en) {
      var ln = en.name;
      return ln === It.Safari || ln === It.MobileSafari;
    },
    cn = function (en) {
      var ln = en.name;
      return ln === It.MobileSafari;
    },
    An = function (en) {
      var ln = en.name;
      return ln === It.Opera;
    },
    Mn = function (en) {
      var ln = en.name;
      return ln === It.InternetExplorer || ln === It.Ie;
    },
    Hn = function (en) {
      var ln = en.name;
      return ln === It.MIUI;
    },
    hr = function (en) {
      var ln = en.name;
      return ln === It.SamsungBrowser;
    },
    pr = function (en) {
      var ln = en.version;
      return tn(ln);
    },
    jr = function (en) {
      var ln = en.major;
      return tn(ln);
    },
    fi = function (en) {
      var ln = en.name;
      return tn(ln);
    },
    wi = function (en) {
      var ln = en.name;
      return tn(ln);
    },
    wr = function (en) {
      var ln = en.version;
      return tn(ln);
    },
    Rr = function () {
      var en = pn(),
        ln = en && en.userAgent && en.userAgent.toLowerCase();
      return typeof ln == "string" ? /electron/.test(ln) : !1;
    },
    $r = function (en) {
      return typeof en == "string" && en.indexOf("Edg/") !== -1;
    },
    xr = function () {
      var en = pn();
      return (
        en &&
        (/iPad|iPhone|iPod/.test(en.platform) ||
          (en.platform === "MacIntel" && en.maxTouchPoints > 1)) &&
        !window.MSStream
      );
    },
    Fr = function () {
      return _n("iPad");
    },
    Cr = function () {
      return _n("iPhone");
    },
    zr = function () {
      return _n("iPod");
    },
    pi = function (en) {
      return tn(en);
    };
  function qr(Sn) {
    var en = Sn || de,
      ln = en.device,
      Un = en.browser,
      rr = en.os,
      Yr = en.engine,
      yi = en.ua;
    return {
      isSmartTV: In(ln),
      isConsole: Yt(ln),
      isWearable: Gn(ln),
      isEmbedded: Gt(ln),
      isMobileSafari: cn(Un) || Fr(),
      isChromium: Sr(Un),
      isMobile: rn(ln) || Fr(),
      isMobileOnly: Yn(ln),
      isTablet: zn(ln) || Fr(),
      isBrowser: or(ln),
      isDesktop: or(ln),
      isAndroid: mn(rr),
      isWinPhone: nr(rr),
      isIOS: yr(rr) || Fr(),
      isChrome: Jn(Un),
      isFirefox: mr(Un),
      isSafari: Hr(Un),
      isOpera: An(Un),
      isIE: Mn(Un),
      osVersion: qn(rr),
      osName: jn(rr),
      fullBrowserVersion: pr(Un),
      browserVersion: jr(Un),
      browserName: fi(Un),
      mobileVendor: hn(ln),
      mobileModel: En(ln),
      engineName: wi(Yr),
      engineVersion: wr(Yr),
      getUA: pi(yi),
      isEdge: Ur(Un) || $r(yi),
      isYandex: Pr(Un),
      deviceType: Ln(ln),
      isIOS13: xr(),
      isIPad13: Fr(),
      isIPhone13: Cr(),
      isIPod13: zr(),
      isElectron: Rr(),
      isEdgeChromium: $r(yi),
      isLegacyEdge: Ur(Un) && !$r(yi),
      isWindows: Vn(rr),
      isMacOs: Fn(rr),
      isMIUI: Hn(Un),
      isSamsungBrowser: hr(Un),
    };
  }
  var Ir = In(l),
    Pi = Yt(l),
    mi = Gn(l),
    Ut = Gt(l),
    $t = cn(o) || Fr(),
    un = Sr(o),
    yn = rn(l) || Fr(),
    Rn = Yn(l),
    kn = zn(l) || Fr(),
    er = or(l),
    Xn = or(l),
    zt = mn(u),
    Zt = nr(u),
    an = yr(u) || Fr(),
    Qt = Jn(o),
    fn = mr(o),
    wn = Hr(o),
    On = An(o),
    Kn = Mn(o),
    Zn = qn(u),
    ar = jn(u),
    cr = pr(o),
    Qn = jr(o),
    gr = fi(o),
    Tr = hn(l),
    Qr = En(l),
    Dr = wi(c),
    Br = wr(c),
    Mr = pi(p),
    oi = Ur(o) || $r(p),
    Xr = Pr(o),
    ti = Ln(l),
    bi = xr(),
    ni = Fr(),
    ai = Cr(),
    Kr = zr(),
    Ii = Rr(),
    gi = $r(p),
    Mi = Ur(o) && !$r(p),
    Ui = Vn(u),
    di = Fn(u),
    ps = Hn(o),
    la = hr(o),
    El = function (en) {
      if (!en || typeof en != "string") {
        console.error("No valid user agent string was provided");
        return;
      }
      var ln = P(en),
        Un = ln.device,
        rr = ln.browser,
        Yr = ln.os,
        yi = ln.engine,
        Zi = ln.ua;
      return qr({ device: Un, browser: rr, os: Yr, engine: yi, ua: Zi });
    },
    oc = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return zt
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    za = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return er
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    Va = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return Kn
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    Eo = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return an
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    Ga = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return yn
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    qs = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return kn
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    ci = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return Zt
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    ro = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children;
      en.viewClassName, en.style;
      var rr = Ct(en, [
        "renderWithFragment",
        "children",
        "viewClassName",
        "style",
      ]);
      return Rn
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    To = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return Ir
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    Xo = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return Pi
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    po = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children,
        rr = Ct(en, ["renderWithFragment", "children"]);
      return mi
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", rr, Un)
        : null;
    },
    Zc = function (en) {
      var ln = en.renderWithFragment,
        Un = en.children;
      en.viewClassName, en.style;
      var rr = en.condition,
        Yr = Ct(en, [
          "renderWithFragment",
          "children",
          "viewClassName",
          "style",
          "condition",
        ]);
      return rr
        ? ln
          ? t.createElement(e.Fragment, null, Un)
          : t.createElement("div", Yr, Un)
        : null;
    };
  function ji(Sn) {
    return (function (en) {
      St(ln, en);
      function ln(Un) {
        var rr;
        return (
          Be(this, ln),
          (rr = Dt(this, wt(ln).call(this, Un))),
          (rr.isEventListenerAdded = !1),
          (rr.handleOrientationChange = rr.handleOrientationChange.bind(
            kt(rr)
          )),
          (rr.onOrientationChange = rr.onOrientationChange.bind(kt(rr))),
          (rr.onPageLoad = rr.onPageLoad.bind(kt(rr))),
          (rr.state = { isLandscape: !1, isPortrait: !1 }),
          rr
        );
      }
      return (
        st(ln, [
          {
            key: "handleOrientationChange",
            value: function () {
              this.isEventListenerAdded || (this.isEventListenerAdded = !0);
              var rr = window.innerWidth > window.innerHeight ? 90 : 0;
              this.setState({ isPortrait: rr === 0, isLandscape: rr === 90 });
            },
          },
          {
            key: "onOrientationChange",
            value: function () {
              this.handleOrientationChange();
            },
          },
          {
            key: "onPageLoad",
            value: function () {
              this.handleOrientationChange();
            },
          },
          {
            key: "componentDidMount",
            value: function () {
              (typeof window > "u" ? "undefined" : nt(window)) !== void 0 &&
                yn &&
                (this.isEventListenerAdded
                  ? window.removeEventListener("load", this.onPageLoad, !1)
                  : (this.handleOrientationChange(),
                    window.addEventListener("load", this.onPageLoad, !1)),
                window.addEventListener(
                  "resize",
                  this.onOrientationChange,
                  !1
                ));
            },
          },
          {
            key: "componentWillUnmount",
            value: function () {
              window.removeEventListener(
                "resize",
                this.onOrientationChange,
                !1
              );
            },
          },
          {
            key: "render",
            value: function () {
              return t.createElement(
                Sn,
                xt({}, this.props, {
                  isLandscape: this.state.isLandscape,
                  isPortrait: this.state.isPortrait,
                })
              );
            },
          },
        ]),
        ln
      );
    })(t.Component);
  }
  function bo() {
    var Sn = e.useState(function () {
        var Yr = window.innerWidth > window.innerHeight ? 90 : 0;
        return {
          isPortrait: Yr === 0,
          isLandscape: Yr === 90,
          orientation: Yr === 0 ? "portrait" : "landscape",
        };
      }),
      en = Vt(Sn, 2),
      ln = en[0],
      Un = en[1],
      rr = e.useCallback(
        function () {
          var Yr = window.innerWidth > window.innerHeight ? 90 : 0,
            yi = {
              isPortrait: Yr === 0,
              isLandscape: Yr === 90,
              orientation: Yr === 0 ? "portrait" : "landscape",
            };
          ln.orientation !== yi.orientation && Un(yi);
        },
        [ln.orientation]
      );
    return (
      e.useEffect(
        function () {
          return (
            (typeof window > "u" ? "undefined" : nt(window)) !== void 0 &&
              yn &&
              (rr(),
              window.addEventListener("load", rr, !1),
              window.addEventListener("resize", rr, !1)),
            function () {
              window.removeEventListener("resize", rr, !1),
                window.removeEventListener("load", rr, !1);
            }
          );
        },
        [rr]
      ),
      ln
    );
  }
  function ac(Sn) {
    var en = Sn || window.navigator.userAgent;
    return P(en);
  }
  function Ha(Sn) {
    var en = Sn || window.navigator.userAgent,
      ln = ac(en),
      Un = qr(ln);
    return [Un, ln];
  }
  return (
    (lib$1.AndroidView = oc),
    (lib$1.BrowserTypes = It),
    (lib$1.BrowserView = za),
    (lib$1.ConsoleView = Xo),
    (lib$1.CustomView = Zc),
    (lib$1.IEView = Va),
    (lib$1.IOSView = Eo),
    (lib$1.MobileOnlyView = ro),
    (lib$1.MobileView = Ga),
    (lib$1.OsTypes = Ot),
    (lib$1.SmartTVView = To),
    (lib$1.TabletView = qs),
    (lib$1.WearableView = po),
    (lib$1.WinPhoneView = ci),
    (lib$1.browserName = gr),
    (lib$1.browserVersion = Qn),
    (lib$1.deviceDetect = jt),
    (lib$1.deviceType = ti),
    (lib$1.engineName = Dr),
    (lib$1.engineVersion = Br),
    (lib$1.fullBrowserVersion = cr),
    (lib$1.getSelectorsByUserAgent = El),
    (lib$1.getUA = Mr),
    (lib$1.isAndroid = zt),
    (lib$1.isBrowser = er),
    (lib$1.isChrome = Qt),
    (lib$1.isChromium = un),
    (lib$1.isConsole = Pi),
    (lib$1.isDesktop = Xn),
    (lib$1.isEdge = oi),
    (lib$1.isEdgeChromium = gi),
    (lib$1.isElectron = Ii),
    (lib$1.isEmbedded = Ut),
    (lib$1.isFirefox = fn),
    (lib$1.isIE = Kn),
    (lib$1.isIOS = an),
    (lib$1.isIOS13 = bi),
    (lib$1.isIPad13 = ni),
    (lib$1.isIPhone13 = ai),
    (lib$1.isIPod13 = Kr),
    (lib$1.isLegacyEdge = Mi),
    (lib$1.isMIUI = ps),
    (lib$1.isMacOs = di),
    (lib$1.isMobile = yn),
    (lib$1.isMobileOnly = Rn),
    (lib$1.isMobileSafari = $t),
    (lib$1.isOpera = On),
    (lib$1.isSafari = wn),
    (lib$1.isSamsungBrowser = la),
    (lib$1.isSmartTV = Ir),
    (lib$1.isTablet = kn),
    (lib$1.isWearable = mi),
    (lib$1.isWinPhone = Zt),
    (lib$1.isWindows = Ui),
    (lib$1.isYandex = Xr),
    (lib$1.mobileModel = Qr),
    (lib$1.mobileVendor = Tr),
    (lib$1.osName = ar),
    (lib$1.osVersion = Zn),
    (lib$1.parseUserAgent = P),
    (lib$1.setUserAgent = Kt),
    (lib$1.useDeviceData = ac),
    (lib$1.useDeviceSelectors = Ha),
    (lib$1.useMobileOrientation = bo),
    (lib$1.withOrientationChange = ji),
    lib$1
  );
}
var libExports = requireLib$1();
const useDeviceType = () => ({
    deviceType: reactExports.useMemo(
      () => (libExports.isMobileOnly ? "mobile" : "desktop"),
      [libExports.isMobileOnly]
    ),
    isTouchDevices: libExports.isMobile,
  }),
  OrbitingDot = ({
    width: n,
    height: e,
    orbitWidth: t,
    orbitColor: r = "#fff",
    top: s = "auto",
    left: o = "auto",
    right: a = "auto",
    bottom: l = "auto",
    angle: c = 0,
    duration: u = 4,
    idSuffix: p,
    visibilityKeyframes: N = {
      startVisible: 0,
      startHidden: 0.35,
      endHidden: 0.75,
      endVisible: 1,
    },
    gradientTransform: P = "rotate(90)",
    gradientColors: de = {
      startColor: "rgba(255, 255, 255, 0.4)",
      endColor: "rgba(255, 255, 255, 0)",
      startOffset: 0,
      endOffset: 24,
    },
  }) => {
    const { isTouchDevices: me } = useDeviceType();
    if (me) return null;
    const Ye = `
  M ${(n * 16) / 2},0 
  a ${(n * 16) / 2},${(e * 16) / 2} 0 1,1 0,${e * 16}
  a ${(n * 16) / 2},${(e * 16) / 2} 0 1,1 0,-${e * 16}
`,
      nt = `orbit-gradient-${p}`;
    return jsxRuntimeExports.jsxs(OrbitContainer, {
      width: n,
      height: e,
      top: s,
      left: o,
      right: a,
      bottom: l,
      angle: c,
      children: [
        jsxRuntimeExports.jsxs(OrbitPath, {
          width: n * 16,
          height: e * 16,
          viewBox: `0 0 ${n * 16} ${e * 16}`,
          children: [
            jsxRuntimeExports.jsx("defs", {
              children: jsxRuntimeExports.jsxs("linearGradient", {
                id: nt,
                gradientUnits: "userSpaceOnUse",
                gradientTransform: P,
                children: [
                  jsxRuntimeExports.jsx("stop", {
                    offset: `${de.startOffset}%`,
                    stopColor: de.startColor,
                  }),
                  jsxRuntimeExports.jsx("stop", {
                    offset: `${de.endOffset}%`,
                    stopColor: de.endColor,
                  }),
                ],
              }),
            }),
            jsxRuntimeExports.jsx("path", {
              d: Ye,
              fill: "none",
              stroke: `url(#${nt})`,
              strokeWidth: t,
            }),
          ],
        }),
        jsxRuntimeExports.jsxs(OrbitPath, {
          width: n * 16,
          height: e * 16,
          viewBox: `0 0 ${n * 16} ${e * 16}`,
          children: [
            jsxRuntimeExports.jsx("path", {
              d: Ye,
              fill: "transparent",
              stroke: "transparent",
              strokeWidth: t,
            }),
            jsxRuntimeExports.jsx(OrbitDot, {
              r: t * 1,
              fill: r,
              duration: u,
              keyframesConfig: N,
              children: jsxRuntimeExports.jsx("animateMotion", {
                dur: `${u}s`,
                repeatCount: "indefinite",
                path: Ye,
              }),
            }),
          ],
        }),
      ],
    });
  },
  useBreakpoints = () => {
    const [n, e] = reactExports.useState("small");
    return (
      reactExports.useEffect(() => {
        const t = () => {
          const r = window.innerWidth;
          r <= 767
            ? e("small")
            : r >= 768 && r <= 1280
            ? e("medium")
            : r >= 1281 && r <= 1440
            ? e("large")
            : r >= 1441 && r <= 1920
            ? e("extraLarge")
            : e("extraWIde");
        };
        return (
          window.addEventListener("resize", t),
          t(),
          () => {
            window.removeEventListener("resize", t);
          }
        );
      }, []),
      n
    );
  },
  mainParams = {
    small: {
      width: 58.125,
      height: 19.875,
      orbitWidth: 2,
      top: "40vh",
      left: "auto",
      right: "-15vw",
      bottom: "auto",
      angle: 55,
      duration: 5,
      idSuffix: "main",
      visibilityKeyframes: {
        startVisible: 0.28,
        startHidden: 0.33,
        endHidden: 0.68,
        endVisible: 0.72,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 24,
      },
    },
    medium: {
      width: 55.125,
      height: 19.875,
      orbitWidth: 2,
      top: "30vh",
      left: "auto",
      right: "30vw",
      bottom: "auto",
      angle: 65,
      duration: 5,
      idSuffix: "main",
      visibilityKeyframes: {
        startVisible: 0.28,
        startHidden: 0.33,
        endHidden: 0.68,
        endVisible: 0.72,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 28,
      },
    },
    large: {
      width: 60.125,
      height: 18.875,
      orbitWidth: 2,
      top: "40vh",
      left: "11vw",
      right: "auto",
      bottom: "auto",
      angle: 65,
      duration: 5,
      idSuffix: "main",
      visibilityKeyframes: {
        startVisible: 0.28,
        startHidden: 0.33,
        endHidden: 0.68,
        endVisible: 0.72,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 24,
      },
    },
    extraLarge: {
      width: 68.125,
      height: 21.875,
      orbitWidth: 2,
      top: "45vh",
      left: "10vw",
      right: "auto",
      bottom: "auto",
      angle: 55,
      duration: 5,
      idSuffix: "main",
      visibilityKeyframes: {
        startVisible: 0.28,
        startHidden: 0.33,
        endHidden: 0.68,
        endVisible: 0.72,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 24,
      },
    },
    extraWIde: {
      width: 78.125,
      height: 27.875,
      orbitWidth: 2,
      top: "55vh",
      left: "5vw",
      right: "auto",
      bottom: "auto",
      angle: 55,
      duration: 5,
      idSuffix: "main",
      visibilityKeyframes: {
        startVisible: 0.28,
        startHidden: 0.33,
        endHidden: 0.68,
        endVisible: 0.72,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 28,
      },
    },
  },
  mainMiniParams = {
    small: {
      width: 40.625,
      height: 15.625,
      orbitWidth: 2,
      top: "20vh",
      left: "25vw",
      right: "auto",
      bottom: "auto",
      angle: 245,
      duration: 7,
      idSuffix: "main-mini",
      visibilityKeyframes: {
        startVisible: 0.27,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.75,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 35,
      },
    },
    medium: {
      width: 30.625,
      height: 12.625,
      orbitWidth: 2,
      top: "40vh",
      left: "auto",
      right: "0vw",
      bottom: "auto",
      angle: 245,
      duration: 7,
      idSuffix: "main-mini",
      visibilityKeyframes: {
        startVisible: 0.27,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.75,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 30,
      },
    },
    large: {
      width: 37.625,
      height: 12.625,
      orbitWidth: 2,
      top: "45vh",
      left: "auto",
      right: "-5vw",
      bottom: "auto",
      angle: 120,
      duration: 7,
      idSuffix: "main-mini",
      visibilityKeyframes: {
        startVisible: 0.27,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.75,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 30,
      },
    },
    extraLarge: {
      width: 38.625,
      height: 15.625,
      orbitWidth: 2,
      top: "40vh",
      left: "52vw",
      right: "auto",
      bottom: "auto",
      angle: 120,
      duration: 7,
      idSuffix: "main-mini",
      visibilityKeyframes: {
        startVisible: 0.27,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.75,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 30,
      },
    },
    extraWIde: {
      width: 38.625,
      height: 15.625,
      orbitWidth: 2,
      top: "45vh",
      left: "56vw",
      right: "auto",
      bottom: "auto",
      angle: 120,
      duration: 7,
      idSuffix: "main-mini",
      visibilityKeyframes: {
        startVisible: 0.27,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.75,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 30,
      },
    },
  },
  legendParams = {
    small: {
      width: 41.875,
      height: 15,
      orbitWidth: 2,
      top: "auto",
      left: "auto",
      right: "10vw",
      bottom: "35vh",
      angle: 160,
      duration: 3,
      idSuffix: "legend",
      visibilityKeyframes: {
        startVisible: 0.1,
        startHidden: 0.3,
        endHidden: 0.75,
        endVisible: 0.8,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 22.5,
      },
    },
    medium: {
      width: 41.875,
      height: 15,
      orbitWidth: 2,
      top: "auto",
      left: "auto",
      right: "10vw",
      bottom: "35vh",
      angle: 160,
      duration: 3,
      idSuffix: "legend",
      visibilityKeyframes: {
        startVisible: 0.1,
        startHidden: 0.3,
        endHidden: 0.75,
        endVisible: 0.8,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 22.5,
      },
    },
    large: {
      width: 41.875,
      height: 15,
      orbitWidth: 2,
      top: "auto",
      left: "auto",
      right: "10vw",
      bottom: "35vh",
      angle: 160,
      duration: 3,
      idSuffix: "legend",
      visibilityKeyframes: {
        startVisible: 0.1,
        startHidden: 0.3,
        endHidden: 0.75,
        endVisible: 0.8,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 22.5,
      },
    },
    extraLarge: {
      width: 37.875,
      height: 12,
      orbitWidth: 2,
      top: "auto",
      left: "auto",
      right: "20vw",
      bottom: "40vh",
      angle: 160,
      duration: 3,
      idSuffix: "legend",
      visibilityKeyframes: {
        startVisible: 0.1,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.8,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 22.5,
      },
    },
    extraWIde: {
      width: 40.875,
      height: 13,
      orbitWidth: 2,
      top: "auto",
      left: "auto",
      right: "13vw",
      bottom: "35vh",
      angle: 160,
      duration: 4,
      idSuffix: "legend",
      visibilityKeyframes: {
        startVisible: 0.1,
        startHidden: 0.3,
        endHidden: 0.7,
        endVisible: 0.8,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 22.5,
      },
    },
  },
  howItWorksParams = {
    small: {
      width: 20.625,
      height: 8,
      orbitWidth: 2,
      top: "35vh",
      left: "auto",
      right: "7vw",
      bottom: "auto",
      angle: 30,
      duration: 4,
      idSuffix: "howItWorks",
      visibilityKeyframes: {
        startVisible: 0.2,
        startHidden: 0.35,
        endHidden: 0.7,
        endVisible: 0.9,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 35,
      },
    },
    medium: {
      width: 20.625,
      height: 10,
      orbitWidth: 2,
      top: "30vh",
      left: "auto",
      right: "41vw",
      bottom: "auto",
      angle: 30,
      duration: 4,
      idSuffix: "howItWorks",
      visibilityKeyframes: {
        startVisible: 0.2,
        startHidden: 0.35,
        endHidden: 0.7,
        endVisible: 0.9,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 35,
      },
    },
    large: {
      width: 24.625,
      height: 12,
      orbitWidth: 2,
      top: "35vh",
      left: "auto",
      right: "39vw",
      bottom: "auto",
      angle: 30,
      duration: 4,
      idSuffix: "howItWorks",
      visibilityKeyframes: {
        startVisible: 0.2,
        startHidden: 0.35,
        endHidden: 0.7,
        endVisible: 0.9,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 35,
      },
    },
    extraLarge: {
      width: 27.625,
      height: 15,
      orbitWidth: 2,
      top: "35vh",
      left: "auto",
      right: "37.5vw",
      bottom: "auto",
      angle: 30,
      duration: 4,
      idSuffix: "howItWorks",
      visibilityKeyframes: {
        startVisible: 0.2,
        startHidden: 0.35,
        endHidden: 0.7,
        endVisible: 0.9,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 35,
      },
    },
    extraWIde: {
      width: 30.625,
      height: 16,
      orbitWidth: 2,
      top: "35vh",
      left: "auto",
      right: "34vw",
      bottom: "auto",
      angle: 30,
      duration: 4,
      idSuffix: "howItWorks",
      visibilityKeyframes: {
        startVisible: 0.2,
        startHidden: 0.35,
        endHidden: 0.7,
        endVisible: 0.9,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 35,
      },
    },
  },
  futureParams = {
    small: {
      width: 40.9375,
      height: 27.8125,
      orbitWidth: 2,
      top: "auto",
      left: "auto",
      right: "5vw",
      bottom: "auto",
      angle: 180,
      duration: 5,
      idSuffix: "future",
      visibilityKeyframes: {
        startVisible: 0.28,
        startHidden: 0.33,
        endHidden: 0.68,
        endVisible: 0.72,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 5,
        endOffset: 50,
      },
    },
    medium: {
      width: 52.5,
      height: 21.25,
      orbitWidth: 2,
      top: "auto",
      left: "15vw",
      right: "auto",
      bottom: "25vw",
      angle: 145,
      duration: 5,
      idSuffix: "future",
      visibilityKeyframes: {
        startVisible: 0.25,
        startHidden: 0.28,
        endHidden: 0.73,
        endVisible: 0.78,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 20,
      },
    },
    large: {
      width: 52.5,
      height: 21.25,
      orbitWidth: 2,
      top: "auto",
      left: "15vw",
      right: "auto",
      bottom: "20vw",
      angle: 160,
      duration: 5,
      idSuffix: "future",
      visibilityKeyframes: {
        startVisible: 0.25,
        startHidden: 0.28,
        endHidden: 0.73,
        endVisible: 0.78,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 20,
      },
    },
    extraLarge: {
      width: 62.5,
      height: 21.25,
      orbitWidth: 2,
      top: "22vw",
      left: "8vw",
      right: "auto",
      bottom: "auto",
      angle: 160,
      duration: 5,
      idSuffix: "future",
      visibilityKeyframes: {
        startVisible: 0.25,
        startHidden: 0.28,
        endHidden: 0.73,
        endVisible: 0.78,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 20,
      },
    },
    extraWIde: {
      width: 62.5,
      height: 21.25,
      orbitWidth: 2,
      top: "22vw",
      left: "5vw",
      right: "auto",
      bottom: "auto",
      angle: 160,
      duration: 5,
      idSuffix: "future",
      visibilityKeyframes: {
        startVisible: 0.25,
        startHidden: 0.28,
        endHidden: 0.73,
        endVisible: 0.78,
      },
      gradientTransform: "rotate(90)",
      gradientColors: {
        startColor: "rgba(255, 255, 255, 0.1)",
        endColor: "rgba(255, 255, 255, 0)",
        startOffset: 0,
        endOffset: 20,
      },
    },
  },
  getOrbitingDotParams = (n, e) => {
    switch (n) {
      case "main":
        return mainParams[e];
      case "main-mini":
        return mainMiniParams[e];
      case "legend":
        return legendParams[e];
      case "howItWorks":
        return howItWorksParams[e];
      case "future":
        return futureParams[e];
      default:
        throw new Error(`Unknown idSuffix: ${n}`);
    }
  },
  Legend = () => {
    const n = useBreakpoints(),
      e = getOrbitingDotParams("legend", n),
      { ref: t, inView: r } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: s, inView: o } = useInView({ triggerOnce: !1, threshold: 0 }),
      a = [
        {
          title: "AI Avatar",
          descr:
            "Create a unique, intelligent digital persona that learns and evolves with your interactions and tasks",
          icon: IntelligenceIcon,
        },
        {
          title: "Earn & Learn",
          descr:
            "Monetize your AI training skills and earn rewards while developing cutting-edge artificial intelligence",
          icon: PersonalityIcon,
        },
        {
          title: "Cross-Platform",
          descr:
            "Build a unified digital identity that transcends metaverse boundaries, carrying your AI's knowledge everywhere",
          icon: CrossPlatformIcon,
        },
        {
          title: "Community",
          descr:
            "Join a collaborative ecosystem of innovators, sharing knowledge and pushing the boundaries of AI development",
          icon: CommunityIcon,
        },
      ],
      l = reactExports.useMemo(() => (r ? "animateTitle visible" : ""), [r]),
      c = reactExports.useMemo(() => (o ? "animateDescr visible" : ""), [o]);
    return jsxRuntimeExports.jsxs(LegendBlock, {
      id: "legend",
      style: {
        scrollSnapAlign: "start",
        position: "relative",
        boxShadow:
          n === "small"
            ? "inset 0px 0px 100px 50px rgba(0, 0, 0, 0.2)"
            : "inset 0px 0px 300px 200px rgba(0, 0, 0, 0.2)",
      },
      children: [
        n !== "small" && jsxRuntimeExports.jsx(OrbitingDot, { ...e }),
        jsxRuntimeExports.jsx(GradientBG, {
          width: n === "small" ? "45%" : "55%",
          height: n === "small" ? "75%" : "70%",
          opacity: 0.2,
          position:
            n === "small" ? "top: 20%; right: 0%;" : "top: 15%; right: 0%;",
          children: jsxRuntimeExports.jsx(Gradient, {
            style: {
              background:
                "radial-gradient(50% 50% at 50% 50%, #4535d3ed 30%, #4637d194 60%, #7f64f200 105%)",
            },
          }),
        }),
        jsxRuntimeExports.jsx(Container, {
          children: jsxRuntimeExports.jsxs(Content$6, {
            children: [
              jsxRuntimeExports.jsxs(TextBlockAnimate, {
                children: [
                  jsxRuntimeExports.jsx(TextTitle$1, {
                    ref: t,
                    className: l,
                    children: "AI Evolution Reimagined",
                  }),
                  jsxRuntimeExports.jsx(TextDescr$2, {
                    ref: s,
                    className: c,
                    children:
                      "Empower Your Digital Journey Through Gamified AI Development and Personalization",
                  }),
                ],
              }),
              jsxRuntimeExports.jsx(Container, {
                style: {
                  display: "flex",
                  alignItems: "flex-end",
                  padding: "0",
                },
                children: jsxRuntimeExports.jsx(SwiperSlider, { cards: a }),
              }),
            ],
          }),
        }),
      ],
    });
  };
var reactDomExports = requireReactDom();
const ReactDOM = getDefaultExportFromCjs(reactDomExports),
  spin = mt`
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
`,
  reverseSpin = mt`
  0% {
    transform: rotate(360deg);
  }
  100% {
    transform: rotate(0deg);
  }
`,
  MainLoaderPortal = dt.div`
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;

    z-index: 1000;
`,
  SpinnerWrapper = dt.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
  background-color: transparent;
  z-index: 25;
`,
  SpinnerGroup = dt.div`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 18.75rem;
  height: 18.75rem;
`,
  SpinnerCircle = dt.div.withConfig({
    shouldForwardProp: (n) =>
      ![
        "size",
        "borderPx",
        "borderTopPx",
        "color",
        "duration",
        "direction",
      ].includes(n),
  })`
  position: absolute;
  width: ${({ size: n }) => n}px;
  height: ${({ size: n }) => n}px;
  border: ${({ borderPx: n }) => n}px solid rgba(0, 0, 0, 0);
  border-top: ${({ borderTopPx: n, color: e }) => `${n}px solid ${e}`};
  border-radius: 50%;
  animation: ${({ direction: n }) => (n === "reverse" ? reverseSpin : spin)}
    ${({ duration: n }) => n} linear infinite;
`,
  shapeAnim = mt`
  0% {
    width: 0;
    height: 0;
    opacity: 0;
  }
  50% {
    width: 0;
    height: 0;
    opacity: 0;
  }
  75% {
    width: 100rem;
    height: 75rem;
    opacity: 0.8;
  }
  100% {
    width: 0;
    height: 0;
    opacity: 0;
  }
`,
  shape1Anim = mt`
  0% {
    transform: scale(0);
    opacity: 0;
  }
  55% {
    transform: scale(0);
    opacity: 0;
  }
  75% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(0);
    opacity: 0;
  }
`,
  shape2Anim = mt`
  0% {
    width: 6rem;
    height: 6rem;
    opacity: 0;
  }
  30% {
    width: 60rem;
    height: 60rem;
    opacity: 0.8;
  }
  50% {
    width: 40rem;
    height: 40rem;
    opacity: 0.2;
  }
  100% {
    width: 24rem;
    height: 24rem;
    opacity: 0;
  }
`;
mt`
  0% {
    transform: scale(0.2);
    opacity: 0;
  }
  25% {
    transform: scale(1);
    opacity: 0.8;
  }
  50% {
    transform: scale(0.4);
    opacity: 0;
  }
  100% {
    transform: scale(0.2);
    opacity: 0;
  }
`;
const shape4Anim = mt`
  0% {
    transform: scale(1);
    opacity: 0;
  }
  20% {
    transform: scale(0.1);
    opacity: 1;
  }
  50% {
    transform: scale(1);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 0;
  }
`,
  ComponentWrapper = dt.div`
  position: relative;
  z-index: 1;
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, #433581 0%, #02030b 85.47%);
  overflow: hidden;
  display: flex;
  align-items: center;
`,
  Shape$1 = dt.div`
  position: absolute;
  z-index: 1;
  top: -40rem;
  right: -25rem;
  width: 150rem;
  height: 75rem;
  overflow: visible;
  will-change: transform, opacity;
  transform: translateZ(0);

  &:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      180deg,
      rgb(127, 100, 242) 45%,
      rgb(42, 42, 44) 100%
    );
    border-radius: 100%;
    filter: blur(100px);
    animation: ${shapeAnim} 15s infinite;
  }

  @media (max-width: 48rem) {
    top: -4rem;
    right: -5rem;
    width: 10rem;
    height: 15rem;

    &:after {
      filter: blur(50px);
    }
  }
`,
  Shape1 = dt.div`
  position: absolute;
  z-index: 1;
  top: 25rem;
  right: 35rem;
  width: 125rem;
  height: 75rem;
  overflow: visible;
  will-change: transform, opacity;
  transform: translateZ(0);

  &:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      180deg,
      rgb(63, 11, 112) 30%,
      rgb(56, 56, 56) 100%
    );
    border-radius: 100%;
    filter: blur(100px);
    animation: ${shape1Anim} 15s infinite;
  }

  @media (max-width: 48rem) {
    top: 25rem;
    right: 35rem;
    width: 10rem;
    height: 15rem;

    &:after {
      filter: blur(50px);
    }
  }
`,
  Shape2 = dt.div`
  position: absolute;
  z-index: 1;
  top: -25rem;
  left: -25rem;
  width: 60rem;
  height: 60rem;
  overflow: visible;
  will-change: transform, opacity;
  transform: translateZ(0);

  &:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, rgb(92, 46, 86) 0%, rgb(46, 45, 77) 70%);
    border-radius: 100%;
    filter: blur(100px);
    animation: ${shape2Anim} 15s infinite;
  }

  @media (max-width: 48rem) {
    top: -5rem;
    left: -5rem;
    width: 5rem;
    height: 10rem;

    &:after {
      filter: blur(50px);
    }
  }
`,
  Shape3 = dt.div`
  position: absolute;
  z-index: 2;
  top: -60rem;
  right: -90rem;
  width: 125rem;
  height: 125rem;
  overflow: visible;
  will-change: transform, opacity;
  transform: translateZ(0);

  &:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgb(128, 64, 158);
    border-radius: 100%;
    filter: blur(100px);
    animation: ${shape4Anim} 15s infinite;
  }

  @media (max-width: 48rem) {
    top: -15rem;
    right: -25rem;
    width: 25rem;
    height: 25rem;

    &:after {
      filter: blur(50px);
    }
  }
`,
  AnimatedBG = ({ children: n }) =>
    jsxRuntimeExports.jsxs(ComponentWrapper, {
      children: [
        jsxRuntimeExports.jsx(Shape$1, {}),
        jsxRuntimeExports.jsx(Shape1, {}),
        jsxRuntimeExports.jsx(Shape2, {}),
        jsxRuntimeExports.jsx(Shape3, {}),
        n,
      ],
    });
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const REVISION = "176",
  MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  CullFaceNone = 0,
  CullFaceBack = 1,
  CullFaceFront = 2,
  CullFaceFrontBack = 3,
  BasicShadowMap = 0,
  PCFShadowMap = 1,
  PCFSoftShadowMap = 2,
  VSMShadowMap = 3,
  FrontSide = 0,
  BackSide = 1,
  DoubleSide = 2,
  NoBlending = 0,
  NormalBlending = 1,
  AdditiveBlending = 2,
  SubtractiveBlending = 3,
  MultiplyBlending = 4,
  CustomBlending = 5,
  AddEquation = 100,
  SubtractEquation = 101,
  ReverseSubtractEquation = 102,
  MinEquation = 103,
  MaxEquation = 104,
  ZeroFactor = 200,
  OneFactor = 201,
  SrcColorFactor = 202,
  OneMinusSrcColorFactor = 203,
  SrcAlphaFactor = 204,
  OneMinusSrcAlphaFactor = 205,
  DstAlphaFactor = 206,
  OneMinusDstAlphaFactor = 207,
  DstColorFactor = 208,
  OneMinusDstColorFactor = 209,
  SrcAlphaSaturateFactor = 210,
  ConstantColorFactor = 211,
  OneMinusConstantColorFactor = 212,
  ConstantAlphaFactor = 213,
  OneMinusConstantAlphaFactor = 214,
  NeverDepth = 0,
  AlwaysDepth = 1,
  LessDepth = 2,
  LessEqualDepth = 3,
  EqualDepth = 4,
  GreaterEqualDepth = 5,
  GreaterDepth = 6,
  NotEqualDepth = 7,
  MultiplyOperation = 0,
  MixOperation = 1,
  AddOperation = 2,
  NoToneMapping = 0,
  LinearToneMapping = 1,
  ReinhardToneMapping = 2,
  CineonToneMapping = 3,
  ACESFilmicToneMapping = 4,
  CustomToneMapping = 5,
  AgXToneMapping = 6,
  NeutralToneMapping = 7,
  AttachedBindMode = "attached",
  DetachedBindMode = "detached",
  UVMapping = 300,
  CubeReflectionMapping = 301,
  CubeRefractionMapping = 302,
  EquirectangularReflectionMapping = 303,
  EquirectangularRefractionMapping = 304,
  CubeUVReflectionMapping = 306,
  RepeatWrapping = 1e3,
  ClampToEdgeWrapping = 1001,
  MirroredRepeatWrapping = 1002,
  NearestFilter = 1003,
  NearestMipmapNearestFilter = 1004,
  NearestMipMapNearestFilter = 1004,
  NearestMipmapLinearFilter = 1005,
  NearestMipMapLinearFilter = 1005,
  LinearFilter = 1006,
  LinearMipmapNearestFilter = 1007,
  LinearMipMapNearestFilter = 1007,
  LinearMipmapLinearFilter = 1008,
  LinearMipMapLinearFilter = 1008,
  UnsignedByteType = 1009,
  ByteType = 1010,
  ShortType = 1011,
  UnsignedShortType = 1012,
  IntType = 1013,
  UnsignedIntType = 1014,
  FloatType = 1015,
  HalfFloatType = 1016,
  UnsignedShort4444Type = 1017,
  UnsignedShort5551Type = 1018,
  UnsignedInt248Type = 1020,
  UnsignedInt5999Type = 35902,
  AlphaFormat = 1021,
  RGBFormat = 1022,
  RGBAFormat = 1023,
  DepthFormat = 1026,
  DepthStencilFormat = 1027,
  RedFormat = 1028,
  RedIntegerFormat = 1029,
  RGFormat = 1030,
  RGIntegerFormat = 1031,
  RGBIntegerFormat = 1032,
  RGBAIntegerFormat = 1033,
  RGB_S3TC_DXT1_Format = 33776,
  RGBA_S3TC_DXT1_Format = 33777,
  RGBA_S3TC_DXT3_Format = 33778,
  RGBA_S3TC_DXT5_Format = 33779,
  RGB_PVRTC_4BPPV1_Format = 35840,
  RGB_PVRTC_2BPPV1_Format = 35841,
  RGBA_PVRTC_4BPPV1_Format = 35842,
  RGBA_PVRTC_2BPPV1_Format = 35843,
  RGB_ETC1_Format = 36196,
  RGB_ETC2_Format = 37492,
  RGBA_ETC2_EAC_Format = 37496,
  RGBA_ASTC_4x4_Format = 37808,
  RGBA_ASTC_5x4_Format = 37809,
  RGBA_ASTC_5x5_Format = 37810,
  RGBA_ASTC_6x5_Format = 37811,
  RGBA_ASTC_6x6_Format = 37812,
  RGBA_ASTC_8x5_Format = 37813,
  RGBA_ASTC_8x6_Format = 37814,
  RGBA_ASTC_8x8_Format = 37815,
  RGBA_ASTC_10x5_Format = 37816,
  RGBA_ASTC_10x6_Format = 37817,
  RGBA_ASTC_10x8_Format = 37818,
  RGBA_ASTC_10x10_Format = 37819,
  RGBA_ASTC_12x10_Format = 37820,
  RGBA_ASTC_12x12_Format = 37821,
  RGBA_BPTC_Format = 36492,
  RGB_BPTC_SIGNED_Format = 36494,
  RGB_BPTC_UNSIGNED_Format = 36495,
  RED_RGTC1_Format = 36283,
  SIGNED_RED_RGTC1_Format = 36284,
  RED_GREEN_RGTC2_Format = 36285,
  SIGNED_RED_GREEN_RGTC2_Format = 36286,
  LoopOnce = 2200,
  LoopRepeat = 2201,
  LoopPingPong = 2202,
  InterpolateDiscrete = 2300,
  InterpolateLinear = 2301,
  InterpolateSmooth = 2302,
  ZeroCurvatureEnding = 2400,
  ZeroSlopeEnding = 2401,
  WrapAroundEnding = 2402,
  NormalAnimationBlendMode = 2500,
  AdditiveAnimationBlendMode = 2501,
  TrianglesDrawMode = 0,
  TriangleStripDrawMode = 1,
  TriangleFanDrawMode = 2,
  BasicDepthPacking = 3200,
  RGBADepthPacking = 3201,
  RGBDepthPacking = 3202,
  RGDepthPacking = 3203,
  TangentSpaceNormalMap = 0,
  ObjectSpaceNormalMap = 1,
  NoColorSpace = "",
  SRGBColorSpace = "srgb",
  LinearSRGBColorSpace = "srgb-linear",
  LinearTransfer = "linear",
  SRGBTransfer = "srgb",
  ZeroStencilOp = 0,
  KeepStencilOp = 7680,
  ReplaceStencilOp = 7681,
  IncrementStencilOp = 7682,
  DecrementStencilOp = 7683,
  IncrementWrapStencilOp = 34055,
  DecrementWrapStencilOp = 34056,
  InvertStencilOp = 5386,
  NeverStencilFunc = 512,
  LessStencilFunc = 513,
  EqualStencilFunc = 514,
  LessEqualStencilFunc = 515,
  GreaterStencilFunc = 516,
  NotEqualStencilFunc = 517,
  GreaterEqualStencilFunc = 518,
  AlwaysStencilFunc = 519,
  NeverCompare = 512,
  LessCompare = 513,
  EqualCompare = 514,
  LessEqualCompare = 515,
  GreaterCompare = 516,
  NotEqualCompare = 517,
  GreaterEqualCompare = 518,
  AlwaysCompare = 519,
  StaticDrawUsage = 35044,
  DynamicDrawUsage = 35048,
  StreamDrawUsage = 35040,
  StaticReadUsage = 35045,
  DynamicReadUsage = 35049,
  StreamReadUsage = 35041,
  StaticCopyUsage = 35046,
  DynamicCopyUsage = 35050,
  StreamCopyUsage = 35042,
  GLSL1 = "100",
  GLSL3 = "300 es",
  WebGLCoordinateSystem = 2e3,
  WebGPUCoordinateSystem = 2001,
  TimestampQuery = { COMPUTE: "compute", RENDER: "render" },
  InterpolationSamplingType = {
    PERSPECTIVE: "perspective",
    LINEAR: "linear",
    FLAT: "flat",
  },
  InterpolationSamplingMode = {
    NORMAL: "normal",
    CENTROID: "centroid",
    SAMPLE: "sample",
    FLAT_FIRST: "flat first",
    FLAT_EITHER: "flat either",
  };
class EventDispatcher {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    const r = this._listeners;
    return r === void 0 ? !1 : r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const r = this._listeners;
    if (r === void 0) return;
    const s = r[e];
    if (s !== void 0) {
      const o = s.indexOf(t);
      o !== -1 && s.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const r = t[e.type];
    if (r !== void 0) {
      e.target = this;
      const s = r.slice(0);
      for (let o = 0, a = s.length; o < a; o++) s[o].call(this, e);
      e.target = null;
    }
  }
}
const _lut = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180,
  RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    _lut[n & 255] +
    _lut[(n >> 8) & 255] +
    _lut[(n >> 16) & 255] +
    _lut[(n >> 24) & 255] +
    "-" +
    _lut[e & 255] +
    _lut[(e >> 8) & 255] +
    "-" +
    _lut[((e >> 16) & 15) | 64] +
    _lut[(e >> 24) & 255] +
    "-" +
    _lut[(t & 63) | 128] +
    _lut[(t >> 8) & 255] +
    "-" +
    _lut[(t >> 16) & 255] +
    _lut[(t >> 24) & 255] +
    _lut[r & 255] +
    _lut[(r >> 8) & 255] +
    _lut[(r >> 16) & 255] +
    _lut[(r >> 24) & 255]
  ).toLowerCase();
}
function clamp$1(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function euclideanModulo(n, e) {
  return ((n % e) + e) % e;
}
function mapLinear(n, e, t, r, s) {
  return r + ((n - e) * (s - r)) / (t - e);
}
function inverseLerp(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function lerp(n, e, t) {
  return (1 - t) * n + t * e;
}
function damp(n, e, t, r) {
  return lerp(n, e, 1 - Math.exp(-t * r));
}
function pingpong(n, e = 1) {
  return e - Math.abs(euclideanModulo(n, e * 2) - e);
}
function smoothstep(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function smootherstep(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function randInt(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function randFloat(n, e) {
  return n + Math.random() * (e - n);
}
function randFloatSpread(n) {
  return n * (0.5 - Math.random());
}
function seededRandom(n) {
  n !== void 0 && (_seed = n);
  let e = (_seed += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function degToRad(n) {
  return n * DEG2RAD;
}
function radToDeg(n) {
  return n * RAD2DEG;
}
function isPowerOfTwo(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function ceilPowerOfTwo(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function floorPowerOfTwo(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function setQuaternionFromProperEuler(n, e, t, r, s) {
  const o = Math.cos,
    a = Math.sin,
    l = o(t / 2),
    c = a(t / 2),
    u = o((e + r) / 2),
    p = a((e + r) / 2),
    N = o((e - r) / 2),
    P = a((e - r) / 2),
    de = o((r - e) / 2),
    me = a((r - e) / 2);
  switch (s) {
    case "XYX":
      n.set(l * p, c * N, c * P, l * u);
      break;
    case "YZY":
      n.set(c * P, l * p, c * N, l * u);
      break;
    case "ZXZ":
      n.set(c * N, c * P, l * p, l * u);
      break;
    case "XZX":
      n.set(l * p, c * me, c * de, l * u);
      break;
    case "YXY":
      n.set(c * de, l * p, c * me, l * u);
      break;
    case "ZYZ":
      n.set(c * me, c * de, l * p, l * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          s
      );
  }
}
function denormalize(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$1(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp: clamp$1,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize: normalize$1,
  denormalize,
};
class Vector2 {
  constructor(e = 0, t = 0) {
    (Vector2.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * r + s[6]),
      (this.y = s[1] * t + s[4] * r + s[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = clamp$1(this.x, e.x, t.x)),
      (this.y = clamp$1(this.y, e.y, t.y)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = clamp$1(this.x, e, t)), (this.y = clamp$1(this.y, e, t)), this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(clamp$1(r, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(clamp$1(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      s = Math.sin(t),
      o = this.x - e.x,
      a = this.y - e.y;
    return (this.x = o * r - a * s + e.x), (this.y = o * s + a * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Matrix3 {
  constructor(e, t, r, s, o, a, l, c, u) {
    (Matrix3.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, s, o, a, l, c, u);
  }
  set(e, t, r, s, o, a, l, c, u) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[1] = s),
      (p[2] = l),
      (p[3] = t),
      (p[4] = o),
      (p[5] = c),
      (p[6] = r),
      (p[7] = a),
      (p[8] = u),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      s = t.elements,
      o = this.elements,
      a = r[0],
      l = r[3],
      c = r[6],
      u = r[1],
      p = r[4],
      N = r[7],
      P = r[2],
      de = r[5],
      me = r[8],
      Ye = s[0],
      nt = s[3],
      Be = s[6],
      ot = s[1],
      st = s[4],
      vt = s[7],
      xt = s[2],
      St = s[5],
      wt = s[8];
    return (
      (o[0] = a * Ye + l * ot + c * xt),
      (o[3] = a * nt + l * st + c * St),
      (o[6] = a * Be + l * vt + c * wt),
      (o[1] = u * Ye + p * ot + N * xt),
      (o[4] = u * nt + p * st + N * St),
      (o[7] = u * Be + p * vt + N * wt),
      (o[2] = P * Ye + de * ot + me * xt),
      (o[5] = P * nt + de * st + me * St),
      (o[8] = P * Be + de * vt + me * wt),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      s = e[2],
      o = e[3],
      a = e[4],
      l = e[5],
      c = e[6],
      u = e[7],
      p = e[8];
    return (
      t * a * p - t * l * u - r * o * p + r * l * c + s * o * u - s * a * c
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      s = e[2],
      o = e[3],
      a = e[4],
      l = e[5],
      c = e[6],
      u = e[7],
      p = e[8],
      N = p * a - l * u,
      P = l * c - p * o,
      de = u * o - a * c,
      me = t * N + r * P + s * de;
    if (me === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const Ye = 1 / me;
    return (
      (e[0] = N * Ye),
      (e[1] = (s * u - p * r) * Ye),
      (e[2] = (l * r - s * a) * Ye),
      (e[3] = P * Ye),
      (e[4] = (p * t - s * c) * Ye),
      (e[5] = (s * o - l * t) * Ye),
      (e[6] = de * Ye),
      (e[7] = (r * c - u * t) * Ye),
      (e[8] = (a * t - r * o) * Ye),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, s, o, a, l) {
    const c = Math.cos(o),
      u = Math.sin(o);
    return (
      this.set(
        r * c,
        r * u,
        -r * (c * a + u * l) + a + e,
        -s * u,
        s * c,
        -s * (-u * a + c * l) + l + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(_m3.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(_m3.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(_m3.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let s = 0; s < 9; s++) if (t[s] !== r[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = new Matrix3();
function arrayNeedsUint32(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function getTypedArray(n, e) {
  return new TYPED_ARRAYS[n](e);
}
function createElementNS(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function createCanvasElement() {
  const n = createElementNS("canvas");
  return (n.style.display = "block"), n;
}
const _cache = {};
function warnOnce(n) {
  n in _cache || ((_cache[n] = !0), console.warn(n));
}
function probeAsync(n, e, t) {
  return new Promise(function (r, s) {
    function o() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          s();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          r();
      }
    }
    setTimeout(o, t);
  });
}
function toNormalizedProjectionMatrix(n) {
  const e = n.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function toReversedProjectionMatrix(n) {
  const e = n.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const LINEAR_REC709_TO_XYZ = new Matrix3().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  XYZ_TO_LINEAR_REC709 = new Matrix3().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
function createColorManagement() {
  const n = {
      enabled: !0,
      workingColorSpace: LinearSRGBColorSpace,
      spaces: {},
      convert: function (s, o, a) {
        return (
          this.enabled === !1 ||
            o === a ||
            !o ||
            !a ||
            (this.spaces[o].transfer === SRGBTransfer &&
              ((s.r = SRGBToLinear(s.r)),
              (s.g = SRGBToLinear(s.g)),
              (s.b = SRGBToLinear(s.b))),
            this.spaces[o].primaries !== this.spaces[a].primaries &&
              (s.applyMatrix3(this.spaces[o].toXYZ),
              s.applyMatrix3(this.spaces[a].fromXYZ)),
            this.spaces[a].transfer === SRGBTransfer &&
              ((s.r = LinearToSRGB(s.r)),
              (s.g = LinearToSRGB(s.g)),
              (s.b = LinearToSRGB(s.b)))),
          s
        );
      },
      fromWorkingColorSpace: function (s, o) {
        return this.convert(s, this.workingColorSpace, o);
      },
      toWorkingColorSpace: function (s, o) {
        return this.convert(s, o, this.workingColorSpace);
      },
      getPrimaries: function (s) {
        return this.spaces[s].primaries;
      },
      getTransfer: function (s) {
        return s === NoColorSpace ? LinearTransfer : this.spaces[s].transfer;
      },
      getLuminanceCoefficients: function (s, o = this.workingColorSpace) {
        return s.fromArray(this.spaces[o].luminanceCoefficients);
      },
      define: function (s) {
        Object.assign(this.spaces, s);
      },
      _getMatrix: function (s, o, a) {
        return s.copy(this.spaces[o].toXYZ).multiply(this.spaces[a].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (s) {
        return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (s = this.workingColorSpace) {
        return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    r = [0.3127, 0.329];
  return (
    n.define({
      [LinearSRGBColorSpace]: {
        primaries: e,
        whitePoint: r,
        transfer: LinearTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace },
      },
      [SRGBColorSpace]: {
        primaries: e,
        whitePoint: r,
        transfer: SRGBTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace },
      },
    }),
    n
  );
}
const ColorManagement = createColorManagement();
function SRGBToLinear(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let r;
    if (e instanceof HTMLCanvasElement) r = e;
    else {
      _canvas === void 0 && (_canvas = createElementNS("canvas")),
        (_canvas.width = e.width),
        (_canvas.height = e.height);
      const s = _canvas.getContext("2d");
      e instanceof ImageData
        ? s.putImageData(e, 0, 0)
        : s.drawImage(e, 0, 0, e.width, e.height),
        (r = _canvas);
    }
    return r.toDataURL(t);
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = createElementNS("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const s = r.getImageData(0, 0, e.width, e.height),
        o = s.data;
      for (let a = 0; a < o.length; a++) o[a] = SRGBToLinear(o[a] / 255) * 255;
      return r.putImageData(s, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(SRGBToLinear(t[r] / 255) * 255))
          : (t[r] = SRGBToLinear(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let _sourceId = 0;
class Source {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: _sourceId++ }),
      (this.uuid = generateUUID()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      s = this.data;
    if (s !== null) {
      let o;
      if (Array.isArray(s)) {
        o = [];
        for (let a = 0, l = s.length; a < l; a++)
          s[a].isDataTexture
            ? o.push(serializeImage(s[a].image))
            : o.push(serializeImage(s[a]));
      } else o = serializeImage(s);
      r.url = o;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function serializeImage(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? ImageUtils.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(
    e = Texture.DEFAULT_IMAGE,
    t = Texture.DEFAULT_MAPPING,
    r = ClampToEdgeWrapping,
    s = ClampToEdgeWrapping,
    o = LinearFilter,
    a = LinearMipmapLinearFilter,
    l = RGBAFormat,
    c = UnsignedByteType,
    u = Texture.DEFAULT_ANISOTROPY,
    p = NoColorSpace
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: _textureId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.source = new Source(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = s),
      (this.magFilter = o),
      (this.minFilter = a),
      (this.anisotropy = u),
      (this.format = l),
      (this.internalFormat = null),
      (this.type = c),
      (this.offset = new Vector2(0, 0)),
      (this.repeat = new Vector2(1, 1)),
      (this.center = new Vector2(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Matrix3()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = p),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.isTextureArray = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.isTextureArray = e.isTextureArray),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== UVMapping) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case RepeatWrapping:
          e.x = e.x - Math.floor(e.x);
          break;
        case ClampToEdgeWrapping:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          e.y = e.y - Math.floor(e.y);
          break;
        case ClampToEdgeWrapping:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(e = 0, t = 0, r = 0, s = 1) {
    (Vector4.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = s);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, s) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = s), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      s = this.z,
      o = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * r + a[8] * s + a[12] * o),
      (this.y = a[1] * t + a[5] * r + a[9] * s + a[13] * o),
      (this.z = a[2] * t + a[6] * r + a[10] * s + a[14] * o),
      (this.w = a[3] * t + a[7] * r + a[11] * s + a[15] * o),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, s, o;
    const c = e.elements,
      u = c[0],
      p = c[4],
      N = c[8],
      P = c[1],
      de = c[5],
      me = c[9],
      Ye = c[2],
      nt = c[6],
      Be = c[10];
    if (
      Math.abs(p - P) < 0.01 &&
      Math.abs(N - Ye) < 0.01 &&
      Math.abs(me - nt) < 0.01
    ) {
      if (
        Math.abs(p + P) < 0.1 &&
        Math.abs(N + Ye) < 0.1 &&
        Math.abs(me + nt) < 0.1 &&
        Math.abs(u + de + Be - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const st = (u + 1) / 2,
        vt = (de + 1) / 2,
        xt = (Be + 1) / 2,
        St = (p + P) / 4,
        wt = (N + Ye) / 4,
        bt = (me + nt) / 4;
      return (
        st > vt && st > xt
          ? st < 0.01
            ? ((r = 0), (s = 0.707106781), (o = 0.707106781))
            : ((r = Math.sqrt(st)), (s = St / r), (o = wt / r))
          : vt > xt
          ? vt < 0.01
            ? ((r = 0.707106781), (s = 0), (o = 0.707106781))
            : ((s = Math.sqrt(vt)), (r = St / s), (o = bt / s))
          : xt < 0.01
          ? ((r = 0.707106781), (s = 0.707106781), (o = 0))
          : ((o = Math.sqrt(xt)), (r = wt / o), (s = bt / o)),
        this.set(r, s, o, t),
        this
      );
    }
    let ot = Math.sqrt(
      (nt - me) * (nt - me) + (N - Ye) * (N - Ye) + (P - p) * (P - p)
    );
    return (
      Math.abs(ot) < 0.001 && (ot = 1),
      (this.x = (nt - me) / ot),
      (this.y = (N - Ye) / ot),
      (this.z = (P - p) / ot),
      (this.w = Math.acos((u + de + Be - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = clamp$1(this.x, e.x, t.x)),
      (this.y = clamp$1(this.y, e.y, t.y)),
      (this.z = clamp$1(this.z, e.z, t.z)),
      (this.w = clamp$1(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = clamp$1(this.x, e, t)),
      (this.y = clamp$1(this.y, e, t)),
      (this.z = clamp$1(this.z, e, t)),
      (this.w = clamp$1(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(clamp$1(r, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = r.depth ? r.depth : 1),
      (this.scissor = new Vector4(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Vector4(0, 0, e, t));
    const s = { width: e, height: t, depth: this.depth };
    r = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
        multiview: !1,
      },
      r
    );
    const o = new Texture(
      s,
      r.mapping,
      r.wrapS,
      r.wrapT,
      r.magFilter,
      r.minFilter,
      r.format,
      r.type,
      r.anisotropy,
      r.colorSpace
    );
    (o.flipY = !1),
      (o.generateMipmaps = r.generateMipmaps),
      (o.internalFormat = r.internalFormat),
      (this.textures = []);
    const a = r.count;
    for (let l = 0; l < a; l++)
      (this.textures[l] = o.clone()),
        (this.textures[l].isRenderTargetTexture = !0),
        (this.textures[l].renderTarget = this);
    (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples),
      (this.multiview = r.multiview);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let s = 0, o = this.textures.length; s < o; s++)
        (this.textures[s].image.width = e),
          (this.textures[s].image.height = t),
          (this.textures[s].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let t = 0, r = e.textures.length; t < r; t++) {
      (this.textures[t] = e.textures[t].clone()),
        (this.textures[t].isRenderTargetTexture = !0),
        (this.textures[t].renderTarget = this);
      const s = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new Source(s);
    }
    return (
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class DataArrayTexture extends Texture {
  constructor(e = null, t = 1, r = 1, s = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: s }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, t = 1, r = 1, s = {}) {
    super(e, t, s),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new DataArrayTexture(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Data3DTexture extends Texture {
  constructor(e = null, t = 1, r = 1, s = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: s }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, t = 1, r = 1, s = {}) {
    super(e, t, s),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new Data3DTexture(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Quaternion {
  constructor(e = 0, t = 0, r = 0, s = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = s);
  }
  static slerpFlat(e, t, r, s, o, a, l) {
    let c = r[s + 0],
      u = r[s + 1],
      p = r[s + 2],
      N = r[s + 3];
    const P = o[a + 0],
      de = o[a + 1],
      me = o[a + 2],
      Ye = o[a + 3];
    if (l === 0) {
      (e[t + 0] = c), (e[t + 1] = u), (e[t + 2] = p), (e[t + 3] = N);
      return;
    }
    if (l === 1) {
      (e[t + 0] = P), (e[t + 1] = de), (e[t + 2] = me), (e[t + 3] = Ye);
      return;
    }
    if (N !== Ye || c !== P || u !== de || p !== me) {
      let nt = 1 - l;
      const Be = c * P + u * de + p * me + N * Ye,
        ot = Be >= 0 ? 1 : -1,
        st = 1 - Be * Be;
      if (st > Number.EPSILON) {
        const xt = Math.sqrt(st),
          St = Math.atan2(xt, Be * ot);
        (nt = Math.sin(nt * St) / xt), (l = Math.sin(l * St) / xt);
      }
      const vt = l * ot;
      if (
        ((c = c * nt + P * vt),
        (u = u * nt + de * vt),
        (p = p * nt + me * vt),
        (N = N * nt + Ye * vt),
        nt === 1 - l)
      ) {
        const xt = 1 / Math.sqrt(c * c + u * u + p * p + N * N);
        (c *= xt), (u *= xt), (p *= xt), (N *= xt);
      }
    }
    (e[t] = c), (e[t + 1] = u), (e[t + 2] = p), (e[t + 3] = N);
  }
  static multiplyQuaternionsFlat(e, t, r, s, o, a) {
    const l = r[s],
      c = r[s + 1],
      u = r[s + 2],
      p = r[s + 3],
      N = o[a],
      P = o[a + 1],
      de = o[a + 2],
      me = o[a + 3];
    return (
      (e[t] = l * me + p * N + c * de - u * P),
      (e[t + 1] = c * me + p * P + u * N - l * de),
      (e[t + 2] = u * me + p * de + l * P - c * N),
      (e[t + 3] = p * me - l * N - c * P - u * de),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, s) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = s),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const r = e._x,
      s = e._y,
      o = e._z,
      a = e._order,
      l = Math.cos,
      c = Math.sin,
      u = l(r / 2),
      p = l(s / 2),
      N = l(o / 2),
      P = c(r / 2),
      de = c(s / 2),
      me = c(o / 2);
    switch (a) {
      case "XYZ":
        (this._x = P * p * N + u * de * me),
          (this._y = u * de * N - P * p * me),
          (this._z = u * p * me + P * de * N),
          (this._w = u * p * N - P * de * me);
        break;
      case "YXZ":
        (this._x = P * p * N + u * de * me),
          (this._y = u * de * N - P * p * me),
          (this._z = u * p * me - P * de * N),
          (this._w = u * p * N + P * de * me);
        break;
      case "ZXY":
        (this._x = P * p * N - u * de * me),
          (this._y = u * de * N + P * p * me),
          (this._z = u * p * me + P * de * N),
          (this._w = u * p * N - P * de * me);
        break;
      case "ZYX":
        (this._x = P * p * N - u * de * me),
          (this._y = u * de * N + P * p * me),
          (this._z = u * p * me - P * de * N),
          (this._w = u * p * N + P * de * me);
        break;
      case "YZX":
        (this._x = P * p * N + u * de * me),
          (this._y = u * de * N + P * p * me),
          (this._z = u * p * me - P * de * N),
          (this._w = u * p * N - P * de * me);
        break;
      case "XZY":
        (this._x = P * p * N - u * de * me),
          (this._y = u * de * N - P * p * me),
          (this._z = u * p * me + P * de * N),
          (this._w = u * p * N + P * de * me);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      s = Math.sin(r);
    return (
      (this._x = e.x * s),
      (this._y = e.y * s),
      (this._z = e.z * s),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      s = t[4],
      o = t[8],
      a = t[1],
      l = t[5],
      c = t[9],
      u = t[2],
      p = t[6],
      N = t[10],
      P = r + l + N;
    if (P > 0) {
      const de = 0.5 / Math.sqrt(P + 1);
      (this._w = 0.25 / de),
        (this._x = (p - c) * de),
        (this._y = (o - u) * de),
        (this._z = (a - s) * de);
    } else if (r > l && r > N) {
      const de = 2 * Math.sqrt(1 + r - l - N);
      (this._w = (p - c) / de),
        (this._x = 0.25 * de),
        (this._y = (s + a) / de),
        (this._z = (o + u) / de);
    } else if (l > N) {
      const de = 2 * Math.sqrt(1 + l - r - N);
      (this._w = (o - u) / de),
        (this._x = (s + a) / de),
        (this._y = 0.25 * de),
        (this._z = (c + p) / de);
    } else {
      const de = 2 * Math.sqrt(1 + N - r - l);
      (this._w = (a - s) / de),
        (this._x = (o + u) / de),
        (this._y = (c + p) / de),
        (this._z = 0.25 * de);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(clamp$1(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const s = Math.min(1, t / r);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      s = e._y,
      o = e._z,
      a = e._w,
      l = t._x,
      c = t._y,
      u = t._z,
      p = t._w;
    return (
      (this._x = r * p + a * l + s * u - o * c),
      (this._y = s * p + a * c + o * l - r * u),
      (this._z = o * p + a * u + r * c - s * l),
      (this._w = a * p - r * l - s * c - o * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      s = this._y,
      o = this._z,
      a = this._w;
    let l = a * e._w + r * e._x + s * e._y + o * e._z;
    if (
      (l < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (l = -l))
        : this.copy(e),
      l >= 1)
    )
      return (this._w = a), (this._x = r), (this._y = s), (this._z = o), this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const de = 1 - t;
      return (
        (this._w = de * a + t * this._w),
        (this._x = de * r + t * this._x),
        (this._y = de * s + t * this._y),
        (this._z = de * o + t * this._z),
        this.normalize(),
        this
      );
    }
    const u = Math.sqrt(c),
      p = Math.atan2(u, l),
      N = Math.sin((1 - t) * p) / u,
      P = Math.sin(t * p) / u;
    return (
      (this._w = a * N + this._w * P),
      (this._x = r * N + this._x * P),
      (this._y = s * N + this._y * P),
      (this._z = o * N + this._z * P),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      r = Math.random(),
      s = Math.sqrt(1 - r),
      o = Math.sqrt(r);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Vector3 {
  constructor(e = 0, t = 0, r = 0) {
    (Vector3.prototype.isVector3 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      s = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[3] * r + o[6] * s),
      (this.y = o[1] * t + o[4] * r + o[7] * s),
      (this.z = o[2] * t + o[5] * r + o[8] * s),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      s = this.z,
      o = e.elements,
      a = 1 / (o[3] * t + o[7] * r + o[11] * s + o[15]);
    return (
      (this.x = (o[0] * t + o[4] * r + o[8] * s + o[12]) * a),
      (this.y = (o[1] * t + o[5] * r + o[9] * s + o[13]) * a),
      (this.z = (o[2] * t + o[6] * r + o[10] * s + o[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      s = this.z,
      o = e.x,
      a = e.y,
      l = e.z,
      c = e.w,
      u = 2 * (a * s - l * r),
      p = 2 * (l * t - o * s),
      N = 2 * (o * r - a * t);
    return (
      (this.x = t + c * u + a * N - l * p),
      (this.y = r + c * p + l * u - o * N),
      (this.z = s + c * N + o * p - a * u),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      s = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * s),
      (this.y = o[1] * t + o[5] * r + o[9] * s),
      (this.z = o[2] * t + o[6] * r + o[10] * s),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = clamp$1(this.x, e.x, t.x)),
      (this.y = clamp$1(this.y, e.y, t.y)),
      (this.z = clamp$1(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = clamp$1(this.x, e, t)),
      (this.y = clamp$1(this.y, e, t)),
      (this.z = clamp$1(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(clamp$1(r, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      s = e.y,
      o = e.z,
      a = t.x,
      l = t.y,
      c = t.z;
    return (
      (this.x = s * c - o * l),
      (this.y = o * a - r * c),
      (this.z = r * l - s * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return _vector$c.copy(this).projectOnVector(e), this.sub(_vector$c);
  }
  reflect(e) {
    return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(clamp$1(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      s = this.z - e.z;
    return t * t + r * r + s * s;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const s = Math.sin(t) * e;
    return (
      (this.x = s * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = s * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      s = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = s), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      r = Math.sqrt(1 - t * t);
    return (
      (this.x = r * Math.cos(e)), (this.y = t), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _vector$c = new Vector3(),
  _quaternion$4 = new Quaternion();
class Box3 {
  constructor(
    e = new Vector3(1 / 0, 1 / 0, 1 / 0),
    t = new Vector3(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(_vector$b.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(_vector$b.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = _vector$b.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const o = r.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, l = o.count; a < l; a++)
          e.isMesh === !0
            ? e.getVertexPosition(a, _vector$b)
            : _vector$b.fromBufferAttribute(o, a),
            _vector$b.applyMatrix4(e.matrixWorld),
            this.expandByPoint(_vector$b);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            _box$4.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            _box$4.copy(r.boundingBox)),
          _box$4.applyMatrix4(e.matrixWorld),
          this.union(_box$4);
    }
    const s = e.children;
    for (let o = 0, a = s.length; o < a; o++) this.expandByObject(s[o], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, _vector$b),
      _vector$b.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(_center),
      _extents.subVectors(this.max, _center),
      _v0$2.subVectors(e.a, _center),
      _v1$7.subVectors(e.b, _center),
      _v2$4.subVectors(e.c, _center),
      _f0.subVectors(_v1$7, _v0$2),
      _f1.subVectors(_v2$4, _v1$7),
      _f2.subVectors(_v0$2, _v2$4);
    let t = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ];
    return !satForAxes(t, _v0$2, _v1$7, _v2$4, _extents) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !satForAxes(t, _v0$2, _v1$7, _v2$4, _extents))
      ? !1
      : (_triangleNormal.crossVectors(_f0, _f1),
        (t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]),
        satForAxes(t, _v0$2, _v1$7, _v2$4, _extents));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _vector$b).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(_vector$b).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(_points),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
  ],
  _vector$b = new Vector3(),
  _box$4 = new Box3(),
  _v0$2 = new Vector3(),
  _v1$7 = new Vector3(),
  _v2$4 = new Vector3(),
  _f0 = new Vector3(),
  _f1 = new Vector3(),
  _f2 = new Vector3(),
  _center = new Vector3(),
  _extents = new Vector3(),
  _triangleNormal = new Vector3(),
  _testAxis = new Vector3();
function satForAxes(n, e, t, r, s) {
  for (let o = 0, a = n.length - 3; o <= a; o += 3) {
    _testAxis.fromArray(n, o);
    const l =
        s.x * Math.abs(_testAxis.x) +
        s.y * Math.abs(_testAxis.y) +
        s.z * Math.abs(_testAxis.z),
      c = e.dot(_testAxis),
      u = t.dot(_testAxis),
      p = r.dot(_testAxis);
    if (Math.max(-Math.max(c, u, p), Math.min(c, u, p)) > l) return !1;
  }
  return !0;
}
const _box$3 = new Box3(),
  _v1$6 = new Vector3(),
  _v2$3 = new Vector3();
class Sphere {
  constructor(e = new Vector3(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : _box$3.setFromPoints(e).getCenter(r);
    let s = 0;
    for (let o = 0, a = e.length; o < a; o++)
      s = Math.max(s, r.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(s)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    _v1$6.subVectors(e, this.center);
    const t = _v1$6.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        s = (r - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, s / r), (this.radius += s);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (_v2$3.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(_v1$6.copy(e.center).add(_v2$3)),
            this.expandByPoint(_v1$6.copy(e.center).sub(_v2$3))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = new Vector3(),
  _segCenter = new Vector3(),
  _segDir = new Vector3(),
  _diff = new Vector3(),
  _edge1 = new Vector3(),
  _edge2 = new Vector3(),
  _normal$1 = new Vector3();
class Ray {
  constructor(e = new Vector3(), t = new Vector3(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _vector$a)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _vector$a.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (_vector$a.copy(this.origin).addScaledVector(this.direction, t),
        _vector$a.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, s) {
    _segCenter.copy(e).add(t).multiplyScalar(0.5),
      _segDir.copy(t).sub(e).normalize(),
      _diff.copy(this.origin).sub(_segCenter);
    const o = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(_segDir),
      l = _diff.dot(this.direction),
      c = -_diff.dot(_segDir),
      u = _diff.lengthSq(),
      p = Math.abs(1 - a * a);
    let N, P, de, me;
    if (p > 0)
      if (((N = a * c - l), (P = a * l - c), (me = o * p), N >= 0))
        if (P >= -me)
          if (P <= me) {
            const Ye = 1 / p;
            (N *= Ye),
              (P *= Ye),
              (de = N * (N + a * P + 2 * l) + P * (a * N + P + 2 * c) + u);
          } else
            (P = o),
              (N = Math.max(0, -(a * P + l))),
              (de = -N * N + P * (P + 2 * c) + u);
        else
          (P = -o),
            (N = Math.max(0, -(a * P + l))),
            (de = -N * N + P * (P + 2 * c) + u);
      else
        P <= -me
          ? ((N = Math.max(0, -(-a * o + l))),
            (P = N > 0 ? -o : Math.min(Math.max(-o, -c), o)),
            (de = -N * N + P * (P + 2 * c) + u))
          : P <= me
          ? ((N = 0),
            (P = Math.min(Math.max(-o, -c), o)),
            (de = P * (P + 2 * c) + u))
          : ((N = Math.max(0, -(a * o + l))),
            (P = N > 0 ? o : Math.min(Math.max(-o, -c), o)),
            (de = -N * N + P * (P + 2 * c) + u));
    else
      (P = a > 0 ? -o : o),
        (N = Math.max(0, -(a * P + l))),
        (de = -N * N + P * (P + 2 * c) + u);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, N),
      s && s.copy(_segCenter).addScaledVector(_segDir, P),
      de
    );
  }
  intersectSphere(e, t) {
    _vector$a.subVectors(e.center, this.origin);
    const r = _vector$a.dot(this.direction),
      s = _vector$a.dot(_vector$a) - r * r,
      o = e.radius * e.radius;
    if (s > o) return null;
    const a = Math.sqrt(o - s),
      l = r - a,
      c = r + a;
    return c < 0 ? null : l < 0 ? this.at(c, t) : this.at(l, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, s, o, a, l, c;
    const u = 1 / this.direction.x,
      p = 1 / this.direction.y,
      N = 1 / this.direction.z,
      P = this.origin;
    return (
      u >= 0
        ? ((r = (e.min.x - P.x) * u), (s = (e.max.x - P.x) * u))
        : ((r = (e.max.x - P.x) * u), (s = (e.min.x - P.x) * u)),
      p >= 0
        ? ((o = (e.min.y - P.y) * p), (a = (e.max.y - P.y) * p))
        : ((o = (e.max.y - P.y) * p), (a = (e.min.y - P.y) * p)),
      r > a ||
      o > s ||
      ((o > r || isNaN(r)) && (r = o),
      (a < s || isNaN(s)) && (s = a),
      N >= 0
        ? ((l = (e.min.z - P.z) * N), (c = (e.max.z - P.z) * N))
        : ((l = (e.max.z - P.z) * N), (c = (e.min.z - P.z) * N)),
      r > c || l > s) ||
      ((l > r || r !== r) && (r = l), (c < s || s !== s) && (s = c), s < 0)
        ? null
        : this.at(r >= 0 ? r : s, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, _vector$a) !== null;
  }
  intersectTriangle(e, t, r, s, o) {
    _edge1.subVectors(t, e),
      _edge2.subVectors(r, e),
      _normal$1.crossVectors(_edge1, _edge2);
    let a = this.direction.dot(_normal$1),
      l;
    if (a > 0) {
      if (s) return null;
      l = 1;
    } else if (a < 0) (l = -1), (a = -a);
    else return null;
    _diff.subVectors(this.origin, e);
    const c = l * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (c < 0) return null;
    const u = l * this.direction.dot(_edge1.cross(_diff));
    if (u < 0 || c + u > a) return null;
    const p = -l * _diff.dot(_normal$1);
    return p < 0 ? null : this.at(p / a, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(e, t, r, s, o, a, l, c, u, p, N, P, de, me, Ye, nt) {
    (Matrix4.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 &&
        this.set(e, t, r, s, o, a, l, c, u, p, N, P, de, me, Ye, nt);
  }
  set(e, t, r, s, o, a, l, c, u, p, N, P, de, me, Ye, nt) {
    const Be = this.elements;
    return (
      (Be[0] = e),
      (Be[4] = t),
      (Be[8] = r),
      (Be[12] = s),
      (Be[1] = o),
      (Be[5] = a),
      (Be[9] = l),
      (Be[13] = c),
      (Be[2] = u),
      (Be[6] = p),
      (Be[10] = N),
      (Be[14] = P),
      (Be[3] = de),
      (Be[7] = me),
      (Be[11] = Ye),
      (Be[15] = nt),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      s = 1 / _v1$5.setFromMatrixColumn(e, 0).length(),
      o = 1 / _v1$5.setFromMatrixColumn(e, 1).length(),
      a = 1 / _v1$5.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * s),
      (t[1] = r[1] * s),
      (t[2] = r[2] * s),
      (t[3] = 0),
      (t[4] = r[4] * o),
      (t[5] = r[5] * o),
      (t[6] = r[6] * o),
      (t[7] = 0),
      (t[8] = r[8] * a),
      (t[9] = r[9] * a),
      (t[10] = r[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      s = e.y,
      o = e.z,
      a = Math.cos(r),
      l = Math.sin(r),
      c = Math.cos(s),
      u = Math.sin(s),
      p = Math.cos(o),
      N = Math.sin(o);
    if (e.order === "XYZ") {
      const P = a * p,
        de = a * N,
        me = l * p,
        Ye = l * N;
      (t[0] = c * p),
        (t[4] = -c * N),
        (t[8] = u),
        (t[1] = de + me * u),
        (t[5] = P - Ye * u),
        (t[9] = -l * c),
        (t[2] = Ye - P * u),
        (t[6] = me + de * u),
        (t[10] = a * c);
    } else if (e.order === "YXZ") {
      const P = c * p,
        de = c * N,
        me = u * p,
        Ye = u * N;
      (t[0] = P + Ye * l),
        (t[4] = me * l - de),
        (t[8] = a * u),
        (t[1] = a * N),
        (t[5] = a * p),
        (t[9] = -l),
        (t[2] = de * l - me),
        (t[6] = Ye + P * l),
        (t[10] = a * c);
    } else if (e.order === "ZXY") {
      const P = c * p,
        de = c * N,
        me = u * p,
        Ye = u * N;
      (t[0] = P - Ye * l),
        (t[4] = -a * N),
        (t[8] = me + de * l),
        (t[1] = de + me * l),
        (t[5] = a * p),
        (t[9] = Ye - P * l),
        (t[2] = -a * u),
        (t[6] = l),
        (t[10] = a * c);
    } else if (e.order === "ZYX") {
      const P = a * p,
        de = a * N,
        me = l * p,
        Ye = l * N;
      (t[0] = c * p),
        (t[4] = me * u - de),
        (t[8] = P * u + Ye),
        (t[1] = c * N),
        (t[5] = Ye * u + P),
        (t[9] = de * u - me),
        (t[2] = -u),
        (t[6] = l * c),
        (t[10] = a * c);
    } else if (e.order === "YZX") {
      const P = a * c,
        de = a * u,
        me = l * c,
        Ye = l * u;
      (t[0] = c * p),
        (t[4] = Ye - P * N),
        (t[8] = me * N + de),
        (t[1] = N),
        (t[5] = a * p),
        (t[9] = -l * p),
        (t[2] = -u * p),
        (t[6] = de * N + me),
        (t[10] = P - Ye * N);
    } else if (e.order === "XZY") {
      const P = a * c,
        de = a * u,
        me = l * c,
        Ye = l * u;
      (t[0] = c * p),
        (t[4] = -N),
        (t[8] = u * p),
        (t[1] = P * N + Ye),
        (t[5] = a * p),
        (t[9] = de * N - me),
        (t[2] = me * N - de),
        (t[6] = l * p),
        (t[10] = Ye * N + P);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_zero, e, _one);
  }
  lookAt(e, t, r) {
    const s = this.elements;
    return (
      _z.subVectors(e, t),
      _z.lengthSq() === 0 && (_z.z = 1),
      _z.normalize(),
      _x.crossVectors(r, _z),
      _x.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (_z.x += 1e-4) : (_z.z += 1e-4),
        _z.normalize(),
        _x.crossVectors(r, _z)),
      _x.normalize(),
      _y.crossVectors(_z, _x),
      (s[0] = _x.x),
      (s[4] = _y.x),
      (s[8] = _z.x),
      (s[1] = _x.y),
      (s[5] = _y.y),
      (s[9] = _z.y),
      (s[2] = _x.z),
      (s[6] = _y.z),
      (s[10] = _z.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      s = t.elements,
      o = this.elements,
      a = r[0],
      l = r[4],
      c = r[8],
      u = r[12],
      p = r[1],
      N = r[5],
      P = r[9],
      de = r[13],
      me = r[2],
      Ye = r[6],
      nt = r[10],
      Be = r[14],
      ot = r[3],
      st = r[7],
      vt = r[11],
      xt = r[15],
      St = s[0],
      wt = s[4],
      bt = s[8],
      Tt = s[12],
      Ct = s[1],
      kt = s[5],
      Dt = s[9],
      Vt = s[13],
      Ht = s[2],
      qt = s[6],
      Ft = s[10],
      Bt = s[14],
      Mt = s[3],
      Pt = s[7],
      It = s[11],
      Ot = s[15];
    return (
      (o[0] = a * St + l * Ct + c * Ht + u * Mt),
      (o[4] = a * wt + l * kt + c * qt + u * Pt),
      (o[8] = a * bt + l * Dt + c * Ft + u * It),
      (o[12] = a * Tt + l * Vt + c * Bt + u * Ot),
      (o[1] = p * St + N * Ct + P * Ht + de * Mt),
      (o[5] = p * wt + N * kt + P * qt + de * Pt),
      (o[9] = p * bt + N * Dt + P * Ft + de * It),
      (o[13] = p * Tt + N * Vt + P * Bt + de * Ot),
      (o[2] = me * St + Ye * Ct + nt * Ht + Be * Mt),
      (o[6] = me * wt + Ye * kt + nt * qt + Be * Pt),
      (o[10] = me * bt + Ye * Dt + nt * Ft + Be * It),
      (o[14] = me * Tt + Ye * Vt + nt * Bt + Be * Ot),
      (o[3] = ot * St + st * Ct + vt * Ht + xt * Mt),
      (o[7] = ot * wt + st * kt + vt * qt + xt * Pt),
      (o[11] = ot * bt + st * Dt + vt * Ft + xt * It),
      (o[15] = ot * Tt + st * Vt + vt * Bt + xt * Ot),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      s = e[8],
      o = e[12],
      a = e[1],
      l = e[5],
      c = e[9],
      u = e[13],
      p = e[2],
      N = e[6],
      P = e[10],
      de = e[14],
      me = e[3],
      Ye = e[7],
      nt = e[11],
      Be = e[15];
    return (
      me *
        (+o * c * N -
          s * u * N -
          o * l * P +
          r * u * P +
          s * l * de -
          r * c * de) +
      Ye *
        (+t * c * de -
          t * u * P +
          o * a * P -
          s * a * de +
          s * u * p -
          o * c * p) +
      nt *
        (+t * u * N -
          t * l * de -
          o * a * N +
          r * a * de +
          o * l * p -
          r * u * p) +
      Be *
        (-s * l * p - t * c * N + t * l * P + s * a * N - r * a * P + r * c * p)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const s = this.elements;
    return (
      e.isVector3
        ? ((s[12] = e.x), (s[13] = e.y), (s[14] = e.z))
        : ((s[12] = e), (s[13] = t), (s[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      s = e[2],
      o = e[3],
      a = e[4],
      l = e[5],
      c = e[6],
      u = e[7],
      p = e[8],
      N = e[9],
      P = e[10],
      de = e[11],
      me = e[12],
      Ye = e[13],
      nt = e[14],
      Be = e[15],
      ot =
        N * nt * u -
        Ye * P * u +
        Ye * c * de -
        l * nt * de -
        N * c * Be +
        l * P * Be,
      st =
        me * P * u -
        p * nt * u -
        me * c * de +
        a * nt * de +
        p * c * Be -
        a * P * Be,
      vt =
        p * Ye * u -
        me * N * u +
        me * l * de -
        a * Ye * de -
        p * l * Be +
        a * N * Be,
      xt =
        me * N * c -
        p * Ye * c -
        me * l * P +
        a * Ye * P +
        p * l * nt -
        a * N * nt,
      St = t * ot + r * st + s * vt + o * xt;
    if (St === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const wt = 1 / St;
    return (
      (e[0] = ot * wt),
      (e[1] =
        (Ye * P * o -
          N * nt * o -
          Ye * s * de +
          r * nt * de +
          N * s * Be -
          r * P * Be) *
        wt),
      (e[2] =
        (l * nt * o -
          Ye * c * o +
          Ye * s * u -
          r * nt * u -
          l * s * Be +
          r * c * Be) *
        wt),
      (e[3] =
        (N * c * o -
          l * P * o -
          N * s * u +
          r * P * u +
          l * s * de -
          r * c * de) *
        wt),
      (e[4] = st * wt),
      (e[5] =
        (p * nt * o -
          me * P * o +
          me * s * de -
          t * nt * de -
          p * s * Be +
          t * P * Be) *
        wt),
      (e[6] =
        (me * c * o -
          a * nt * o -
          me * s * u +
          t * nt * u +
          a * s * Be -
          t * c * Be) *
        wt),
      (e[7] =
        (a * P * o -
          p * c * o +
          p * s * u -
          t * P * u -
          a * s * de +
          t * c * de) *
        wt),
      (e[8] = vt * wt),
      (e[9] =
        (me * N * o -
          p * Ye * o -
          me * r * de +
          t * Ye * de +
          p * r * Be -
          t * N * Be) *
        wt),
      (e[10] =
        (a * Ye * o -
          me * l * o +
          me * r * u -
          t * Ye * u -
          a * r * Be +
          t * l * Be) *
        wt),
      (e[11] =
        (p * l * o -
          a * N * o -
          p * r * u +
          t * N * u +
          a * r * de -
          t * l * de) *
        wt),
      (e[12] = xt * wt),
      (e[13] =
        (p * Ye * s -
          me * N * s +
          me * r * P -
          t * Ye * P -
          p * r * nt +
          t * N * nt) *
        wt),
      (e[14] =
        (me * l * s -
          a * Ye * s -
          me * r * c +
          t * Ye * c +
          a * r * nt -
          t * l * nt) *
        wt),
      (e[15] =
        (a * N * s -
          p * l * s +
          p * r * c -
          t * N * c -
          a * r * P +
          t * l * P) *
        wt),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      s = e.y,
      o = e.z;
    return (
      (t[0] *= r),
      (t[4] *= s),
      (t[8] *= o),
      (t[1] *= r),
      (t[5] *= s),
      (t[9] *= o),
      (t[2] *= r),
      (t[6] *= s),
      (t[10] *= o),
      (t[3] *= r),
      (t[7] *= s),
      (t[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, s));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      s = Math.sin(t),
      o = 1 - r,
      a = e.x,
      l = e.y,
      c = e.z,
      u = o * a,
      p = o * l;
    return (
      this.set(
        u * a + r,
        u * l - s * c,
        u * c + s * l,
        0,
        u * l + s * c,
        p * l + r,
        p * c - s * a,
        0,
        u * c - s * l,
        p * c + s * a,
        o * c * c + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, s, o, a) {
    return this.set(1, r, o, 0, e, 1, a, 0, t, s, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const s = this.elements,
      o = t._x,
      a = t._y,
      l = t._z,
      c = t._w,
      u = o + o,
      p = a + a,
      N = l + l,
      P = o * u,
      de = o * p,
      me = o * N,
      Ye = a * p,
      nt = a * N,
      Be = l * N,
      ot = c * u,
      st = c * p,
      vt = c * N,
      xt = r.x,
      St = r.y,
      wt = r.z;
    return (
      (s[0] = (1 - (Ye + Be)) * xt),
      (s[1] = (de + vt) * xt),
      (s[2] = (me - st) * xt),
      (s[3] = 0),
      (s[4] = (de - vt) * St),
      (s[5] = (1 - (P + Be)) * St),
      (s[6] = (nt + ot) * St),
      (s[7] = 0),
      (s[8] = (me + st) * wt),
      (s[9] = (nt - ot) * wt),
      (s[10] = (1 - (P + Ye)) * wt),
      (s[11] = 0),
      (s[12] = e.x),
      (s[13] = e.y),
      (s[14] = e.z),
      (s[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const s = this.elements;
    let o = _v1$5.set(s[0], s[1], s[2]).length();
    const a = _v1$5.set(s[4], s[5], s[6]).length(),
      l = _v1$5.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = s[12]),
      (e.y = s[13]),
      (e.z = s[14]),
      _m1$2.copy(this);
    const u = 1 / o,
      p = 1 / a,
      N = 1 / l;
    return (
      (_m1$2.elements[0] *= u),
      (_m1$2.elements[1] *= u),
      (_m1$2.elements[2] *= u),
      (_m1$2.elements[4] *= p),
      (_m1$2.elements[5] *= p),
      (_m1$2.elements[6] *= p),
      (_m1$2.elements[8] *= N),
      (_m1$2.elements[9] *= N),
      (_m1$2.elements[10] *= N),
      t.setFromRotationMatrix(_m1$2),
      (r.x = o),
      (r.y = a),
      (r.z = l),
      this
    );
  }
  makePerspective(e, t, r, s, o, a, l = WebGLCoordinateSystem) {
    const c = this.elements,
      u = (2 * o) / (t - e),
      p = (2 * o) / (r - s),
      N = (t + e) / (t - e),
      P = (r + s) / (r - s);
    let de, me;
    if (l === WebGLCoordinateSystem)
      (de = -(a + o) / (a - o)), (me = (-2 * a * o) / (a - o));
    else if (l === WebGPUCoordinateSystem)
      (de = -a / (a - o)), (me = (-a * o) / (a - o));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l
      );
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = N),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = p),
      (c[9] = P),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = de),
      (c[14] = me),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, s, o, a, l = WebGLCoordinateSystem) {
    const c = this.elements,
      u = 1 / (t - e),
      p = 1 / (r - s),
      N = 1 / (a - o),
      P = (t + e) * u,
      de = (r + s) * p;
    let me, Ye;
    if (l === WebGLCoordinateSystem) (me = (a + o) * N), (Ye = -2 * N);
    else if (l === WebGPUCoordinateSystem) (me = o * N), (Ye = -1 * N);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l
      );
    return (
      (c[0] = 2 * u),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = -P),
      (c[1] = 0),
      (c[5] = 2 * p),
      (c[9] = 0),
      (c[13] = -de),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = Ye),
      (c[14] = -me),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let s = 0; s < 16; s++) if (t[s] !== r[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const _v1$5 = new Vector3(),
  _m1$2 = new Matrix4(),
  _zero = new Vector3(0, 0, 0),
  _one = new Vector3(1, 1, 1),
  _x = new Vector3(),
  _y = new Vector3(),
  _z = new Vector3(),
  _matrix$2 = new Matrix4(),
  _quaternion$3 = new Quaternion();
class Euler {
  constructor(e = 0, t = 0, r = 0, s = Euler.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = s);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, s = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = s),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const s = e.elements,
      o = s[0],
      a = s[4],
      l = s[8],
      c = s[1],
      u = s[5],
      p = s[9],
      N = s[2],
      P = s[6],
      de = s[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(clamp$1(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-p, de)), (this._z = Math.atan2(-a, o)))
            : ((this._x = Math.atan2(P, u)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-clamp$1(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(l, de)), (this._z = Math.atan2(c, u)))
            : ((this._y = Math.atan2(-N, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(clamp$1(P, -1, 1))),
          Math.abs(P) < 0.9999999
            ? ((this._y = Math.atan2(-N, de)), (this._z = Math.atan2(-a, u)))
            : ((this._y = 0), (this._z = Math.atan2(c, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-clamp$1(N, -1, 1))),
          Math.abs(N) < 0.9999999
            ? ((this._x = Math.atan2(P, de)), (this._z = Math.atan2(c, o)))
            : ((this._x = 0), (this._z = Math.atan2(-a, u)));
        break;
      case "YZX":
        (this._z = Math.asin(clamp$1(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-p, u)), (this._y = Math.atan2(-N, o)))
            : ((this._x = 0), (this._y = Math.atan2(l, de)));
        break;
      case "XZY":
        (this._z = Math.asin(-clamp$1(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(P, u)), (this._y = Math.atan2(l, o)))
            : ((this._x = Math.atan2(-p, de)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      _matrix$2.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(_matrix$2, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return (
      _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = new Vector3(),
  _q1 = new Quaternion(),
  _m1$1$1 = new Matrix4(),
  _target = new Vector3(),
  _position$3 = new Vector3(),
  _scale$2 = new Vector3(),
  _quaternion$2 = new Quaternion(),
  _xAxis = new Vector3(1, 0, 0),
  _yAxis = new Vector3(0, 1, 0),
  _zAxis = new Vector3(0, 0, 1),
  _addedEvent = { type: "added" },
  _removedEvent = { type: "removed" },
  _childaddedEvent = { type: "childadded", child: null },
  _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: _object3DId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Object3D.DEFAULT_UP.clone());
    const e = new Vector3(),
      t = new Euler(),
      r = new Quaternion(),
      s = new Vector3(1, 1, 1);
    function o() {
      r.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(o),
      r._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: s },
        modelViewMatrix: { value: new Matrix4() },
        normalMatrix: { value: new Matrix3() },
      }),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Layers()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.premultiply(_q1), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(_xAxis, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(_yAxis, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(_zAxis, e);
  }
  translateOnAxis(e, t) {
    return (
      _v1$4.copy(e).applyQuaternion(this.quaternion),
      this.position.add(_v1$4.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(_xAxis, e);
  }
  translateY(e) {
    return this.translateOnAxis(_yAxis, e);
  }
  translateZ(e) {
    return this.translateOnAxis(_zAxis, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? _target.copy(e) : _target.set(e, t, r);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1),
      _position$3.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? _m1$1$1.lookAt(_position$3, _target, this.up)
        : _m1$1$1.lookAt(_target, _position$3, this.up),
      this.quaternion.setFromRotationMatrix(_m1$1$1),
      s &&
        (_m1$1$1.extractRotation(s.matrixWorld),
        _q1.setFromRotationMatrix(_m1$1$1),
        this.quaternion.premultiply(_q1.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(_addedEvent),
            (_childaddedEvent.child = e),
            this.dispatchEvent(_childaddedEvent),
            (_childaddedEvent.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(_removedEvent),
        (_childremovedEvent.child = e),
        this.dispatchEvent(_childremovedEvent),
        (_childremovedEvent.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      _m1$1$1.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1),
        _m1$1$1.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(_m1$1$1),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(_addedEvent),
      (_childaddedEvent.child = e),
      this.dispatchEvent(_childaddedEvent),
      (_childaddedEvent.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, s = this.children.length; r < s; r++) {
      const a = this.children[r].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const s = this.children;
    for (let o = 0, a = s.length; o < a; o++)
      s[o].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, e, _scale$2),
      e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, _quaternion$2, e),
      e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, s = t.length; r < s; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, s = t.length; r < s; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, s = t.length; r < s; r++) t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const s = this.children;
      for (let o = 0, a = s.length; o < a; o++) s[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const s = {};
    (s.uuid = this.uuid),
      (s.type = this.type),
      this.name !== "" && (s.name = this.name),
      this.castShadow === !0 && (s.castShadow = !0),
      this.receiveShadow === !0 && (s.receiveShadow = !0),
      this.visible === !1 && (s.visible = !1),
      this.frustumCulled === !1 && (s.frustumCulled = !1),
      this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (s.userData = this.userData),
      (s.layers = this.layers.mask),
      (s.matrix = this.matrix.toArray()),
      (s.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((s.type = "InstancedMesh"),
        (s.count = this.count),
        (s.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (s.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((s.type = "BatchedMesh"),
        (s.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (s.sortObjects = this.sortObjects),
        (s.drawRanges = this._drawRanges),
        (s.reservedRanges = this._reservedRanges),
        (s.geometryInfo = this._geometryInfo.map((l) => ({
          ...l,
          boundingBox: l.boundingBox
            ? {
                min: l.boundingBox.min.toArray(),
                max: l.boundingBox.max.toArray(),
              }
            : void 0,
          boundingSphere: l.boundingSphere
            ? {
                radius: l.boundingSphere.radius,
                center: l.boundingSphere.center.toArray(),
              }
            : void 0,
        }))),
        (s.instanceInfo = this._instanceInfo.map((l) => ({ ...l }))),
        (s.availableInstanceIds = this._availableInstanceIds.slice()),
        (s.availableGeometryIds = this._availableGeometryIds.slice()),
        (s.nextIndexStart = this._nextIndexStart),
        (s.nextVertexStart = this._nextVertexStart),
        (s.geometryCount = this._geometryCount),
        (s.maxInstanceCount = this._maxInstanceCount),
        (s.maxVertexCount = this._maxVertexCount),
        (s.maxIndexCount = this._maxIndexCount),
        (s.geometryInitialized = this._geometryInitialized),
        (s.matricesTexture = this._matricesTexture.toJSON(e)),
        (s.indirectTexture = this._indirectTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (s.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (s.boundingSphere = {
            center: this.boundingSphere.center.toArray(),
            radius: this.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (s.boundingBox = {
            min: this.boundingBox.min.toArray(),
            max: this.boundingBox.max.toArray(),
          }));
    function o(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (s.background = this.background.toJSON())
          : this.background.isTexture &&
            (s.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let u = 0, p = c.length; u < p; u++) {
            const N = c[u];
            o(e.shapes, N);
          }
        else o(e.shapes, c);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((s.bindMode = this.bindMode),
        (s.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (s.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          l.push(o(e.materials, this.material[c]));
        s.material = l;
      } else s.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        s.animations.push(o(e.animations, c));
      }
    }
    if (t) {
      const l = a(e.geometries),
        c = a(e.materials),
        u = a(e.textures),
        p = a(e.images),
        N = a(e.shapes),
        P = a(e.skeletons),
        de = a(e.animations),
        me = a(e.nodes);
      l.length > 0 && (r.geometries = l),
        c.length > 0 && (r.materials = c),
        u.length > 0 && (r.textures = u),
        p.length > 0 && (r.images = p),
        N.length > 0 && (r.shapes = N),
        P.length > 0 && (r.skeletons = P),
        de.length > 0 && (r.animations = de),
        me.length > 0 && (r.nodes = me);
    }
    return (r.object = s), r;
    function a(l) {
      const c = [];
      for (const u in l) {
        const p = l[u];
        delete p.metadata, c.push(p);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const s = e.children[r];
        this.add(s.clone());
      }
    return this;
  }
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$1 = new Vector3(),
  _v1$3 = new Vector3(),
  _v2$2 = new Vector3(),
  _v3$2 = new Vector3(),
  _vab = new Vector3(),
  _vac = new Vector3(),
  _vbc = new Vector3(),
  _vap = new Vector3(),
  _vbp = new Vector3(),
  _vcp = new Vector3(),
  _v40 = new Vector4(),
  _v41 = new Vector4(),
  _v42 = new Vector4();
class Triangle {
  constructor(e = new Vector3(), t = new Vector3(), r = new Vector3()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, s) {
    s.subVectors(r, t), _v0$1.subVectors(e, t), s.cross(_v0$1);
    const o = s.lengthSq();
    return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, s, o) {
    _v0$1.subVectors(s, t), _v1$3.subVectors(r, t), _v2$2.subVectors(e, t);
    const a = _v0$1.dot(_v0$1),
      l = _v0$1.dot(_v1$3),
      c = _v0$1.dot(_v2$2),
      u = _v1$3.dot(_v1$3),
      p = _v1$3.dot(_v2$2),
      N = a * u - l * l;
    if (N === 0) return o.set(0, 0, 0), null;
    const P = 1 / N,
      de = (u * c - l * p) * P,
      me = (a * p - l * c) * P;
    return o.set(1 - de - me, me, de);
  }
  static containsPoint(e, t, r, s) {
    return this.getBarycoord(e, t, r, s, _v3$2) === null
      ? !1
      : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(e, t, r, s, o, a, l, c) {
    return this.getBarycoord(e, t, r, s, _v3$2) === null
      ? ((c.x = 0),
        (c.y = 0),
        "z" in c && (c.z = 0),
        "w" in c && (c.w = 0),
        null)
      : (c.setScalar(0),
        c.addScaledVector(o, _v3$2.x),
        c.addScaledVector(a, _v3$2.y),
        c.addScaledVector(l, _v3$2.z),
        c);
  }
  static getInterpolatedAttribute(e, t, r, s, o, a) {
    return (
      _v40.setScalar(0),
      _v41.setScalar(0),
      _v42.setScalar(0),
      _v40.fromBufferAttribute(e, t),
      _v41.fromBufferAttribute(e, r),
      _v42.fromBufferAttribute(e, s),
      a.setScalar(0),
      a.addScaledVector(_v40, o.x),
      a.addScaledVector(_v41, o.y),
      a.addScaledVector(_v42, o.z),
      a
    );
  }
  static isFrontFacing(e, t, r, s) {
    return (
      _v0$1.subVectors(r, t),
      _v1$3.subVectors(e, t),
      _v0$1.cross(_v1$3).dot(s) < 0
    );
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, s) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, t, r, s) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, s),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      _v0$1.subVectors(this.c, this.b),
      _v1$3.subVectors(this.a, this.b),
      _v0$1.cross(_v1$3).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Triangle.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Triangle.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, s, o) {
    return Triangle.getInterpolation(e, this.a, this.b, this.c, t, r, s, o);
  }
  containsPoint(e) {
    return Triangle.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      s = this.b,
      o = this.c;
    let a, l;
    _vab.subVectors(s, r), _vac.subVectors(o, r), _vap.subVectors(e, r);
    const c = _vab.dot(_vap),
      u = _vac.dot(_vap);
    if (c <= 0 && u <= 0) return t.copy(r);
    _vbp.subVectors(e, s);
    const p = _vab.dot(_vbp),
      N = _vac.dot(_vbp);
    if (p >= 0 && N <= p) return t.copy(s);
    const P = c * N - p * u;
    if (P <= 0 && c >= 0 && p <= 0)
      return (a = c / (c - p)), t.copy(r).addScaledVector(_vab, a);
    _vcp.subVectors(e, o);
    const de = _vab.dot(_vcp),
      me = _vac.dot(_vcp);
    if (me >= 0 && de <= me) return t.copy(o);
    const Ye = de * u - c * me;
    if (Ye <= 0 && u >= 0 && me <= 0)
      return (l = u / (u - me)), t.copy(r).addScaledVector(_vac, l);
    const nt = p * me - de * N;
    if (nt <= 0 && N - p >= 0 && de - me >= 0)
      return (
        _vbc.subVectors(o, s),
        (l = (N - p) / (N - p + (de - me))),
        t.copy(s).addScaledVector(_vbc, l)
      );
    const Be = 1 / (nt + Ye + P);
    return (
      (a = Ye * Be),
      (l = P * Be),
      t.copy(r).addScaledVector(_vab, a).addScaledVector(_vac, l)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  _hslA = { h: 0, s: 0, l: 0 },
  _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Color {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const s = e;
      s && s.isColor
        ? this.copy(s)
        : typeof s == "number"
        ? this.setHex(s)
        : typeof s == "string" && this.setStyle(s);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = SRGBColorSpace) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      ColorManagement.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, s = ColorManagement.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      ColorManagement.toWorkingColorSpace(this, s),
      this
    );
  }
  setHSL(e, t, r, s = ColorManagement.workingColorSpace) {
    if (
      ((e = euclideanModulo(e, 1)),
      (t = clamp$1(t, 0, 1)),
      (r = clamp$1(r, 0, 1)),
      t === 0)
    )
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        a = 2 * r - o;
      (this.r = hue2rgb(a, o, e + 1 / 3)),
        (this.g = hue2rgb(a, o, e)),
        (this.b = hue2rgb(a, o, e - 1 / 3));
    }
    return ColorManagement.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, t = SRGBColorSpace) {
    function r(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let s;
    if ((s = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const a = s[1],
        l = s[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                t
              )
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l
              ))
          )
            return (
              r(o[4]),
              this.setHSL(
                parseFloat(o[1]) / 360,
                parseFloat(o[2]) / 100,
                parseFloat(o[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((s = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = s[1],
        a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (a === 6) return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = SRGBColorSpace) {
    const r = _colorKeywords[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (
      (this.r = SRGBToLinear(e.r)),
      (this.g = SRGBToLinear(e.g)),
      (this.b = SRGBToLinear(e.b)),
      this
    );
  }
  copyLinearToSRGB(e) {
    return (
      (this.r = LinearToSRGB(e.r)),
      (this.g = LinearToSRGB(e.g)),
      (this.b = LinearToSRGB(e.b)),
      this
    );
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = SRGBColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), e),
      Math.round(clamp$1(_color.r * 255, 0, 255)) * 65536 +
        Math.round(clamp$1(_color.g * 255, 0, 255)) * 256 +
        Math.round(clamp$1(_color.b * 255, 0, 255))
    );
  }
  getHexString(e = SRGBColorSpace) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), t);
    const r = _color.r,
      s = _color.g,
      o = _color.b,
      a = Math.max(r, s, o),
      l = Math.min(r, s, o);
    let c, u;
    const p = (l + a) / 2;
    if (l === a) (c = 0), (u = 0);
    else {
      const N = a - l;
      switch (((u = p <= 0.5 ? N / (a + l) : N / (2 - a - l)), a)) {
        case r:
          c = (s - o) / N + (s < o ? 6 : 0);
          break;
        case s:
          c = (o - r) / N + 2;
          break;
        case o:
          c = (r - s) / N + 4;
          break;
      }
      c /= 6;
    }
    return (e.h = c), (e.s = u), (e.l = p), e;
  }
  getRGB(e, t = ColorManagement.workingColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), t),
      (e.r = _color.r),
      (e.g = _color.g),
      (e.b = _color.b),
      e
    );
  }
  getStyle(e = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), e);
    const t = _color.r,
      r = _color.g,
      s = _color.b;
    return e !== SRGBColorSpace
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${s.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          s * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return (
      this.getHSL(_hslA), this.setHSL(_hslA.h + e, _hslA.s + t, _hslA.l + r)
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(_hslA), e.getHSL(_hslB);
    const r = lerp(_hslA.h, _hslB.h, t),
      s = lerp(_hslA.s, _hslB.s, t),
      o = lerp(_hslA.l, _hslB.l, t);
    return this.setHSL(r, s, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      s = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * t + o[3] * r + o[6] * s),
      (this.g = o[1] * t + o[4] * r + o[7] * s),
      (this.b = o[2] * t + o[5] * r + o[8] * s),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const _color = new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: _materialId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = NormalBlending),
      (this.side = FrontSide),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = SrcAlphaFactor),
      (this.blendDst = OneMinusSrcAlphaFactor),
      (this.blendEquation = AddEquation),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Color(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = LessEqualDepth),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = AlwaysStencilFunc),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = KeepStencilOp),
      (this.stencilZFail = KeepStencilOp),
      (this.stencilZPass = KeepStencilOp),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const s = this[t];
        if (s === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        s && s.isColor
          ? s.set(r)
          : s && s.isVector3 && r && r.isVector3
          ? s.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== NormalBlending && (r.blending = this.blending),
      this.side !== FrontSide && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== SrcAlphaFactor && (r.blendSrc = this.blendSrc),
      this.blendDst !== OneMinusSrcAlphaFactor && (r.blendDst = this.blendDst),
      this.blendEquation !== AddEquation &&
        (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== LessEqualDepth && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== AlwaysStencilFunc &&
        (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== KeepStencilOp && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== KeepStencilOp &&
        (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== KeepStencilOp &&
        (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function s(o) {
      const a = [];
      for (const l in o) {
        const c = o[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (t) {
      const o = s(e.textures),
        a = s(e.images);
      o.length > 0 && (r.textures = o), a.length > 0 && (r.images = a);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const s = t.length;
      r = new Array(s);
      for (let o = 0; o !== s; ++o) r[o] = t[o].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class MeshBasicMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const _tables = _generateTables();
function _generateTables() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    s = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const u = c - 127;
    u < -27
      ? ((r[c] = 0), (r[c | 256] = 32768), (s[c] = 24), (s[c | 256] = 24))
      : u < -14
      ? ((r[c] = 1024 >> (-u - 14)),
        (r[c | 256] = (1024 >> (-u - 14)) | 32768),
        (s[c] = -u - 1),
        (s[c | 256] = -u - 1))
      : u <= 15
      ? ((r[c] = (u + 15) << 10),
        (r[c | 256] = ((u + 15) << 10) | 32768),
        (s[c] = 13),
        (s[c | 256] = 13))
      : u < 128
      ? ((r[c] = 31744), (r[c | 256] = 64512), (s[c] = 24), (s[c | 256] = 24))
      : ((r[c] = 31744), (r[c | 256] = 64512), (s[c] = 13), (s[c | 256] = 13));
  }
  const o = new Uint32Array(2048),
    a = new Uint32Array(64),
    l = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let u = c << 13,
      p = 0;
    for (; (u & 8388608) === 0; ) (u <<= 1), (p -= 8388608);
    (u &= -8388609), (p += 947912704), (o[c] = u | p);
  }
  for (let c = 1024; c < 2048; ++c) o[c] = 939524096 + ((c - 1024) << 13);
  for (let c = 1; c < 31; ++c) a[c] = c << 23;
  (a[31] = 1199570944), (a[32] = 2147483648);
  for (let c = 33; c < 63; ++c) a[c] = 2147483648 + ((c - 32) << 23);
  a[63] = 3347054592;
  for (let c = 1; c < 64; ++c) c !== 32 && (l[c] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: s,
    mantissaTable: o,
    exponentTable: a,
    offsetTable: l,
  };
}
function toHalfFloat(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = clamp$1(n, -65504, 65504)),
    (_tables.floatView[0] = n);
  const e = _tables.uint32View[0],
    t = (e >> 23) & 511;
  return _tables.baseTable[t] + ((e & 8388607) >> _tables.shiftTable[t]);
}
function fromHalfFloat(n) {
  const e = n >> 10;
  return (
    (_tables.uint32View[0] =
      _tables.mantissaTable[_tables.offsetTable[e] + (n & 1023)] +
      _tables.exponentTable[e]),
    _tables.floatView[0]
  );
}
class DataUtils {
  static toHalfFloat(e) {
    return toHalfFloat(e);
  }
  static fromHalfFloat(e) {
    return fromHalfFloat(e);
  }
}
const _vector$9 = new Vector3(),
  _vector2$1 = new Vector2();
let _id$2 = 0;
class BufferAttribute {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: _id$2++ }),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = StaticDrawUsage),
      (this.updateRanges = []),
      (this.gpuType = FloatType),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let s = 0, o = this.itemSize; s < o; s++)
      this.array[e + s] = t.array[r + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        _vector2$1.fromBufferAttribute(this, t),
          _vector2$1.applyMatrix3(e),
          this.setXY(t, _vector2$1.x, _vector2$1.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        _vector$9.fromBufferAttribute(this, t),
          _vector$9.applyMatrix3(e),
          this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      _vector$9.fromBufferAttribute(this, t),
        _vector$9.applyMatrix4(e),
        this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      _vector$9.fromBufferAttribute(this, t),
        _vector$9.applyNormalMatrix(e),
        this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      _vector$9.fromBufferAttribute(this, t),
        _vector$9.transformDirection(e),
        this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = denormalize(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = normalize$1(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = normalize$1(t, this.array)), (r = normalize$1(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = normalize$1(t, this.array)),
        (r = normalize$1(r, this.array)),
        (s = normalize$1(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = s),
      this
    );
  }
  setXYZW(e, t, r, s, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = normalize$1(t, this.array)),
        (r = normalize$1(r, this.array)),
        (s = normalize$1(s, this.array)),
        (o = normalize$1(o, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = s),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== StaticDrawUsage && (e.usage = this.usage),
      e
    );
  }
}
class Int8BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = fromHalfFloat(this.array[e * this.itemSize]);
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize] = toHalfFloat(t)),
      this
    );
  }
  getY(e) {
    let t = fromHalfFloat(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize + 1] = toHalfFloat(t)),
      this
    );
  }
  getZ(e) {
    let t = fromHalfFloat(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize + 2] = toHalfFloat(t)),
      this
    );
  }
  getW(e) {
    let t = fromHalfFloat(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.array[e * this.itemSize + 3] = toHalfFloat(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = normalize$1(t, this.array)), (r = normalize$1(r, this.array))),
      (this.array[e + 0] = toHalfFloat(t)),
      (this.array[e + 1] = toHalfFloat(r)),
      this
    );
  }
  setXYZ(e, t, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = normalize$1(t, this.array)),
        (r = normalize$1(r, this.array)),
        (s = normalize$1(s, this.array))),
      (this.array[e + 0] = toHalfFloat(t)),
      (this.array[e + 1] = toHalfFloat(r)),
      (this.array[e + 2] = toHalfFloat(s)),
      this
    );
  }
  setXYZW(e, t, r, s, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = normalize$1(t, this.array)),
        (r = normalize$1(r, this.array)),
        (s = normalize$1(s, this.array)),
        (o = normalize$1(o, this.array))),
      (this.array[e + 0] = toHalfFloat(t)),
      (this.array[e + 1] = toHalfFloat(r)),
      (this.array[e + 2] = toHalfFloat(s)),
      (this.array[e + 3] = toHalfFloat(o)),
      this
    );
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let _id$1 = 0;
const _m1$3 = new Matrix4(),
  _obj = new Object3D(),
  _offset = new Vector3(),
  _box$2 = new Box3(),
  _boxMorphTargets = new Box3(),
  _vector$8 = new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _id$1++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (
            arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute
          )(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new Matrix3().getNormalMatrix(e);
      r.applyNormalMatrix(o), (r.needsUpdate = !0);
    }
    const s = this.attributes.tangent;
    return (
      s !== void 0 && (s.transformDirection(e), (s.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return _m1$3.makeRotationFromQuaternion(e), this.applyMatrix4(_m1$3), this;
  }
  rotateX(e) {
    return _m1$3.makeRotationX(e), this.applyMatrix4(_m1$3), this;
  }
  rotateY(e) {
    return _m1$3.makeRotationY(e), this.applyMatrix4(_m1$3), this;
  }
  rotateZ(e) {
    return _m1$3.makeRotationZ(e), this.applyMatrix4(_m1$3), this;
  }
  translate(e, t, r) {
    return _m1$3.makeTranslation(e, t, r), this.applyMatrix4(_m1$3), this;
  }
  scale(e, t, r) {
    return _m1$3.makeScale(e, t, r), this.applyMatrix4(_m1$3), this;
  }
  lookAt(e) {
    return (
      _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(_offset).negate(),
      this.translate(_offset.x, _offset.y, _offset.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const r = [];
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        r.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(r, 3));
    } else {
      const r = Math.min(e.length, t.count);
      for (let s = 0; s < r; s++) {
        const o = e[s];
        t.setXYZ(s, o.x, o.y, o.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new Vector3(-1 / 0, -1 / 0, -1 / 0),
          new Vector3(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, s = t.length; r < s; r++) {
          const o = t[r];
          _box$2.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min),
                this.boundingBox.expandByPoint(_vector$8),
                _vector$8.addVectors(this.boundingBox.max, _box$2.max),
                this.boundingBox.expandByPoint(_vector$8))
              : (this.boundingBox.expandByPoint(_box$2.min),
                this.boundingBox.expandByPoint(_box$2.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new Vector3(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((_box$2.setFromBufferAttribute(e), t))
        for (let o = 0, a = t.length; o < a; o++) {
          const l = t[o];
          _boxMorphTargets.setFromBufferAttribute(l),
            this.morphTargetsRelative
              ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min),
                _box$2.expandByPoint(_vector$8),
                _vector$8.addVectors(_box$2.max, _boxMorphTargets.max),
                _box$2.expandByPoint(_vector$8))
              : (_box$2.expandByPoint(_boxMorphTargets.min),
                _box$2.expandByPoint(_boxMorphTargets.max));
        }
      _box$2.getCenter(r);
      let s = 0;
      for (let o = 0, a = e.count; o < a; o++)
        _vector$8.fromBufferAttribute(e, o),
          (s = Math.max(s, r.distanceToSquared(_vector$8)));
      if (t)
        for (let o = 0, a = t.length; o < a; o++) {
          const l = t[o],
            c = this.morphTargetsRelative;
          for (let u = 0, p = l.count; u < p; u++)
            _vector$8.fromBufferAttribute(l, u),
              c && (_offset.fromBufferAttribute(e, u), _vector$8.add(_offset)),
              (s = Math.max(s, r.distanceToSquared(_vector$8)));
        }
      (this.boundingSphere.radius = Math.sqrt(s)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = t.position,
      s = t.normal,
      o = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * r.count), 4)
      );
    const a = this.getAttribute("tangent"),
      l = [],
      c = [];
    for (let bt = 0; bt < r.count; bt++)
      (l[bt] = new Vector3()), (c[bt] = new Vector3());
    const u = new Vector3(),
      p = new Vector3(),
      N = new Vector3(),
      P = new Vector2(),
      de = new Vector2(),
      me = new Vector2(),
      Ye = new Vector3(),
      nt = new Vector3();
    function Be(bt, Tt, Ct) {
      u.fromBufferAttribute(r, bt),
        p.fromBufferAttribute(r, Tt),
        N.fromBufferAttribute(r, Ct),
        P.fromBufferAttribute(o, bt),
        de.fromBufferAttribute(o, Tt),
        me.fromBufferAttribute(o, Ct),
        p.sub(u),
        N.sub(u),
        de.sub(P),
        me.sub(P);
      const kt = 1 / (de.x * me.y - me.x * de.y);
      isFinite(kt) &&
        (Ye.copy(p)
          .multiplyScalar(me.y)
          .addScaledVector(N, -de.y)
          .multiplyScalar(kt),
        nt
          .copy(N)
          .multiplyScalar(de.x)
          .addScaledVector(p, -me.x)
          .multiplyScalar(kt),
        l[bt].add(Ye),
        l[Tt].add(Ye),
        l[Ct].add(Ye),
        c[bt].add(nt),
        c[Tt].add(nt),
        c[Ct].add(nt));
    }
    let ot = this.groups;
    ot.length === 0 && (ot = [{ start: 0, count: e.count }]);
    for (let bt = 0, Tt = ot.length; bt < Tt; ++bt) {
      const Ct = ot[bt],
        kt = Ct.start,
        Dt = Ct.count;
      for (let Vt = kt, Ht = kt + Dt; Vt < Ht; Vt += 3)
        Be(e.getX(Vt + 0), e.getX(Vt + 1), e.getX(Vt + 2));
    }
    const st = new Vector3(),
      vt = new Vector3(),
      xt = new Vector3(),
      St = new Vector3();
    function wt(bt) {
      xt.fromBufferAttribute(s, bt), St.copy(xt);
      const Tt = l[bt];
      st.copy(Tt),
        st.sub(xt.multiplyScalar(xt.dot(Tt))).normalize(),
        vt.crossVectors(St, Tt);
      const kt = vt.dot(c[bt]) < 0 ? -1 : 1;
      a.setXYZW(bt, st.x, st.y, st.z, kt);
    }
    for (let bt = 0, Tt = ot.length; bt < Tt; ++bt) {
      const Ct = ot[bt],
        kt = Ct.start,
        Dt = Ct.count;
      for (let Vt = kt, Ht = kt + Dt; Vt < Ht; Vt += 3)
        wt(e.getX(Vt + 0)), wt(e.getX(Vt + 1)), wt(e.getX(Vt + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new BufferAttribute(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let P = 0, de = r.count; P < de; P++) r.setXYZ(P, 0, 0, 0);
      const s = new Vector3(),
        o = new Vector3(),
        a = new Vector3(),
        l = new Vector3(),
        c = new Vector3(),
        u = new Vector3(),
        p = new Vector3(),
        N = new Vector3();
      if (e)
        for (let P = 0, de = e.count; P < de; P += 3) {
          const me = e.getX(P + 0),
            Ye = e.getX(P + 1),
            nt = e.getX(P + 2);
          s.fromBufferAttribute(t, me),
            o.fromBufferAttribute(t, Ye),
            a.fromBufferAttribute(t, nt),
            p.subVectors(a, o),
            N.subVectors(s, o),
            p.cross(N),
            l.fromBufferAttribute(r, me),
            c.fromBufferAttribute(r, Ye),
            u.fromBufferAttribute(r, nt),
            l.add(p),
            c.add(p),
            u.add(p),
            r.setXYZ(me, l.x, l.y, l.z),
            r.setXYZ(Ye, c.x, c.y, c.z),
            r.setXYZ(nt, u.x, u.y, u.z);
        }
      else
        for (let P = 0, de = t.count; P < de; P += 3)
          s.fromBufferAttribute(t, P + 0),
            o.fromBufferAttribute(t, P + 1),
            a.fromBufferAttribute(t, P + 2),
            p.subVectors(a, o),
            N.subVectors(s, o),
            p.cross(N),
            r.setXYZ(P + 0, p.x, p.y, p.z),
            r.setXYZ(P + 1, p.x, p.y, p.z),
            r.setXYZ(P + 2, p.x, p.y, p.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      _vector$8.fromBufferAttribute(e, t),
        _vector$8.normalize(),
        e.setXYZ(t, _vector$8.x, _vector$8.y, _vector$8.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const u = l.array,
        p = l.itemSize,
        N = l.normalized,
        P = new u.constructor(c.length * p);
      let de = 0,
        me = 0;
      for (let Ye = 0, nt = c.length; Ye < nt; Ye++) {
        l.isInterleavedBufferAttribute
          ? (de = c[Ye] * l.data.stride + l.offset)
          : (de = c[Ye] * p);
        for (let Be = 0; Be < p; Be++) P[me++] = u[de++];
      }
      return new BufferAttribute(P, p, N);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new BufferGeometry(),
      r = this.index.array,
      s = this.attributes;
    for (const l in s) {
      const c = s[l],
        u = e(c, r);
      t.setAttribute(l, u);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const c = [],
        u = o[l];
      for (let p = 0, N = u.length; p < N; p++) {
        const P = u[p],
          de = e(P, r);
        c.push(de);
      }
      t.morphAttributes[l] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const c = this.parameters;
      for (const u in c) c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const c in r) {
      const u = r[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const s = {};
    let o = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c],
        p = [];
      for (let N = 0, P = u.length; N < P; N++) {
        const de = u[N];
        p.push(de.toJSON(e.data));
      }
      p.length > 0 && ((s[c] = p), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = s),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const l = this.boundingSphere;
    return (
      l !== null &&
        (e.data.boundingSphere = {
          center: l.center.toArray(),
          radius: l.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone());
    const s = e.attributes;
    for (const u in s) {
      const p = s[u];
      this.setAttribute(u, p.clone(t));
    }
    const o = e.morphAttributes;
    for (const u in o) {
      const p = [],
        N = o[u];
      for (let P = 0, de = N.length; P < de; P++) p.push(N[P].clone(t));
      this.morphAttributes[u] = p;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let u = 0, p = a.length; u < p; u++) {
      const N = a[u];
      this.addGroup(N.start, N.count, N.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return (
      c !== null && (this.boundingSphere = c.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = new Matrix4(),
  _ray$3 = new Ray(),
  _sphere$6 = new Sphere(),
  _sphereHitAt = new Vector3(),
  _vA$1 = new Vector3(),
  _vB$1 = new Vector3(),
  _vC$1 = new Vector3(),
  _tempA = new Vector3(),
  _morphA = new Vector3(),
  _intersectionPoint = new Vector3(),
  _intersectionPointWorld = new Vector3();
class Mesh extends Object3D {
  constructor(e = new BufferGeometry(), t = new MeshBasicMaterial()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const s = t[r[0]];
      if (s !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = s.length; o < a; o++) {
          const l = s[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      s = r.attributes.position,
      o = r.morphAttributes.position,
      a = r.morphTargetsRelative;
    t.fromBufferAttribute(s, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      _morphA.set(0, 0, 0);
      for (let c = 0, u = o.length; c < u; c++) {
        const p = l[c],
          N = o[c];
        p !== 0 &&
          (_tempA.fromBufferAttribute(N, e),
          a
            ? _morphA.addScaledVector(_tempA, p)
            : _morphA.addScaledVector(_tempA.sub(t), p));
      }
      t.add(_morphA);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      s = this.material,
      o = this.matrixWorld;
    s !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      _sphere$6.copy(r.boundingSphere),
      _sphere$6.applyMatrix4(o),
      _ray$3.copy(e.ray).recast(e.near),
      !(
        _sphere$6.containsPoint(_ray$3.origin) === !1 &&
        (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null ||
          _ray$3.origin.distanceToSquared(_sphereHitAt) > (e.far - e.near) ** 2)
      ) &&
        (_inverseMatrix$3.copy(o).invert(),
        _ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3),
        !(
          r.boundingBox !== null && _ray$3.intersectsBox(r.boundingBox) === !1
        ) && this._computeIntersections(e, t, _ray$3)));
  }
  _computeIntersections(e, t, r) {
    let s;
    const o = this.geometry,
      a = this.material,
      l = o.index,
      c = o.attributes.position,
      u = o.attributes.uv,
      p = o.attributes.uv1,
      N = o.attributes.normal,
      P = o.groups,
      de = o.drawRange;
    if (l !== null)
      if (Array.isArray(a))
        for (let me = 0, Ye = P.length; me < Ye; me++) {
          const nt = P[me],
            Be = a[nt.materialIndex],
            ot = Math.max(nt.start, de.start),
            st = Math.min(
              l.count,
              Math.min(nt.start + nt.count, de.start + de.count)
            );
          for (let vt = ot, xt = st; vt < xt; vt += 3) {
            const St = l.getX(vt),
              wt = l.getX(vt + 1),
              bt = l.getX(vt + 2);
            (s = checkGeometryIntersection(
              this,
              Be,
              e,
              r,
              u,
              p,
              N,
              St,
              wt,
              bt
            )),
              s &&
                ((s.faceIndex = Math.floor(vt / 3)),
                (s.face.materialIndex = nt.materialIndex),
                t.push(s));
          }
        }
      else {
        const me = Math.max(0, de.start),
          Ye = Math.min(l.count, de.start + de.count);
        for (let nt = me, Be = Ye; nt < Be; nt += 3) {
          const ot = l.getX(nt),
            st = l.getX(nt + 1),
            vt = l.getX(nt + 2);
          (s = checkGeometryIntersection(this, a, e, r, u, p, N, ot, st, vt)),
            s && ((s.faceIndex = Math.floor(nt / 3)), t.push(s));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let me = 0, Ye = P.length; me < Ye; me++) {
          const nt = P[me],
            Be = a[nt.materialIndex],
            ot = Math.max(nt.start, de.start),
            st = Math.min(
              c.count,
              Math.min(nt.start + nt.count, de.start + de.count)
            );
          for (let vt = ot, xt = st; vt < xt; vt += 3) {
            const St = vt,
              wt = vt + 1,
              bt = vt + 2;
            (s = checkGeometryIntersection(
              this,
              Be,
              e,
              r,
              u,
              p,
              N,
              St,
              wt,
              bt
            )),
              s &&
                ((s.faceIndex = Math.floor(vt / 3)),
                (s.face.materialIndex = nt.materialIndex),
                t.push(s));
          }
        }
      else {
        const me = Math.max(0, de.start),
          Ye = Math.min(c.count, de.start + de.count);
        for (let nt = me, Be = Ye; nt < Be; nt += 3) {
          const ot = nt,
            st = nt + 1,
            vt = nt + 2;
          (s = checkGeometryIntersection(this, a, e, r, u, p, N, ot, st, vt)),
            s && ((s.faceIndex = Math.floor(nt / 3)), t.push(s));
        }
      }
  }
}
function checkIntersection$1(n, e, t, r, s, o, a, l) {
  let c;
  if (
    (e.side === BackSide
      ? (c = r.intersectTriangle(a, o, s, !0, l))
      : (c = r.intersectTriangle(s, o, a, e.side === FrontSide, l)),
    c === null)
  )
    return null;
  _intersectionPointWorld.copy(l),
    _intersectionPointWorld.applyMatrix4(n.matrixWorld);
  const u = t.ray.origin.distanceTo(_intersectionPointWorld);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: _intersectionPointWorld.clone(), object: n };
}
function checkGeometryIntersection(n, e, t, r, s, o, a, l, c, u) {
  n.getVertexPosition(l, _vA$1),
    n.getVertexPosition(c, _vB$1),
    n.getVertexPosition(u, _vC$1);
  const p = checkIntersection$1(
    n,
    e,
    t,
    r,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint
  );
  if (p) {
    const N = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, N),
      s &&
        (p.uv = Triangle.getInterpolatedAttribute(
          s,
          l,
          c,
          u,
          N,
          new Vector2()
        )),
      o &&
        (p.uv1 = Triangle.getInterpolatedAttribute(
          o,
          l,
          c,
          u,
          N,
          new Vector2()
        )),
      a &&
        ((p.normal = Triangle.getInterpolatedAttribute(
          a,
          l,
          c,
          u,
          N,
          new Vector3()
        )),
        p.normal.dot(r.direction) > 0 && p.normal.multiplyScalar(-1));
    const P = { a: l, b: c, c: u, normal: new Vector3(), materialIndex: 0 };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, P.normal),
      (p.face = P),
      (p.barycoord = N);
  }
  return p;
}
class BoxGeometry extends BufferGeometry {
  constructor(e = 1, t = 1, r = 1, s = 1, o = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: s,
        heightSegments: o,
        depthSegments: a,
      });
    const l = this;
    (s = Math.floor(s)), (o = Math.floor(o)), (a = Math.floor(a));
    const c = [],
      u = [],
      p = [],
      N = [];
    let P = 0,
      de = 0;
    me("z", "y", "x", -1, -1, r, t, e, a, o, 0),
      me("z", "y", "x", 1, -1, r, t, -e, a, o, 1),
      me("x", "z", "y", 1, 1, e, r, t, s, a, 2),
      me("x", "z", "y", 1, -1, e, r, -t, s, a, 3),
      me("x", "y", "z", 1, -1, e, t, r, s, o, 4),
      me("x", "y", "z", -1, -1, e, t, -r, s, o, 5),
      this.setIndex(c),
      this.setAttribute("position", new Float32BufferAttribute(u, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(p, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(N, 2));
    function me(Ye, nt, Be, ot, st, vt, xt, St, wt, bt, Tt) {
      const Ct = vt / wt,
        kt = xt / bt,
        Dt = vt / 2,
        Vt = xt / 2,
        Ht = St / 2,
        qt = wt + 1,
        Ft = bt + 1;
      let Bt = 0,
        Mt = 0;
      const Pt = new Vector3();
      for (let It = 0; It < Ft; It++) {
        const Ot = It * kt - Vt;
        for (let Xt = 0; Xt < qt; Xt++) {
          const sn = Xt * Ct - Dt;
          (Pt[Ye] = sn * ot),
            (Pt[nt] = Ot * st),
            (Pt[Be] = Ht),
            u.push(Pt.x, Pt.y, Pt.z),
            (Pt[Ye] = 0),
            (Pt[nt] = 0),
            (Pt[Be] = St > 0 ? 1 : -1),
            p.push(Pt.x, Pt.y, Pt.z),
            N.push(Xt / wt),
            N.push(1 - It / bt),
            (Bt += 1);
        }
      }
      for (let It = 0; It < bt; It++)
        for (let Ot = 0; Ot < wt; Ot++) {
          const Xt = P + Ot + qt * It,
            sn = P + Ot + qt * (It + 1),
            Kt = P + (Ot + 1) + qt * (It + 1),
            tn = P + (Ot + 1) + qt * It;
          c.push(Xt, sn, tn), c.push(sn, Kt, tn), (Mt += 6);
        }
      l.addGroup(de, Mt, Tt), (de += Mt), (P += Bt);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new BoxGeometry(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function cloneUniforms(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const s = n[t][r];
      s &&
      (s.isColor ||
        s.isMatrix3 ||
        s.isMatrix4 ||
        s.isVector2 ||
        s.isVector3 ||
        s.isVector4 ||
        s.isTexture ||
        s.isQuaternion)
        ? s.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = s.clone())
        : Array.isArray(s)
        ? (e[t][r] = s.slice())
        : (e[t][r] = s);
    }
  }
  return e;
}
function mergeUniforms(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = cloneUniforms(n[t]);
    for (const s in r) e[s] = r[s];
  }
  return e;
}
function cloneUniformsGroups(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function getUnlitUniformColorSpace(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = default_vertex),
      (this.fragmentShader = default_fragment),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = cloneUniforms(e.uniforms)),
      (this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture
        ? (t.uniforms[s] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (t.uniforms[s] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (t.uniforms[s] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (t.uniforms[s] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (t.uniforms[s] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (t.uniforms[s] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (t.uniforms[s] = { type: "m4", value: a.toArray() })
        : (t.uniforms[s] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const s in this.extensions) this.extensions[s] === !0 && (r[s] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class Camera extends Object3D {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.projectionMatrixInverse = new Matrix4()),
      (this.coordinateSystem = WebGLCoordinateSystem);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = new Vector3(),
  _minTarget = new Vector2(),
  _maxTarget = new Vector2();
class PerspectiveCamera extends Camera {
  constructor(e = 50, t = 1, r = 0.1, s = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = s),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = RAD2DEG * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(DEG2RAD * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, r) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z),
      _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(_v3$1.x, _v3$1.y).multiplyScalar(-e / _v3$1.z);
  }
  getViewSize(e, t) {
    return (
      this.getViewBounds(e, _minTarget, _maxTarget),
      t.subVectors(_maxTarget, _minTarget)
    );
  }
  setViewOffset(e, t, r, s, o, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = s),
      (this.view.width = o),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      s = this.aspect * r,
      o = -0.5 * s;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth,
        u = a.fullHeight;
      (o += (a.offsetX * s) / c),
        (t -= (a.offsetY * r) / u),
        (s *= a.width / c),
        (r *= a.height / u);
    }
    const l = this.filmOffset;
    l !== 0 && (o += (e * l) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        o,
        o + s,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const fov = -90,
  aspect = 1;
class CubeCamera extends Object3D {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const s = new PerspectiveCamera(fov, aspect, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new PerspectiveCamera(fov, aspect, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new PerspectiveCamera(fov, aspect, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new PerspectiveCamera(fov, aspect, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new PerspectiveCamera(fov, aspect, e, t);
    (c.layers = this.layers), this.add(c);
    const u = new PerspectiveCamera(fov, aspect, e, t);
    (u.layers = this.layers), this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, s, o, a, l, c] = t;
    for (const u of t) this.remove(u);
    if (e === WebGLCoordinateSystem)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 1, 0),
        s.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1);
    else if (e === WebGPUCoordinateSystem)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, -1, 0),
        s.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, 1),
        c.up.set(0, -1, 0),
        c.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const u of t) this.add(u), u.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [o, a, l, c, u, p] = this.children,
      N = e.getRenderTarget(),
      P = e.getActiveCubeFace(),
      de = e.getActiveMipmapLevel(),
      me = e.xr.enabled;
    e.xr.enabled = !1;
    const Ye = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, s),
      e.render(t, o),
      e.setRenderTarget(r, 1, s),
      e.render(t, a),
      e.setRenderTarget(r, 2, s),
      e.render(t, l),
      e.setRenderTarget(r, 3, s),
      e.render(t, c),
      e.setRenderTarget(r, 4, s),
      e.render(t, u),
      (r.texture.generateMipmaps = Ye),
      e.setRenderTarget(r, 5, s),
      e.render(t, p),
      e.setRenderTarget(N, P, de),
      (e.xr.enabled = me),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class CubeTexture extends Texture {
  constructor(e = [], t = CubeReflectionMapping, r, s, o, a, l, c, u, p) {
    super(e, t, r, s, o, a, l, c, u, p),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      s = [r, r, r, r, r, r];
    (this.texture = new CubeTexture(
      s,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter =
        t.minFilter !== void 0 ? t.minFilter : LinearFilter);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      s = new BoxGeometry(5, 5, 5),
      o = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: BackSide,
        blending: NoBlending,
      });
    o.uniforms.tEquirect.value = t;
    const a = new Mesh(s, o),
      l = t.minFilter;
    return (
      t.minFilter === LinearMipmapLinearFilter && (t.minFilter = LinearFilter),
      new CubeCamera(1, 10, this).update(e, a),
      (t.minFilter = l),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t = !0, r = !0, s = !0) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, r, s);
    e.setRenderTarget(o);
  }
}
class Group extends Object3D {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Group()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Group()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Vector3()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Vector3())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Group()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Vector3()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Vector3())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let s = null,
      o = null,
      a = null;
    const l = this._targetRay,
      c = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        a = !0;
        for (const Ye of e.hand.values()) {
          const nt = t.getJointPose(Ye, r),
            Be = this._getHandJoint(u, Ye);
          nt !== null &&
            (Be.matrix.fromArray(nt.transform.matrix),
            Be.matrix.decompose(Be.position, Be.rotation, Be.scale),
            (Be.matrixWorldNeedsUpdate = !0),
            (Be.jointRadius = nt.radius)),
            (Be.visible = nt !== null);
        }
        const p = u.joints["index-finger-tip"],
          N = u.joints["thumb-tip"],
          P = p.position.distanceTo(N.position),
          de = 0.02,
          me = 0.005;
        u.inputState.pinching && P > de + me
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            P <= de - me &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        c !== null &&
          e.gripSpace &&
          ((o = t.getPose(e.gripSpace, r)),
          o !== null &&
            (c.matrix.fromArray(o.transform.matrix),
            c.matrix.decompose(c.position, c.rotation, c.scale),
            (c.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((c.hasLinearVelocity = !0),
                c.linearVelocity.copy(o.linearVelocity))
              : (c.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((c.hasAngularVelocity = !0),
                c.angularVelocity.copy(o.angularVelocity))
              : (c.hasAngularVelocity = !1)));
      l !== null &&
        ((s = t.getPose(e.targetRaySpace, r)),
        s === null && o !== null && (s = o),
        s !== null &&
          (l.matrix.fromArray(s.transform.matrix),
          l.matrix.decompose(l.position, l.rotation, l.scale),
          (l.matrixWorldNeedsUpdate = !0),
          s.linearVelocity
            ? ((l.hasLinearVelocity = !0),
              l.linearVelocity.copy(s.linearVelocity))
            : (l.hasLinearVelocity = !1),
          s.angularVelocity
            ? ((l.hasAngularVelocity = !0),
              l.angularVelocity.copy(s.angularVelocity))
            : (l.hasAngularVelocity = !1),
          this.dispatchEvent(_moveEvent)));
    }
    return (
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      u !== null && (u.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new Group();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
class FogExp2 {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.density = t);
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Fog {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Scene extends Object3D {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Euler()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Euler()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class InterleavedBuffer {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = StaticDrawUsage),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = generateUUID());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let s = 0, o = this.stride; s < o; s++)
      this.array[e + s] = t.array[r + s];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const _vector$7 = new Vector3();
class InterleavedBufferAttribute {
  constructor(e, t, r, s = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = s);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      _vector$7.fromBufferAttribute(this, t),
        _vector$7.applyMatrix4(e),
        this.setXYZ(t, _vector$7.x, _vector$7.y, _vector$7.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      _vector$7.fromBufferAttribute(this, t),
        _vector$7.applyNormalMatrix(e),
        this.setXYZ(t, _vector$7.x, _vector$7.y, _vector$7.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      _vector$7.fromBufferAttribute(this, t),
        _vector$7.transformDirection(e),
        this.setXYZ(t, _vector$7.x, _vector$7.y, _vector$7.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = denormalize(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = normalize$1(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = r),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = normalize$1(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = denormalize(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = normalize$1(t, this.array)), (r = normalize$1(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = normalize$1(t, this.array)),
        (r = normalize$1(r, this.array)),
        (s = normalize$1(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = s),
      this
    );
  }
  setXYZW(e, t, r, s, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = normalize$1(t, this.array)),
        (r = normalize$1(r, this.array)),
        (s = normalize$1(s, this.array)),
        (o = normalize$1(o, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = s),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const s = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[s + o]);
      }
      return new BufferAttribute(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new InterleavedBufferAttribute(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const s = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[s + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class SpriteMaterial extends Material {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let _geometry;
const _intersectPoint = new Vector3(),
  _worldScale = new Vector3(),
  _mvPosition = new Vector3(),
  _alignedPosition = new Vector2(),
  _rotatedPosition = new Vector2(),
  _viewWorldMatrix = new Matrix4(),
  _vA = new Vector3(),
  _vB = new Vector3(),
  _vC = new Vector3(),
  _uvA = new Vector2(),
  _uvB = new Vector2(),
  _uvC = new Vector2();
class Sprite extends Object3D {
  constructor(e = new SpriteMaterial()) {
    if (
      (super(),
      (this.isSprite = !0),
      (this.type = "Sprite"),
      _geometry === void 0)
    ) {
      _geometry = new BufferGeometry();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new InterleavedBuffer(t, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]),
        _geometry.setAttribute(
          "position",
          new InterleavedBufferAttribute(r, 3, 0, !1)
        ),
        _geometry.setAttribute(
          "uv",
          new InterleavedBufferAttribute(r, 2, 3, !1)
        );
    }
    (this.geometry = _geometry),
      (this.material = e),
      (this.center = new Vector2(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      _worldScale.setFromMatrixScale(this.matrixWorld),
      _viewWorldMatrix.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        _worldScale.multiplyScalar(-_mvPosition.z);
    const r = this.material.rotation;
    let s, o;
    r !== 0 && ((o = Math.cos(r)), (s = Math.sin(r)));
    const a = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, a, _worldScale, s, o),
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, a, _worldScale, s, o),
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, a, _worldScale, s, o),
      _uvA.set(0, 0),
      _uvB.set(1, 0),
      _uvC.set(1, 1);
    let l = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
    if (
      l === null &&
      (transformVertex(
        _vB.set(-0.5, 0.5, 0),
        _mvPosition,
        a,
        _worldScale,
        s,
        o
      ),
      _uvB.set(0, 1),
      (l = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint)),
      l === null)
    )
      return;
    const c = e.ray.origin.distanceTo(_intersectPoint);
    c < e.near ||
      c > e.far ||
      t.push({
        distance: c,
        point: _intersectPoint.clone(),
        uv: Triangle.getInterpolation(
          _intersectPoint,
          _vA,
          _vB,
          _vC,
          _uvA,
          _uvB,
          _uvC,
          new Vector2()
        ),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function transformVertex(n, e, t, r, s, o) {
  _alignedPosition.subVectors(n, t).addScalar(0.5).multiply(r),
    s !== void 0
      ? ((_rotatedPosition.x = o * _alignedPosition.x - s * _alignedPosition.y),
        (_rotatedPosition.y = s * _alignedPosition.x + o * _alignedPosition.y))
      : _rotatedPosition.copy(_alignedPosition),
    n.copy(e),
    (n.x += _rotatedPosition.x),
    (n.y += _rotatedPosition.y),
    n.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = new Vector3(),
  _v2$1 = new Vector3();
class LOD extends Object3D {
  constructor() {
    super(),
      (this.isLOD = !0),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const s = this.levels;
    let o;
    for (o = 0; o < s.length && !(t < s[o].distance); o++);
    return (
      s.splice(o, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let r = 0; r < t.length; r++)
      if (t[r].distance === e) {
        const s = t.splice(r, 1);
        return this.remove(s[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), e < o)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const s = e.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(s).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      _v1$2.setFromMatrixPosition(e.matrixWorld),
        _v2$1.setFromMatrixPosition(this.matrixWorld);
      const r = _v1$2.distanceTo(_v2$1) / e.zoom;
      t[0].object.visible = !0;
      let s, o;
      for (s = 1, o = t.length; s < o; s++) {
        let a = t[s].distance;
        if ((t[s].object.visible && (a -= a * t[s].hysteresis), r >= a))
          (t[s - 1].object.visible = !1), (t[s].object.visible = !0);
        else break;
      }
      for (this._currentLevel = s - 1; s < o; s++) t[s].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let s = 0, o = r.length; s < o; s++) {
      const a = r[s];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis,
      });
    }
    return t;
  }
}
const _basePosition = new Vector3(),
  _skinIndex = new Vector4(),
  _skinWeight = new Vector4(),
  _vector3 = new Vector3(),
  _matrix4 = new Matrix4(),
  _vertex = new Vector3(),
  _sphere$5 = new Sphere(),
  _inverseMatrix$2 = new Matrix4(),
  _ray$2 = new Ray();
class SkinnedMesh extends Mesh {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = AttachedBindMode),
      (this.bindMatrix = new Matrix4()),
      (this.bindMatrixInverse = new Matrix4()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Box3()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, _vertex),
        this.boundingBox.expandByPoint(_vertex);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, _vertex),
        this.boundingSphere.expandByPoint(_vertex);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      _sphere$5.copy(this.boundingSphere),
      _sphere$5.applyMatrix4(s),
      e.ray.intersectsSphere(_sphere$5) !== !1 &&
        (_inverseMatrix$2.copy(s).invert(),
        _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),
        !(
          this.boundingBox !== null &&
          _ray$2.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, _ray$2)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Vector4(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, s = t.count; r < s; r++) {
      e.fromBufferAttribute(t, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === AttachedBindMode
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === DetachedBindMode
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      s = this.geometry;
    _skinIndex.fromBufferAttribute(s.attributes.skinIndex, e),
      _skinWeight.fromBufferAttribute(s.attributes.skinWeight, e),
      _basePosition.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const a = _skinWeight.getComponent(o);
      if (a !== 0) {
        const l = _skinIndex.getComponent(o);
        _matrix4.multiplyMatrices(r.bones[l].matrixWorld, r.boneInverses[l]),
          t.addScaledVector(
            _vector3.copy(_basePosition).applyMatrix4(_matrix4),
            a
          );
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bone extends Object3D {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class DataTexture extends Texture {
  constructor(
    e = null,
    t = 1,
    r = 1,
    s,
    o,
    a,
    l,
    c,
    u = NearestFilter,
    p = NearestFilter,
    N,
    P
  ) {
    super(null, a, l, c, u, p, s, o, N, P),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const _offsetMatrix = new Matrix4(),
  _identityMatrix$1 = new Matrix4();
class Skeleton {
  constructor(e = [], t = []) {
    (this.uuid = generateUUID()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, s = this.bones.length; r < s; r++)
        this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Matrix4();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      s = this.boneTexture;
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o] ? e[o].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(l, t[o]), _offsetMatrix.toArray(r, o * 16);
    }
    s !== null && (s.needsUpdate = !0);
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new DataTexture(t, e, e, RGBAFormat, FloatType);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const s = this.bones[t];
      if (s.name === e) return s;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, s = e.bones.length; r < s; r++) {
      const o = e.bones[r];
      let a = t[o];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (a = new Bone())),
        this.bones.push(a),
        this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s];
      e.bones.push(a.uuid);
      const l = r[s];
      e.boneInverses.push(l.toArray());
    }
    return e;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(e, t, r, s = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = s);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const _instanceLocalMatrix = new Matrix4(),
  _instanceWorldMatrix = new Matrix4(),
  _instanceIntersects = [],
  _box3 = new Box3(),
  _identity = new Matrix4(),
  _mesh$1 = new Mesh(),
  _sphere$4 = new Sphere();
class InstancedMesh extends Mesh {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new InstancedBufferAttribute(
        new Float32Array(r * 16),
        16
      )),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let s = 0; s < r; s++) this.setMatrixAt(s, _identity);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Box3()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, _instanceLocalMatrix),
        _box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),
        this.boundingBox.union(_box3);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, _instanceLocalMatrix),
        _sphere$4.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),
        this.boundingSphere.union(_sphere$4);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      s = this.morphTexture.source.data.data,
      o = r.length + 1,
      a = e * o + 1;
    for (let l = 0; l < r.length; l++) r[l] = s[a + l];
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      s = this.count;
    if (
      ((_mesh$1.geometry = this.geometry),
      (_mesh$1.material = this.material),
      _mesh$1.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        _sphere$4.copy(this.boundingSphere),
        _sphere$4.applyMatrix4(r),
        e.ray.intersectsSphere(_sphere$4) !== !1))
    )
      for (let o = 0; o < s; o++) {
        this.getMatrixAt(o, _instanceLocalMatrix),
          _instanceWorldMatrix.multiplyMatrices(r, _instanceLocalMatrix),
          (_mesh$1.matrixWorld = _instanceWorldMatrix),
          _mesh$1.raycast(e, _instanceIntersects);
        for (let a = 0, l = _instanceIntersects.length; a < l; a++) {
          const c = _instanceIntersects[a];
          (c.instanceId = o), (c.object = this), t.push(c);
        }
        _instanceIntersects.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new InstancedBufferAttribute(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      s = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new DataTexture(
        new Float32Array(s * this.count),
        s,
        this.count,
        RedFormat,
        FloatType
      ));
    const o = this.morphTexture.source.data.data;
    let a = 0;
    for (let u = 0; u < r.length; u++) a += r[u];
    const l = this.geometry.morphTargetsRelative ? 1 : 1 - a,
      c = s * e;
    (o[c] = l), o.set(r, c + 1);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null));
  }
}
const _vector1 = new Vector3(),
  _vector2 = new Vector3(),
  _normalMatrix = new Matrix3();
class Plane {
  constructor(e = new Vector3(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, s) {
    return this.normal.set(e, t, r), (this.constant = s), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const s = _vector1
      .subVectors(r, t)
      .cross(_vector2.subVectors(e, t))
      .normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(_vector1),
      s = this.normal.dot(r);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / s;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || _normalMatrix.getNormalMatrix(e),
      s = this.coplanarPoint(_vector1).applyMatrix4(e),
      o = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -s.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$3 = new Sphere(),
  _vector$6 = new Vector3();
class Frustum {
  constructor(
    e = new Plane(),
    t = new Plane(),
    r = new Plane(),
    s = new Plane(),
    o = new Plane(),
    a = new Plane()
  ) {
    this.planes = [e, t, r, s, o, a];
  }
  set(e, t, r, s, o, a) {
    const l = this.planes;
    return (
      l[0].copy(e),
      l[1].copy(t),
      l[2].copy(r),
      l[3].copy(s),
      l[4].copy(o),
      l[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = WebGLCoordinateSystem) {
    const r = this.planes,
      s = e.elements,
      o = s[0],
      a = s[1],
      l = s[2],
      c = s[3],
      u = s[4],
      p = s[5],
      N = s[6],
      P = s[7],
      de = s[8],
      me = s[9],
      Ye = s[10],
      nt = s[11],
      Be = s[12],
      ot = s[13],
      st = s[14],
      vt = s[15];
    if (
      (r[0].setComponents(c - o, P - u, nt - de, vt - Be).normalize(),
      r[1].setComponents(c + o, P + u, nt + de, vt + Be).normalize(),
      r[2].setComponents(c + a, P + p, nt + me, vt + ot).normalize(),
      r[3].setComponents(c - a, P - p, nt - me, vt - ot).normalize(),
      r[4].setComponents(c - l, P - N, nt - Ye, vt - st).normalize(),
      t === WebGLCoordinateSystem)
    )
      r[5].setComponents(c + l, P + N, nt + Ye, vt + st).normalize();
    else if (t === WebGPUCoordinateSystem)
      r[5].setComponents(l, N, Ye, st).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        _sphere$3.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        _sphere$3.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(_sphere$3);
  }
  intersectsSprite(e) {
    return (
      _sphere$3.center.set(0, 0, 0),
      (_sphere$3.radius = 0.7071067811865476),
      _sphere$3.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(_sphere$3)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      s = -e.radius;
    for (let o = 0; o < 6; o++) if (t[o].distanceToPoint(r) < s) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const s = t[r];
      if (
        ((_vector$6.x = s.normal.x > 0 ? e.max.x : e.min.x),
        (_vector$6.y = s.normal.y > 0 ? e.max.y : e.min.y),
        (_vector$6.z = s.normal.z > 0 ? e.max.z : e.min.z),
        s.distanceToPoint(_vector$6) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _projScreenMatrix$2 = new Matrix4(),
  _frustum$1 = new Frustum();
class FrustumArray {
  constructor() {
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  intersectsObject(e, t) {
    if (!t.isArrayCamera || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const s = t.cameras[r];
      if (
        (_projScreenMatrix$2.multiplyMatrices(
          s.projectionMatrix,
          s.matrixWorldInverse
        ),
        _frustum$1.setFromProjectionMatrix(
          _projScreenMatrix$2,
          this.coordinateSystem
        ),
        _frustum$1.intersectsObject(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSprite(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const s = t.cameras[r];
      if (
        (_projScreenMatrix$2.multiplyMatrices(
          s.projectionMatrix,
          s.matrixWorldInverse
        ),
        _frustum$1.setFromProjectionMatrix(
          _projScreenMatrix$2,
          this.coordinateSystem
        ),
        _frustum$1.intersectsSprite(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSphere(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const s = t.cameras[r];
      if (
        (_projScreenMatrix$2.multiplyMatrices(
          s.projectionMatrix,
          s.matrixWorldInverse
        ),
        _frustum$1.setFromProjectionMatrix(
          _projScreenMatrix$2,
          this.coordinateSystem
        ),
        _frustum$1.intersectsSphere(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsBox(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const s = t.cameras[r];
      if (
        (_projScreenMatrix$2.multiplyMatrices(
          s.projectionMatrix,
          s.matrixWorldInverse
        ),
        _frustum$1.setFromProjectionMatrix(
          _projScreenMatrix$2,
          this.coordinateSystem
        ),
        _frustum$1.intersectsBox(e))
      )
        return !0;
    }
    return !1;
  }
  containsPoint(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const s = t.cameras[r];
      if (
        (_projScreenMatrix$2.multiplyMatrices(
          s.projectionMatrix,
          s.matrixWorldInverse
        ),
        _frustum$1.setFromProjectionMatrix(
          _projScreenMatrix$2,
          this.coordinateSystem
        ),
        _frustum$1.containsPoint(e))
      )
        return !0;
    }
    return !1;
  }
  clone() {
    return new FrustumArray();
  }
}
function ascIdSort(n, e) {
  return n - e;
}
function sortOpaque(n, e) {
  return n.z - e.z;
}
function sortTransparent(n, e) {
  return e.z - n.z;
}
class MultiDrawRenderList {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, r, s) {
    const o = this.pool,
      a = this.list;
    this.index >= o.length &&
      o.push({ start: -1, count: -1, z: -1, index: -1 });
    const l = o[this.index];
    a.push(l),
      this.index++,
      (l.start = e),
      (l.count = t),
      (l.z = r),
      (l.index = s);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const _matrix$1 = new Matrix4(),
  _whiteColor = new Color(1, 1, 1),
  _frustum = new Frustum(),
  _frustumArray = new FrustumArray(),
  _box$1 = new Box3(),
  _sphere$2 = new Sphere(),
  _vector$5 = new Vector3(),
  _forward = new Vector3(),
  _temp = new Vector3(),
  _renderList = new MultiDrawRenderList(),
  _mesh = new Mesh(),
  _batchIntersects = [];
function copyAttributeData(n, e, t = 0) {
  const r = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const s = n.count;
    for (let o = 0; o < s; o++)
      for (let a = 0; a < r; a++)
        e.setComponent(o + t, a, n.getComponent(o, a));
  } else e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
function copyArrayContents(n, e) {
  if (n.constructor !== e.constructor) {
    const t = Math.min(n.length, e.length);
    for (let r = 0; r < t; r++) e[r] = n[r];
  } else {
    const t = Math.min(n.length, e.length);
    e.set(new n.constructor(n.buffer, 0, t));
  }
}
class BatchedMesh extends Mesh {
  constructor(e, t, r = t * 2, s) {
    super(new BufferGeometry(), s),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = r),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      r = new DataTexture(t, e, e, RGBAFormat, FloatType);
    this._matricesTexture = r;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      r = new DataTexture(t, e, e, RedIntegerFormat, UnsignedIntType);
    this._indirectTexture = r;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      r = new DataTexture(t, e, e, RGBAFormat, FloatType);
    (r.colorSpace = ColorManagement.workingColorSpace),
      (this._colorsTexture = r);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      r = this._maxVertexCount,
      s = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const a = e.getAttribute(o),
          { array: l, itemSize: c, normalized: u } = a,
          p = new l.constructor(r * c),
          N = new BufferAttribute(p, c, u);
        t.setAttribute(o, N);
      }
      if (e.getIndex() !== null) {
        const o = r > 65535 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new BufferAttribute(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in t.attributes) {
      if (!e.hasAttribute(r))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const s = e.getAttribute(r),
        o = t.getAttribute(r);
      if (s.itemSize !== o.itemSize || s.normalized !== o.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`
      );
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let r = 0, s = t.length; r < s; r++) {
      if (t[r].active === !1) continue;
      const o = t[r].geometryIndex;
      this.getMatrixAt(r, _matrix$1),
        this.getBoundingBoxAt(o, _box$1).applyMatrix4(_matrix$1),
        e.union(_box$1);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let r = 0, s = t.length; r < s; r++) {
      if (t[r].active === !1) continue;
      const o = t[r].geometryIndex;
      this.getMatrixAt(r, _matrix$1),
        this.getBoundingSphereAt(o, _sphere$2).applyMatrix4(_matrix$1),
        e.union(_sphere$2);
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const r = { visible: !0, active: !0, geometryIndex: e };
    let s = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(ascIdSort),
        (s = this._availableInstanceIds.shift()),
        (this._instanceInfo[s] = r))
      : ((s = this._instanceInfo.length), this._instanceInfo.push(r));
    const o = this._matricesTexture;
    _matrix$1.identity().toArray(o.image.data, s * 16), (o.needsUpdate = !0);
    const a = this._colorsTexture;
    return (
      a && (_whiteColor.toArray(a.image.data, s * 4), (a.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      s
    );
  }
  addGeometry(e, t = -1, r = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const s = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      o = this._geometryInfo;
    (s.vertexStart = this._nextVertexStart),
      (s.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t);
    const a = e.getIndex();
    if (
      (a !== null &&
        ((s.indexStart = this._nextIndexStart),
        (s.reservedIndexCount = r === -1 ? a.count : r)),
      (s.indexStart !== -1 &&
        s.indexStart + s.reservedIndexCount > this._maxIndexCount) ||
        s.vertexStart + s.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    let c;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(ascIdSort),
          (c = this._availableGeometryIds.shift()),
          (o[c] = s))
        : ((c = this._geometryCount), this._geometryCount++, o.push(s)),
      this.setGeometryAt(c, e),
      (this._nextIndexStart = s.indexStart + s.reservedIndexCount),
      (this._nextVertexStart = s.vertexStart + s.reservedVertexCount),
      c
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry,
      s = r.getIndex() !== null,
      o = r.getIndex(),
      a = t.getIndex(),
      l = this._geometryInfo[e];
    if (
      (s && a.count > l.reservedIndexCount) ||
      t.attributes.position.count > l.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const c = l.vertexStart,
      u = l.reservedVertexCount;
    l.vertexCount = t.getAttribute("position").count;
    for (const p in r.attributes) {
      const N = t.getAttribute(p),
        P = r.getAttribute(p);
      copyAttributeData(N, P, c);
      const de = N.itemSize;
      for (let me = N.count, Ye = u; me < Ye; me++) {
        const nt = c + me;
        for (let Be = 0; Be < de; Be++) P.setComponent(nt, Be, 0);
      }
      (P.needsUpdate = !0), P.addUpdateRange(c * de, u * de);
    }
    if (s) {
      const p = l.indexStart,
        N = l.reservedIndexCount;
      l.indexCount = t.getIndex().count;
      for (let P = 0; P < a.count; P++) o.setX(p + P, c + a.getX(P));
      for (let P = a.count, de = N; P < de; P++) o.setX(p + P, c);
      (o.needsUpdate = !0), o.addUpdateRange(p, l.reservedIndexCount);
    }
    return (
      (l.start = s ? l.indexStart : l.vertexStart),
      (l.count = s ? l.indexCount : l.vertexCount),
      (l.boundingBox = null),
      t.boundingBox !== null && (l.boundingBox = t.boundingBox.clone()),
      (l.boundingSphere = null),
      t.boundingSphere !== null &&
        (l.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const r = this._instanceInfo;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].active && r[s].geometryIndex === e && this.deleteInstance(s);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const r = this._geometryInfo,
      s = r
        .map((a, l) => l)
        .sort((a, l) => r[a].vertexStart - r[l].vertexStart),
      o = this.geometry;
    for (let a = 0, l = r.length; a < l; a++) {
      const c = s[a],
        u = r[c];
      if (u.active !== !1) {
        if (o.index !== null) {
          if (u.indexStart !== t) {
            const { indexStart: p, vertexStart: N, reservedIndexCount: P } = u,
              de = o.index,
              me = de.array,
              Ye = e - N;
            for (let nt = p; nt < p + P; nt++) me[nt] = me[nt] + Ye;
            de.array.copyWithin(t, p, p + P),
              de.addUpdateRange(t, P),
              (u.indexStart = t);
          }
          t += u.reservedIndexCount;
        }
        if (u.vertexStart !== e) {
          const { vertexStart: p, reservedVertexCount: N } = u,
            P = o.attributes;
          for (const de in P) {
            const me = P[de],
              { array: Ye, itemSize: nt } = me;
            Ye.copyWithin(e * nt, p * nt, (p + N) * nt),
              me.addUpdateRange(e * nt, N * nt);
          }
          u.vertexStart = e;
        }
        (e += u.reservedVertexCount),
          (u.start = o.index ? u.indexStart : u.vertexStart),
          (this._nextIndexStart = o.index
            ? u.indexStart + u.reservedIndexCount
            : 0),
          (this._nextVertexStart = u.vertexStart + u.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this.geometry,
      s = this._geometryInfo[e];
    if (s.boundingBox === null) {
      const o = new Box3(),
        a = r.index,
        l = r.attributes.position;
      for (let c = s.start, u = s.start + s.count; c < u; c++) {
        let p = c;
        a && (p = a.getX(p)),
          o.expandByPoint(_vector$5.fromBufferAttribute(l, p));
      }
      s.boundingBox = o;
    }
    return t.copy(s.boundingBox), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this.geometry,
      s = this._geometryInfo[e];
    if (s.boundingSphere === null) {
      const o = new Sphere();
      this.getBoundingBoxAt(e, _box$1), _box$1.getCenter(o.center);
      const a = r.index,
        l = r.attributes.position;
      let c = 0;
      for (let u = s.start, p = s.start + s.count; u < p; u++) {
        let N = u;
        a && (N = a.getX(N)),
          _vector$5.fromBufferAttribute(l, N),
          (c = Math.max(c, o.center.distanceToSquared(_vector$5)));
      }
      (o.radius = Math.sqrt(c)), (s.boundingSphere = o);
    }
    return t.copy(s.boundingSphere), t;
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const r = this._matricesTexture,
      s = this._matricesTexture.image.data;
    return t.toArray(s, e * 16), (r.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const r = this._geometryInfo[e];
    return (
      (t.vertexStart = r.vertexStart),
      (t.vertexCount = r.vertexCount),
      (t.reservedVertexCount = r.reservedVertexCount),
      (t.indexStart = r.indexStart),
      (t.indexCount = r.indexCount),
      (t.reservedIndexCount = r.reservedIndexCount),
      (t.start = r.start),
      (t.count = r.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      r = this._instanceInfo;
    for (t.sort(ascIdSort); t[t.length - 1] === r.length; ) r.pop(), t.pop();
    if (e < r.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`
      );
    const s = new Int32Array(e),
      o = new Int32Array(e);
    copyArrayContents(this._multiDrawCounts, s),
      copyArrayContents(this._multiDrawStarts, o),
      (this._multiDrawCounts = s),
      (this._multiDrawStarts = o),
      (this._maxInstanceCount = e);
    const a = this._indirectTexture,
      l = this._matricesTexture,
      c = this._colorsTexture;
    a.dispose(),
      this._initIndirectTexture(),
      copyArrayContents(a.image.data, this._indirectTexture.image.data),
      l.dispose(),
      this._initMatricesTexture(),
      copyArrayContents(l.image.data, this._matricesTexture.image.data),
      c &&
        (c.dispose(),
        this._initColorsTexture(),
        copyArrayContents(c.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(e, t) {
    const r = [...this._geometryInfo].filter((l) => l.active);
    if (Math.max(...r.map((l) => l.vertexStart + l.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`
      );
    if (
      this.geometry.index &&
      Math.max(...r.map((c) => c.indexStart + c.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`
      );
    const o = this.geometry;
    o.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new BufferGeometry()),
        this._initializeGeometry(o));
    const a = this.geometry;
    o.index && copyArrayContents(o.index.array, a.index.array);
    for (const l in o.attributes)
      copyArrayContents(o.attributes[l].array, a.attributes[l].array);
  }
  raycast(e, t) {
    const r = this._instanceInfo,
      s = this._geometryInfo,
      o = this.matrixWorld,
      a = this.geometry;
    (_mesh.material = this.material),
      (_mesh.geometry.index = a.index),
      (_mesh.geometry.attributes = a.attributes),
      _mesh.geometry.boundingBox === null &&
        (_mesh.geometry.boundingBox = new Box3()),
      _mesh.geometry.boundingSphere === null &&
        (_mesh.geometry.boundingSphere = new Sphere());
    for (let l = 0, c = r.length; l < c; l++) {
      if (!r[l].visible || !r[l].active) continue;
      const u = r[l].geometryIndex,
        p = s[u];
      _mesh.geometry.setDrawRange(p.start, p.count),
        this.getMatrixAt(l, _mesh.matrixWorld).premultiply(o),
        this.getBoundingBoxAt(u, _mesh.geometry.boundingBox),
        this.getBoundingSphereAt(u, _mesh.geometry.boundingSphere),
        _mesh.raycast(e, _batchIntersects);
      for (let N = 0, P = _batchIntersects.length; N < P; N++) {
        const de = _batchIntersects[N];
        (de.object = this), (de.batchId = l), t.push(de);
      }
      _batchIntersects.length = 0;
    }
    (_mesh.material = null),
      (_mesh.geometry.index = null),
      (_mesh.geometry.attributes = {}),
      _mesh.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._availableInstanceIds = e._availableInstanceIds.slice()),
      (this._availableGeometryIds = e._availableGeometryIds.slice()),
      (this._nextIndexStart = e._nextIndexStart),
      (this._nextVertexStart = e._nextVertexStart),
      (this._geometryCount = e._geometryCount),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._indirectTexture = e._indirectTexture.clone()),
      (this._indirectTexture.image.data =
        this._indirectTexture.image.data.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null));
  }
  onBeforeRender(e, t, r, s, o) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const a = s.getIndex(),
      l = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
      c = this._instanceInfo,
      u = this._multiDrawStarts,
      p = this._multiDrawCounts,
      N = this._geometryInfo,
      P = this.perObjectFrustumCulled,
      de = this._indirectTexture,
      me = de.image.data,
      Ye = r.isArrayCamera ? _frustumArray : _frustum;
    P &&
      !r.isArrayCamera &&
      (_matrix$1
        .multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse)
        .multiply(this.matrixWorld),
      _frustum.setFromProjectionMatrix(_matrix$1, e.coordinateSystem));
    let nt = 0;
    if (this.sortObjects) {
      _matrix$1.copy(this.matrixWorld).invert(),
        _vector$5.setFromMatrixPosition(r.matrixWorld).applyMatrix4(_matrix$1),
        _forward
          .set(0, 0, -1)
          .transformDirection(r.matrixWorld)
          .transformDirection(_matrix$1);
      for (let st = 0, vt = c.length; st < vt; st++)
        if (c[st].visible && c[st].active) {
          const xt = c[st].geometryIndex;
          this.getMatrixAt(st, _matrix$1),
            this.getBoundingSphereAt(xt, _sphere$2).applyMatrix4(_matrix$1);
          let St = !1;
          if ((P && (St = !Ye.intersectsSphere(_sphere$2, r)), !St)) {
            const wt = N[xt],
              bt = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
            _renderList.push(wt.start, wt.count, bt, st);
          }
        }
      const Be = _renderList.list,
        ot = this.customSort;
      ot === null
        ? Be.sort(o.transparent ? sortTransparent : sortOpaque)
        : ot.call(this, Be, r);
      for (let st = 0, vt = Be.length; st < vt; st++) {
        const xt = Be[st];
        (u[nt] = xt.start * l), (p[nt] = xt.count), (me[nt] = xt.index), nt++;
      }
      _renderList.reset();
    } else
      for (let Be = 0, ot = c.length; Be < ot; Be++)
        if (c[Be].visible && c[Be].active) {
          const st = c[Be].geometryIndex;
          let vt = !1;
          if (
            (P &&
              (this.getMatrixAt(Be, _matrix$1),
              this.getBoundingSphereAt(st, _sphere$2).applyMatrix4(_matrix$1),
              (vt = !Ye.intersectsSphere(_sphere$2, r))),
            !vt)
          ) {
            const xt = N[st];
            (u[nt] = xt.start * l), (p[nt] = xt.count), (me[nt] = Be), nt++;
          }
        }
    (de.needsUpdate = !0),
      (this._multiDrawCount = nt),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, r, s, o, a) {
    this.onBeforeRender(e, null, s, o, a);
  }
}
class LineBasicMaterial extends Material {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const _vStart = new Vector3(),
  _vEnd = new Vector3(),
  _inverseMatrix$1 = new Matrix4(),
  _ray$1 = new Ray(),
  _sphere$1 = new Sphere(),
  _intersectPointOnRay = new Vector3(),
  _intersectPointOnSegment = new Vector3();
class Line extends Object3D {
  constructor(e = new BufferGeometry(), t = new LineBasicMaterial()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let s = 1, o = t.count; s < o; s++)
        _vStart.fromBufferAttribute(t, s - 1),
          _vEnd.fromBufferAttribute(t, s),
          (r[s] = r[s - 1]),
          (r[s] += _vStart.distanceTo(_vEnd));
      e.setAttribute("lineDistance", new Float32BufferAttribute(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      s = this.matrixWorld,
      o = e.params.Line.threshold,
      a = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      _sphere$1.copy(r.boundingSphere),
      _sphere$1.applyMatrix4(s),
      (_sphere$1.radius += o),
      e.ray.intersectsSphere(_sphere$1) === !1)
    )
      return;
    _inverseMatrix$1.copy(s).invert(),
      _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = l * l,
      u = this.isLineSegments ? 2 : 1,
      p = r.index,
      P = r.attributes.position;
    if (p !== null) {
      const de = Math.max(0, a.start),
        me = Math.min(p.count, a.start + a.count);
      for (let Ye = de, nt = me - 1; Ye < nt; Ye += u) {
        const Be = p.getX(Ye),
          ot = p.getX(Ye + 1),
          st = checkIntersection(this, e, _ray$1, c, Be, ot, Ye);
        st && t.push(st);
      }
      if (this.isLineLoop) {
        const Ye = p.getX(me - 1),
          nt = p.getX(de),
          Be = checkIntersection(this, e, _ray$1, c, Ye, nt, me - 1);
        Be && t.push(Be);
      }
    } else {
      const de = Math.max(0, a.start),
        me = Math.min(P.count, a.start + a.count);
      for (let Ye = de, nt = me - 1; Ye < nt; Ye += u) {
        const Be = checkIntersection(this, e, _ray$1, c, Ye, Ye + 1, Ye);
        Be && t.push(Be);
      }
      if (this.isLineLoop) {
        const Ye = checkIntersection(this, e, _ray$1, c, me - 1, de, me - 1);
        Ye && t.push(Ye);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const s = t[r[0]];
      if (s !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = s.length; o < a; o++) {
          const l = s[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
}
function checkIntersection(n, e, t, r, s, o, a) {
  const l = n.geometry.attributes.position;
  if (
    (_vStart.fromBufferAttribute(l, s),
    _vEnd.fromBufferAttribute(l, o),
    t.distanceSqToSegment(
      _vStart,
      _vEnd,
      _intersectPointOnRay,
      _intersectPointOnSegment
    ) > r)
  )
    return;
  _intersectPointOnRay.applyMatrix4(n.matrixWorld);
  const u = e.ray.origin.distanceTo(_intersectPointOnRay);
  if (!(u < e.near || u > e.far))
    return {
      distance: u,
      point: _intersectPointOnSegment.clone().applyMatrix4(n.matrixWorld),
      index: a,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    };
}
const _start = new Vector3(),
  _end = new Vector3();
class LineSegments extends Line {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let s = 0, o = t.count; s < o; s += 2)
        _start.fromBufferAttribute(t, s),
          _end.fromBufferAttribute(t, s + 1),
          (r[s] = s === 0 ? 0 : r[s - 1]),
          (r[s + 1] = r[s] + _start.distanceTo(_end));
      e.setAttribute("lineDistance", new Float32BufferAttribute(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class LineLoop extends Line {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class PointsMaterial extends Material {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const _inverseMatrix = new Matrix4(),
  _ray = new Ray(),
  _sphere = new Sphere(),
  _position$2 = new Vector3();
class Points extends Object3D {
  constructor(e = new BufferGeometry(), t = new PointsMaterial()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      s = this.matrixWorld,
      o = e.params.Points.threshold,
      a = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      _sphere.copy(r.boundingSphere),
      _sphere.applyMatrix4(s),
      (_sphere.radius += o),
      e.ray.intersectsSphere(_sphere) === !1)
    )
      return;
    _inverseMatrix.copy(s).invert(),
      _ray.copy(e.ray).applyMatrix4(_inverseMatrix);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = l * l,
      u = r.index,
      N = r.attributes.position;
    if (u !== null) {
      const P = Math.max(0, a.start),
        de = Math.min(u.count, a.start + a.count);
      for (let me = P, Ye = de; me < Ye; me++) {
        const nt = u.getX(me);
        _position$2.fromBufferAttribute(N, nt),
          testPoint(_position$2, nt, c, s, e, t, this);
      }
    } else {
      const P = Math.max(0, a.start),
        de = Math.min(N.count, a.start + a.count);
      for (let me = P, Ye = de; me < Ye; me++)
        _position$2.fromBufferAttribute(N, me),
          testPoint(_position$2, me, c, s, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const s = t[r[0]];
      if (s !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = s.length; o < a; o++) {
          const l = s[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[l] = o);
        }
      }
    }
  }
}
function testPoint(n, e, t, r, s, o, a) {
  const l = _ray.distanceSqToPoint(n);
  if (l < t) {
    const c = new Vector3();
    _ray.closestPointToPoint(n, c), c.applyMatrix4(r);
    const u = s.ray.origin.distanceTo(c);
    if (u < s.near || u > s.far) return;
    o.push({
      distance: u,
      distanceToRay: Math.sqrt(l),
      point: c,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a,
    });
  }
}
class VideoTexture extends Texture {
  constructor(e, t, r, s, o = LinearFilter, a = LinearFilter, l, c, u) {
    super(e, t, r, s, o, a, l, c, u),
      (this.isVideoTexture = !0),
      (this.generateMipmaps = !1);
    const p = this;
    function N() {
      (p.needsUpdate = !0), e.requestVideoFrameCallback(N);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(N);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class VideoFrameTexture extends VideoTexture {
  constructor(e, t, r, s, o, a, l, c) {
    super({}, e, t, r, s, o, a, l, c), (this.isVideoFrameTexture = !0);
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    (this.image = e), (this.needsUpdate = !0);
  }
}
class FramebufferTexture extends Texture {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class CompressedTexture extends Texture {
  constructor(e, t, r, s, o, a, l, c, u, p, N, P) {
    super(null, a, l, c, u, p, s, o, N, P),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class CompressedArrayTexture extends CompressedTexture {
  constructor(e, t, r, s, o, a) {
    super(e, t, r, o, a),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = s),
      (this.wrapR = ClampToEdgeWrapping),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class CompressedCubeTexture extends CompressedTexture {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, CubeReflectionMapping),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class CanvasTexture extends Texture {
  constructor(e, t, r, s, o, a, l, c, u) {
    super(e, t, r, s, o, a, l, c, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class DepthTexture extends Texture {
  constructor(
    e,
    t,
    r = UnsignedIntType,
    s,
    o,
    a,
    l = NearestFilter,
    c = NearestFilter,
    u,
    p = DepthFormat
  ) {
    if (p !== DepthFormat && p !== DepthStencilFormat)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    super(null, s, o, a, l, c, p, r, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.source = new Source(Object.assign({}, e.image))),
      (this.compareFunction = e.compareFunction),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class DepthArrayTexture extends DepthTexture {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t),
      (this.isDepthArrayTexture = !0),
      (this.image = { width: e, height: t, depth: r }),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class CapsuleGeometry extends BufferGeometry {
  constructor(e = 1, t = 1, r = 4, s = 8, o = 1) {
    super(),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: r,
        radialSegments: s,
        heightSegments: o,
      }),
      (t = Math.max(0, t)),
      (r = Math.max(1, Math.floor(r))),
      (s = Math.max(3, Math.floor(s))),
      (o = Math.max(1, Math.floor(o)));
    const a = [],
      l = [],
      c = [],
      u = [],
      p = t / 2,
      N = (Math.PI / 2) * e,
      P = t,
      de = 2 * N + P,
      me = r * 2 + o,
      Ye = s + 1,
      nt = new Vector3(),
      Be = new Vector3();
    for (let ot = 0; ot <= me; ot++) {
      let st = 0,
        vt = 0,
        xt = 0,
        St = 0;
      if (ot <= r) {
        const Tt = ot / r,
          Ct = (Tt * Math.PI) / 2;
        (vt = -p - e * Math.cos(Ct)),
          (xt = e * Math.sin(Ct)),
          (St = -e * Math.cos(Ct)),
          (st = Tt * N);
      } else if (ot <= r + o) {
        const Tt = (ot - r) / o;
        (vt = -p + Tt * t), (xt = e), (St = 0), (st = N + Tt * P);
      } else {
        const Tt = (ot - r - o) / r,
          Ct = (Tt * Math.PI) / 2;
        (vt = p + e * Math.sin(Ct)),
          (xt = e * Math.cos(Ct)),
          (St = e * Math.sin(Ct)),
          (st = N + P + Tt * N);
      }
      const wt = Math.max(0, Math.min(1, st / de));
      let bt = 0;
      ot === 0 ? (bt = 0.5 / s) : ot === me && (bt = -0.5 / s);
      for (let Tt = 0; Tt <= s; Tt++) {
        const Ct = Tt / s,
          kt = Ct * Math.PI * 2,
          Dt = Math.sin(kt),
          Vt = Math.cos(kt);
        (Be.x = -xt * Vt),
          (Be.y = vt),
          (Be.z = xt * Dt),
          l.push(Be.x, Be.y, Be.z),
          nt.set(-xt * Vt, St, xt * Dt),
          nt.normalize(),
          c.push(nt.x, nt.y, nt.z),
          u.push(Ct + bt, wt);
      }
      if (ot > 0) {
        const Tt = (ot - 1) * Ye;
        for (let Ct = 0; Ct < s; Ct++) {
          const kt = Tt + Ct,
            Dt = Tt + Ct + 1,
            Vt = ot * Ye + Ct,
            Ht = ot * Ye + Ct + 1;
          a.push(kt, Dt, Vt), a.push(Dt, Ht, Vt);
        }
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Float32BufferAttribute(l, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(c, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new CapsuleGeometry(
      e.radius,
      e.height,
      e.capSegments,
      e.radialSegments,
      e.heightSegments
    );
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(e = 1, t = 32, r = 0, s = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: s,
      }),
      (t = Math.max(3, t));
    const o = [],
      a = [],
      l = [],
      c = [],
      u = new Vector3(),
      p = new Vector2();
    a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let N = 0, P = 3; N <= t; N++, P += 3) {
      const de = r + (N / t) * s;
      (u.x = e * Math.cos(de)),
        (u.y = e * Math.sin(de)),
        a.push(u.x, u.y, u.z),
        l.push(0, 0, 1),
        (p.x = (a[P] / e + 1) / 2),
        (p.y = (a[P + 1] / e + 1) / 2),
        c.push(p.x, p.y);
    }
    for (let N = 1; N <= t; N++) o.push(N, N + 1, 0);
    this.setIndex(o),
      this.setAttribute("position", new Float32BufferAttribute(a, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(l, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new CircleGeometry(
      e.radius,
      e.segments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    s = 32,
    o = 1,
    a = !1,
    l = 0,
    c = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: s,
        heightSegments: o,
        openEnded: a,
        thetaStart: l,
        thetaLength: c,
      });
    const u = this;
    (s = Math.floor(s)), (o = Math.floor(o));
    const p = [],
      N = [],
      P = [],
      de = [];
    let me = 0;
    const Ye = [],
      nt = r / 2;
    let Be = 0;
    ot(),
      a === !1 && (e > 0 && st(!0), t > 0 && st(!1)),
      this.setIndex(p),
      this.setAttribute("position", new Float32BufferAttribute(N, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(P, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(de, 2));
    function ot() {
      const vt = new Vector3(),
        xt = new Vector3();
      let St = 0;
      const wt = (t - e) / r;
      for (let bt = 0; bt <= o; bt++) {
        const Tt = [],
          Ct = bt / o,
          kt = Ct * (t - e) + e;
        for (let Dt = 0; Dt <= s; Dt++) {
          const Vt = Dt / s,
            Ht = Vt * c + l,
            qt = Math.sin(Ht),
            Ft = Math.cos(Ht);
          (xt.x = kt * qt),
            (xt.y = -Ct * r + nt),
            (xt.z = kt * Ft),
            N.push(xt.x, xt.y, xt.z),
            vt.set(qt, wt, Ft).normalize(),
            P.push(vt.x, vt.y, vt.z),
            de.push(Vt, 1 - Ct),
            Tt.push(me++);
        }
        Ye.push(Tt);
      }
      for (let bt = 0; bt < s; bt++)
        for (let Tt = 0; Tt < o; Tt++) {
          const Ct = Ye[Tt][bt],
            kt = Ye[Tt + 1][bt],
            Dt = Ye[Tt + 1][bt + 1],
            Vt = Ye[Tt][bt + 1];
          (e > 0 || Tt !== 0) && (p.push(Ct, kt, Vt), (St += 3)),
            (t > 0 || Tt !== o - 1) && (p.push(kt, Dt, Vt), (St += 3));
        }
      u.addGroup(Be, St, 0), (Be += St);
    }
    function st(vt) {
      const xt = me,
        St = new Vector2(),
        wt = new Vector3();
      let bt = 0;
      const Tt = vt === !0 ? e : t,
        Ct = vt === !0 ? 1 : -1;
      for (let Dt = 1; Dt <= s; Dt++)
        N.push(0, nt * Ct, 0), P.push(0, Ct, 0), de.push(0.5, 0.5), me++;
      const kt = me;
      for (let Dt = 0; Dt <= s; Dt++) {
        const Ht = (Dt / s) * c + l,
          qt = Math.cos(Ht),
          Ft = Math.sin(Ht);
        (wt.x = Tt * Ft),
          (wt.y = nt * Ct),
          (wt.z = Tt * qt),
          N.push(wt.x, wt.y, wt.z),
          P.push(0, Ct, 0),
          (St.x = qt * 0.5 + 0.5),
          (St.y = Ft * 0.5 * Ct + 0.5),
          de.push(St.x, St.y),
          me++;
      }
      for (let Dt = 0; Dt < s; Dt++) {
        const Vt = xt + Dt,
          Ht = kt + Dt;
        vt === !0 ? p.push(Ht, Ht + 1, Vt) : p.push(Ht + 1, Ht, Vt), (bt += 3);
      }
      u.addGroup(Be, bt, vt === !0 ? 1 : 2), (Be += bt);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new CylinderGeometry(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(e = 1, t = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(0, e, t, r, s, o, a, l),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
  }
  static fromJSON(e) {
    return new ConeGeometry(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(e = [], t = [], r = 1, s = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: s });
    const o = [],
      a = [];
    l(s),
      u(r),
      p(),
      this.setAttribute("position", new Float32BufferAttribute(o, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(o.slice(), 3)),
      this.setAttribute("uv", new Float32BufferAttribute(a, 2)),
      s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(ot) {
      const st = new Vector3(),
        vt = new Vector3(),
        xt = new Vector3();
      for (let St = 0; St < t.length; St += 3)
        de(t[St + 0], st),
          de(t[St + 1], vt),
          de(t[St + 2], xt),
          c(st, vt, xt, ot);
    }
    function c(ot, st, vt, xt) {
      const St = xt + 1,
        wt = [];
      for (let bt = 0; bt <= St; bt++) {
        wt[bt] = [];
        const Tt = ot.clone().lerp(vt, bt / St),
          Ct = st.clone().lerp(vt, bt / St),
          kt = St - bt;
        for (let Dt = 0; Dt <= kt; Dt++)
          Dt === 0 && bt === St
            ? (wt[bt][Dt] = Tt)
            : (wt[bt][Dt] = Tt.clone().lerp(Ct, Dt / kt));
      }
      for (let bt = 0; bt < St; bt++)
        for (let Tt = 0; Tt < 2 * (St - bt) - 1; Tt++) {
          const Ct = Math.floor(Tt / 2);
          Tt % 2 === 0
            ? (P(wt[bt][Ct + 1]), P(wt[bt + 1][Ct]), P(wt[bt][Ct]))
            : (P(wt[bt][Ct + 1]), P(wt[bt + 1][Ct + 1]), P(wt[bt + 1][Ct]));
        }
    }
    function u(ot) {
      const st = new Vector3();
      for (let vt = 0; vt < o.length; vt += 3)
        (st.x = o[vt + 0]),
          (st.y = o[vt + 1]),
          (st.z = o[vt + 2]),
          st.normalize().multiplyScalar(ot),
          (o[vt + 0] = st.x),
          (o[vt + 1] = st.y),
          (o[vt + 2] = st.z);
    }
    function p() {
      const ot = new Vector3();
      for (let st = 0; st < o.length; st += 3) {
        (ot.x = o[st + 0]), (ot.y = o[st + 1]), (ot.z = o[st + 2]);
        const vt = nt(ot) / 2 / Math.PI + 0.5,
          xt = Be(ot) / Math.PI + 0.5;
        a.push(vt, 1 - xt);
      }
      me(), N();
    }
    function N() {
      for (let ot = 0; ot < a.length; ot += 6) {
        const st = a[ot + 0],
          vt = a[ot + 2],
          xt = a[ot + 4],
          St = Math.max(st, vt, xt),
          wt = Math.min(st, vt, xt);
        St > 0.9 &&
          wt < 0.1 &&
          (st < 0.2 && (a[ot + 0] += 1),
          vt < 0.2 && (a[ot + 2] += 1),
          xt < 0.2 && (a[ot + 4] += 1));
      }
    }
    function P(ot) {
      o.push(ot.x, ot.y, ot.z);
    }
    function de(ot, st) {
      const vt = ot * 3;
      (st.x = e[vt + 0]), (st.y = e[vt + 1]), (st.z = e[vt + 2]);
    }
    function me() {
      const ot = new Vector3(),
        st = new Vector3(),
        vt = new Vector3(),
        xt = new Vector3(),
        St = new Vector2(),
        wt = new Vector2(),
        bt = new Vector2();
      for (let Tt = 0, Ct = 0; Tt < o.length; Tt += 9, Ct += 6) {
        ot.set(o[Tt + 0], o[Tt + 1], o[Tt + 2]),
          st.set(o[Tt + 3], o[Tt + 4], o[Tt + 5]),
          vt.set(o[Tt + 6], o[Tt + 7], o[Tt + 8]),
          St.set(a[Ct + 0], a[Ct + 1]),
          wt.set(a[Ct + 2], a[Ct + 3]),
          bt.set(a[Ct + 4], a[Ct + 5]),
          xt.copy(ot).add(st).add(vt).divideScalar(3);
        const kt = nt(xt);
        Ye(St, Ct + 0, ot, kt), Ye(wt, Ct + 2, st, kt), Ye(bt, Ct + 4, vt, kt);
      }
    }
    function Ye(ot, st, vt, xt) {
      xt < 0 && ot.x === 1 && (a[st] = ot.x - 1),
        vt.x === 0 && vt.z === 0 && (a[st] = xt / 2 / Math.PI + 0.5);
    }
    function nt(ot) {
      return Math.atan2(ot.z, -ot.x);
    }
    function Be(ot) {
      return Math.atan2(-ot.y, Math.sqrt(ot.x * ot.x + ot.z * ot.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new PolyhedronGeometry(e.vertices, e.indices, e.radius, e.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      s = 1 / r,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -s,
        -r,
        0,
        -s,
        r,
        0,
        s,
        -r,
        0,
        s,
        r,
        -s,
        -r,
        0,
        -s,
        r,
        0,
        s,
        -r,
        0,
        s,
        r,
        0,
        -r,
        0,
        -s,
        r,
        0,
        -s,
        -r,
        0,
        s,
        r,
        0,
        s,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(o, a, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new DodecahedronGeometry(e.radius, e.detail);
  }
}
const _v0$3 = new Vector3(),
  _v1$1 = new Vector3(),
  _normal = new Vector3(),
  _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const s = Math.pow(10, 4),
        o = Math.cos(DEG2RAD * t),
        a = e.getIndex(),
        l = e.getAttribute("position"),
        c = a ? a.count : l.count,
        u = [0, 0, 0],
        p = ["a", "b", "c"],
        N = new Array(3),
        P = {},
        de = [];
      for (let me = 0; me < c; me += 3) {
        a
          ? ((u[0] = a.getX(me)),
            (u[1] = a.getX(me + 1)),
            (u[2] = a.getX(me + 2)))
          : ((u[0] = me), (u[1] = me + 1), (u[2] = me + 2));
        const { a: Ye, b: nt, c: Be } = _triangle;
        if (
          (Ye.fromBufferAttribute(l, u[0]),
          nt.fromBufferAttribute(l, u[1]),
          Be.fromBufferAttribute(l, u[2]),
          _triangle.getNormal(_normal),
          (N[0] = `${Math.round(Ye.x * s)},${Math.round(Ye.y * s)},${Math.round(
            Ye.z * s
          )}`),
          (N[1] = `${Math.round(nt.x * s)},${Math.round(nt.y * s)},${Math.round(
            nt.z * s
          )}`),
          (N[2] = `${Math.round(Be.x * s)},${Math.round(Be.y * s)},${Math.round(
            Be.z * s
          )}`),
          !(N[0] === N[1] || N[1] === N[2] || N[2] === N[0]))
        )
          for (let ot = 0; ot < 3; ot++) {
            const st = (ot + 1) % 3,
              vt = N[ot],
              xt = N[st],
              St = _triangle[p[ot]],
              wt = _triangle[p[st]],
              bt = `${vt}_${xt}`,
              Tt = `${xt}_${vt}`;
            Tt in P && P[Tt]
              ? (_normal.dot(P[Tt].normal) <= o &&
                  (de.push(St.x, St.y, St.z), de.push(wt.x, wt.y, wt.z)),
                (P[Tt] = null))
              : bt in P ||
                (P[bt] = {
                  index0: u[ot],
                  index1: u[st],
                  normal: _normal.clone(),
                });
          }
      }
      for (const me in P)
        if (P[me]) {
          const { index0: Ye, index1: nt } = P[me];
          _v0$3.fromBufferAttribute(l, Ye),
            _v1$1.fromBufferAttribute(l, nt),
            de.push(_v0$3.x, _v0$3.y, _v0$3.z),
            de.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      this.setAttribute("position", new Float32BufferAttribute(de, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Curve {
  constructor() {
    (this.type = "Curve"),
      (this.arcLengthDivisions = 200),
      (this.needsUpdate = !1),
      (this.cacheArcLengths = null);
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      s = this.getPoint(0),
      o = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      (r = this.getPoint(a / e)), (o += r.distanceTo(s)), t.push(o), (s = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t = null) {
    const r = this.getLengths();
    let s = 0;
    const o = r.length;
    let a;
    t ? (a = t) : (a = e * r[o - 1]);
    let l = 0,
      c = o - 1,
      u;
    for (; l <= c; )
      if (((s = Math.floor(l + (c - l) / 2)), (u = r[s] - a), u < 0)) l = s + 1;
      else if (u > 0) c = s - 1;
      else {
        c = s;
        break;
      }
    if (((s = c), r[s] === a)) return s / (o - 1);
    const p = r[s],
      P = r[s + 1] - p,
      de = (a - p) / P;
    return (s + de) / (o - 1);
  }
  getTangent(e, t) {
    let s = e - 1e-4,
      o = e + 1e-4;
    s < 0 && (s = 0), o > 1 && (o = 1);
    const a = this.getPoint(s),
      l = this.getPoint(o),
      c = t || (a.isVector2 ? new Vector2() : new Vector3());
    return c.copy(l).sub(a).normalize(), c;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t = !1) {
    const r = new Vector3(),
      s = [],
      o = [],
      a = [],
      l = new Vector3(),
      c = new Matrix4();
    for (let de = 0; de <= e; de++) {
      const me = de / e;
      s[de] = this.getTangentAt(me, new Vector3());
    }
    (o[0] = new Vector3()), (a[0] = new Vector3());
    let u = Number.MAX_VALUE;
    const p = Math.abs(s[0].x),
      N = Math.abs(s[0].y),
      P = Math.abs(s[0].z);
    p <= u && ((u = p), r.set(1, 0, 0)),
      N <= u && ((u = N), r.set(0, 1, 0)),
      P <= u && r.set(0, 0, 1),
      l.crossVectors(s[0], r).normalize(),
      o[0].crossVectors(s[0], l),
      a[0].crossVectors(s[0], o[0]);
    for (let de = 1; de <= e; de++) {
      if (
        ((o[de] = o[de - 1].clone()),
        (a[de] = a[de - 1].clone()),
        l.crossVectors(s[de - 1], s[de]),
        l.length() > Number.EPSILON)
      ) {
        l.normalize();
        const me = Math.acos(clamp$1(s[de - 1].dot(s[de]), -1, 1));
        o[de].applyMatrix4(c.makeRotationAxis(l, me));
      }
      a[de].crossVectors(s[de], o[de]);
    }
    if (t === !0) {
      let de = Math.acos(clamp$1(o[0].dot(o[e]), -1, 1));
      (de /= e), s[0].dot(l.crossVectors(o[0], o[e])) > 0 && (de = -de);
      for (let me = 1; me <= e; me++)
        o[me].applyMatrix4(c.makeRotationAxis(s[me], de * me)),
          a[me].crossVectors(s[me], o[me]);
    }
    return { tangents: s, normals: o, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class EllipseCurve extends Curve {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    s = 1,
    o = 0,
    a = Math.PI * 2,
    l = !1,
    c = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = s),
      (this.aStartAngle = o),
      (this.aEndAngle = a),
      (this.aClockwise = l),
      (this.aRotation = c);
  }
  getPoint(e, t = new Vector2()) {
    const r = t,
      s = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += s;
    for (; o > s; ) o -= s;
    o < Number.EPSILON && (a ? (o = 0) : (o = s)),
      this.aClockwise === !0 && !a && (o === s ? (o = -s) : (o = o - s));
    const l = this.aStartAngle + e * o;
    let c = this.aX + this.xRadius * Math.cos(l),
      u = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const p = Math.cos(this.aRotation),
        N = Math.sin(this.aRotation),
        P = c - this.aX,
        de = u - this.aY;
      (c = P * p - de * N + this.aX), (u = P * N + de * p + this.aY);
    }
    return r.set(c, u);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class ArcCurve extends EllipseCurve {
  constructor(e, t, r, s, o, a) {
    super(e, t, r, r, s, o, a),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function CubicPoly() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function s(o, a, l, c) {
    (n = o),
      (e = l),
      (t = -3 * o + 3 * a - 2 * l - c),
      (r = 2 * o - 2 * a + l + c);
  }
  return {
    initCatmullRom: function (o, a, l, c, u) {
      s(a, l, u * (l - o), u * (c - a));
    },
    initNonuniformCatmullRom: function (o, a, l, c, u, p, N) {
      let P = (a - o) / u - (l - o) / (u + p) + (l - a) / p,
        de = (l - a) / p - (c - a) / (p + N) + (c - l) / N;
      (P *= p), (de *= p), s(a, l, P, de);
    },
    calc: function (o) {
      const a = o * o,
        l = a * o;
      return n + e * o + t * a + r * l;
    },
  };
}
const tmp = new Vector3(),
  px = new CubicPoly(),
  py = new CubicPoly(),
  pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(e = [], t = !1, r = "centripetal", s = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = s);
  }
  getPoint(e, t = new Vector3()) {
    const r = t,
      s = this.points,
      o = s.length,
      a = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(a),
      c = a - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o)
      : c === 0 && l === o - 1 && ((l = o - 2), (c = 1));
    let u, p;
    this.closed || l > 0
      ? (u = s[(l - 1) % o])
      : (tmp.subVectors(s[0], s[1]).add(s[0]), (u = tmp));
    const N = s[l % o],
      P = s[(l + 1) % o];
    if (
      (this.closed || l + 2 < o
        ? (p = s[(l + 2) % o])
        : (tmp.subVectors(s[o - 1], s[o - 2]).add(s[o - 1]), (p = tmp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const de = this.curveType === "chordal" ? 0.5 : 0.25;
      let me = Math.pow(u.distanceToSquared(N), de),
        Ye = Math.pow(N.distanceToSquared(P), de),
        nt = Math.pow(P.distanceToSquared(p), de);
      Ye < 1e-4 && (Ye = 1),
        me < 1e-4 && (me = Ye),
        nt < 1e-4 && (nt = Ye),
        px.initNonuniformCatmullRom(u.x, N.x, P.x, p.x, me, Ye, nt),
        py.initNonuniformCatmullRom(u.y, N.y, P.y, p.y, me, Ye, nt),
        pz.initNonuniformCatmullRom(u.z, N.z, P.z, p.z, me, Ye, nt);
    } else
      this.curveType === "catmullrom" &&
        (px.initCatmullRom(u.x, N.x, P.x, p.x, this.tension),
        py.initCatmullRom(u.y, N.y, P.y, p.y, this.tension),
        pz.initCatmullRom(u.z, N.z, P.z, p.z, this.tension));
    return r.set(px.calc(c), py.calc(c), pz.calc(c)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const s = e.points[t];
      this.points.push(s.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const s = this.points[t];
      e.points.push(s.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const s = e.points[t];
      this.points.push(new Vector3().fromArray(s));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function CatmullRom(n, e, t, r, s) {
  const o = (r - e) * 0.5,
    a = (s - t) * 0.5,
    l = n * n,
    c = n * l;
  return (
    (2 * t - 2 * r + o + a) * c + (-3 * t + 3 * r - 2 * o - a) * l + o * n + t
  );
}
function QuadraticBezierP0(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function QuadraticBezierP1(n, e) {
  return 2 * (1 - n) * n * e;
}
function QuadraticBezierP2(n, e) {
  return n * n * e;
}
function QuadraticBezier(n, e, t, r) {
  return (
    QuadraticBezierP0(n, e) + QuadraticBezierP1(n, t) + QuadraticBezierP2(n, r)
  );
}
function CubicBezierP0(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function CubicBezierP1(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function CubicBezierP2(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function CubicBezierP3(n, e) {
  return n * n * n * e;
}
function CubicBezier(n, e, t, r, s) {
  return (
    CubicBezierP0(n, e) +
    CubicBezierP1(n, t) +
    CubicBezierP2(n, r) +
    CubicBezierP3(n, s)
  );
}
class CubicBezierCurve extends Curve {
  constructor(
    e = new Vector2(),
    t = new Vector2(),
    r = new Vector2(),
    s = new Vector2()
  ) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = s);
  }
  getPoint(e, t = new Vector2()) {
    const r = t,
      s = this.v0,
      o = this.v1,
      a = this.v2,
      l = this.v3;
    return (
      r.set(
        CubicBezier(e, s.x, o.x, a.x, l.x),
        CubicBezier(e, s.y, o.y, a.y, l.y)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(
    e = new Vector3(),
    t = new Vector3(),
    r = new Vector3(),
    s = new Vector3()
  ) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = s);
  }
  getPoint(e, t = new Vector3()) {
    const r = t,
      s = this.v0,
      o = this.v1,
      a = this.v2,
      l = this.v3;
    return (
      r.set(
        CubicBezier(e, s.x, o.x, a.x, l.x),
        CubicBezier(e, s.y, o.y, a.y, l.y),
        CubicBezier(e, s.z, o.z, a.z, l.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class LineCurve extends Curve {
  constructor(e = new Vector2(), t = new Vector2()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new Vector2()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Vector2()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class LineCurve3 extends Curve {
  constructor(e = new Vector3(), t = new Vector3()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new Vector3()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Vector3()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(e = new Vector2(), t = new Vector2(), r = new Vector2()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new Vector2()) {
    const r = t,
      s = this.v0,
      o = this.v1,
      a = this.v2;
    return (
      r.set(
        QuadraticBezier(e, s.x, o.x, a.x),
        QuadraticBezier(e, s.y, o.y, a.y)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(e = new Vector3(), t = new Vector3(), r = new Vector3()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new Vector3()) {
    const r = t,
      s = this.v0,
      o = this.v1,
      a = this.v2;
    return (
      r.set(
        QuadraticBezier(e, s.x, o.x, a.x),
        QuadraticBezier(e, s.y, o.y, a.y),
        QuadraticBezier(e, s.z, o.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class SplineCurve extends Curve {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new Vector2()) {
    const r = t,
      s = this.points,
      o = (s.length - 1) * e,
      a = Math.floor(o),
      l = o - a,
      c = s[a === 0 ? a : a - 1],
      u = s[a],
      p = s[a > s.length - 2 ? s.length - 1 : a + 1],
      N = s[a > s.length - 3 ? s.length - 1 : a + 2];
    return (
      r.set(
        CatmullRom(l, c.x, u.x, p.x, N.x),
        CatmullRom(l, c.y, u.y, p.y, N.y)
      ),
      r
    );
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const s = e.points[t];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const s = this.points[t];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const s = e.points[t];
      this.points.push(new Vector2().fromArray(s));
    }
    return this;
  }
}
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve,
});
class CurvePath extends Curve {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[r](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      s = this.getCurveLengths();
    let o = 0;
    for (; o < s.length; ) {
      if (s[o] >= r) {
        const a = s[o] - r,
          l = this.curves[o],
          c = l.getLength(),
          u = c === 0 ? 0 : 1 - a / c;
        return l.getPointAt(u, t);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, s = this.curves.length; r < s; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let s = 0, o = this.curves; s < o.length; s++) {
      const a = o[s],
        l = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
          ? 1
          : a.isSplineCurve
          ? e * a.points.length
          : e,
        c = a.getPoints(l);
      for (let u = 0; u < c.length; u++) {
        const p = c[u];
        (r && r.equals(p)) || (t.push(p), (r = p));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const s = e.curves[t];
      this.curves.push(s.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const s = this.curves[t];
      e.curves.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const s = e.curves[t];
      this.curves.push(new Curves[s.type]().fromJSON(s));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Vector2()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new LineCurve(this.currentPoint.clone(), new Vector2(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, s) {
    const o = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, t),
      new Vector2(r, s)
    );
    return this.curves.push(o), this.currentPoint.set(r, s), this;
  }
  bezierCurveTo(e, t, r, s, o, a) {
    const l = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, t),
      new Vector2(r, s),
      new Vector2(o, a)
    );
    return this.curves.push(l), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new SplineCurve(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, s, o, a) {
    const l = this.currentPoint.x,
      c = this.currentPoint.y;
    return this.absarc(e + l, t + c, r, s, o, a), this;
  }
  absarc(e, t, r, s, o, a) {
    return this.absellipse(e, t, r, r, s, o, a), this;
  }
  ellipse(e, t, r, s, o, a, l, c) {
    const u = this.currentPoint.x,
      p = this.currentPoint.y;
    return this.absellipse(e + u, t + p, r, s, o, a, l, c), this;
  }
  absellipse(e, t, r, s, o, a, l, c) {
    const u = new EllipseCurve(e, t, r, s, o, a, l, c);
    if (this.curves.length > 0) {
      const N = u.getPoint(0);
      N.equals(this.currentPoint) || this.lineTo(N.x, N.y);
    }
    this.curves.push(u);
    const p = u.getPoint(1);
    return this.currentPoint.copy(p), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Shape extends Path {
  constructor(e) {
    super(e),
      (this.uuid = generateUUID()),
      (this.type = "Shape"),
      (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, s = this.holes.length; r < s; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const s = e.holes[t];
      this.holes.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const s = this.holes[t];
      e.holes.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const s = e.holes[t];
      this.holes.push(new Path().fromJSON(s));
    }
    return this;
  }
}
function earcut(n, e, t = 2) {
  const r = e && e.length,
    s = r ? e[0] * t : n.length;
  let o = linkedList(n, 0, s, t, !0);
  const a = [];
  if (!o || o.next === o.prev) return a;
  let l, c, u;
  if ((r && (o = eliminateHoles(n, e, o, t)), n.length > 80 * t)) {
    (l = 1 / 0), (c = 1 / 0);
    let p = -1 / 0,
      N = -1 / 0;
    for (let P = t; P < s; P += t) {
      const de = n[P],
        me = n[P + 1];
      de < l && (l = de),
        me < c && (c = me),
        de > p && (p = de),
        me > N && (N = me);
    }
    (u = Math.max(p - l, N - c)), (u = u !== 0 ? 32767 / u : 0);
  }
  return earcutLinked(o, a, t, l, c, u, 0), a;
}
function linkedList(n, e, t, r, s) {
  let o;
  if (s === signedArea(n, e, t, r) > 0)
    for (let a = e; a < t; a += r)
      o = insertNode((a / r) | 0, n[a], n[a + 1], o);
  else
    for (let a = t - r; a >= e; a -= r)
      o = insertNode((a / r) | 0, n[a], n[a + 1], o);
  return o && equals(o, o.next) && (removeNode(o), (o = o.next)), o;
}
function filterPoints(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1),
      !t.steiner && (equals(t, t.next) || area(t.prev, t, t.next) === 0))
    ) {
      if ((removeNode(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function earcutLinked(n, e, t, r, s, o, a) {
  if (!n) return;
  !a && o && indexCurve(n, r, s, o);
  let l = n;
  for (; n.prev !== n.next; ) {
    const c = n.prev,
      u = n.next;
    if (o ? isEarHashed(n, r, s, o) : isEar(n)) {
      e.push(c.i, n.i, u.i), removeNode(n), (n = u.next), (l = u.next);
      continue;
    }
    if (((n = u), n === l)) {
      a
        ? a === 1
          ? ((n = cureLocalIntersections(filterPoints(n), e)),
            earcutLinked(n, e, t, r, s, o, 2))
          : a === 2 && splitEarcut(n, e, t, r, s, o)
        : earcutLinked(filterPoints(n), e, t, r, s, o, 1);
      break;
    }
  }
}
function isEar(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (area(e, t, r) >= 0) return !1;
  const s = e.x,
    o = t.x,
    a = r.x,
    l = e.y,
    c = t.y,
    u = r.y,
    p = Math.min(s, o, a),
    N = Math.min(l, c, u),
    P = Math.max(s, o, a),
    de = Math.max(l, c, u);
  let me = r.next;
  for (; me !== e; ) {
    if (
      me.x >= p &&
      me.x <= P &&
      me.y >= N &&
      me.y <= de &&
      pointInTriangleExceptFirst(s, l, o, c, a, u, me.x, me.y) &&
      area(me.prev, me, me.next) >= 0
    )
      return !1;
    me = me.next;
  }
  return !0;
}
function isEarHashed(n, e, t, r) {
  const s = n.prev,
    o = n,
    a = n.next;
  if (area(s, o, a) >= 0) return !1;
  const l = s.x,
    c = o.x,
    u = a.x,
    p = s.y,
    N = o.y,
    P = a.y,
    de = Math.min(l, c, u),
    me = Math.min(p, N, P),
    Ye = Math.max(l, c, u),
    nt = Math.max(p, N, P),
    Be = zOrder(de, me, e, t, r),
    ot = zOrder(Ye, nt, e, t, r);
  let st = n.prevZ,
    vt = n.nextZ;
  for (; st && st.z >= Be && vt && vt.z <= ot; ) {
    if (
      (st.x >= de &&
        st.x <= Ye &&
        st.y >= me &&
        st.y <= nt &&
        st !== s &&
        st !== a &&
        pointInTriangleExceptFirst(l, p, c, N, u, P, st.x, st.y) &&
        area(st.prev, st, st.next) >= 0) ||
      ((st = st.prevZ),
      vt.x >= de &&
        vt.x <= Ye &&
        vt.y >= me &&
        vt.y <= nt &&
        vt !== s &&
        vt !== a &&
        pointInTriangleExceptFirst(l, p, c, N, u, P, vt.x, vt.y) &&
        area(vt.prev, vt, vt.next) >= 0)
    )
      return !1;
    vt = vt.nextZ;
  }
  for (; st && st.z >= Be; ) {
    if (
      st.x >= de &&
      st.x <= Ye &&
      st.y >= me &&
      st.y <= nt &&
      st !== s &&
      st !== a &&
      pointInTriangleExceptFirst(l, p, c, N, u, P, st.x, st.y) &&
      area(st.prev, st, st.next) >= 0
    )
      return !1;
    st = st.prevZ;
  }
  for (; vt && vt.z <= ot; ) {
    if (
      vt.x >= de &&
      vt.x <= Ye &&
      vt.y >= me &&
      vt.y <= nt &&
      vt !== s &&
      vt !== a &&
      pointInTriangleExceptFirst(l, p, c, N, u, P, vt.x, vt.y) &&
      area(vt.prev, vt, vt.next) >= 0
    )
      return !1;
    vt = vt.nextZ;
  }
  return !0;
}
function cureLocalIntersections(n, e) {
  let t = n;
  do {
    const r = t.prev,
      s = t.next.next;
    !equals(r, s) &&
      intersects(r, t, t.next, s) &&
      locallyInside(r, s) &&
      locallyInside(s, r) &&
      (e.push(r.i, t.i, s.i), removeNode(t), removeNode(t.next), (t = n = s)),
      (t = t.next);
  } while (t !== n);
  return filterPoints(t);
}
function splitEarcut(n, e, t, r, s, o) {
  let a = n;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && isValidDiagonal(a, l)) {
        let c = splitPolygon(a, l);
        (a = filterPoints(a, a.next)),
          (c = filterPoints(c, c.next)),
          earcutLinked(a, e, t, r, s, o, 0),
          earcutLinked(c, e, t, r, s, o, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== n);
}
function eliminateHoles(n, e, t, r) {
  const s = [];
  for (let o = 0, a = e.length; o < a; o++) {
    const l = e[o] * r,
      c = o < a - 1 ? e[o + 1] * r : n.length,
      u = linkedList(n, l, c, r, !1);
    u === u.next && (u.steiner = !0), s.push(getLeftmost(u));
  }
  s.sort(compareXYSlope);
  for (let o = 0; o < s.length; o++) t = eliminateHole(s[o], t);
  return t;
}
function compareXYSlope(n, e) {
  let t = n.x - e.x;
  if (t === 0 && ((t = n.y - e.y), t === 0)) {
    const r = (n.next.y - n.y) / (n.next.x - n.x),
      s = (e.next.y - e.y) / (e.next.x - e.x);
    t = r - s;
  }
  return t;
}
function eliminateHole(n, e) {
  const t = findHoleBridge(n, e);
  if (!t) return e;
  const r = splitPolygon(t, n);
  return filterPoints(r, r.next), filterPoints(t, t.next);
}
function findHoleBridge(n, e) {
  let t = e;
  const r = n.x,
    s = n.y;
  let o = -1 / 0,
    a;
  if (equals(n, t)) return t;
  do {
    if (equals(n, t.next)) return t.next;
    if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
      const N = t.x + ((s - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        N <= r &&
        N > o &&
        ((o = N), (a = t.x < t.next.x ? t : t.next), N === r)
      )
        return a;
    }
    t = t.next;
  } while (t !== e);
  if (!a) return null;
  const l = a,
    c = a.x,
    u = a.y;
  let p = 1 / 0;
  t = a;
  do {
    if (
      r >= t.x &&
      t.x >= c &&
      r !== t.x &&
      pointInTriangle(s < u ? r : o, s, c, u, s < u ? o : r, s, t.x, t.y)
    ) {
      const N = Math.abs(s - t.y) / (r - t.x);
      locallyInside(t, n) &&
        (N < p ||
          (N === p &&
            (t.x > a.x || (t.x === a.x && sectorContainsSector(a, t))))) &&
        ((a = t), (p = N));
    }
    t = t.next;
  } while (t !== l);
  return a;
}
function sectorContainsSector(n, e) {
  return area(n.prev, n, e.prev) < 0 && area(e.next, n, n.next) < 0;
}
function indexCurve(n, e, t, r) {
  let s = n;
  do
    s.z === 0 && (s.z = zOrder(s.x, s.y, e, t, r)),
      (s.prevZ = s.prev),
      (s.nextZ = s.next),
      (s = s.next);
  while (s !== n);
  (s.prevZ.nextZ = null), (s.prevZ = null), sortLinked(s);
}
function sortLinked(n) {
  let e,
    t = 1;
  do {
    let r = n,
      s;
    n = null;
    let o = null;
    for (e = 0; r; ) {
      e++;
      let a = r,
        l = 0;
      for (let u = 0; u < t && (l++, (a = a.nextZ), !!a); u++);
      let c = t;
      for (; l > 0 || (c > 0 && a); )
        l !== 0 && (c === 0 || !a || r.z <= a.z)
          ? ((s = r), (r = r.nextZ), l--)
          : ((s = a), (a = a.nextZ), c--),
          o ? (o.nextZ = s) : (n = s),
          (s.prevZ = o),
          (o = s);
      r = a;
    }
    (o.nextZ = null), (t *= 2);
  } while (e > 1);
  return n;
}
function zOrder(n, e, t, r, s) {
  return (
    (n = ((n - t) * s) | 0),
    (e = ((e - r) * s) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function getLeftmost(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function pointInTriangle(n, e, t, r, s, o, a, l) {
  return (
    (s - a) * (e - l) >= (n - a) * (o - l) &&
    (n - a) * (r - l) >= (t - a) * (e - l) &&
    (t - a) * (o - l) >= (s - a) * (r - l)
  );
}
function pointInTriangleExceptFirst(n, e, t, r, s, o, a, l) {
  return !(n === a && e === l) && pointInTriangle(n, e, t, r, s, o, a, l);
}
function isValidDiagonal(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !intersectsPolygon(n, e) &&
    ((locallyInside(n, e) &&
      locallyInside(e, n) &&
      middleInside(n, e) &&
      (area(n.prev, n, e.prev) || area(n, e.prev, e))) ||
      (equals(n, e) &&
        area(n.prev, n, n.next) > 0 &&
        area(e.prev, e, e.next) > 0))
  );
}
function area(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function equals(n, e) {
  return n.x === e.x && n.y === e.y;
}
function intersects(n, e, t, r) {
  const s = sign(area(n, e, t)),
    o = sign(area(n, e, r)),
    a = sign(area(t, r, n)),
    l = sign(area(t, r, e));
  return !!(
    (s !== o && a !== l) ||
    (s === 0 && onSegment(n, t, e)) ||
    (o === 0 && onSegment(n, r, e)) ||
    (a === 0 && onSegment(t, n, r)) ||
    (l === 0 && onSegment(t, e, r))
  );
}
function onSegment(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function sign(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function intersectsPolygon(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      intersects(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function locallyInside(n, e) {
  return area(n.prev, n, n.next) < 0
    ? area(n, e, n.next) >= 0 && area(n, n.prev, e) >= 0
    : area(n, e, n.prev) < 0 || area(n, n.next, e) < 0;
}
function middleInside(n, e) {
  let t = n,
    r = !1;
  const s = (n.x + e.x) / 2,
    o = (n.y + e.y) / 2;
  do
    t.y > o != t.next.y > o &&
      t.next.y !== t.y &&
      s < ((t.next.x - t.x) * (o - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function splitPolygon(n, e) {
  const t = createNode(n.i, n.x, n.y),
    r = createNode(e.i, e.x, e.y),
    s = n.next,
    o = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = s),
    (s.prev = t),
    (r.next = t),
    (t.prev = r),
    (o.next = r),
    (r.prev = o),
    r
  );
}
function insertNode(n, e, t, r) {
  const s = createNode(n, e, t);
  return (
    r
      ? ((s.next = r.next), (s.prev = r), (r.next.prev = s), (r.next = s))
      : ((s.prev = s), (s.next = s)),
    s
  );
}
function removeNode(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function createNode(n, e, t) {
  return {
    i: n,
    x: e,
    y: t,
    prev: null,
    next: null,
    z: 0,
    prevZ: null,
    nextZ: null,
    steiner: !1,
  };
}
function signedArea(n, e, t, r) {
  let s = 0;
  for (let o = e, a = t - r; o < t; o += r)
    (s += (n[a] - n[o]) * (n[o + 1] + n[a + 1])), (a = o);
  return s;
}
class Earcut {
  static triangulate(e, t, r = 2) {
    return earcut(e, t, r);
  }
}
class ShapeUtils {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let s = t - 1, o = 0; o < t; s = o++)
      r += e[s].x * e[o].y - e[o].x * e[s].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return ShapeUtils.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      s = [],
      o = [];
    removeDupEndPts(e), addContour(r, e);
    let a = e.length;
    t.forEach(removeDupEndPts);
    for (let c = 0; c < t.length; c++)
      s.push(a), (a += t[c].length), addContour(r, t[c]);
    const l = Earcut.triangulate(r, s);
    for (let c = 0; c < l.length; c += 3) o.push(l.slice(c, c + 3));
    return o;
  }
}
function removeDupEndPts(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function addContour(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(
    e = new Shape([
      new Vector2(0.5, 0.5),
      new Vector2(-0.5, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      s = [],
      o = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const u = e[l];
      a(u);
    }
    this.setAttribute("position", new Float32BufferAttribute(s, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(o, 2)),
      this.computeVertexNormals();
    function a(l) {
      const c = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        p = t.steps !== void 0 ? t.steps : 1,
        N = t.depth !== void 0 ? t.depth : 1;
      let P = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        de = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        me = t.bevelSize !== void 0 ? t.bevelSize : de - 0.1,
        Ye = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        nt = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const Be = t.extrudePath,
        ot = t.UVGenerator !== void 0 ? t.UVGenerator : WorldUVGenerator;
      let st,
        vt = !1,
        xt,
        St,
        wt,
        bt;
      Be &&
        ((st = Be.getSpacedPoints(p)),
        (vt = !0),
        (P = !1),
        (xt = Be.computeFrenetFrames(p, !1)),
        (St = new Vector3()),
        (wt = new Vector3()),
        (bt = new Vector3())),
        P || ((nt = 0), (de = 0), (me = 0), (Ye = 0));
      const Tt = l.extractPoints(u);
      let Ct = Tt.shape;
      const kt = Tt.holes;
      if (!ShapeUtils.isClockWise(Ct)) {
        Ct = Ct.reverse();
        for (let jt = 0, Yn = kt.length; jt < Yn; jt++) {
          const zn = kt[jt];
          ShapeUtils.isClockWise(zn) && (kt[jt] = zn.reverse());
        }
      }
      function Vt(jt) {
        const zn = 10000000000000001e-36;
        let rn = jt[0];
        for (let In = 1; In <= jt.length; In++) {
          const or = In % jt.length,
            Gn = jt[or],
            Yt = Gn.x - rn.x,
            Gt = Gn.y - rn.y,
            hn = Yt * Yt + Gt * Gt,
            En = Math.max(
              Math.abs(Gn.x),
              Math.abs(Gn.y),
              Math.abs(rn.x),
              Math.abs(rn.y)
            ),
            Ln = zn * En * En;
          if (hn <= Ln) {
            jt.splice(or, 1), In--;
            continue;
          }
          rn = Gn;
        }
      }
      Vt(Ct), kt.forEach(Vt);
      const Ht = kt.length,
        qt = Ct;
      for (let jt = 0; jt < Ht; jt++) {
        const Yn = kt[jt];
        Ct = Ct.concat(Yn);
      }
      function Ft(jt, Yn, zn) {
        return (
          Yn || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          jt.clone().addScaledVector(Yn, zn)
        );
      }
      const Bt = Ct.length;
      function Mt(jt, Yn, zn) {
        let rn, In, or;
        const Gn = jt.x - Yn.x,
          Yt = jt.y - Yn.y,
          Gt = zn.x - jt.x,
          hn = zn.y - jt.y,
          En = Gn * Gn + Yt * Yt,
          Ln = Gn * hn - Yt * Gt;
        if (Math.abs(Ln) > Number.EPSILON) {
          const mn = Math.sqrt(En),
            Vn = Math.sqrt(Gt * Gt + hn * hn),
            Fn = Yn.x - Yt / mn,
            nr = Yn.y + Gn / mn,
            yr = zn.x - hn / Vn,
            qn = zn.y + Gt / Vn,
            jn = ((yr - Fn) * hn - (qn - nr) * Gt) / (Gn * hn - Yt * Gt);
          (rn = Fn + Gn * jn - jt.x), (In = nr + Yt * jn - jt.y);
          const Jn = rn * rn + In * In;
          if (Jn <= 2) return new Vector2(rn, In);
          or = Math.sqrt(Jn / 2);
        } else {
          let mn = !1;
          Gn > Number.EPSILON
            ? Gt > Number.EPSILON && (mn = !0)
            : Gn < -Number.EPSILON
            ? Gt < -Number.EPSILON && (mn = !0)
            : Math.sign(Yt) === Math.sign(hn) && (mn = !0),
            mn
              ? ((rn = -Yt), (In = Gn), (or = Math.sqrt(En)))
              : ((rn = Gn), (In = Yt), (or = Math.sqrt(En / 2)));
        }
        return new Vector2(rn / or, In / or);
      }
      const Pt = [];
      for (
        let jt = 0, Yn = qt.length, zn = Yn - 1, rn = jt + 1;
        jt < Yn;
        jt++, zn++, rn++
      )
        zn === Yn && (zn = 0),
          rn === Yn && (rn = 0),
          (Pt[jt] = Mt(qt[jt], qt[zn], qt[rn]));
      const It = [];
      let Ot,
        Xt = Pt.concat();
      for (let jt = 0, Yn = Ht; jt < Yn; jt++) {
        const zn = kt[jt];
        Ot = [];
        for (
          let rn = 0, In = zn.length, or = In - 1, Gn = rn + 1;
          rn < In;
          rn++, or++, Gn++
        )
          or === In && (or = 0),
            Gn === In && (Gn = 0),
            (Ot[rn] = Mt(zn[rn], zn[or], zn[Gn]));
        It.push(Ot), (Xt = Xt.concat(Ot));
      }
      let sn;
      if (nt === 0) sn = ShapeUtils.triangulateShape(qt, kt);
      else {
        const jt = [],
          Yn = [];
        for (let zn = 0; zn < nt; zn++) {
          const rn = zn / nt,
            In = de * Math.cos((rn * Math.PI) / 2),
            or = me * Math.sin((rn * Math.PI) / 2) + Ye;
          for (let Gn = 0, Yt = qt.length; Gn < Yt; Gn++) {
            const Gt = Ft(qt[Gn], Pt[Gn], or);
            $n(Gt.x, Gt.y, -In), rn === 0 && jt.push(Gt);
          }
          for (let Gn = 0, Yt = Ht; Gn < Yt; Gn++) {
            const Gt = kt[Gn];
            Ot = It[Gn];
            const hn = [];
            for (let En = 0, Ln = Gt.length; En < Ln; En++) {
              const mn = Ft(Gt[En], Ot[En], or);
              $n(mn.x, mn.y, -In), rn === 0 && hn.push(mn);
            }
            rn === 0 && Yn.push(hn);
          }
        }
        sn = ShapeUtils.triangulateShape(jt, Yn);
      }
      const Kt = sn.length,
        tn = me + Ye;
      for (let jt = 0; jt < Bt; jt++) {
        const Yn = P ? Ft(Ct[jt], Xt[jt], tn) : Ct[jt];
        vt
          ? (wt.copy(xt.normals[0]).multiplyScalar(Yn.x),
            St.copy(xt.binormals[0]).multiplyScalar(Yn.y),
            bt.copy(st[0]).add(wt).add(St),
            $n(bt.x, bt.y, bt.z))
          : $n(Yn.x, Yn.y, 0);
      }
      for (let jt = 1; jt <= p; jt++)
        for (let Yn = 0; Yn < Bt; Yn++) {
          const zn = P ? Ft(Ct[Yn], Xt[Yn], tn) : Ct[Yn];
          vt
            ? (wt.copy(xt.normals[jt]).multiplyScalar(zn.x),
              St.copy(xt.binormals[jt]).multiplyScalar(zn.y),
              bt.copy(st[jt]).add(wt).add(St),
              $n(bt.x, bt.y, bt.z))
            : $n(zn.x, zn.y, (N / p) * jt);
        }
      for (let jt = nt - 1; jt >= 0; jt--) {
        const Yn = jt / nt,
          zn = de * Math.cos((Yn * Math.PI) / 2),
          rn = me * Math.sin((Yn * Math.PI) / 2) + Ye;
        for (let In = 0, or = qt.length; In < or; In++) {
          const Gn = Ft(qt[In], Pt[In], rn);
          $n(Gn.x, Gn.y, N + zn);
        }
        for (let In = 0, or = kt.length; In < or; In++) {
          const Gn = kt[In];
          Ot = It[In];
          for (let Yt = 0, Gt = Gn.length; Yt < Gt; Yt++) {
            const hn = Ft(Gn[Yt], Ot[Yt], rn);
            vt
              ? $n(hn.x, hn.y + st[p - 1].y, st[p - 1].x + zn)
              : $n(hn.x, hn.y, N + zn);
          }
        }
      }
      pn(), _n();
      function pn() {
        const jt = s.length / 3;
        if (P) {
          let Yn = 0,
            zn = Bt * Yn;
          for (let rn = 0; rn < Kt; rn++) {
            const In = sn[rn];
            tr(In[2] + zn, In[1] + zn, In[0] + zn);
          }
          (Yn = p + nt * 2), (zn = Bt * Yn);
          for (let rn = 0; rn < Kt; rn++) {
            const In = sn[rn];
            tr(In[0] + zn, In[1] + zn, In[2] + zn);
          }
        } else {
          for (let Yn = 0; Yn < Kt; Yn++) {
            const zn = sn[Yn];
            tr(zn[2], zn[1], zn[0]);
          }
          for (let Yn = 0; Yn < Kt; Yn++) {
            const zn = sn[Yn];
            tr(zn[0] + Bt * p, zn[1] + Bt * p, zn[2] + Bt * p);
          }
        }
        r.addGroup(jt, s.length / 3 - jt, 0);
      }
      function _n() {
        const jt = s.length / 3;
        let Yn = 0;
        bn(qt, Yn), (Yn += qt.length);
        for (let zn = 0, rn = kt.length; zn < rn; zn++) {
          const In = kt[zn];
          bn(In, Yn), (Yn += In.length);
        }
        r.addGroup(jt, s.length / 3 - jt, 1);
      }
      function bn(jt, Yn) {
        let zn = jt.length;
        for (; --zn >= 0; ) {
          const rn = zn;
          let In = zn - 1;
          In < 0 && (In = jt.length - 1);
          for (let or = 0, Gn = p + nt * 2; or < Gn; or++) {
            const Yt = Bt * or,
              Gt = Bt * (or + 1),
              hn = Yn + rn + Yt,
              En = Yn + In + Yt,
              Ln = Yn + In + Gt,
              mn = Yn + rn + Gt;
            ur(hn, En, Ln, mn);
          }
        }
      }
      function $n(jt, Yn, zn) {
        c.push(jt), c.push(Yn), c.push(zn);
      }
      function tr(jt, Yn, zn) {
        _r(jt), _r(Yn), _r(zn);
        const rn = s.length / 3,
          In = ot.generateTopUV(r, s, rn - 3, rn - 2, rn - 1);
        Bn(In[0]), Bn(In[1]), Bn(In[2]);
      }
      function ur(jt, Yn, zn, rn) {
        _r(jt), _r(Yn), _r(rn), _r(Yn), _r(zn), _r(rn);
        const In = s.length / 3,
          or = ot.generateSideWallUV(r, s, In - 6, In - 3, In - 2, In - 1);
        Bn(or[0]), Bn(or[1]), Bn(or[3]), Bn(or[1]), Bn(or[2]), Bn(or[3]);
      }
      function _r(jt) {
        s.push(c[jt * 3 + 0]), s.push(c[jt * 3 + 1]), s.push(c[jt * 3 + 2]);
      }
      function Bn(jt) {
        o.push(jt.x), o.push(jt.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return toJSON$1(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let o = 0, a = e.shapes.length; o < a; o++) {
      const l = t[e.shapes[o]];
      r.push(l);
    }
    const s = e.options.extrudePath;
    return (
      s !== void 0 &&
        (e.options.extrudePath = new Curves[s.type]().fromJSON(s)),
      new ExtrudeGeometry(r, e.options)
    );
  }
}
const WorldUVGenerator = {
  generateTopUV: function (n, e, t, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[r * 3],
      c = e[r * 3 + 1],
      u = e[s * 3],
      p = e[s * 3 + 1];
    return [new Vector2(o, a), new Vector2(l, c), new Vector2(u, p)];
  },
  generateSideWallUV: function (n, e, t, r, s, o) {
    const a = e[t * 3],
      l = e[t * 3 + 1],
      c = e[t * 3 + 2],
      u = e[r * 3],
      p = e[r * 3 + 1],
      N = e[r * 3 + 2],
      P = e[s * 3],
      de = e[s * 3 + 1],
      me = e[s * 3 + 2],
      Ye = e[o * 3],
      nt = e[o * 3 + 1],
      Be = e[o * 3 + 2];
    return Math.abs(l - p) < Math.abs(a - u)
      ? [
          new Vector2(a, 1 - c),
          new Vector2(u, 1 - N),
          new Vector2(P, 1 - me),
          new Vector2(Ye, 1 - Be),
        ]
      : [
          new Vector2(l, 1 - c),
          new Vector2(p, 1 - N),
          new Vector2(de, 1 - me),
          new Vector2(nt, 1 - Be),
        ];
  },
};
function toJSON$1(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r];
      t.shapes.push(o.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      s = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(s, o, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new IcosahedronGeometry(e.radius, e.detail);
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(
    e = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)],
    t = 12,
    r = 0,
    s = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: s }),
      (t = Math.floor(t)),
      (s = clamp$1(s, 0, Math.PI * 2));
    const o = [],
      a = [],
      l = [],
      c = [],
      u = [],
      p = 1 / t,
      N = new Vector3(),
      P = new Vector2(),
      de = new Vector3(),
      me = new Vector3(),
      Ye = new Vector3();
    let nt = 0,
      Be = 0;
    for (let ot = 0; ot <= e.length - 1; ot++)
      switch (ot) {
        case 0:
          (nt = e[ot + 1].x - e[ot].x),
            (Be = e[ot + 1].y - e[ot].y),
            (de.x = Be * 1),
            (de.y = -nt),
            (de.z = Be * 0),
            Ye.copy(de),
            de.normalize(),
            c.push(de.x, de.y, de.z);
          break;
        case e.length - 1:
          c.push(Ye.x, Ye.y, Ye.z);
          break;
        default:
          (nt = e[ot + 1].x - e[ot].x),
            (Be = e[ot + 1].y - e[ot].y),
            (de.x = Be * 1),
            (de.y = -nt),
            (de.z = Be * 0),
            me.copy(de),
            (de.x += Ye.x),
            (de.y += Ye.y),
            (de.z += Ye.z),
            de.normalize(),
            c.push(de.x, de.y, de.z),
            Ye.copy(me);
      }
    for (let ot = 0; ot <= t; ot++) {
      const st = r + ot * p * s,
        vt = Math.sin(st),
        xt = Math.cos(st);
      for (let St = 0; St <= e.length - 1; St++) {
        (N.x = e[St].x * vt),
          (N.y = e[St].y),
          (N.z = e[St].x * xt),
          a.push(N.x, N.y, N.z),
          (P.x = ot / t),
          (P.y = St / (e.length - 1)),
          l.push(P.x, P.y);
        const wt = c[3 * St + 0] * vt,
          bt = c[3 * St + 1],
          Tt = c[3 * St + 0] * xt;
        u.push(wt, bt, Tt);
      }
    }
    for (let ot = 0; ot < t; ot++)
      for (let st = 0; st < e.length - 1; st++) {
        const vt = st + ot * e.length,
          xt = vt,
          St = vt + e.length,
          wt = vt + e.length + 1,
          bt = vt + 1;
        o.push(xt, St, bt), o.push(wt, bt, St);
      }
    this.setIndex(o),
      this.setAttribute("position", new Float32BufferAttribute(a, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(l, 2)),
      this.setAttribute("normal", new Float32BufferAttribute(u, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new LatheGeometry(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      s = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, s, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new OctahedronGeometry(e.radius, e.detail);
  }
}
class PlaneGeometry extends BufferGeometry {
  constructor(e = 1, t = 1, r = 1, s = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: s,
      });
    const o = e / 2,
      a = t / 2,
      l = Math.floor(r),
      c = Math.floor(s),
      u = l + 1,
      p = c + 1,
      N = e / l,
      P = t / c,
      de = [],
      me = [],
      Ye = [],
      nt = [];
    for (let Be = 0; Be < p; Be++) {
      const ot = Be * P - a;
      for (let st = 0; st < u; st++) {
        const vt = st * N - o;
        me.push(vt, -ot, 0),
          Ye.push(0, 0, 1),
          nt.push(st / l),
          nt.push(1 - Be / c);
      }
    }
    for (let Be = 0; Be < c; Be++)
      for (let ot = 0; ot < l; ot++) {
        const st = ot + u * Be,
          vt = ot + u * (Be + 1),
          xt = ot + 1 + u * (Be + 1),
          St = ot + 1 + u * Be;
        de.push(st, vt, St), de.push(vt, xt, St);
      }
    this.setIndex(de),
      this.setAttribute("position", new Float32BufferAttribute(me, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(Ye, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(nt, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new PlaneGeometry(
      e.width,
      e.height,
      e.widthSegments,
      e.heightSegments
    );
  }
}
class RingGeometry extends BufferGeometry {
  constructor(e = 0.5, t = 1, r = 32, s = 1, o = 0, a = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (r = Math.max(3, r)),
      (s = Math.max(1, s));
    const l = [],
      c = [],
      u = [],
      p = [];
    let N = e;
    const P = (t - e) / s,
      de = new Vector3(),
      me = new Vector2();
    for (let Ye = 0; Ye <= s; Ye++) {
      for (let nt = 0; nt <= r; nt++) {
        const Be = o + (nt / r) * a;
        (de.x = N * Math.cos(Be)),
          (de.y = N * Math.sin(Be)),
          c.push(de.x, de.y, de.z),
          u.push(0, 0, 1),
          (me.x = (de.x / t + 1) / 2),
          (me.y = (de.y / t + 1) / 2),
          p.push(me.x, me.y);
      }
      N += P;
    }
    for (let Ye = 0; Ye < s; Ye++) {
      const nt = Ye * (r + 1);
      for (let Be = 0; Be < r; Be++) {
        const ot = Be + nt,
          st = ot,
          vt = ot + r + 1,
          xt = ot + r + 2,
          St = ot + 1;
        l.push(st, vt, St), l.push(vt, xt, St);
      }
    }
    this.setIndex(l),
      this.setAttribute("position", new Float32BufferAttribute(c, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(u, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(p, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new RingGeometry(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(
    e = new Shape([
      new Vector2(0, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      s = [],
      o = [],
      a = [];
    let l = 0,
      c = 0;
    if (Array.isArray(e) === !1) u(e);
    else
      for (let p = 0; p < e.length; p++)
        u(e[p]), this.addGroup(l, c, p), (l += c), (c = 0);
    this.setIndex(r),
      this.setAttribute("position", new Float32BufferAttribute(s, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(o, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(a, 2));
    function u(p) {
      const N = s.length / 3,
        P = p.extractPoints(t);
      let de = P.shape;
      const me = P.holes;
      ShapeUtils.isClockWise(de) === !1 && (de = de.reverse());
      for (let nt = 0, Be = me.length; nt < Be; nt++) {
        const ot = me[nt];
        ShapeUtils.isClockWise(ot) === !0 && (me[nt] = ot.reverse());
      }
      const Ye = ShapeUtils.triangulateShape(de, me);
      for (let nt = 0, Be = me.length; nt < Be; nt++) {
        const ot = me[nt];
        de = de.concat(ot);
      }
      for (let nt = 0, Be = de.length; nt < Be; nt++) {
        const ot = de[nt];
        s.push(ot.x, ot.y, 0), o.push(0, 0, 1), a.push(ot.x, ot.y);
      }
      for (let nt = 0, Be = Ye.length; nt < Be; nt++) {
        const ot = Ye[nt],
          st = ot[0] + N,
          vt = ot[1] + N,
          xt = ot[2] + N;
        r.push(st, vt, xt), (c += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return toJSON(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      r.push(a);
    }
    return new ShapeGeometry(r, e.curveSegments);
  }
}
function toJSON(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const s = n[t];
      e.shapes.push(s.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class SphereGeometry extends BufferGeometry {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    s = 0,
    o = Math.PI * 2,
    a = 0,
    l = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: s,
        phiLength: o,
        thetaStart: a,
        thetaLength: l,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const c = Math.min(a + l, Math.PI);
    let u = 0;
    const p = [],
      N = new Vector3(),
      P = new Vector3(),
      de = [],
      me = [],
      Ye = [],
      nt = [];
    for (let Be = 0; Be <= r; Be++) {
      const ot = [],
        st = Be / r;
      let vt = 0;
      Be === 0 && a === 0
        ? (vt = 0.5 / t)
        : Be === r && c === Math.PI && (vt = -0.5 / t);
      for (let xt = 0; xt <= t; xt++) {
        const St = xt / t;
        (N.x = -e * Math.cos(s + St * o) * Math.sin(a + st * l)),
          (N.y = e * Math.cos(a + st * l)),
          (N.z = e * Math.sin(s + St * o) * Math.sin(a + st * l)),
          me.push(N.x, N.y, N.z),
          P.copy(N).normalize(),
          Ye.push(P.x, P.y, P.z),
          nt.push(St + vt, 1 - st),
          ot.push(u++);
      }
      p.push(ot);
    }
    for (let Be = 0; Be < r; Be++)
      for (let ot = 0; ot < t; ot++) {
        const st = p[Be][ot + 1],
          vt = p[Be][ot],
          xt = p[Be + 1][ot],
          St = p[Be + 1][ot + 1];
        (Be !== 0 || a > 0) && de.push(st, vt, St),
          (Be !== r - 1 || c < Math.PI) && de.push(vt, xt, St);
      }
    this.setIndex(de),
      this.setAttribute("position", new Float32BufferAttribute(me, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(Ye, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(nt, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new SphereGeometry(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      s = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, s, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new TetrahedronGeometry(e.radius, e.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(e = 1, t = 0.4, r = 12, s = 48, o = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: s,
        arc: o,
      }),
      (r = Math.floor(r)),
      (s = Math.floor(s));
    const a = [],
      l = [],
      c = [],
      u = [],
      p = new Vector3(),
      N = new Vector3(),
      P = new Vector3();
    for (let de = 0; de <= r; de++)
      for (let me = 0; me <= s; me++) {
        const Ye = (me / s) * o,
          nt = (de / r) * Math.PI * 2;
        (N.x = (e + t * Math.cos(nt)) * Math.cos(Ye)),
          (N.y = (e + t * Math.cos(nt)) * Math.sin(Ye)),
          (N.z = t * Math.sin(nt)),
          l.push(N.x, N.y, N.z),
          (p.x = e * Math.cos(Ye)),
          (p.y = e * Math.sin(Ye)),
          P.subVectors(N, p).normalize(),
          c.push(P.x, P.y, P.z),
          u.push(me / s),
          u.push(de / r);
      }
    for (let de = 1; de <= r; de++)
      for (let me = 1; me <= s; me++) {
        const Ye = (s + 1) * de + me - 1,
          nt = (s + 1) * (de - 1) + me - 1,
          Be = (s + 1) * (de - 1) + me,
          ot = (s + 1) * de + me;
        a.push(Ye, nt, ot), a.push(nt, Be, ot);
      }
    this.setIndex(a),
      this.setAttribute("position", new Float32BufferAttribute(l, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(c, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new TorusGeometry(
      e.radius,
      e.tube,
      e.radialSegments,
      e.tubularSegments,
      e.arc
    );
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(e = 1, t = 0.4, r = 64, s = 8, o = 2, a = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: s,
        p: o,
        q: a,
      }),
      (r = Math.floor(r)),
      (s = Math.floor(s));
    const l = [],
      c = [],
      u = [],
      p = [],
      N = new Vector3(),
      P = new Vector3(),
      de = new Vector3(),
      me = new Vector3(),
      Ye = new Vector3(),
      nt = new Vector3(),
      Be = new Vector3();
    for (let st = 0; st <= r; ++st) {
      const vt = (st / r) * o * Math.PI * 2;
      ot(vt, o, a, e, de),
        ot(vt + 0.01, o, a, e, me),
        nt.subVectors(me, de),
        Be.addVectors(me, de),
        Ye.crossVectors(nt, Be),
        Be.crossVectors(Ye, nt),
        Ye.normalize(),
        Be.normalize();
      for (let xt = 0; xt <= s; ++xt) {
        const St = (xt / s) * Math.PI * 2,
          wt = -t * Math.cos(St),
          bt = t * Math.sin(St);
        (N.x = de.x + (wt * Be.x + bt * Ye.x)),
          (N.y = de.y + (wt * Be.y + bt * Ye.y)),
          (N.z = de.z + (wt * Be.z + bt * Ye.z)),
          c.push(N.x, N.y, N.z),
          P.subVectors(N, de).normalize(),
          u.push(P.x, P.y, P.z),
          p.push(st / r),
          p.push(xt / s);
      }
    }
    for (let st = 1; st <= r; st++)
      for (let vt = 1; vt <= s; vt++) {
        const xt = (s + 1) * (st - 1) + (vt - 1),
          St = (s + 1) * st + (vt - 1),
          wt = (s + 1) * st + vt,
          bt = (s + 1) * (st - 1) + vt;
        l.push(xt, St, bt), l.push(St, wt, bt);
      }
    this.setIndex(l),
      this.setAttribute("position", new Float32BufferAttribute(c, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(u, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(p, 2));
    function ot(st, vt, xt, St, wt) {
      const bt = Math.cos(st),
        Tt = Math.sin(st),
        Ct = (xt / vt) * st,
        kt = Math.cos(Ct);
      (wt.x = St * (2 + kt) * 0.5 * bt),
        (wt.y = St * (2 + kt) * Tt * 0.5),
        (wt.z = St * Math.sin(Ct) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new TorusKnotGeometry(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(
    e = new QuadraticBezierCurve3(
      new Vector3(-1, -1, 0),
      new Vector3(-1, 1, 0),
      new Vector3(1, 1, 0)
    ),
    t = 64,
    r = 1,
    s = 8,
    o = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: s,
        closed: o,
      });
    const a = e.computeFrenetFrames(t, o);
    (this.tangents = a.tangents),
      (this.normals = a.normals),
      (this.binormals = a.binormals);
    const l = new Vector3(),
      c = new Vector3(),
      u = new Vector2();
    let p = new Vector3();
    const N = [],
      P = [],
      de = [],
      me = [];
    Ye(),
      this.setIndex(me),
      this.setAttribute("position", new Float32BufferAttribute(N, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(P, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(de, 2));
    function Ye() {
      for (let st = 0; st < t; st++) nt(st);
      nt(o === !1 ? t : 0), ot(), Be();
    }
    function nt(st) {
      p = e.getPointAt(st / t, p);
      const vt = a.normals[st],
        xt = a.binormals[st];
      for (let St = 0; St <= s; St++) {
        const wt = (St / s) * Math.PI * 2,
          bt = Math.sin(wt),
          Tt = -Math.cos(wt);
        (c.x = Tt * vt.x + bt * xt.x),
          (c.y = Tt * vt.y + bt * xt.y),
          (c.z = Tt * vt.z + bt * xt.z),
          c.normalize(),
          P.push(c.x, c.y, c.z),
          (l.x = p.x + r * c.x),
          (l.y = p.y + r * c.y),
          (l.z = p.z + r * c.z),
          N.push(l.x, l.y, l.z);
      }
    }
    function Be() {
      for (let st = 1; st <= t; st++)
        for (let vt = 1; vt <= s; vt++) {
          const xt = (s + 1) * (st - 1) + (vt - 1),
            St = (s + 1) * st + (vt - 1),
            wt = (s + 1) * st + vt,
            bt = (s + 1) * (st - 1) + vt;
          me.push(xt, St, bt), me.push(St, wt, bt);
        }
    }
    function ot() {
      for (let st = 0; st <= t; st++)
        for (let vt = 0; vt <= s; vt++)
          (u.x = st / t), (u.y = vt / s), de.push(u.x, u.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new TubeGeometry(
      new Curves[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        s = new Vector3(),
        o = new Vector3();
      if (e.index !== null) {
        const a = e.attributes.position,
          l = e.index;
        let c = e.groups;
        c.length === 0 &&
          (c = [{ start: 0, count: l.count, materialIndex: 0 }]);
        for (let u = 0, p = c.length; u < p; ++u) {
          const N = c[u],
            P = N.start,
            de = N.count;
          for (let me = P, Ye = P + de; me < Ye; me += 3)
            for (let nt = 0; nt < 3; nt++) {
              const Be = l.getX(me + nt),
                ot = l.getX(me + ((nt + 1) % 3));
              s.fromBufferAttribute(a, Be),
                o.fromBufferAttribute(a, ot),
                isUniqueEdge(s, o, r) === !0 &&
                  (t.push(s.x, s.y, s.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let l = 0, c = a.count / 3; l < c; l++)
          for (let u = 0; u < 3; u++) {
            const p = 3 * l + u,
              N = 3 * l + ((u + 1) % 3);
            s.fromBufferAttribute(a, p),
              o.fromBufferAttribute(a, N),
              isUniqueEdge(s, o, r) === !0 &&
                (t.push(s.x, s.y, s.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new Float32BufferAttribute(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function isUniqueEdge(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    s = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(s) === !0 ? !1 : (t.add(r), t.add(s), !0);
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry,
});
class ShadowMaterial extends Material {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Color(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class MeshStandardMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new Color(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Vector2(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return clamp$1((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Color(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Color(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Color(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class MeshPhongMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Color(16777215)),
      (this.specular = new Color(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshToonMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshNormalMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class MeshLambertMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Euler()),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class MeshDepthMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = BasicDepthPacking),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class MeshDistanceMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class MeshMatcapMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Color(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function convertArray(n, e) {
  return !n || n.constructor === e
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function isTypedArray(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function getKeyframeOrder(n) {
  function e(s, o) {
    return n[s] - n[o];
  }
  const t = n.length,
    r = new Array(t);
  for (let s = 0; s !== t; ++s) r[s] = s;
  return r.sort(e), r;
}
function sortedArray(n, e, t) {
  const r = n.length,
    s = new n.constructor(r);
  for (let o = 0, a = 0; a !== r; ++o) {
    const l = t[o] * e;
    for (let c = 0; c !== e; ++c) s[a++] = n[l + c];
  }
  return s;
}
function flattenJSON(n, e, t, r) {
  let s = 1,
    o = n[0];
  for (; o !== void 0 && o[r] === void 0; ) o = n[s++];
  if (o === void 0) return;
  let a = o[r];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = o[r]),
          a !== void 0 && (e.push(o.time), t.push(...a)),
          (o = n[s++]);
      while (o !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = o[r]),
          a !== void 0 && (e.push(o.time), a.toArray(t, t.length)),
          (o = n[s++]);
      while (o !== void 0);
    else
      do (a = o[r]), a !== void 0 && (e.push(o.time), t.push(a)), (o = n[s++]);
      while (o !== void 0);
}
function subclip(n, e, t, r, s = 30) {
  const o = n.clone();
  o.name = e;
  const a = [];
  for (let c = 0; c < o.tracks.length; ++c) {
    const u = o.tracks[c],
      p = u.getValueSize(),
      N = [],
      P = [];
    for (let de = 0; de < u.times.length; ++de) {
      const me = u.times[de] * s;
      if (!(me < t || me >= r)) {
        N.push(u.times[de]);
        for (let Ye = 0; Ye < p; ++Ye) P.push(u.values[de * p + Ye]);
      }
    }
    N.length !== 0 &&
      ((u.times = convertArray(N, u.times.constructor)),
      (u.values = convertArray(P, u.values.constructor)),
      a.push(u));
  }
  o.tracks = a;
  let l = 1 / 0;
  for (let c = 0; c < o.tracks.length; ++c)
    l > o.tracks[c].times[0] && (l = o.tracks[c].times[0]);
  for (let c = 0; c < o.tracks.length; ++c) o.tracks[c].shift(-1 * l);
  return o.resetDuration(), o;
}
function makeClipAdditive(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const s = t.tracks.length,
    o = e / r;
  for (let a = 0; a < s; ++a) {
    const l = t.tracks[a],
      c = l.ValueTypeName;
    if (c === "bool" || c === "string") continue;
    const u = n.tracks.find(function (Be) {
      return Be.name === l.name && Be.ValueTypeName === c;
    });
    if (u === void 0) continue;
    let p = 0;
    const N = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = N / 3);
    let P = 0;
    const de = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (P = de / 3);
    const me = l.times.length - 1;
    let Ye;
    if (o <= l.times[0]) {
      const Be = p,
        ot = N - p;
      Ye = l.values.slice(Be, ot);
    } else if (o >= l.times[me]) {
      const Be = me * N + p,
        ot = Be + N - p;
      Ye = l.values.slice(Be, ot);
    } else {
      const Be = l.createInterpolant(),
        ot = p,
        st = N - p;
      Be.evaluate(o), (Ye = Be.resultBuffer.slice(ot, st));
    }
    c === "quaternion" &&
      new Quaternion().fromArray(Ye).normalize().conjugate().toArray(Ye);
    const nt = u.times.length;
    for (let Be = 0; Be < nt; ++Be) {
      const ot = Be * de + P;
      if (c === "quaternion")
        Quaternion.multiplyQuaternionsFlat(u.values, ot, Ye, 0, u.values, ot);
      else {
        const st = de - P * 2;
        for (let vt = 0; vt < st; ++vt) u.values[ot + vt] -= Ye[vt];
      }
    }
  }
  return (n.blendMode = AdditiveAnimationBlendMode), n;
}
class AnimationUtils {
  static convertArray(e, t) {
    return convertArray(e, t);
  }
  static isTypedArray(e) {
    return isTypedArray(e);
  }
  static getKeyframeOrder(e) {
    return getKeyframeOrder(e);
  }
  static sortedArray(e, t, r) {
    return sortedArray(e, t, r);
  }
  static flattenJSON(e, t, r, s) {
    flattenJSON(e, t, r, s);
  }
  static subclip(e, t, r, s, o = 30) {
    return subclip(e, t, r, s, o);
  }
  static makeClipAdditive(e, t = 0, r = e, s = 30) {
    return makeClipAdditive(e, t, r, s);
  }
}
class Interpolant {
  constructor(e, t, r, s) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = s !== void 0 ? s : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      s = t[r],
      o = t[r - 1];
    e: {
      t: {
        let a;
        n: {
          r: if (!(e < s)) {
            for (let l = r + 2; ; ) {
              if (s === void 0) {
                if (e < o) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === l) break;
              if (((o = s), (s = t[++r]), e < s)) break t;
            }
            a = t.length;
            break n;
          }
          if (!(e >= o)) {
            const l = t[1];
            e < l && ((r = 2), (o = l));
            for (let c = r - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === c) break;
              if (((s = o), (o = t[--r - 1]), e >= o)) break t;
            }
            (a = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < a; ) {
          const l = (r + a) >>> 1;
          e < t[l] ? (a = l) : (r = l + 1);
        }
        if (((s = t[r]), (o = t[r - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (s === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, o, s);
    }
    return this.interpolate_(r, o, e, s);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      s = this.valueSize,
      o = e * s;
    for (let a = 0; a !== s; ++a) t[a] = r[o + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
  constructor(e, t, r, s) {
    super(e, t, r, s),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding,
      });
  }
  intervalChanged_(e, t, r) {
    const s = this.parameterPositions;
    let o = e - 2,
      a = e + 1,
      l = s[o],
      c = s[a];
    if (l === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          (o = e), (l = 2 * t - r);
          break;
        case WrapAroundEnding:
          (o = s.length - 2), (l = t + s[o] - s[o + 1]);
          break;
        default:
          (o = e), (l = r);
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          (a = e), (c = 2 * r - t);
          break;
        case WrapAroundEnding:
          (a = 1), (c = r + s[1] - s[0]);
          break;
        default:
          (a = e - 1), (c = t);
      }
    const u = (r - t) * 0.5,
      p = this.valueSize;
    (this._weightPrev = u / (t - l)),
      (this._weightNext = u / (c - r)),
      (this._offsetPrev = o * p),
      (this._offsetNext = a * p);
  }
  interpolate_(e, t, r, s) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = e * l,
      u = c - l,
      p = this._offsetPrev,
      N = this._offsetNext,
      P = this._weightPrev,
      de = this._weightNext,
      me = (r - t) / (s - t),
      Ye = me * me,
      nt = Ye * me,
      Be = -P * nt + 2 * P * Ye - P * me,
      ot = (1 + P) * nt + (-1.5 - 2 * P) * Ye + (-0.5 + P) * me + 1,
      st = (-1 - de) * nt + (1.5 + de) * Ye + 0.5 * me,
      vt = de * nt - de * Ye;
    for (let xt = 0; xt !== l; ++xt)
      o[xt] = Be * a[p + xt] + ot * a[u + xt] + st * a[c + xt] + vt * a[N + xt];
    return o;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
  interpolate_(e, t, r, s) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = e * l,
      u = c - l,
      p = (r - t) / (s - t),
      N = 1 - p;
    for (let P = 0; P !== l; ++P) o[P] = a[u + P] * N + a[c + P] * p;
    return o;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class KeyframeTrack {
  constructor(e, t, r, s) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = convertArray(t, this.TimeBufferType)),
      (this.values = convertArray(r, this.ValueBufferType)),
      this.setInterpolation(s || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: convertArray(e.times, Array),
        values: convertArray(e.values, Array),
      };
      const s = e.getInterpolation();
      s !== e.DefaultInterpolation && (r.interpolation = s);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new DiscreteInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
  InterpolantFactoryMethodLinear(e) {
    return new LinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
  InterpolantFactoryMethodSmooth(e) {
    return new CubicInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case InterpolateDiscrete:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, s = t.length; r !== s; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, s = t.length; r !== s; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      s = r.length;
    let o = 0,
      a = s - 1;
    for (; o !== s && r[o] < e; ) ++o;
    for (; a !== -1 && r[a] > t; ) --a;
    if ((++a, o !== 0 || a !== s)) {
      o >= a && ((a = Math.max(a, 1)), (o = a - 1));
      const l = this.getValueSize();
      (this.times = r.slice(o, a)),
        (this.values = this.values.slice(o * l, a * l));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      s = this.values,
      o = r.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let l = 0; l !== o; l++) {
      const c = r[l];
      if (typeof c == "number" && isNaN(c)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          l,
          c
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, l, c, a),
          (e = !1);
        break;
      }
      a = c;
    }
    if (s !== void 0 && isTypedArray(s))
      for (let l = 0, c = s.length; l !== c; ++l) {
        const u = s[l];
        if (isNaN(u)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            l,
            u
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.getValueSize(),
      s = this.getInterpolation() === InterpolateSmooth,
      o = e.length - 1;
    let a = 1;
    for (let l = 1; l < o; ++l) {
      let c = !1;
      const u = e[l],
        p = e[l + 1];
      if (u !== p && (l !== 1 || u !== e[0]))
        if (s) c = !0;
        else {
          const N = l * r,
            P = N - r,
            de = N + r;
          for (let me = 0; me !== r; ++me) {
            const Ye = t[N + me];
            if (Ye !== t[P + me] || Ye !== t[de + me]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (l !== a) {
          e[a] = e[l];
          const N = l * r,
            P = a * r;
          for (let de = 0; de !== r; ++de) t[P + de] = t[N + de];
        }
        ++a;
      }
    }
    if (o > 0) {
      e[a] = e[o];
      for (let l = o * r, c = a * r, u = 0; u !== r; ++u) t[c + u] = t[l + u];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = e.slice(0, a)), (this.values = t.slice(0, a * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.constructor,
      s = new r(this.name, e, t);
    return (s.createInterpolant = this.createInterpolant), s;
  }
}
KeyframeTrack.prototype.ValueTypeName = "";
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
  interpolate_(e, t, r, s) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = (r - t) / (s - t);
    let u = e * l;
    for (let p = u + l; u !== p; u += 4)
      Quaternion.slerpFlat(o, 0, a, u - l, a, u, c);
    return o;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
  InterpolantFactoryMethodLinear(e) {
    return new QuaternionLinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    );
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(e = "", t = -1, r = [], s = NormalAnimationBlendMode) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = s),
      (this.uuid = generateUUID()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      s = 1 / (e.fps || 1);
    for (let a = 0, l = r.length; a !== l; ++a)
      t.push(parseKeyframeTrack(r[a]).scale(s));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      s = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, a = r.length; o !== a; ++o)
      t.push(KeyframeTrack.toJSON(r[o]));
    return s;
  }
  static CreateFromMorphTargetSequence(e, t, r, s) {
    const o = t.length,
      a = [];
    for (let l = 0; l < o; l++) {
      let c = [],
        u = [];
      c.push((l + o - 1) % o, l, (l + 1) % o), u.push(0, 1, 0);
      const p = getKeyframeOrder(c);
      (c = sortedArray(c, 1, p)),
        (u = sortedArray(u, 1, p)),
        !s && c[0] === 0 && (c.push(o), u.push(u[0])),
        a.push(
          new NumberKeyframeTrack(
            ".morphTargetInfluences[" + t[l].name + "]",
            c,
            u
          ).scale(1 / r)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const s = e;
      r = (s.geometry && s.geometry.animations) || s.animations;
    }
    for (let s = 0; s < r.length; s++) if (r[s].name === t) return r[s];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const s = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let l = 0, c = e.length; l < c; l++) {
      const u = e[l],
        p = u.name.match(o);
      if (p && p.length > 1) {
        const N = p[1];
        let P = s[N];
        P || (s[N] = P = []), P.push(u);
      }
    }
    const a = [];
    for (const l in s)
      a.push(this.CreateFromMorphTargetSequence(l, s[l], t, r));
    return a;
  }
  static parseAnimation(e, t) {
    if (
      (console.warn(
        "THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"
      ),
      !e)
    )
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (N, P, de, me, Ye) {
        if (de.length !== 0) {
          const nt = [],
            Be = [];
          flattenJSON(de, nt, Be, me),
            nt.length !== 0 && Ye.push(new N(P, nt, Be));
        }
      },
      s = [],
      o = e.name || "default",
      a = e.fps || 30,
      l = e.blendMode;
    let c = e.length || -1;
    const u = e.hierarchy || [];
    for (let N = 0; N < u.length; N++) {
      const P = u[N].keys;
      if (!(!P || P.length === 0))
        if (P[0].morphTargets) {
          const de = {};
          let me;
          for (me = 0; me < P.length; me++)
            if (P[me].morphTargets)
              for (let Ye = 0; Ye < P[me].morphTargets.length; Ye++)
                de[P[me].morphTargets[Ye]] = -1;
          for (const Ye in de) {
            const nt = [],
              Be = [];
            for (let ot = 0; ot !== P[me].morphTargets.length; ++ot) {
              const st = P[me];
              nt.push(st.time), Be.push(st.morphTarget === Ye ? 1 : 0);
            }
            s.push(
              new NumberKeyframeTrack(
                ".morphTargetInfluence[" + Ye + "]",
                nt,
                Be
              )
            );
          }
          c = de.length * a;
        } else {
          const de = ".bones[" + t[N].name + "]";
          r(VectorKeyframeTrack, de + ".position", P, "pos", s),
            r(QuaternionKeyframeTrack, de + ".quaternion", P, "rot", s),
            r(VectorKeyframeTrack, de + ".scale", P, "scl", s);
        }
    }
    return s.length === 0 ? null : new this(o, c, s, l);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = this.tracks[r];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function parseKeyframeTrack(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = getTrackTypeForValueTypeName(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    flattenJSON(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Cache = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class LoadingManager {
  constructor(e, t, r) {
    const s = this;
    let o = !1,
      a = 0,
      l = 0,
      c;
    const u = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (p) {
        l++, o === !1 && s.onStart !== void 0 && s.onStart(p, a, l), (o = !0);
      }),
      (this.itemEnd = function (p) {
        a++,
          s.onProgress !== void 0 && s.onProgress(p, a, l),
          a === l && ((o = !1), s.onLoad !== void 0 && s.onLoad());
      }),
      (this.itemError = function (p) {
        s.onError !== void 0 && s.onError(p);
      }),
      (this.resolveURL = function (p) {
        return c ? c(p) : p;
      }),
      (this.setURLModifier = function (p) {
        return (c = p), this;
      }),
      (this.addHandler = function (p, N) {
        return u.push(p, N), this;
      }),
      (this.removeHandler = function (p) {
        const N = u.indexOf(p);
        return N !== -1 && u.splice(N, 2), this;
      }),
      (this.getHandler = function (p) {
        for (let N = 0, P = u.length; N < P; N += 2) {
          const de = u[N],
            me = u[N + 1];
          if ((de.global && (de.lastIndex = 0), de.test(p))) return me;
        }
        return null;
      });
  }
}
const DefaultLoadingManager = new LoadingManager();
let Loader$2 = class {
  constructor(e) {
    (this.manager = e !== void 0 ? e : DefaultLoadingManager),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (s, o) {
      r.load(e, s, t, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
};
Loader$2.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class FileLoader extends Loader$2 {
  constructor(e) {
    super(e), (this.mimeType = ""), (this.responseType = "");
  }
  load(e, t, r, s) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Cache.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (loading[e] !== void 0) {
      loading[e].push({ onLoad: t, onProgress: r, onError: s });
      return;
    }
    (loading[e] = []),
      loading[e].push({ onLoad: t, onProgress: r, onError: s });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      l = this.mimeType,
      c = this.responseType;
    fetch(a)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u;
          const p = loading[e],
            N = u.body.getReader(),
            P = u.headers.get("X-File-Size") || u.headers.get("Content-Length"),
            de = P ? parseInt(P) : 0,
            me = de !== 0;
          let Ye = 0;
          const nt = new ReadableStream({
            start(Be) {
              ot();
              function ot() {
                N.read().then(
                  ({ done: st, value: vt }) => {
                    if (st) Be.close();
                    else {
                      Ye += vt.byteLength;
                      const xt = new ProgressEvent("progress", {
                        lengthComputable: me,
                        loaded: Ye,
                        total: de,
                      });
                      for (let St = 0, wt = p.length; St < wt; St++) {
                        const bt = p[St];
                        bt.onProgress && bt.onProgress(xt);
                      }
                      Be.enqueue(vt), ot();
                    }
                  },
                  (st) => {
                    Be.error(st);
                  }
                );
              }
            },
          });
          return new Response(nt);
        } else
          throw new HttpError(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u
          );
      })
      .then((u) => {
        switch (c) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((p) => new DOMParser().parseFromString(p, l));
          case "json":
            return u.json();
          default:
            if (l === "") return u.text();
            {
              const N = /charset="?([^;"\s]*)"?/i.exec(l),
                P = N && N[1] ? N[1].toLowerCase() : void 0,
                de = new TextDecoder(P);
              return u.arrayBuffer().then((me) => de.decode(me));
            }
        }
      })
      .then((u) => {
        Cache.add(e, u);
        const p = loading[e];
        delete loading[e];
        for (let N = 0, P = p.length; N < P; N++) {
          const de = p[N];
          de.onLoad && de.onLoad(u);
        }
      })
      .catch((u) => {
        const p = loading[e];
        if (p === void 0) throw (this.manager.itemError(e), u);
        delete loading[e];
        for (let N = 0, P = p.length; N < P; N++) {
          const de = p[N];
          de.onError && de.onError(u);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class AnimationLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = this,
      a = new FileLoader(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (c) {
            s ? s(c) : console.error(c), o.manager.itemError(e);
          }
        },
        r,
        s
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const s = AnimationClip.parse(e[r]);
      t.push(s);
    }
    return t;
  }
}
class CompressedTextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = this,
      a = [],
      l = new CompressedTexture(),
      c = new FileLoader(this.manager);
    c.setPath(this.path),
      c.setResponseType("arraybuffer"),
      c.setRequestHeader(this.requestHeader),
      c.setWithCredentials(o.withCredentials);
    let u = 0;
    function p(N) {
      c.load(
        e[N],
        function (P) {
          const de = o.parse(P, !0);
          (a[N] = {
            width: de.width,
            height: de.height,
            format: de.format,
            mipmaps: de.mipmaps,
          }),
            (u += 1),
            u === 6 &&
              (de.mipmapCount === 1 && (l.minFilter = LinearFilter),
              (l.image = a),
              (l.format = de.format),
              (l.needsUpdate = !0),
              t && t(l));
        },
        r,
        s
      );
    }
    if (Array.isArray(e)) for (let N = 0, P = e.length; N < P; ++N) p(N);
    else
      c.load(
        e,
        function (N) {
          const P = o.parse(N, !0);
          if (P.isCubemap) {
            const de = P.mipmaps.length / P.mipmapCount;
            for (let me = 0; me < de; me++) {
              a[me] = { mipmaps: [] };
              for (let Ye = 0; Ye < P.mipmapCount; Ye++)
                a[me].mipmaps.push(P.mipmaps[me * P.mipmapCount + Ye]),
                  (a[me].format = P.format),
                  (a[me].width = P.width),
                  (a[me].height = P.height);
            }
            l.image = a;
          } else
            (l.image.width = P.width),
              (l.image.height = P.height),
              (l.mipmaps = P.mipmaps);
          P.mipmapCount === 1 && (l.minFilter = LinearFilter),
            (l.format = P.format),
            (l.needsUpdate = !0),
            t && t(l);
        },
        r,
        s
      );
    return l;
  }
}
class ImageLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      a = Cache.get(e);
    if (a !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), o.manager.itemEnd(e);
        }, 0),
        a
      );
    const l = createElementNS("img");
    function c() {
      p(), Cache.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function u(N) {
      p(), s && s(N), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function p() {
      l.removeEventListener("load", c, !1),
        l.removeEventListener("error", u, !1);
    }
    return (
      l.addEventListener("load", c, !1),
      l.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (l.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (l.src = e),
      l
    );
  }
}
class CubeTextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = new CubeTexture();
    o.colorSpace = SRGBColorSpace;
    const a = new ImageLoader(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let l = 0;
    function c(u) {
      a.load(
        e[u],
        function (p) {
          (o.images[u] = p), l++, l === 6 && ((o.needsUpdate = !0), t && t(o));
        },
        void 0,
        s
      );
    }
    for (let u = 0; u < e.length; ++u) c(u);
    return o;
  }
}
class DataTextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = this,
      a = new DataTexture(),
      l = new FileLoader(this.manager);
    return (
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setPath(this.path),
      l.setWithCredentials(o.withCredentials),
      l.load(
        e,
        function (c) {
          let u;
          try {
            u = o.parse(c);
          } catch (p) {
            if (s !== void 0) s(p);
            else {
              console.error(p);
              return;
            }
          }
          u.image !== void 0
            ? (a.image = u.image)
            : u.data !== void 0 &&
              ((a.image.width = u.width),
              (a.image.height = u.height),
              (a.image.data = u.data)),
            (a.wrapS = u.wrapS !== void 0 ? u.wrapS : ClampToEdgeWrapping),
            (a.wrapT = u.wrapT !== void 0 ? u.wrapT : ClampToEdgeWrapping),
            (a.magFilter = u.magFilter !== void 0 ? u.magFilter : LinearFilter),
            (a.minFilter = u.minFilter !== void 0 ? u.minFilter : LinearFilter),
            (a.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1),
            u.colorSpace !== void 0 && (a.colorSpace = u.colorSpace),
            u.flipY !== void 0 && (a.flipY = u.flipY),
            u.format !== void 0 && (a.format = u.format),
            u.type !== void 0 && (a.type = u.type),
            u.mipmaps !== void 0 &&
              ((a.mipmaps = u.mipmaps),
              (a.minFilter = LinearMipmapLinearFilter)),
            u.mipmapCount === 1 && (a.minFilter = LinearFilter),
            u.generateMipmaps !== void 0 &&
              (a.generateMipmaps = u.generateMipmaps),
            (a.needsUpdate = !0),
            t && t(a, u);
        },
        r,
        s
      ),
      a
    );
  }
}
class TextureLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = new Texture(),
      a = new ImageLoader(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (l) {
          (o.image = l), (o.needsUpdate = !0), t !== void 0 && t(o);
        },
        r,
        s
      ),
      o
    );
  }
}
class Light extends Object3D {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Color(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class HemisphereLight extends Light {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Color(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const _projScreenMatrix$1 = new Matrix4(),
  _lightPositionWorld$1 = new Vector3(),
  _lookTarget$1 = new Vector3();
class LightShadow {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Vector2(512, 512)),
      (this.mapType = UnsignedByteType),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Matrix4()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Frustum()),
      (this._frameExtents = new Vector2(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Vector4(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(_lightPositionWorld$1),
      _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(_lookTarget$1),
      t.updateMatrixWorld(),
      _projScreenMatrix$1.multiplyMatrices(
        t.projectionMatrix,
        t.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(_projScreenMatrix$1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      (this.autoUpdate = e.autoUpdate),
      (this.needsUpdate = e.needsUpdate),
      (this.normalBias = e.normalBias),
      (this.blurSamples = e.blurSamples),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = RAD2DEG * 2 * e.angle * this.focus,
      s = this.mapSize.width / this.mapSize.height,
      o = e.distance || t.far;
    (r !== t.fov || s !== t.aspect || o !== t.far) &&
      ((t.fov = r), (t.aspect = s), (t.far = o), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class SpotLight extends Light {
  constructor(e, t, r = 0, s = Math.PI / 3, o = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.distance = r),
      (this.angle = s),
      (this.penumbra = o),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new SpotLightShadow());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const _projScreenMatrix = new Matrix4(),
  _lightPositionWorld = new Vector3(),
  _lookTarget = new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Vector2(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      s = this.matrix,
      o = e.distance || r.far;
    o !== r.far && ((r.far = o), r.updateProjectionMatrix()),
      _lightPositionWorld.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(_lightPositionWorld),
      _lookTarget.copy(r.position),
      _lookTarget.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(_lookTarget),
      r.updateMatrixWorld(),
      s.makeTranslation(
        -_lightPositionWorld.x,
        -_lightPositionWorld.y,
        -_lightPositionWorld.z
      ),
      _projScreenMatrix.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(e, t, r = 0, s = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = s),
      (this.shadow = new PointLightShadow());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class OrthographicCamera extends Camera {
  constructor(e = -1, t = 1, r = 1, s = -1, o = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = s),
      (this.near = o),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, s, o, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = s),
      (this.view.width = o),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      s = (this.top + this.bottom) / 2;
    let o = r - e,
      a = r + e,
      l = s + t,
      c = s - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += u * this.view.offsetX),
        (a = o + u * this.view.width),
        (l -= p * this.view.offsetY),
        (c = l - p * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      o,
      a,
      l,
      c,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0);
  }
}
class DirectionalLight extends Light {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.shadow = new DirectionalLightShadow());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class AmbientLight extends Light {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class RectAreaLight extends Light {
  constructor(e, t, r = 10, s = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = s);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class SphericalHarmonics3 {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new Vector3());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      s = e.y,
      o = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.282095),
      t.addScaledVector(a[1], 0.488603 * s),
      t.addScaledVector(a[2], 0.488603 * o),
      t.addScaledVector(a[3], 0.488603 * r),
      t.addScaledVector(a[4], 1.092548 * (r * s)),
      t.addScaledVector(a[5], 1.092548 * (s * o)),
      t.addScaledVector(a[6], 0.315392 * (3 * o * o - 1)),
      t.addScaledVector(a[7], 1.092548 * (r * o)),
      t.addScaledVector(a[8], 0.546274 * (r * r - s * s)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      s = e.y,
      o = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.886227),
      t.addScaledVector(a[1], 2 * 0.511664 * s),
      t.addScaledVector(a[2], 2 * 0.511664 * o),
      t.addScaledVector(a[3], 2 * 0.511664 * r),
      t.addScaledVector(a[4], 2 * 0.429043 * r * s),
      t.addScaledVector(a[5], 2 * 0.429043 * s * o),
      t.addScaledVector(a[6], 0.743125 * o * o - 0.247708),
      t.addScaledVector(a[7], 2 * 0.429043 * r * o),
      t.addScaledVector(a[8], 0.429043 * (r * r - s * s)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let s = 0; s < 9; s++) r[s].fromArray(e, t + s * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let s = 0; s < 9; s++) r[s].toArray(e, t + s * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      s = e.y,
      o = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * s),
      (t[2] = 0.488603 * o),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * s),
      (t[5] = 1.092548 * s * o),
      (t[6] = 0.315392 * (3 * o * o - 1)),
      (t[7] = 1.092548 * r * o),
      (t[8] = 0.546274 * (r * r - s * s));
  }
}
class LightProbe extends Light {
  constructor(e = new SphericalHarmonics3(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class MaterialLoader extends Loader$2 {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, s) {
    const o = this,
      a = new FileLoader(o.manager);
    a.setPath(o.path),
      a.setRequestHeader(o.requestHeader),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (c) {
            s ? s(c) : console.error(c), o.manager.itemError(e);
          }
        },
        r,
        s
      );
  }
  parse(e) {
    const t = this.textures;
    function r(o) {
      return (
        t[o] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", o),
        t[o]
      );
    }
    const s = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (s.uuid = e.uuid),
      e.name !== void 0 && (s.name = e.name),
      e.color !== void 0 && s.color !== void 0 && s.color.setHex(e.color),
      e.roughness !== void 0 && (s.roughness = e.roughness),
      e.metalness !== void 0 && (s.metalness = e.metalness),
      e.sheen !== void 0 && (s.sheen = e.sheen),
      e.sheenColor !== void 0 &&
        (s.sheenColor = new Color().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (s.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        s.emissive !== void 0 &&
        s.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        s.specular !== void 0 &&
        s.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (s.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        s.specularColor !== void 0 &&
        s.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (s.shininess = e.shininess),
      e.clearcoat !== void 0 && (s.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (s.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (s.dispersion = e.dispersion),
      e.iridescence !== void 0 && (s.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (s.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (s.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (s.transmission = e.transmission),
      e.thickness !== void 0 && (s.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (s.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        s.attenuationColor !== void 0 &&
        s.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (s.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (s.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (s.fog = e.fog),
      e.flatShading !== void 0 && (s.flatShading = e.flatShading),
      e.blending !== void 0 && (s.blending = e.blending),
      e.combine !== void 0 && (s.combine = e.combine),
      e.side !== void 0 && (s.side = e.side),
      e.shadowSide !== void 0 && (s.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (s.opacity = e.opacity),
      e.transparent !== void 0 && (s.transparent = e.transparent),
      e.alphaTest !== void 0 && (s.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (s.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (s.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (s.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (s.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (s.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (s.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (s.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (s.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (s.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (s.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (s.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        s.blendColor !== void 0 &&
        s.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (s.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (s.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (s.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (s.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (s.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (s.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (s.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (s.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (s.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (s.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (s.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (s.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (s.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (s.rotation = e.rotation),
      e.linewidth !== void 0 && (s.linewidth = e.linewidth),
      e.dashSize !== void 0 && (s.dashSize = e.dashSize),
      e.gapSize !== void 0 && (s.gapSize = e.gapSize),
      e.scale !== void 0 && (s.scale = e.scale),
      e.polygonOffset !== void 0 && (s.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (s.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (s.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (s.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (s.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (s.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (s.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (s.visible = e.visible),
      e.toneMapped !== void 0 && (s.toneMapped = e.toneMapped),
      e.userData !== void 0 && (s.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (s.vertexColors = e.vertexColors > 0)
          : (s.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const a = e.uniforms[o];
        switch (((s.uniforms[o] = {}), a.type)) {
          case "t":
            s.uniforms[o].value = r(a.value);
            break;
          case "c":
            s.uniforms[o].value = new Color().setHex(a.value);
            break;
          case "v2":
            s.uniforms[o].value = new Vector2().fromArray(a.value);
            break;
          case "v3":
            s.uniforms[o].value = new Vector3().fromArray(a.value);
            break;
          case "v4":
            s.uniforms[o].value = new Vector4().fromArray(a.value);
            break;
          case "m3":
            s.uniforms[o].value = new Matrix3().fromArray(a.value);
            break;
          case "m4":
            s.uniforms[o].value = new Matrix4().fromArray(a.value);
            break;
          default:
            s.uniforms[o].value = a.value;
        }
      }
    if (
      (e.defines !== void 0 && (s.defines = e.defines),
      e.vertexShader !== void 0 && (s.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (s.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (s.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) s.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (s.lights = e.lights),
      e.clipping !== void 0 && (s.clipping = e.clipping),
      e.size !== void 0 && (s.size = e.size),
      e.sizeAttenuation !== void 0 && (s.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (s.map = r(e.map)),
      e.matcap !== void 0 && (s.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (s.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (s.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (s.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (s.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (s.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]),
        (s.normalScale = new Vector2().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 &&
        (s.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (s.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (s.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (s.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (s.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (s.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (s.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (s.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (s.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (s.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (s.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        s.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (s.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (s.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (s.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (s.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (s.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (s.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (s.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (s.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (s.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (s.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (s.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (s.clearcoatNormalScale = new Vector2().fromArray(
          e.clearcoatNormalScale
        )),
      e.iridescenceMap !== void 0 && (s.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (s.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (s.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (s.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (s.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (s.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (s.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      s
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  createMaterialFromType(e) {
    return MaterialLoader.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material,
    };
    return new t[e]();
  }
}
class LoaderUtils {
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class BufferGeometryLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = this,
      a = new FileLoader(o.manager);
    a.setPath(o.path),
      a.setRequestHeader(o.requestHeader),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(o.parse(JSON.parse(l)));
          } catch (c) {
            s ? s(c) : console.error(c), o.manager.itemError(e);
          }
        },
        r,
        s
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function s(de, me) {
      if (t[me] !== void 0) return t[me];
      const nt = de.interleavedBuffers[me],
        Be = o(de, nt.buffer),
        ot = getTypedArray(nt.type, Be),
        st = new InterleavedBuffer(ot, nt.stride);
      return (st.uuid = nt.uuid), (t[me] = st), st;
    }
    function o(de, me) {
      if (r[me] !== void 0) return r[me];
      const nt = de.arrayBuffers[me],
        Be = new Uint32Array(nt).buffer;
      return (r[me] = Be), Be;
    }
    const a = e.isInstancedBufferGeometry
        ? new InstancedBufferGeometry()
        : new BufferGeometry(),
      l = e.data.index;
    if (l !== void 0) {
      const de = getTypedArray(l.type, l.array);
      a.setIndex(new BufferAttribute(de, 1));
    }
    const c = e.data.attributes;
    for (const de in c) {
      const me = c[de];
      let Ye;
      if (me.isInterleavedBufferAttribute) {
        const nt = s(e.data, me.data);
        Ye = new InterleavedBufferAttribute(
          nt,
          me.itemSize,
          me.offset,
          me.normalized
        );
      } else {
        const nt = getTypedArray(me.type, me.array),
          Be = me.isInstancedBufferAttribute
            ? InstancedBufferAttribute
            : BufferAttribute;
        Ye = new Be(nt, me.itemSize, me.normalized);
      }
      me.name !== void 0 && (Ye.name = me.name),
        me.usage !== void 0 && Ye.setUsage(me.usage),
        a.setAttribute(de, Ye);
    }
    const u = e.data.morphAttributes;
    if (u)
      for (const de in u) {
        const me = u[de],
          Ye = [];
        for (let nt = 0, Be = me.length; nt < Be; nt++) {
          const ot = me[nt];
          let st;
          if (ot.isInterleavedBufferAttribute) {
            const vt = s(e.data, ot.data);
            st = new InterleavedBufferAttribute(
              vt,
              ot.itemSize,
              ot.offset,
              ot.normalized
            );
          } else {
            const vt = getTypedArray(ot.type, ot.array);
            st = new BufferAttribute(vt, ot.itemSize, ot.normalized);
          }
          ot.name !== void 0 && (st.name = ot.name), Ye.push(st);
        }
        a.morphAttributes[de] = Ye;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const N = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (N !== void 0)
      for (let de = 0, me = N.length; de !== me; ++de) {
        const Ye = N[de];
        a.addGroup(Ye.start, Ye.count, Ye.materialIndex);
      }
    const P = e.data.boundingSphere;
    if (P !== void 0) {
      const de = new Vector3();
      P.center !== void 0 && de.fromArray(P.center),
        (a.boundingSphere = new Sphere(de, P.radius));
    }
    return (
      e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
    );
  }
}
class ObjectLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = this,
      a = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const l = new FileLoader(this.manager);
    l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          let u = null;
          try {
            u = JSON.parse(c);
          } catch (N) {
            s !== void 0 && s(N),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                N.message
              );
            return;
          }
          const p = u.metadata;
          if (
            p === void 0 ||
            p.type === void 0 ||
            p.type.toLowerCase() === "geometry"
          ) {
            s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(u, t);
        },
        r,
        s
      );
  }
  async loadAsync(e, t) {
    const r = this,
      s = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const o = new FileLoader(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const a = await o.loadAsync(e, t),
      l = JSON.parse(a),
      c = l.metadata;
    if (
      c === void 0 ||
      c.type === void 0 ||
      c.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(l);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      s = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, s),
      a = this.parseImages(e.images, function () {
        t !== void 0 && t(u);
      }),
      l = this.parseTextures(e.textures, a),
      c = this.parseMaterials(e.materials, l),
      u = this.parseObject(e.object, o, c, l, r),
      p = this.parseSkeletons(e.skeletons, u);
    if ((this.bindSkeletons(u, p), this.bindLightTargets(u), t !== void 0)) {
      let N = !1;
      for (const P in a)
        if (a[P].data instanceof HTMLImageElement) {
          N = !0;
          break;
        }
      N === !1 && t(u);
    }
    return u;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = await this.parseImagesAsync(e.images),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, s, l, a, t),
      u = this.parseSkeletons(e.skeletons, c);
    return this.bindSkeletons(c, u), this.bindLightTargets(c), c;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, s = e.length; r < s; r++) {
        const o = new Shape().fromJSON(e[r]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      s = {};
    if (
      (t.traverse(function (o) {
        o.isBone && (s[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, a = e.length; o < a; o++) {
        const l = new Skeleton().fromJSON(e[o], s);
        r[l.uuid] = l;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const s = new BufferGeometryLoader();
      for (let o = 0, a = e.length; o < a; o++) {
        let l;
        const c = e[o];
        switch (c.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            l = s.parse(c);
            break;
          default:
            c.type in Geometries
              ? (l = Geometries[c.type].fromJSON(c, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${c.type}"`
                );
        }
        (l.uuid = c.uuid),
          c.name !== void 0 && (l.name = c.name),
          c.userData !== void 0 && (l.userData = c.userData),
          (r[c.uuid] = l);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      s = {};
    if (e !== void 0) {
      const o = new MaterialLoader();
      o.setTextures(t);
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a];
        r[c.uuid] === void 0 && (r[c.uuid] = o.parse(c)),
          (s[c.uuid] = r[c.uuid]);
      }
    }
    return s;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const s = e[r],
          o = AnimationClip.parse(s);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      s = {};
    let o;
    function a(c) {
      return (
        r.manager.itemStart(c),
        o.load(
          c,
          function () {
            r.manager.itemEnd(c);
          },
          void 0,
          function () {
            r.manager.itemError(c), r.manager.itemEnd(c);
          }
        )
      );
    }
    function l(c) {
      if (typeof c == "string") {
        const u = c,
          p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u;
        return a(p);
      } else
        return c.data
          ? {
              data: getTypedArray(c.type, c.data),
              width: c.width,
              height: c.height,
            }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const c = new LoadingManager(t);
      (o = new ImageLoader(c)), o.setCrossOrigin(this.crossOrigin);
      for (let u = 0, p = e.length; u < p; u++) {
        const N = e[u],
          P = N.url;
        if (Array.isArray(P)) {
          const de = [];
          for (let me = 0, Ye = P.length; me < Ye; me++) {
            const nt = P[me],
              Be = l(nt);
            Be !== null &&
              (Be instanceof HTMLImageElement
                ? de.push(Be)
                : de.push(new DataTexture(Be.data, Be.width, Be.height)));
          }
          s[N.uuid] = new Source(de);
        } else {
          const de = l(N.url);
          s[N.uuid] = new Source(de);
        }
      }
    }
    return s;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let s;
    async function o(a) {
      if (typeof a == "string") {
        const l = a,
          c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
        return await s.loadAsync(c);
      } else
        return a.data
          ? {
              data: getTypedArray(a.type, a.data),
              width: a.width,
              height: a.height,
            }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (s = new ImageLoader(this.manager)), s.setCrossOrigin(this.crossOrigin);
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a],
          u = c.url;
        if (Array.isArray(u)) {
          const p = [];
          for (let N = 0, P = u.length; N < P; N++) {
            const de = u[N],
              me = await o(de);
            me !== null &&
              (me instanceof HTMLImageElement
                ? p.push(me)
                : p.push(new DataTexture(me.data, me.width, me.height)));
          }
          r[c.uuid] = new Source(p);
        } else {
          const p = await o(c.url);
          r[c.uuid] = new Source(p);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(o, a) {
      return typeof o == "number"
        ? o
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            o
          ),
          a[o]);
    }
    const s = {};
    if (e !== void 0)
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        l.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
          t[l.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", l.image);
        const c = t[l.image],
          u = c.data;
        let p;
        Array.isArray(u)
          ? ((p = new CubeTexture()), u.length === 6 && (p.needsUpdate = !0))
          : (u && u.data ? (p = new DataTexture()) : (p = new Texture()),
            u && (p.needsUpdate = !0)),
          (p.source = c),
          (p.uuid = l.uuid),
          l.name !== void 0 && (p.name = l.name),
          l.mapping !== void 0 && (p.mapping = r(l.mapping, TEXTURE_MAPPING)),
          l.channel !== void 0 && (p.channel = l.channel),
          l.offset !== void 0 && p.offset.fromArray(l.offset),
          l.repeat !== void 0 && p.repeat.fromArray(l.repeat),
          l.center !== void 0 && p.center.fromArray(l.center),
          l.rotation !== void 0 && (p.rotation = l.rotation),
          l.wrap !== void 0 &&
            ((p.wrapS = r(l.wrap[0], TEXTURE_WRAPPING)),
            (p.wrapT = r(l.wrap[1], TEXTURE_WRAPPING))),
          l.format !== void 0 && (p.format = l.format),
          l.internalFormat !== void 0 && (p.internalFormat = l.internalFormat),
          l.type !== void 0 && (p.type = l.type),
          l.colorSpace !== void 0 && (p.colorSpace = l.colorSpace),
          l.minFilter !== void 0 &&
            (p.minFilter = r(l.minFilter, TEXTURE_FILTER)),
          l.magFilter !== void 0 &&
            (p.magFilter = r(l.magFilter, TEXTURE_FILTER)),
          l.anisotropy !== void 0 && (p.anisotropy = l.anisotropy),
          l.flipY !== void 0 && (p.flipY = l.flipY),
          l.generateMipmaps !== void 0 &&
            (p.generateMipmaps = l.generateMipmaps),
          l.premultiplyAlpha !== void 0 &&
            (p.premultiplyAlpha = l.premultiplyAlpha),
          l.unpackAlignment !== void 0 &&
            (p.unpackAlignment = l.unpackAlignment),
          l.compareFunction !== void 0 &&
            (p.compareFunction = l.compareFunction),
          l.userData !== void 0 && (p.userData = l.userData),
          (s[l.uuid] = p);
      }
    return s;
  }
  parseObject(e, t, r, s, o) {
    let a;
    function l(P) {
      return (
        t[P] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", P),
        t[P]
      );
    }
    function c(P) {
      if (P !== void 0) {
        if (Array.isArray(P)) {
          const de = [];
          for (let me = 0, Ye = P.length; me < Ye; me++) {
            const nt = P[me];
            r[nt] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", nt),
              de.push(r[nt]);
          }
          return de;
        }
        return (
          r[P] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", P),
          r[P]
        );
      }
    }
    function u(P) {
      return (
        s[P] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", P),
        s[P]
      );
    }
    let p, N;
    switch (e.type) {
      case "Scene":
        (a = new Scene()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (a.background = new Color(e.background))
              : (a.background = u(e.background))),
          e.environment !== void 0 && (a.environment = u(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (a.fog = new Fog(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (a.fog = new FogExp2(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (a.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (a.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (a.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            a.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (a.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            a.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (a = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (a.focus = e.focus),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (a = new OrthographicCamera(
          e.left,
          e.right,
          e.top,
          e.bottom,
          e.near,
          e.far
        )),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new AmbientLight(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (a = new DirectionalLight(e.color, e.intensity)),
          (a.target = e.target || "");
        break;
      case "PointLight":
        a = new PointLight(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new RectAreaLight(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (a = new SpotLight(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (a.target = e.target || "");
        break;
      case "HemisphereLight":
        a = new HemisphereLight(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new LightProbe().fromJSON(e);
        break;
      case "SkinnedMesh":
        (p = l(e.geometry)),
          (N = c(e.material)),
          (a = new SkinnedMesh(p, N)),
          e.bindMode !== void 0 && (a.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        (p = l(e.geometry)), (N = c(e.material)), (a = new Mesh(p, N));
        break;
      case "InstancedMesh":
        (p = l(e.geometry)), (N = c(e.material));
        const P = e.count,
          de = e.instanceMatrix,
          me = e.instanceColor;
        (a = new InstancedMesh(p, N, P)),
          (a.instanceMatrix = new InstancedBufferAttribute(
            new Float32Array(de.array),
            16
          )),
          me !== void 0 &&
            (a.instanceColor = new InstancedBufferAttribute(
              new Float32Array(me.array),
              me.itemSize
            ));
        break;
      case "BatchedMesh":
        (p = l(e.geometry)),
          (N = c(e.material)),
          (a = new BatchedMesh(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            N
          )),
          (a.geometry = p),
          (a.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (a.sortObjects = e.sortObjects),
          (a._drawRanges = e.drawRanges),
          (a._reservedRanges = e.reservedRanges),
          (a._geometryInfo = e.geometryInfo.map((Ye) => {
            let nt = null,
              Be = null;
            return (
              Ye.boundingBox !== void 0 &&
                ((nt = new Box3()),
                nt.min.fromArray(Ye.boundingBox.min),
                nt.max.fromArray(Ye.boundingBox.max)),
              Ye.boundingSphere !== void 0 &&
                ((Be = new Sphere()),
                (Be.radius = Ye.boundingSphere.radius),
                Be.center.fromArray(Ye.boundingSphere.center)),
              { ...Ye, boundingBox: nt, boundingSphere: Be }
            );
          })),
          (a._instanceInfo = e.instanceInfo),
          (a._availableInstanceIds = e._availableInstanceIds),
          (a._availableGeometryIds = e._availableGeometryIds),
          (a._nextIndexStart = e.nextIndexStart),
          (a._nextVertexStart = e.nextVertexStart),
          (a._geometryCount = e.geometryCount),
          (a._maxInstanceCount = e.maxInstanceCount),
          (a._maxVertexCount = e.maxVertexCount),
          (a._maxIndexCount = e.maxIndexCount),
          (a._geometryInitialized = e.geometryInitialized),
          (a._matricesTexture = u(e.matricesTexture.uuid)),
          (a._indirectTexture = u(e.indirectTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (a._colorsTexture = u(e.colorsTexture.uuid)),
          e.boundingSphere !== void 0 &&
            ((a.boundingSphere = new Sphere()),
            a.boundingSphere.center.fromArray(e.boundingSphere.center),
            (a.boundingSphere.radius = e.boundingSphere.radius)),
          e.boundingBox !== void 0 &&
            ((a.boundingBox = new Box3()),
            a.boundingBox.min.fromArray(e.boundingBox.min),
            a.boundingBox.max.fromArray(e.boundingBox.max));
        break;
      case "LOD":
        a = new LOD();
        break;
      case "Line":
        a = new Line(l(e.geometry), c(e.material));
        break;
      case "LineLoop":
        a = new LineLoop(l(e.geometry), c(e.material));
        break;
      case "LineSegments":
        a = new LineSegments(l(e.geometry), c(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new Points(l(e.geometry), c(e.material));
        break;
      case "Sprite":
        a = new Sprite(c(e.material));
        break;
      case "Group":
        a = new Group();
        break;
      case "Bone":
        a = new Bone();
        break;
      default:
        a = new Object3D();
    }
    if (
      ((a.uuid = e.uuid),
      e.name !== void 0 && (a.name = e.name),
      e.matrix !== void 0
        ? (a.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (a.matrixAutoUpdate = e.matrixAutoUpdate),
          a.matrixAutoUpdate &&
            a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (e.position !== void 0 && a.position.fromArray(e.position),
          e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && a.scale.fromArray(e.scale)),
      e.up !== void 0 && a.up.fromArray(e.up),
      e.castShadow !== void 0 && (a.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (a.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (a.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          a.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (a.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (a.visible = e.visible),
      e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
      e.userData !== void 0 && (a.userData = e.userData),
      e.layers !== void 0 && (a.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const P = e.children;
      for (let de = 0; de < P.length; de++)
        a.add(this.parseObject(P[de], t, r, s, o));
    }
    if (e.animations !== void 0) {
      const P = e.animations;
      for (let de = 0; de < P.length; de++) {
        const me = P[de];
        a.animations.push(o[me]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const P = e.levels;
      for (let de = 0; de < P.length; de++) {
        const me = P[de],
          Ye = a.getObjectByProperty("uuid", me.object);
        Ye !== void 0 && a.addLevel(Ye, me.distance, me.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const s = t[r.skeleton];
          s === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(s, r.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const r = t.target,
          s = e.getObjectByProperty("uuid", r);
        s !== void 0 ? (t.target = s) : (t.target = new Object3D());
      }
    });
  }
}
const TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    CubeUVReflectionMapping,
  },
  TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping,
  },
  TEXTURE_FILTER = {
    NearestFilter,
    NearestMipmapNearestFilter,
    NearestMipmapLinearFilter,
    LinearFilter,
    LinearMipmapNearestFilter,
    LinearMipmapLinearFilter,
  };
class ImageBitmapLoader extends Loader$2 {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, s) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      a = Cache.get(e);
    if (a !== void 0) {
      if ((o.manager.itemStart(e), a.then)) {
        a.then((u) => {
          t && t(u), o.manager.itemEnd(e);
        }).catch((u) => {
          s && s(u);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(a), o.manager.itemEnd(e);
        }, 0),
        a
      );
    }
    const l = {};
    (l.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (l.headers = this.requestHeader);
    const c = fetch(e, l)
      .then(function (u) {
        return u.blob();
      })
      .then(function (u) {
        return createImageBitmap(
          u,
          Object.assign(o.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (u) {
        return Cache.add(e, u), t && t(u), o.manager.itemEnd(e), u;
      })
      .catch(function (u) {
        s && s(u),
          Cache.remove(e),
          o.manager.itemError(e),
          o.manager.itemEnd(e);
      });
    Cache.add(e, c), o.manager.itemStart(e);
  }
}
let _context$3;
class AudioContext {
  static getContext() {
    return (
      _context$3 === void 0 &&
        (_context$3 = new (window.AudioContext || window.webkitAudioContext)()),
      _context$3
    );
  }
  static setContext(e) {
    _context$3 = e;
  }
}
class AudioLoader extends Loader$2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, s) {
    const o = this,
      a = new FileLoader(this.manager);
    a.setResponseType("arraybuffer"),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (c) {
          try {
            const u = c.slice(0);
            AudioContext.getContext()
              .decodeAudioData(u, function (N) {
                t(N);
              })
              .catch(l);
          } catch (u) {
            l(u);
          }
        },
        r,
        s
      );
    function l(c) {
      s ? s(c) : console.error(c), o.manager.itemError(e);
    }
  }
}
const _eyeRight = new Matrix4(),
  _eyeLeft = new Matrix4(),
  _projectionMatrix = new Matrix4();
class StereoCamera {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new PerspectiveCamera()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new PerspectiveCamera()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        _projectionMatrix.copy(e.projectionMatrix);
      const s = t.eyeSep / 2,
        o = (s * t.near) / t.focus,
        a = (t.near * Math.tan(DEG2RAD * t.fov * 0.5)) / t.zoom;
      let l, c;
      (_eyeLeft.elements[12] = -s),
        (_eyeRight.elements[12] = s),
        (l = -a * t.aspect + o),
        (c = a * t.aspect + o),
        (_projectionMatrix.elements[0] = (2 * t.near) / (c - l)),
        (_projectionMatrix.elements[8] = (c + l) / (c - l)),
        this.cameraL.projectionMatrix.copy(_projectionMatrix),
        (l = -a * t.aspect - o),
        (c = a * t.aspect - o),
        (_projectionMatrix.elements[0] = (2 * t.near) / (c - l)),
        (_projectionMatrix.elements[8] = (c + l) / (c - l)),
        this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight);
  }
}
class ArrayCamera extends PerspectiveCamera {
  constructor(e = []) {
    super(),
      (this.isArrayCamera = !0),
      (this.isMultiViewCamera = !1),
      (this.cameras = e);
  }
}
class Clock {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = now();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function now() {
  return performance.now();
}
const _position$1 = new Vector3(),
  _quaternion$1 = new Quaternion(),
  _scale$1 = new Vector3(),
  _orientation$1 = new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = AudioContext.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Clock());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
      t.positionX)
    ) {
      const s = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(_position$1.x, s),
        t.positionY.linearRampToValueAtTime(_position$1.y, s),
        t.positionZ.linearRampToValueAtTime(_position$1.z, s),
        t.forwardX.linearRampToValueAtTime(_orientation$1.x, s),
        t.forwardY.linearRampToValueAtTime(_orientation$1.y, s),
        t.forwardZ.linearRampToValueAtTime(_orientation$1.z, s),
        t.upX.linearRampToValueAtTime(r.x, s),
        t.upY.linearRampToValueAtTime(r.y, s),
        t.upZ.linearRampToValueAtTime(r.z, s);
    } else
      t.setPosition(_position$1.x, _position$1.y, _position$1.z),
        t.setOrientation(
          _orientation$1.x,
          _orientation$1.y,
          _orientation$1.z,
          r.x,
          r.y,
          r.z
        );
  }
}
class Audio extends Object3D {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== "buffer"
        ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
          this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const _position = new Vector3(),
  _quaternion$5 = new Quaternion(),
  _scale = new Vector3(),
  _orientation = new Vector3();
class PositionalAudio extends Audio {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(_position, _quaternion$5, _scale),
      _orientation.set(0, 0, 1).applyQuaternion(_quaternion$5);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(_position.x, r),
        t.positionY.linearRampToValueAtTime(_position.y, r),
        t.positionZ.linearRampToValueAtTime(_position.z, r),
        t.orientationX.linearRampToValueAtTime(_orientation.x, r),
        t.orientationY.linearRampToValueAtTime(_orientation.y, r),
        t.orientationZ.linearRampToValueAtTime(_orientation.z, r);
    } else
      t.setPosition(_position.x, _position.y, _position.z),
        t.setOrientation(_orientation.x, _orientation.y, _orientation.z);
  }
}
class AudioAnalyser {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class PropertyMixer {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let s, o, a;
    switch (t) {
      case "quaternion":
        (s = this._slerp),
          (o = this._slerpAdditive),
          (a = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (s = this._select),
          (o = this._select),
          (a = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (s = this._lerp),
          (o = this._lerpAdditive),
          (a = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = s),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = a),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      s = this.valueSize,
      o = e * s + s;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let l = 0; l !== s; ++l) r[o + l] = r[l];
      a = t;
    } else {
      a += t;
      const l = t / a;
      this._mixBufferRegion(r, o, 0, l, s);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      s = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, s, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      s = e * t + t,
      o = this.cumulativeWeight,
      a = this.cumulativeWeightAdditive,
      l = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)
    ) {
      const c = t * this._origIndex;
      this._mixBufferRegion(r, s, c, 1 - o, t);
    }
    a > 0 && this._mixBufferRegionAdditive(r, s, this._addIndex * t, 1, t);
    for (let c = t, u = t + t; c !== u; ++c)
      if (r[c] !== r[c + t]) {
        l.setValue(r, s);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      s = r * this._origIndex;
    e.getValue(t, s);
    for (let o = r, a = s; o !== a; ++o) t[o] = t[s + (o % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, s, o) {
    if (s >= 0.5) for (let a = 0; a !== o; ++a) e[t + a] = e[r + a];
  }
  _slerp(e, t, r, s) {
    Quaternion.slerpFlat(e, t, e, t, e, r, s);
  }
  _slerpAdditive(e, t, r, s, o) {
    const a = this._workIndex * o;
    Quaternion.multiplyQuaternionsFlat(e, a, e, t, e, r),
      Quaternion.slerpFlat(e, t, e, t, e, a, s);
  }
  _lerp(e, t, r, s, o) {
    const a = 1 - s;
    for (let l = 0; l !== o; ++l) {
      const c = t + l;
      e[c] = e[c] * a + e[r + l] * s;
    }
  }
  _lerpAdditive(e, t, r, s, o) {
    for (let a = 0; a !== o; ++a) {
      const l = t + a;
      e[l] = e[l] + e[r + a] * s;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/",
  _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"),
  _wordChar = "[^" + _RESERVED_CHARS_RE + "]",
  _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]",
  _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar),
  _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot),
  _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar),
  _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar),
  _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  ),
  _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(e, t, r) {
    const s = r || PropertyBinding.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, s));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      s = this._bindings[r];
    s !== void 0 && s.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let s = this._targetGroup.nCachedObjects_, o = r.length; s !== o; ++s)
      r[s].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class PropertyBinding {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || PropertyBinding.parseTrackName(t)),
      (this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new PropertyBinding.Composite(e, t, r)
      : new PropertyBinding(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(e) {
    const t = _trackRe.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      s = r.nodeName && r.nodeName.lastIndexOf(".");
    if (s !== void 0 && s !== -1) {
      const o = r.nodeName.substring(s + 1);
      _supportedObjectNames.indexOf(o) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, s)), (r.objectName = o));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (o) {
          for (let a = 0; a < o.length; a++) {
            const l = o[a];
            if (l.name === t || l.uuid === t) return l;
            const c = r(l.children);
            if (c) return c;
          }
          return null;
        },
        s = r(e.children);
      if (s) return s;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let s = 0, o = r.length; s !== o; ++s) e[t++] = r[s];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let s = 0, o = r.length; s !== o; ++s) r[s] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let s = 0, o = r.length; s !== o; ++s) r[s] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let s = 0, o = r.length; s !== o; ++s) r[s] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      s = t.propertyName;
    let o = t.propertyIndex;
    if (
      (e ||
        ((e = PropertyBinding.findNode(this.rootNode, t.nodeName)),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let u = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let p = 0; p < e.length; p++)
            if (e[p].name === u) {
              u = p;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[u];
      }
    }
    const a = e[s];
    if (a === void 0) {
      const u = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          u +
          "." +
          s +
          " but it wasn't found.",
        e
      );
      return;
    }
    let l = this.Versioning.None;
    (this.targetObject = e),
      e.isMaterial === !0
        ? (l = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (l = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (o !== void 0) {
      if (s === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (c = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = o);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((c = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((c = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = s);
    (this.getValue = this.GetterByBindingType[c]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[c][l]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray,
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class AnimationObjectGroup {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = generateUUID()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, s = arguments.length; r !== s; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      s = this._parsedPaths,
      o = this._bindings,
      a = o.length;
    let l,
      c = e.length,
      u = this.nCachedObjects_;
    for (let p = 0, N = arguments.length; p !== N; ++p) {
      const P = arguments[p],
        de = P.uuid;
      let me = t[de];
      if (me === void 0) {
        (me = c++), (t[de] = me), e.push(P);
        for (let Ye = 0, nt = a; Ye !== nt; ++Ye)
          o[Ye].push(new PropertyBinding(P, r[Ye], s[Ye]));
      } else if (me < u) {
        l = e[me];
        const Ye = --u,
          nt = e[Ye];
        (t[nt.uuid] = me), (e[me] = nt), (t[de] = Ye), (e[Ye] = P);
        for (let Be = 0, ot = a; Be !== ot; ++Be) {
          const st = o[Be],
            vt = st[Ye];
          let xt = st[me];
          (st[me] = vt),
            xt === void 0 && (xt = new PropertyBinding(P, r[Be], s[Be])),
            (st[Ye] = xt);
        }
      } else
        e[me] !== l &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = u;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      s = r.length;
    let o = this.nCachedObjects_;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a],
        u = c.uuid,
        p = t[u];
      if (p !== void 0 && p >= o) {
        const N = o++,
          P = e[N];
        (t[P.uuid] = p), (e[p] = P), (t[u] = N), (e[N] = c);
        for (let de = 0, me = s; de !== me; ++de) {
          const Ye = r[de],
            nt = Ye[N],
            Be = Ye[p];
          (Ye[p] = nt), (Ye[N] = Be);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      s = r.length;
    let o = this.nCachedObjects_,
      a = e.length;
    for (let l = 0, c = arguments.length; l !== c; ++l) {
      const u = arguments[l],
        p = u.uuid,
        N = t[p];
      if (N !== void 0)
        if ((delete t[p], N < o)) {
          const P = --o,
            de = e[P],
            me = --a,
            Ye = e[me];
          (t[de.uuid] = N), (e[N] = de), (t[Ye.uuid] = P), (e[P] = Ye), e.pop();
          for (let nt = 0, Be = s; nt !== Be; ++nt) {
            const ot = r[nt],
              st = ot[P],
              vt = ot[me];
            (ot[N] = st), (ot[P] = vt), ot.pop();
          }
        } else {
          const P = --a,
            de = e[P];
          P > 0 && (t[de.uuid] = N), (e[N] = de), e.pop();
          for (let me = 0, Ye = s; me !== Ye; ++me) {
            const nt = r[me];
            (nt[N] = nt[P]), nt.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let s = r[e];
    const o = this._bindings;
    if (s !== void 0) return o[s];
    const a = this._paths,
      l = this._parsedPaths,
      c = this._objects,
      u = c.length,
      p = this.nCachedObjects_,
      N = new Array(u);
    (s = o.length), (r[e] = s), a.push(e), l.push(t), o.push(N);
    for (let P = p, de = c.length; P !== de; ++P) {
      const me = c[P];
      N[P] = new PropertyBinding(me, e, t);
    }
    return N;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const s = this._paths,
        o = this._parsedPaths,
        a = this._bindings,
        l = a.length - 1,
        c = a[l],
        u = e[l];
      (t[u] = r),
        (a[r] = c),
        a.pop(),
        (o[r] = o[l]),
        o.pop(),
        (s[r] = s[l]),
        s.pop();
    }
  }
}
class AnimationAction {
  constructor(e, t, r = null, s = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = s);
    const o = t.tracks,
      a = o.length,
      l = new Array(a),
      c = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
    for (let u = 0; u !== a; ++u) {
      const p = o[u].createInterpolant(null);
      (l[u] = p), (p.settings = c);
    }
    (this._interpolantSettings = c),
      (this._interpolants = l),
      (this._propertyBindings = new Array(a)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = LoopRepeat),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r = !1) {
    if ((e.fadeOut(t), this.fadeIn(t), r === !0)) {
      const s = this._clip.duration,
        o = e._clip.duration,
        a = o / s,
        l = s / o;
      e.warp(1, a, t), this.warp(l, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r = !1) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const s = this._mixer,
      o = s.time,
      a = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null &&
      ((l = s._lendControlInterpolant()), (this._timeScaleInterpolant = l));
    const c = l.parameterPositions,
      u = l.sampleValues;
    return (c[0] = o), (c[1] = o + r), (u[0] = e / a), (u[1] = t / a), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, s) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const c = (e - o) * r;
      c < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * c));
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t),
      l = this._updateWeight(e);
    if (l > 0) {
      const c = this._interpolants,
        u = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let p = 0, N = c.length; p !== N; ++p)
            c[p].evaluate(a), u[p].accumulateAdditive(l);
          break;
        case NormalAnimationBlendMode:
        default:
          for (let p = 0, N = c.length; p !== N; ++p)
            c[p].evaluate(a), u[p].accumulate(s, l);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const s = r.evaluate(e)[0];
        (t *= s),
          e > r.parameterPositions[1] &&
            (this.stopFading(), s === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const s = r.evaluate(e)[0];
        (t *= s),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let s = this.time + e,
      o = this._loopCount;
    const a = r === LoopPingPong;
    if (e === 0) return o === -1 ? s : a && (o & 1) === 1 ? t - s : s;
    if (r === LoopOnce) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (s >= t) s = t;
        else if (s < 0) s = 0;
        else {
          this.time = s;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = s),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, a))
            : this._setEndings(this.repetitions === 0, !0, a)),
        s >= t || s < 0)
      ) {
        const l = Math.floor(s / t);
        (s -= t * l), (o += Math.abs(l));
        const c = this.repetitions - o;
        if (c <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (s = e > 0 ? t : 0),
            (this.time = s),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (c === 1) {
            const u = e < 0;
            this._setEndings(u, !u, a);
          } else this._setEndings(!1, !1, a);
          (this._loopCount = o),
            (this.time = s),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: l,
            });
        }
      } else this.time = s;
      if (a && (o & 1) === 1) return t - s;
    }
    return s;
  }
  _setEndings(e, t, r) {
    const s = this._interpolantSettings;
    r
      ? ((s.endingStart = ZeroSlopeEnding), (s.endingEnd = ZeroSlopeEnding))
      : (e
          ? (s.endingStart = this.zeroSlopeAtStart
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (s.endingStart = WrapAroundEnding),
        t
          ? (s.endingEnd = this.zeroSlopeAtEnd
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (s.endingEnd = WrapAroundEnding));
  }
  _scheduleFading(e, t, r) {
    const s = this._mixer,
      o = s.time;
    let a = this._weightInterpolant;
    a === null &&
      ((a = s._lendControlInterpolant()), (this._weightInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = o), (c[0] = t), (l[1] = o + e), (c[1] = r), this;
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      s = e._clip.tracks,
      o = s.length,
      a = e._propertyBindings,
      l = e._interpolants,
      c = r.uuid,
      u = this._bindingsByRootAndName;
    let p = u[c];
    p === void 0 && ((p = {}), (u[c] = p));
    for (let N = 0; N !== o; ++N) {
      const P = s[N],
        de = P.name;
      let me = p[de];
      if (me !== void 0) ++me.referenceCount, (a[N] = me);
      else {
        if (((me = a[N]), me !== void 0)) {
          me._cacheIndex === null &&
            (++me.referenceCount, this._addInactiveBinding(me, c, de));
          continue;
        }
        const Ye = t && t._propertyBindings[N].binding.parsedPath;
        (me = new PropertyMixer(
          PropertyBinding.create(r, de, Ye),
          P.ValueTypeName,
          P.getValueSize()
        )),
          ++me.referenceCount,
          this._addInactiveBinding(me, c, de),
          (a[N] = me);
      }
      l[N].resultBuffer = me.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          s = e._clip.uuid,
          o = this._actionsByClip[s];
        this._bindAction(e, o && o.knownActions[0]),
          this._addInactiveAction(e, s, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, s = t.length; r !== s; ++r) {
        const o = t[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, s = t.length; r !== s; ++r) {
        const o = t[r];
        --o.useCount === 0 &&
          (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const s = this._actions,
      o = this._actionsByClip;
    let a = o[t];
    if (a === void 0)
      (a = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (o[t] = a);
    else {
      const l = a.knownActions;
      (e._byClipCacheIndex = l.length), l.push(e);
    }
    (e._cacheIndex = s.length), s.push(e), (a.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      s = e._cacheIndex;
    (r._cacheIndex = s), (t[s] = r), t.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      a = this._actionsByClip,
      l = a[o],
      c = l.knownActions,
      u = c[c.length - 1],
      p = e._byClipCacheIndex;
    (u._byClipCacheIndex = p),
      (c[p] = u),
      c.pop(),
      (e._byClipCacheIndex = null);
    const N = l.actionByRoot,
      P = (e._localRoot || this._root).uuid;
    delete N[P],
      c.length === 0 && delete a[o],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, s = t.length; r !== s; ++r) {
      const o = t[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      s = this._nActiveActions++,
      o = t[s];
    (e._cacheIndex = s), (t[s] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      s = --this._nActiveActions,
      o = t[s];
    (e._cacheIndex = s), (t[s] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _addInactiveBinding(e, t, r) {
    const s = this._bindingsByRootAndName,
      o = this._bindings;
    let a = s[t];
    a === void 0 && ((a = {}), (s[t] = a)),
      (a[r] = e),
      (e._cacheIndex = o.length),
      o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      s = r.rootNode.uuid,
      o = r.path,
      a = this._bindingsByRootAndName,
      l = a[s],
      c = t[t.length - 1],
      u = e._cacheIndex;
    (c._cacheIndex = u),
      (t[u] = c),
      t.pop(),
      delete l[o],
      Object.keys(l).length === 0 && delete a[s];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      s = this._nActiveBindings++,
      o = t[s];
    (e._cacheIndex = s), (t[s] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      s = --this._nActiveBindings,
      o = t[s];
    (e._cacheIndex = s), (t[s] = e), (o._cacheIndex = r), (t[r] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new LinearInterpolant(
          new Float32Array(2),
          new Float32Array(2),
          1,
          _controlInterpolantsResultBuffer
        )),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      s = --this._nActiveControlInterpolants,
      o = t[s];
    (e.__cacheIndex = s), (t[s] = e), (o.__cacheIndex = r), (t[r] = o);
  }
  clipAction(e, t, r) {
    const s = t || this._root,
      o = s.uuid;
    let a = typeof e == "string" ? AnimationClip.findByName(s, e) : e;
    const l = a !== null ? a.uuid : e,
      c = this._actionsByClip[l];
    let u = null;
    if (
      (r === void 0 &&
        (a !== null ? (r = a.blendMode) : (r = NormalAnimationBlendMode)),
      c !== void 0)
    ) {
      const N = c.actionByRoot[o];
      if (N !== void 0 && N.blendMode === r) return N;
      (u = c.knownActions[0]), a === null && (a = u._clip);
    }
    if (a === null) return null;
    const p = new AnimationAction(this, a, t, r);
    return this._bindAction(p, u), this._addInactiveAction(p, l, o), p;
  }
  existingAction(e, t) {
    const r = t || this._root,
      s = r.uuid,
      o = typeof e == "string" ? AnimationClip.findByName(r, e) : e,
      a = o ? o.uuid : e,
      l = this._actionsByClip[a];
    return (l !== void 0 && l.actionByRoot[s]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      s = (this.time += e),
      o = Math.sign(e),
      a = (this._accuIndex ^= 1);
    for (let u = 0; u !== r; ++u) t[u]._update(s, e, o, a);
    const l = this._bindings,
      c = this._nActiveBindings;
    for (let u = 0; u !== c; ++u) l[u].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      s = this._actionsByClip,
      o = s[r];
    if (o !== void 0) {
      const a = o.knownActions;
      for (let l = 0, c = a.length; l !== c; ++l) {
        const u = a[l];
        this._deactivateAction(u);
        const p = u._cacheIndex,
          N = t[t.length - 1];
        (u._cacheIndex = null),
          (u._byClipCacheIndex = null),
          (N._cacheIndex = p),
          (t[p] = N),
          t.pop(),
          this._removeInactiveBindingsForAction(u);
      }
      delete s[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const a in r) {
      const l = r[a].actionByRoot,
        c = l[t];
      c !== void 0 &&
        (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const s = this._bindingsByRootAndName,
      o = s[t];
    if (o !== void 0)
      for (const a in o) {
        const l = o[a];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class RenderTarget3D extends RenderTarget {
  constructor(e = 1, t = 1, r = 1, s = {}) {
    super(e, t, s),
      (this.isRenderTarget3D = !0),
      (this.depth = r),
      (this.texture = new Data3DTexture(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class RenderTargetArray extends RenderTarget {
  constructor(e = 1, t = 1, r = 1, s = {}) {
    super(e, t, s),
      (this.isRenderTargetArray = !0),
      (this.depth = r),
      (this.texture = new DataArrayTexture(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Uniform {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let _id$3 = 0;
class UniformsGroup extends EventDispatcher {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: _id$3++ }),
      (this.name = ""),
      (this.usage = StaticDrawUsage),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let a = 0; a < o.length; a++) this.uniforms.push(o[a].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class GLBufferAttribute {
  constructor(e, t, r, s, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = s),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const _matrix = new Matrix4();
class Raycaster {
  constructor(e, t, r = 0, s = 1 / 0) {
    (this.ray = new Ray(e, t)),
      (this.near = r),
      (this.far = s),
      (this.camera = null),
      (this.layers = new Layers()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      _matrix.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix),
      this
    );
  }
  intersectObject(e, t = !0, r = []) {
    return intersect(e, this, r, t), r.sort(ascSort), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let s = 0, o = e.length; s < o; s++) intersect(e[s], this, r, t);
    return r.sort(ascSort), r;
  }
}
function ascSort(n, e) {
  return n.distance - e.distance;
}
function intersect(n, e, t, r) {
  let s = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (s = !1),
    s === !0 && r === !0)
  ) {
    const o = n.children;
    for (let a = 0, l = o.length; a < l; a++) intersect(o[a], e, t, !0);
  }
}
class Spherical {
  constructor(e = 1, t = 0, r = 0) {
    (this.radius = e), (this.phi = t), (this.theta = r);
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (this.phi = clamp$1(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(clamp$1(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(e = 1, t = 0, r = 0) {
    (this.radius = e), (this.theta = t), (this.y = r);
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix2 {
  constructor(e, t, r, s) {
    (Matrix2.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, s);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 4; r++) this.elements[r] = e[r + t];
    return this;
  }
  set(e, t, r, s) {
    const o = this.elements;
    return (o[0] = e), (o[2] = t), (o[1] = r), (o[3] = s), this;
  }
}
const _vector$4 = new Vector2();
class Box2 {
  constructor(e = new Vector2(1 / 0, 1 / 0), t = new Vector2(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = _vector$4.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _vector$4).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const _startP = new Vector3(),
  _startEnd = new Vector3();
class Line3 {
  constructor(e = new Vector3(), t = new Vector3()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    _startP.subVectors(e, this.start),
      _startEnd.subVectors(this.end, this.start);
    const r = _startEnd.dot(_startEnd);
    let o = _startEnd.dot(_startP) / r;
    return t && (o = clamp$1(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, r) {
    const s = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(s).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = new Vector3();
class SpotLightHelper extends Object3D {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new BufferGeometry(),
      s = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
      const u = (a / c) * Math.PI * 2,
        p = (l / c) * Math.PI * 2;
      s.push(Math.cos(u), Math.sin(u), 1, Math.cos(p), Math.sin(p), 1);
    }
    r.setAttribute("position", new Float32BufferAttribute(s, 3));
    const o = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    (this.cone = new LineSegments(r, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(_vector$3),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const _vector$2 = new Vector3(),
  _boneMatrix = new Matrix4(),
  _matrixWorldInv = new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(e) {
    const t = getBoneList(e),
      r = new BufferGeometry(),
      s = [],
      o = [],
      a = new Color(0, 0, 1),
      l = new Color(0, 1, 0);
    for (let u = 0; u < t.length; u++) {
      const p = t[u];
      p.parent &&
        p.parent.isBone &&
        (s.push(0, 0, 0),
        s.push(0, 0, 0),
        o.push(a.r, a.g, a.b),
        o.push(l.r, l.g, l.b));
    }
    r.setAttribute("position", new Float32BufferAttribute(s, 3)),
      r.setAttribute("color", new Float32BufferAttribute(o, 3));
    const c = new LineBasicMaterial({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, c),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      s = r.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let o = 0, a = 0; o < t.length; o++) {
      const l = t[o];
      l.parent &&
        l.parent.isBone &&
        (_boneMatrix.multiplyMatrices(_matrixWorldInv, l.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        s.setXYZ(a, _vector$2.x, _vector$2.y, _vector$2.z),
        _boneMatrix.multiplyMatrices(_matrixWorldInv, l.parent.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        s.setXYZ(a + 1, _vector$2.x, _vector$2.y, _vector$2.z),
        (a += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function getBoneList(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push(...getBoneList(n.children[t]));
  return e;
}
class PointLightHelper extends Mesh {
  constructor(e, t, r) {
    const s = new SphereGeometry(t, 4, 2),
      o = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(s, o),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const _vector$1 = new Vector3(),
  _color1 = new Color(),
  _color2 = new Color();
class HemisphereLightHelper extends Object3D {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const s = new OctahedronGeometry(t);
    s.rotateY(Math.PI * 0.5),
      (this.material = new MeshBasicMaterial({
        wireframe: !0,
        fog: !1,
        toneMapped: !1,
      })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = s.getAttribute("position"),
      a = new Float32Array(o.count * 3);
    s.setAttribute("color", new BufferAttribute(a, 3)),
      this.add(new Mesh(s, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
      for (let r = 0, s = t.count; r < s; r++) {
        const o = r < s / 2 ? _color1 : _color2;
        t.setXYZ(r, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(
        _vector$1.setFromMatrixPosition(this.light.matrixWorld).negate()
      );
  }
}
class GridHelper extends LineSegments {
  constructor(e = 10, t = 10, r = 4473924, s = 8947848) {
    (r = new Color(r)), (s = new Color(s));
    const o = t / 2,
      a = e / t,
      l = e / 2,
      c = [],
      u = [];
    for (let P = 0, de = 0, me = -l; P <= t; P++, me += a) {
      c.push(-l, 0, me, l, 0, me), c.push(me, 0, -l, me, 0, l);
      const Ye = P === o ? r : s;
      Ye.toArray(u, de),
        (de += 3),
        Ye.toArray(u, de),
        (de += 3),
        Ye.toArray(u, de),
        (de += 3),
        Ye.toArray(u, de),
        (de += 3);
    }
    const p = new BufferGeometry();
    p.setAttribute("position", new Float32BufferAttribute(c, 3)),
      p.setAttribute("color", new Float32BufferAttribute(u, 3));
    const N = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(p, N), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class PolarGridHelper extends LineSegments {
  constructor(e = 10, t = 16, r = 8, s = 64, o = 4473924, a = 8947848) {
    (o = new Color(o)), (a = new Color(a));
    const l = [],
      c = [];
    if (t > 1)
      for (let N = 0; N < t; N++) {
        const P = (N / t) * (Math.PI * 2),
          de = Math.sin(P) * e,
          me = Math.cos(P) * e;
        l.push(0, 0, 0), l.push(de, 0, me);
        const Ye = N & 1 ? o : a;
        c.push(Ye.r, Ye.g, Ye.b), c.push(Ye.r, Ye.g, Ye.b);
      }
    for (let N = 0; N < r; N++) {
      const P = N & 1 ? o : a,
        de = e - (e / r) * N;
      for (let me = 0; me < s; me++) {
        let Ye = (me / s) * (Math.PI * 2),
          nt = Math.sin(Ye) * de,
          Be = Math.cos(Ye) * de;
        l.push(nt, 0, Be),
          c.push(P.r, P.g, P.b),
          (Ye = ((me + 1) / s) * (Math.PI * 2)),
          (nt = Math.sin(Ye) * de),
          (Be = Math.cos(Ye) * de),
          l.push(nt, 0, Be),
          c.push(P.r, P.g, P.b);
      }
    }
    const u = new BufferGeometry();
    u.setAttribute("position", new Float32BufferAttribute(l, 3)),
      u.setAttribute("color", new Float32BufferAttribute(c, 3));
    const p = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(u, p), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const _v1 = new Vector3(),
  _v2 = new Vector3(),
  _v3 = new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let s = new BufferGeometry();
    s.setAttribute(
      "position",
      new Float32BufferAttribute(
        [-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],
        3
      )
    );
    const o = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Line(s, o)),
      this.add(this.lightPlane),
      (s = new BufferGeometry()),
      s.setAttribute(
        "position",
        new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
      ),
      (this.targetLine = new Line(s, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      _v1.setFromMatrixPosition(this.light.matrixWorld),
      _v2.setFromMatrixPosition(this.light.target.matrixWorld),
      _v3.subVectors(_v2, _v1),
      this.lightPlane.lookAt(_v2),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(_v2),
      (this.targetLine.scale.z = _v3.length());
  }
}
const _vector = new Vector3(),
  _camera = new Camera();
class CameraHelper extends LineSegments {
  constructor(e) {
    const t = new BufferGeometry(),
      r = new LineBasicMaterial({
        color: 16777215,
        vertexColors: !0,
        toneMapped: !1,
      }),
      s = [],
      o = [],
      a = {};
    l("n1", "n2"),
      l("n2", "n4"),
      l("n4", "n3"),
      l("n3", "n1"),
      l("f1", "f2"),
      l("f2", "f4"),
      l("f4", "f3"),
      l("f3", "f1"),
      l("n1", "f1"),
      l("n2", "f2"),
      l("n3", "f3"),
      l("n4", "f4"),
      l("p", "n1"),
      l("p", "n2"),
      l("p", "n3"),
      l("p", "n4"),
      l("u1", "u2"),
      l("u2", "u3"),
      l("u3", "u1"),
      l("c", "t"),
      l("p", "c"),
      l("cn1", "cn2"),
      l("cn3", "cn4"),
      l("cf1", "cf2"),
      l("cf3", "cf4");
    function l(me, Ye) {
      c(me), c(Ye);
    }
    function c(me) {
      s.push(0, 0, 0),
        o.push(0, 0, 0),
        a[me] === void 0 && (a[me] = []),
        a[me].push(s.length / 3 - 1);
    }
    t.setAttribute("position", new Float32BufferAttribute(s, 3)),
      t.setAttribute("color", new Float32BufferAttribute(o, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const u = new Color(16755200),
      p = new Color(16711680),
      N = new Color(43775),
      P = new Color(16777215),
      de = new Color(3355443);
    this.setColors(u, p, N, P, de);
  }
  setColors(e, t, r, s, o) {
    const l = this.geometry.getAttribute("color");
    l.setXYZ(0, e.r, e.g, e.b),
      l.setXYZ(1, e.r, e.g, e.b),
      l.setXYZ(2, e.r, e.g, e.b),
      l.setXYZ(3, e.r, e.g, e.b),
      l.setXYZ(4, e.r, e.g, e.b),
      l.setXYZ(5, e.r, e.g, e.b),
      l.setXYZ(6, e.r, e.g, e.b),
      l.setXYZ(7, e.r, e.g, e.b),
      l.setXYZ(8, e.r, e.g, e.b),
      l.setXYZ(9, e.r, e.g, e.b),
      l.setXYZ(10, e.r, e.g, e.b),
      l.setXYZ(11, e.r, e.g, e.b),
      l.setXYZ(12, e.r, e.g, e.b),
      l.setXYZ(13, e.r, e.g, e.b),
      l.setXYZ(14, e.r, e.g, e.b),
      l.setXYZ(15, e.r, e.g, e.b),
      l.setXYZ(16, e.r, e.g, e.b),
      l.setXYZ(17, e.r, e.g, e.b),
      l.setXYZ(18, e.r, e.g, e.b),
      l.setXYZ(19, e.r, e.g, e.b),
      l.setXYZ(20, e.r, e.g, e.b),
      l.setXYZ(21, e.r, e.g, e.b),
      l.setXYZ(22, e.r, e.g, e.b),
      l.setXYZ(23, e.r, e.g, e.b),
      l.setXYZ(24, t.r, t.g, t.b),
      l.setXYZ(25, t.r, t.g, t.b),
      l.setXYZ(26, t.r, t.g, t.b),
      l.setXYZ(27, t.r, t.g, t.b),
      l.setXYZ(28, t.r, t.g, t.b),
      l.setXYZ(29, t.r, t.g, t.b),
      l.setXYZ(30, t.r, t.g, t.b),
      l.setXYZ(31, t.r, t.g, t.b),
      l.setXYZ(32, r.r, r.g, r.b),
      l.setXYZ(33, r.r, r.g, r.b),
      l.setXYZ(34, r.r, r.g, r.b),
      l.setXYZ(35, r.r, r.g, r.b),
      l.setXYZ(36, r.r, r.g, r.b),
      l.setXYZ(37, r.r, r.g, r.b),
      l.setXYZ(38, s.r, s.g, s.b),
      l.setXYZ(39, s.r, s.g, s.b),
      l.setXYZ(40, o.r, o.g, o.b),
      l.setXYZ(41, o.r, o.g, o.b),
      l.setXYZ(42, o.r, o.g, o.b),
      l.setXYZ(43, o.r, o.g, o.b),
      l.setXYZ(44, o.r, o.g, o.b),
      l.setXYZ(45, o.r, o.g, o.b),
      l.setXYZ(46, o.r, o.g, o.b),
      l.setXYZ(47, o.r, o.g, o.b),
      l.setXYZ(48, o.r, o.g, o.b),
      l.setXYZ(49, o.r, o.g, o.b),
      (l.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      s = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const o = this.camera.coordinateSystem === WebGLCoordinateSystem ? -1 : 0;
    setPoint("c", t, e, _camera, 0, 0, o),
      setPoint("t", t, e, _camera, 0, 0, 1),
      setPoint("n1", t, e, _camera, -1, -1, o),
      setPoint("n2", t, e, _camera, r, -1, o),
      setPoint("n3", t, e, _camera, -1, s, o),
      setPoint("n4", t, e, _camera, r, s, o),
      setPoint("f1", t, e, _camera, -1, -1, 1),
      setPoint("f2", t, e, _camera, r, -1, 1),
      setPoint("f3", t, e, _camera, -1, s, 1),
      setPoint("f4", t, e, _camera, r, s, 1),
      setPoint("u1", t, e, _camera, r * 0.7, s * 1.1, o),
      setPoint("u2", t, e, _camera, -1 * 0.7, s * 1.1, o),
      setPoint("u3", t, e, _camera, 0, s * 2, o),
      setPoint("cf1", t, e, _camera, -1, 0, 1),
      setPoint("cf2", t, e, _camera, r, 0, 1),
      setPoint("cf3", t, e, _camera, 0, -1, 1),
      setPoint("cf4", t, e, _camera, 0, s, 1),
      setPoint("cn1", t, e, _camera, -1, 0, o),
      setPoint("cn2", t, e, _camera, r, 0, o),
      setPoint("cn3", t, e, _camera, 0, -1, o),
      setPoint("cn4", t, e, _camera, 0, s, o),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function setPoint(n, e, t, r, s, o, a) {
  _vector.set(s, o, a).unproject(r);
  const l = e[n];
  if (l !== void 0) {
    const c = t.getAttribute("position");
    for (let u = 0, p = l.length; u < p; u++)
      c.setXYZ(l[u], _vector.x, _vector.y, _vector.z);
  }
}
const _box = new Box3();
class BoxHelper extends LineSegments {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      s = new Float32Array(8 * 3),
      o = new BufferGeometry();
    o.setIndex(new BufferAttribute(r, 1)),
      o.setAttribute("position", new BufferAttribute(s, 3)),
      super(o, new LineBasicMaterial({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update() {
    if (
      (this.object !== void 0 && _box.setFromObject(this.object),
      _box.isEmpty())
    )
      return;
    const e = _box.min,
      t = _box.max,
      r = this.geometry.attributes.position,
      s = r.array;
    (s[0] = t.x),
      (s[1] = t.y),
      (s[2] = t.z),
      (s[3] = e.x),
      (s[4] = t.y),
      (s[5] = t.z),
      (s[6] = e.x),
      (s[7] = e.y),
      (s[8] = t.z),
      (s[9] = t.x),
      (s[10] = e.y),
      (s[11] = t.z),
      (s[12] = t.x),
      (s[13] = t.y),
      (s[14] = e.z),
      (s[15] = e.x),
      (s[16] = t.y),
      (s[17] = e.z),
      (s[18] = e.x),
      (s[19] = e.y),
      (s[20] = e.z),
      (s[21] = t.x),
      (s[22] = e.y),
      (s[23] = e.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Box3Helper extends LineSegments {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      s = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      o = new BufferGeometry();
    o.setIndex(new BufferAttribute(r, 1)),
      o.setAttribute("position", new Float32BufferAttribute(s, 3)),
      super(o, new LineBasicMaterial({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class PlaneHelper extends Line {
  constructor(e, t = 1, r = 16776960) {
    const s = r,
      o = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      a = new BufferGeometry();
    a.setAttribute("position", new Float32BufferAttribute(o, 3)),
      a.computeBoundingSphere(),
      super(a, new LineBasicMaterial({ color: s, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      c = new BufferGeometry();
    c.setAttribute("position", new Float32BufferAttribute(l, 3)),
      c.computeBoundingSphere(),
      this.add(
        new Mesh(
          c,
          new MeshBasicMaterial({
            color: s,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const _axis = new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(
    e = new Vector3(0, 0, 1),
    t = new Vector3(0, 0, 0),
    r = 1,
    s = 16776960,
    o = r * 0.2,
    a = o * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      _lineGeometry === void 0 &&
        ((_lineGeometry = new BufferGeometry()),
        _lineGeometry.setAttribute(
          "position",
          new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
        ),
        (_coneGeometry = new ConeGeometry(0.5, 1, 5, 1)),
        _coneGeometry.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Line(
        _lineGeometry,
        new LineBasicMaterial({ color: s, toneMapped: !1 })
      )),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Mesh(
        _coneGeometry,
        new MeshBasicMaterial({ color: s, toneMapped: !1 })
      )),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, o, a);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(_axis, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class AxesHelper extends LineSegments {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      s = new BufferGeometry();
    s.setAttribute("position", new Float32BufferAttribute(t, 3)),
      s.setAttribute("color", new Float32BufferAttribute(r, 3));
    const o = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(s, o), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const s = new Color(),
      o = this.geometry.attributes.color.array;
    return (
      s.set(e),
      s.toArray(o, 0),
      s.toArray(o, 3),
      s.set(t),
      s.toArray(o, 6),
      s.toArray(o, 9),
      s.set(r),
      s.toArray(o, 12),
      s.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class ShapePath {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Color()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Path()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, s) {
    return this.currentPath.quadraticCurveTo(e, t, r, s), this;
  }
  bezierCurveTo(e, t, r, s, o, a) {
    return this.currentPath.bezierCurveTo(e, t, r, s, o, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(Be) {
      const ot = [];
      for (let st = 0, vt = Be.length; st < vt; st++) {
        const xt = Be[st],
          St = new Shape();
        (St.curves = xt.curves), ot.push(St);
      }
      return ot;
    }
    function r(Be, ot) {
      const st = ot.length;
      let vt = !1;
      for (let xt = st - 1, St = 0; St < st; xt = St++) {
        let wt = ot[xt],
          bt = ot[St],
          Tt = bt.x - wt.x,
          Ct = bt.y - wt.y;
        if (Math.abs(Ct) > Number.EPSILON) {
          if (
            (Ct < 0 && ((wt = ot[St]), (Tt = -Tt), (bt = ot[xt]), (Ct = -Ct)),
            Be.y < wt.y || Be.y > bt.y)
          )
            continue;
          if (Be.y === wt.y) {
            if (Be.x === wt.x) return !0;
          } else {
            const kt = Ct * (Be.x - wt.x) - Tt * (Be.y - wt.y);
            if (kt === 0) return !0;
            if (kt < 0) continue;
            vt = !vt;
          }
        } else {
          if (Be.y !== wt.y) continue;
          if ((bt.x <= Be.x && Be.x <= wt.x) || (wt.x <= Be.x && Be.x <= bt.x))
            return !0;
        }
      }
      return vt;
    }
    const s = ShapeUtils.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let a, l, c;
    const u = [];
    if (o.length === 1)
      return (l = o[0]), (c = new Shape()), (c.curves = l.curves), u.push(c), u;
    let p = !s(o[0].getPoints());
    p = e ? !p : p;
    const N = [],
      P = [];
    let de = [],
      me = 0,
      Ye;
    (P[me] = void 0), (de[me] = []);
    for (let Be = 0, ot = o.length; Be < ot; Be++)
      (l = o[Be]),
        (Ye = l.getPoints()),
        (a = s(Ye)),
        (a = e ? !a : a),
        a
          ? (!p && P[me] && me++,
            (P[me] = { s: new Shape(), p: Ye }),
            (P[me].s.curves = l.curves),
            p && me++,
            (de[me] = []))
          : de[me].push({ h: l, p: Ye[0] });
    if (!P[0]) return t(o);
    if (P.length > 1) {
      let Be = !1,
        ot = 0;
      for (let st = 0, vt = P.length; st < vt; st++) N[st] = [];
      for (let st = 0, vt = P.length; st < vt; st++) {
        const xt = de[st];
        for (let St = 0; St < xt.length; St++) {
          const wt = xt[St];
          let bt = !0;
          for (let Tt = 0; Tt < P.length; Tt++)
            r(wt.p, P[Tt].p) &&
              (st !== Tt && ot++, bt ? ((bt = !1), N[Tt].push(wt)) : (Be = !0));
          bt && N[st].push(wt);
        }
      }
      ot > 0 && Be === !1 && (de = N);
    }
    let nt;
    for (let Be = 0, ot = P.length; Be < ot; Be++) {
      (c = P[Be].s), u.push(c), (nt = de[Be]);
      for (let st = 0, vt = nt.length; st < vt; st++) c.holes.push(nt[st].h);
    }
    return u;
  }
}
class Controls extends EventDispatcher {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect(e) {
    if (e === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), (this.domElement = e);
  }
  disconnect() {}
  dispose() {}
  update() {}
}
function contain(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function cover(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function fill(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  );
}
function getByteLength(n, e, t, r) {
  const s = getTextureTypeByteLength(r);
  switch (t) {
    case AlphaFormat:
      return n * e;
    case RedFormat:
      return ((n * e) / s.components) * s.byteLength;
    case RedIntegerFormat:
      return ((n * e) / s.components) * s.byteLength;
    case RGFormat:
      return ((n * e * 2) / s.components) * s.byteLength;
    case RGIntegerFormat:
      return ((n * e * 2) / s.components) * s.byteLength;
    case RGBFormat:
      return ((n * e * 3) / s.components) * s.byteLength;
    case RGBAFormat:
      return ((n * e * 4) / s.components) * s.byteLength;
    case RGBAIntegerFormat:
      return ((n * e * 4) / s.components) * s.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function getTextureTypeByteLength(n) {
  switch (n) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
class TextureUtils {
  static contain(e, t) {
    return contain(e, t);
  }
  static cover(e, t) {
    return cover(e, t);
  }
  static fill(e) {
    return fill(e);
  }
  static getByteLength(e, t, r, s) {
    return getByteLength(e, t, r, s);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: REVISION } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = REVISION));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function WebGLAnimation() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function s(o, a) {
    t(o, a), (r = n.requestAnimationFrame(s));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(s)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (o) {
      t = o;
    },
    setContext: function (o) {
      n = o;
    },
  };
}
function WebGLAttributes(n) {
  const e = new WeakMap();
  function t(l, c) {
    const u = l.array,
      p = l.usage,
      N = u.byteLength,
      P = n.createBuffer();
    n.bindBuffer(c, P), n.bufferData(c, u, p), l.onUploadCallback();
    let de;
    if (u instanceof Float32Array) de = n.FLOAT;
    else if (u instanceof Uint16Array)
      l.isFloat16BufferAttribute
        ? (de = n.HALF_FLOAT)
        : (de = n.UNSIGNED_SHORT);
    else if (u instanceof Int16Array) de = n.SHORT;
    else if (u instanceof Uint32Array) de = n.UNSIGNED_INT;
    else if (u instanceof Int32Array) de = n.INT;
    else if (u instanceof Int8Array) de = n.BYTE;
    else if (u instanceof Uint8Array) de = n.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray) de = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + u
      );
    return {
      buffer: P,
      type: de,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: l.version,
      size: N,
    };
  }
  function r(l, c, u) {
    const p = c.array,
      N = c.updateRanges;
    if ((n.bindBuffer(u, l), N.length === 0)) n.bufferSubData(u, 0, p);
    else {
      N.sort((de, me) => de.start - me.start);
      let P = 0;
      for (let de = 1; de < N.length; de++) {
        const me = N[P],
          Ye = N[de];
        Ye.start <= me.start + me.count + 1
          ? (me.count = Math.max(me.count, Ye.start + Ye.count - me.start))
          : (++P, (N[P] = Ye));
      }
      N.length = P + 1;
      for (let de = 0, me = N.length; de < me; de++) {
        const Ye = N[de];
        n.bufferSubData(
          u,
          Ye.start * p.BYTES_PER_ELEMENT,
          p,
          Ye.start,
          Ye.count
        );
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function s(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (n.deleteBuffer(c.buffer), e.delete(l));
  }
  function a(l, c) {
    if (
      (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute)
    ) {
      const p = e.get(l);
      (!p || p.version < l.version) &&
        e.set(l, {
          buffer: l.buffer,
          type: l.type,
          bytesPerElement: l.elementSize,
          version: l.version,
        });
      return;
    }
    const u = e.get(l);
    if (u === void 0) e.set(l, t(l, c));
    else if (u.version < l.version) {
      if (u.size !== l.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(u.buffer, l, c), (u.version = l.version);
    }
  }
  return { get: s, remove: o, update: a };
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  common$1 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  colorspace_pars_fragment = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    batching_pars_vertex,
    batching_vertex,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common: common$1,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphinstance_vertex,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1,
  },
  UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Matrix3() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Matrix3() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Matrix3() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Matrix3() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Matrix3() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Matrix3() },
      normalScale: { value: new Vector2(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Matrix3() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Matrix3() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Matrix3() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() },
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
  },
  ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog,
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag,
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag,
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag,
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag,
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag,
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag,
    },
    points: {
      uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag,
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag,
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag,
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag,
    },
    sprite: {
      uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Matrix3() },
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        { color: { value: new Color(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag,
    },
  };
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
};
const _rgb = { r: 0, b: 0, g: 0 },
  _e1$1 = new Euler(),
  _m1$1 = new Matrix4();
function WebGLBackground(n, e, t, r, s, o, a) {
  const l = new Color(0);
  let c = o === !0 ? 0 : 1,
    u,
    p,
    N = null,
    P = 0,
    de = null;
  function me(st) {
    let vt = st.isScene === !0 ? st.background : null;
    return (
      vt &&
        vt.isTexture &&
        (vt = (st.backgroundBlurriness > 0 ? t : e).get(vt)),
      vt
    );
  }
  function Ye(st) {
    let vt = !1;
    const xt = me(st);
    xt === null ? Be(l, c) : xt && xt.isColor && (Be(xt, 1), (vt = !0));
    const St = n.xr.getEnvironmentBlendMode();
    St === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, a)
      : St === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, a),
      (n.autoClear || vt) &&
        (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function nt(st, vt) {
    const xt = me(vt);
    xt && (xt.isCubeTexture || xt.mapping === CubeUVReflectionMapping)
      ? (p === void 0 &&
          ((p = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
              vertexShader: ShaderLib.backgroundCube.vertexShader,
              fragmentShader: ShaderLib.backgroundCube.fragmentShader,
              side: BackSide,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          p.geometry.deleteAttribute("normal"),
          p.geometry.deleteAttribute("uv"),
          (p.onBeforeRender = function (St, wt, bt) {
            this.matrixWorld.copyPosition(bt.matrixWorld);
          }),
          Object.defineProperty(p.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          s.update(p)),
        _e1$1.copy(vt.backgroundRotation),
        (_e1$1.x *= -1),
        (_e1$1.y *= -1),
        (_e1$1.z *= -1),
        xt.isCubeTexture &&
          xt.isRenderTargetTexture === !1 &&
          ((_e1$1.y *= -1), (_e1$1.z *= -1)),
        (p.material.uniforms.envMap.value = xt),
        (p.material.uniforms.flipEnvMap.value =
          xt.isCubeTexture && xt.isRenderTargetTexture === !1 ? -1 : 1),
        (p.material.uniforms.backgroundBlurriness.value =
          vt.backgroundBlurriness),
        (p.material.uniforms.backgroundIntensity.value =
          vt.backgroundIntensity),
        p.material.uniforms.backgroundRotation.value.setFromMatrix4(
          _m1$1.makeRotationFromEuler(_e1$1)
        ),
        (p.material.toneMapped =
          ColorManagement.getTransfer(xt.colorSpace) !== SRGBTransfer),
        (N !== xt || P !== xt.version || de !== n.toneMapping) &&
          ((p.material.needsUpdate = !0),
          (N = xt),
          (P = xt.version),
          (de = n.toneMapping)),
        p.layers.enableAll(),
        st.unshift(p, p.geometry, p.material, 0, 0, null))
      : xt &&
        xt.isTexture &&
        (u === void 0 &&
          ((u = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          u.geometry.deleteAttribute("normal"),
          Object.defineProperty(u.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          s.update(u)),
        (u.material.uniforms.t2D.value = xt),
        (u.material.uniforms.backgroundIntensity.value =
          vt.backgroundIntensity),
        (u.material.toneMapped =
          ColorManagement.getTransfer(xt.colorSpace) !== SRGBTransfer),
        xt.matrixAutoUpdate === !0 && xt.updateMatrix(),
        u.material.uniforms.uvTransform.value.copy(xt.matrix),
        (N !== xt || P !== xt.version || de !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (N = xt),
          (P = xt.version),
          (de = n.toneMapping)),
        u.layers.enableAll(),
        st.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function Be(st, vt) {
    st.getRGB(_rgb, getUnlitUniformColorSpace(n)),
      r.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, vt, a);
  }
  function ot() {
    p !== void 0 && (p.geometry.dispose(), p.material.dispose(), (p = void 0)),
      u !== void 0 &&
        (u.geometry.dispose(), u.material.dispose(), (u = void 0));
  }
  return {
    getClearColor: function () {
      return l;
    },
    setClearColor: function (st, vt = 1) {
      l.set(st), (c = vt), Be(l, c);
    },
    getClearAlpha: function () {
      return c;
    },
    setClearAlpha: function (st) {
      (c = st), Be(l, c);
    },
    render: Ye,
    addToRenderList: nt,
    dispose: ot,
  };
}
function WebGLBindingStates(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    r = {},
    s = P(null);
  let o = s,
    a = !1;
  function l(Ct, kt, Dt, Vt, Ht) {
    let qt = !1;
    const Ft = N(Vt, Dt, kt);
    o !== Ft && ((o = Ft), u(o.object)),
      (qt = de(Ct, Vt, Dt, Ht)),
      qt && me(Ct, Vt, Dt, Ht),
      Ht !== null && e.update(Ht, n.ELEMENT_ARRAY_BUFFER),
      (qt || a) &&
        ((a = !1),
        vt(Ct, kt, Dt, Vt),
        Ht !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(Ht).buffer));
  }
  function c() {
    return n.createVertexArray();
  }
  function u(Ct) {
    return n.bindVertexArray(Ct);
  }
  function p(Ct) {
    return n.deleteVertexArray(Ct);
  }
  function N(Ct, kt, Dt) {
    const Vt = Dt.wireframe === !0;
    let Ht = r[Ct.id];
    Ht === void 0 && ((Ht = {}), (r[Ct.id] = Ht));
    let qt = Ht[kt.id];
    qt === void 0 && ((qt = {}), (Ht[kt.id] = qt));
    let Ft = qt[Vt];
    return Ft === void 0 && ((Ft = P(c())), (qt[Vt] = Ft)), Ft;
  }
  function P(Ct) {
    const kt = [],
      Dt = [],
      Vt = [];
    for (let Ht = 0; Ht < t; Ht++) (kt[Ht] = 0), (Dt[Ht] = 0), (Vt[Ht] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: kt,
      enabledAttributes: Dt,
      attributeDivisors: Vt,
      object: Ct,
      attributes: {},
      index: null,
    };
  }
  function de(Ct, kt, Dt, Vt) {
    const Ht = o.attributes,
      qt = kt.attributes;
    let Ft = 0;
    const Bt = Dt.getAttributes();
    for (const Mt in Bt)
      if (Bt[Mt].location >= 0) {
        const It = Ht[Mt];
        let Ot = qt[Mt];
        if (
          (Ot === void 0 &&
            (Mt === "instanceMatrix" &&
              Ct.instanceMatrix &&
              (Ot = Ct.instanceMatrix),
            Mt === "instanceColor" &&
              Ct.instanceColor &&
              (Ot = Ct.instanceColor)),
          It === void 0 || It.attribute !== Ot || (Ot && It.data !== Ot.data))
        )
          return !0;
        Ft++;
      }
    return o.attributesNum !== Ft || o.index !== Vt;
  }
  function me(Ct, kt, Dt, Vt) {
    const Ht = {},
      qt = kt.attributes;
    let Ft = 0;
    const Bt = Dt.getAttributes();
    for (const Mt in Bt)
      if (Bt[Mt].location >= 0) {
        let It = qt[Mt];
        It === void 0 &&
          (Mt === "instanceMatrix" &&
            Ct.instanceMatrix &&
            (It = Ct.instanceMatrix),
          Mt === "instanceColor" &&
            Ct.instanceColor &&
            (It = Ct.instanceColor));
        const Ot = {};
        (Ot.attribute = It),
          It && It.data && (Ot.data = It.data),
          (Ht[Mt] = Ot),
          Ft++;
      }
    (o.attributes = Ht), (o.attributesNum = Ft), (o.index = Vt);
  }
  function Ye() {
    const Ct = o.newAttributes;
    for (let kt = 0, Dt = Ct.length; kt < Dt; kt++) Ct[kt] = 0;
  }
  function nt(Ct) {
    Be(Ct, 0);
  }
  function Be(Ct, kt) {
    const Dt = o.newAttributes,
      Vt = o.enabledAttributes,
      Ht = o.attributeDivisors;
    (Dt[Ct] = 1),
      Vt[Ct] === 0 && (n.enableVertexAttribArray(Ct), (Vt[Ct] = 1)),
      Ht[Ct] !== kt && (n.vertexAttribDivisor(Ct, kt), (Ht[Ct] = kt));
  }
  function ot() {
    const Ct = o.newAttributes,
      kt = o.enabledAttributes;
    for (let Dt = 0, Vt = kt.length; Dt < Vt; Dt++)
      kt[Dt] !== Ct[Dt] && (n.disableVertexAttribArray(Dt), (kt[Dt] = 0));
  }
  function st(Ct, kt, Dt, Vt, Ht, qt, Ft) {
    Ft === !0
      ? n.vertexAttribIPointer(Ct, kt, Dt, Ht, qt)
      : n.vertexAttribPointer(Ct, kt, Dt, Vt, Ht, qt);
  }
  function vt(Ct, kt, Dt, Vt) {
    Ye();
    const Ht = Vt.attributes,
      qt = Dt.getAttributes(),
      Ft = kt.defaultAttributeValues;
    for (const Bt in qt) {
      const Mt = qt[Bt];
      if (Mt.location >= 0) {
        let Pt = Ht[Bt];
        if (
          (Pt === void 0 &&
            (Bt === "instanceMatrix" &&
              Ct.instanceMatrix &&
              (Pt = Ct.instanceMatrix),
            Bt === "instanceColor" &&
              Ct.instanceColor &&
              (Pt = Ct.instanceColor)),
          Pt !== void 0)
        ) {
          const It = Pt.normalized,
            Ot = Pt.itemSize,
            Xt = e.get(Pt);
          if (Xt === void 0) continue;
          const sn = Xt.buffer,
            Kt = Xt.type,
            tn = Xt.bytesPerElement,
            pn =
              Kt === n.INT || Kt === n.UNSIGNED_INT || Pt.gpuType === IntType;
          if (Pt.isInterleavedBufferAttribute) {
            const _n = Pt.data,
              bn = _n.stride,
              $n = Pt.offset;
            if (_n.isInstancedInterleavedBuffer) {
              for (let tr = 0; tr < Mt.locationSize; tr++)
                Be(Mt.location + tr, _n.meshPerAttribute);
              Ct.isInstancedMesh !== !0 &&
                Vt._maxInstanceCount === void 0 &&
                (Vt._maxInstanceCount = _n.meshPerAttribute * _n.count);
            } else
              for (let tr = 0; tr < Mt.locationSize; tr++) nt(Mt.location + tr);
            n.bindBuffer(n.ARRAY_BUFFER, sn);
            for (let tr = 0; tr < Mt.locationSize; tr++)
              st(
                Mt.location + tr,
                Ot / Mt.locationSize,
                Kt,
                It,
                bn * tn,
                ($n + (Ot / Mt.locationSize) * tr) * tn,
                pn
              );
          } else {
            if (Pt.isInstancedBufferAttribute) {
              for (let _n = 0; _n < Mt.locationSize; _n++)
                Be(Mt.location + _n, Pt.meshPerAttribute);
              Ct.isInstancedMesh !== !0 &&
                Vt._maxInstanceCount === void 0 &&
                (Vt._maxInstanceCount = Pt.meshPerAttribute * Pt.count);
            } else
              for (let _n = 0; _n < Mt.locationSize; _n++) nt(Mt.location + _n);
            n.bindBuffer(n.ARRAY_BUFFER, sn);
            for (let _n = 0; _n < Mt.locationSize; _n++)
              st(
                Mt.location + _n,
                Ot / Mt.locationSize,
                Kt,
                It,
                Ot * tn,
                (Ot / Mt.locationSize) * _n * tn,
                pn
              );
          }
        } else if (Ft !== void 0) {
          const It = Ft[Bt];
          if (It !== void 0)
            switch (It.length) {
              case 2:
                n.vertexAttrib2fv(Mt.location, It);
                break;
              case 3:
                n.vertexAttrib3fv(Mt.location, It);
                break;
              case 4:
                n.vertexAttrib4fv(Mt.location, It);
                break;
              default:
                n.vertexAttrib1fv(Mt.location, It);
            }
        }
      }
    }
    ot();
  }
  function xt() {
    bt();
    for (const Ct in r) {
      const kt = r[Ct];
      for (const Dt in kt) {
        const Vt = kt[Dt];
        for (const Ht in Vt) p(Vt[Ht].object), delete Vt[Ht];
        delete kt[Dt];
      }
      delete r[Ct];
    }
  }
  function St(Ct) {
    if (r[Ct.id] === void 0) return;
    const kt = r[Ct.id];
    for (const Dt in kt) {
      const Vt = kt[Dt];
      for (const Ht in Vt) p(Vt[Ht].object), delete Vt[Ht];
      delete kt[Dt];
    }
    delete r[Ct.id];
  }
  function wt(Ct) {
    for (const kt in r) {
      const Dt = r[kt];
      if (Dt[Ct.id] === void 0) continue;
      const Vt = Dt[Ct.id];
      for (const Ht in Vt) p(Vt[Ht].object), delete Vt[Ht];
      delete Dt[Ct.id];
    }
  }
  function bt() {
    Tt(), (a = !0), o !== s && ((o = s), u(o.object));
  }
  function Tt() {
    (s.geometry = null), (s.program = null), (s.wireframe = !1);
  }
  return {
    setup: l,
    reset: bt,
    resetDefaultState: Tt,
    dispose: xt,
    releaseStatesOfGeometry: St,
    releaseStatesOfProgram: wt,
    initAttributes: Ye,
    enableAttribute: nt,
    disableUnusedAttributes: ot,
  };
}
function WebGLBufferRenderer(n, e, t) {
  let r;
  function s(u) {
    r = u;
  }
  function o(u, p) {
    n.drawArrays(r, u, p), t.update(p, r, 1);
  }
  function a(u, p, N) {
    N !== 0 && (n.drawArraysInstanced(r, u, p, N), t.update(p, r, N));
  }
  function l(u, p, N) {
    if (N === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, u, 0, p, 0, N);
    let de = 0;
    for (let me = 0; me < N; me++) de += p[me];
    t.update(de, r, 1);
  }
  function c(u, p, N, P) {
    if (N === 0) return;
    const de = e.get("WEBGL_multi_draw");
    if (de === null)
      for (let me = 0; me < u.length; me++) a(u[me], p[me], P[me]);
    else {
      de.multiDrawArraysInstancedWEBGL(r, u, 0, p, 0, P, 0, N);
      let me = 0;
      for (let Ye = 0; Ye < N; Ye++) me += p[Ye] * P[Ye];
      t.update(me, r, 1);
    }
  }
  (this.setMode = s),
    (this.render = o),
    (this.renderInstances = a),
    (this.renderMultiDraw = l),
    (this.renderMultiDrawInstances = c);
}
function WebGLCapabilities(n, e, t, r) {
  let s;
  function o() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const wt = e.get("EXT_texture_filter_anisotropic");
      s = n.getParameter(wt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else s = 0;
    return s;
  }
  function a(wt) {
    return !(
      wt !== RGBAFormat &&
      r.convert(wt) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function l(wt) {
    const bt =
      wt === HalfFloatType &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      wt !== UnsignedByteType &&
      r.convert(wt) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      wt !== FloatType &&
      !bt
    );
  }
  function c(wt) {
    if (wt === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      wt = "mediump";
    }
    return wt === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let u = t.precision !== void 0 ? t.precision : "highp";
  const p = c(u);
  p !== u &&
    (console.warn(
      "THREE.WebGLRenderer:",
      u,
      "not supported, using",
      p,
      "instead."
    ),
    (u = p));
  const N = t.logarithmicDepthBuffer === !0,
    P = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    de = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    me = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    Ye = n.getParameter(n.MAX_TEXTURE_SIZE),
    nt = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    Be = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    ot = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    st = n.getParameter(n.MAX_VARYING_VECTORS),
    vt = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    xt = me > 0,
    St = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: c,
    textureFormatReadable: a,
    textureTypeReadable: l,
    precision: u,
    logarithmicDepthBuffer: N,
    reverseDepthBuffer: P,
    maxTextures: de,
    maxVertexTextures: me,
    maxTextureSize: Ye,
    maxCubemapSize: nt,
    maxAttributes: Be,
    maxVertexUniforms: ot,
    maxVaryings: st,
    maxFragmentUniforms: vt,
    vertexTextures: xt,
    maxSamples: St,
  };
}
function WebGLClipping(n) {
  const e = this;
  let t = null,
    r = 0,
    s = !1,
    o = !1;
  const a = new Plane(),
    l = new Matrix3(),
    c = { value: null, needsUpdate: !1 };
  (this.uniform = c),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (N, P) {
      const de = N.length !== 0 || P || r !== 0 || s;
      return (s = P), (r = N.length), de;
    }),
    (this.beginShadows = function () {
      (o = !0), p(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (N, P) {
      t = p(N, P, 0);
    }),
    (this.setState = function (N, P, de) {
      const me = N.clippingPlanes,
        Ye = N.clipIntersection,
        nt = N.clipShadows,
        Be = n.get(N);
      if (!s || me === null || me.length === 0 || (o && !nt)) o ? p(null) : u();
      else {
        const ot = o ? 0 : r,
          st = ot * 4;
        let vt = Be.clippingState || null;
        (c.value = vt), (vt = p(me, P, st, de));
        for (let xt = 0; xt !== st; ++xt) vt[xt] = t[xt];
        (Be.clippingState = vt),
          (this.numIntersection = Ye ? this.numPlanes : 0),
          (this.numPlanes += ot);
      }
    });
  function u() {
    c.value !== t && ((c.value = t), (c.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function p(N, P, de, me) {
    const Ye = N !== null ? N.length : 0;
    let nt = null;
    if (Ye !== 0) {
      if (((nt = c.value), me !== !0 || nt === null)) {
        const Be = de + Ye * 4,
          ot = P.matrixWorldInverse;
        l.getNormalMatrix(ot),
          (nt === null || nt.length < Be) && (nt = new Float32Array(Be));
        for (let st = 0, vt = de; st !== Ye; ++st, vt += 4)
          a.copy(N[st]).applyMatrix4(ot, l),
            a.normal.toArray(nt, vt),
            (nt[vt + 3] = a.constant);
      }
      (c.value = nt), (c.needsUpdate = !0);
    }
    return (e.numPlanes = Ye), (e.numIntersection = 0), nt;
  }
}
function WebGLCubeMaps(n) {
  let e = new WeakMap();
  function t(a, l) {
    return (
      l === EquirectangularReflectionMapping
        ? (a.mapping = CubeReflectionMapping)
        : l === EquirectangularRefractionMapping &&
          (a.mapping = CubeRefractionMapping),
      a
    );
  }
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (
        l === EquirectangularReflectionMapping ||
        l === EquirectangularRefractionMapping
      )
        if (e.has(a)) {
          const c = e.get(a).texture;
          return t(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const u = new WebGLCubeRenderTarget(c.height);
            return (
              u.fromEquirectangularTexture(n, a),
              e.set(a, u),
              a.addEventListener("dispose", s),
              t(u.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: r, dispose: o };
}
const LOD_MIN = 4,
  EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  MAX_SAMPLES = 20,
  _flatCamera = new OrthographicCamera(),
  _clearColor = new Color();
let _oldTarget = null,
  _oldActiveCubeFace = 0,
  _oldActiveMipmapLevel = 0,
  _oldXrEnabled = !1;
const PHI = (1 + Math.sqrt(5)) / 2,
  INV_PHI = 1 / PHI,
  _axisDirections = [
    new Vector3(-PHI, INV_PHI, 0),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(-1, 1, -1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, 1),
  ],
  _origin = new Vector3();
class PMREMGenerator {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, s = 100, o = {}) {
    const { size: a = 256, position: l = _origin } = o;
    (_oldTarget = this._renderer.getRenderTarget()),
      (_oldActiveCubeFace = this._renderer.getActiveCubeFace()),
      (_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel()),
      (_oldXrEnabled = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(a);
    const c = this._allocateTargets();
    return (
      (c.depthBuffer = !0),
      this._sceneToCubeUV(e, r, s, c, l),
      t > 0 && this._blur(c, 0, 0, t),
      this._applyPMREM(c),
      this._cleanup(c),
      c
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = _getCubemapMaterial()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = _getEquirectMaterial()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(
      _oldTarget,
      _oldActiveCubeFace,
      _oldActiveMipmapLevel
    ),
      (this._renderer.xr.enabled = _oldXrEnabled),
      (e.scissorTest = !1),
      _setViewport(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (_oldTarget = this._renderer.getRenderTarget()),
      (_oldActiveCubeFace = this._renderer.getActiveCubeFace()),
      (_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel()),
      (_oldXrEnabled = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: !1,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: !1,
      },
      s = _createRenderTarget(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = _createRenderTarget(e, t, r));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(o)),
        (this._blurMaterial = _getBlurShader(o, e, t));
    }
    return s;
  }
  _compileMaterial(e) {
    const t = new Mesh(this._lodPlanes[0], e);
    this._renderer.compile(t, _flatCamera);
  }
  _sceneToCubeUV(e, t, r, s, o) {
    const c = new PerspectiveCamera(90, 1, t, r),
      u = [1, -1, 1, 1, 1, 1],
      p = [1, 1, 1, -1, -1, -1],
      N = this._renderer,
      P = N.autoClear,
      de = N.toneMapping;
    N.getClearColor(_clearColor),
      (N.toneMapping = NoToneMapping),
      (N.autoClear = !1);
    const me = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: !1,
        depthTest: !1,
      }),
      Ye = new Mesh(new BoxGeometry(), me);
    let nt = !1;
    const Be = e.background;
    Be
      ? Be.isColor && (me.color.copy(Be), (e.background = null), (nt = !0))
      : (me.color.copy(_clearColor), (nt = !0));
    for (let ot = 0; ot < 6; ot++) {
      const st = ot % 3;
      st === 0
        ? (c.up.set(0, u[ot], 0),
          c.position.set(o.x, o.y, o.z),
          c.lookAt(o.x + p[ot], o.y, o.z))
        : st === 1
        ? (c.up.set(0, 0, u[ot]),
          c.position.set(o.x, o.y, o.z),
          c.lookAt(o.x, o.y + p[ot], o.z))
        : (c.up.set(0, u[ot], 0),
          c.position.set(o.x, o.y, o.z),
          c.lookAt(o.x, o.y, o.z + p[ot]));
      const vt = this._cubeSize;
      _setViewport(s, st * vt, ot > 2 ? vt : 0, vt, vt),
        N.setRenderTarget(s),
        nt && N.render(Ye, c),
        N.render(e, c);
    }
    Ye.geometry.dispose(),
      Ye.material.dispose(),
      (N.toneMapping = de),
      (N.autoClear = P),
      (e.background = Be);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      s =
        e.mapping === CubeReflectionMapping ||
        e.mapping === CubeRefractionMapping;
    s
      ? (this._cubemapMaterial === null &&
          (this._cubemapMaterial = _getCubemapMaterial()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null &&
        (this._equirectMaterial = _getEquirectMaterial());
    const o = s ? this._cubemapMaterial : this._equirectMaterial,
      a = new Mesh(this._lodPlanes[0], o),
      l = o.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    _setViewport(t, 0, 0, 3 * c, 2 * c),
      r.setRenderTarget(t),
      r.render(a, _flatCamera);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let o = 1; o < s; o++) {
      const a = Math.sqrt(
          this._sigmas[o] * this._sigmas[o] -
            this._sigmas[o - 1] * this._sigmas[o - 1]
        ),
        l = _axisDirections[(s - o - 1) % _axisDirections.length];
      this._blur(e, o - 1, o, a, l);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, s, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, r, s, "latitudinal", o),
      this._halfBlur(a, e, r, r, s, "longitudinal", o);
  }
  _halfBlur(e, t, r, s, o, a, l) {
    const c = this._renderer,
      u = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const p = 3,
      N = new Mesh(this._lodPlanes[s], u),
      P = u.uniforms,
      de = this._sizeLods[r] - 1,
      me = isFinite(o)
        ? Math.PI / (2 * de)
        : (2 * Math.PI) / (2 * MAX_SAMPLES - 1),
      Ye = o / me,
      nt = isFinite(o) ? 1 + Math.floor(p * Ye) : MAX_SAMPLES;
    nt > MAX_SAMPLES &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${nt} samples when the maximum is set to ${MAX_SAMPLES}`
      );
    const Be = [];
    let ot = 0;
    for (let wt = 0; wt < MAX_SAMPLES; ++wt) {
      const bt = wt / Ye,
        Tt = Math.exp((-bt * bt) / 2);
      Be.push(Tt), wt === 0 ? (ot += Tt) : wt < nt && (ot += 2 * Tt);
    }
    for (let wt = 0; wt < Be.length; wt++) Be[wt] = Be[wt] / ot;
    (P.envMap.value = e.texture),
      (P.samples.value = nt),
      (P.weights.value = Be),
      (P.latitudinal.value = a === "latitudinal"),
      l && (P.poleAxis.value = l);
    const { _lodMax: st } = this;
    (P.dTheta.value = me), (P.mipInt.value = st - r);
    const vt = this._sizeLods[s],
      xt = 3 * vt * (s > st - LOD_MIN ? s - st + LOD_MIN : 0),
      St = 4 * (this._cubeSize - vt);
    _setViewport(t, xt, St, 3 * vt, 2 * vt),
      c.setRenderTarget(t),
      c.render(N, _flatCamera);
  }
}
function _createPlanes(n) {
  const e = [],
    t = [],
    r = [];
  let s = n;
  const o = n - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let a = 0; a < o; a++) {
    const l = Math.pow(2, s);
    t.push(l);
    let c = 1 / l;
    a > n - LOD_MIN
      ? (c = EXTRA_LOD_SIGMA[a - n + LOD_MIN - 1])
      : a === 0 && (c = 0),
      r.push(c);
    const u = 1 / (l - 2),
      p = -u,
      N = 1 + u,
      P = [p, p, N, p, N, N, p, p, N, N, p, N],
      de = 6,
      me = 6,
      Ye = 3,
      nt = 2,
      Be = 1,
      ot = new Float32Array(Ye * me * de),
      st = new Float32Array(nt * me * de),
      vt = new Float32Array(Be * me * de);
    for (let St = 0; St < de; St++) {
      const wt = ((St % 3) * 2) / 3 - 1,
        bt = St > 2 ? 0 : -1,
        Tt = [
          wt,
          bt,
          0,
          wt + 2 / 3,
          bt,
          0,
          wt + 2 / 3,
          bt + 1,
          0,
          wt,
          bt,
          0,
          wt + 2 / 3,
          bt + 1,
          0,
          wt,
          bt + 1,
          0,
        ];
      ot.set(Tt, Ye * me * St), st.set(P, nt * me * St);
      const Ct = [St, St, St, St, St, St];
      vt.set(Ct, Be * me * St);
    }
    const xt = new BufferGeometry();
    xt.setAttribute("position", new BufferAttribute(ot, Ye)),
      xt.setAttribute("uv", new BufferAttribute(st, nt)),
      xt.setAttribute("faceIndex", new BufferAttribute(vt, Be)),
      e.push(xt),
      s > LOD_MIN && s--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function _createRenderTarget(n, e, t) {
  const r = new WebGLRenderTarget(n, e, t);
  return (
    (r.texture.mapping = CubeUVReflectionMapping),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function _setViewport(n, e, t, r, s) {
  n.viewport.set(e, t, r, s), n.scissor.set(e, t, r, s);
}
function _getBlurShader(n, e, t) {
  const r = new Float32Array(MAX_SAMPLES),
    s = new Vector3(0, 1, 0);
  return new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(n) {
  let e = new WeakMap(),
    t = null;
  function r(l) {
    if (l && l.isTexture) {
      const c = l.mapping,
        u =
          c === EquirectangularReflectionMapping ||
          c === EquirectangularRefractionMapping,
        p = c === CubeReflectionMapping || c === CubeRefractionMapping;
      if (u || p) {
        let N = e.get(l);
        const P = N !== void 0 ? N.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== P)
          return (
            t === null && (t = new PMREMGenerator(n)),
            (N = u ? t.fromEquirectangular(l, N) : t.fromCubemap(l, N)),
            (N.texture.pmremVersion = l.pmremVersion),
            e.set(l, N),
            N.texture
          );
        if (N !== void 0) return N.texture;
        {
          const de = l.image;
          return (u && de && de.height > 0) || (p && de && s(de))
            ? (t === null && (t = new PMREMGenerator(n)),
              (N = u ? t.fromEquirectangular(l) : t.fromCubemap(l)),
              (N.texture.pmremVersion = l.pmremVersion),
              e.set(l, N),
              l.addEventListener("dispose", o),
              N.texture)
            : null;
        }
      }
    }
    return l;
  }
  function s(l) {
    let c = 0;
    const u = 6;
    for (let p = 0; p < u; p++) l[p] !== void 0 && c++;
    return c === u;
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: a };
}
function WebGLExtensions(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let s;
    switch (r) {
      case "WEBGL_depth_texture":
        s =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = n.getExtension(r);
    }
    return (e[r] = s), s;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const s = t(r);
      return (
        s === null &&
          warnOnce("THREE.WebGLRenderer: " + r + " extension not supported."),
        s
      );
    },
  };
}
function WebGLGeometries(n, e, t, r) {
  const s = {},
    o = new WeakMap();
  function a(N) {
    const P = N.target;
    P.index !== null && e.remove(P.index);
    for (const me in P.attributes) e.remove(P.attributes[me]);
    P.removeEventListener("dispose", a), delete s[P.id];
    const de = o.get(P);
    de && (e.remove(de), o.delete(P)),
      r.releaseStatesOfGeometry(P),
      P.isInstancedBufferGeometry === !0 && delete P._maxInstanceCount,
      t.memory.geometries--;
  }
  function l(N, P) {
    return (
      s[P.id] === !0 ||
        (P.addEventListener("dispose", a),
        (s[P.id] = !0),
        t.memory.geometries++),
      P
    );
  }
  function c(N) {
    const P = N.attributes;
    for (const de in P) e.update(P[de], n.ARRAY_BUFFER);
  }
  function u(N) {
    const P = [],
      de = N.index,
      me = N.attributes.position;
    let Ye = 0;
    if (de !== null) {
      const ot = de.array;
      Ye = de.version;
      for (let st = 0, vt = ot.length; st < vt; st += 3) {
        const xt = ot[st + 0],
          St = ot[st + 1],
          wt = ot[st + 2];
        P.push(xt, St, St, wt, wt, xt);
      }
    } else if (me !== void 0) {
      const ot = me.array;
      Ye = me.version;
      for (let st = 0, vt = ot.length / 3 - 1; st < vt; st += 3) {
        const xt = st + 0,
          St = st + 1,
          wt = st + 2;
        P.push(xt, St, St, wt, wt, xt);
      }
    } else return;
    const nt = new (
      arrayNeedsUint32(P) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(P, 1);
    nt.version = Ye;
    const Be = o.get(N);
    Be && e.remove(Be), o.set(N, nt);
  }
  function p(N) {
    const P = o.get(N);
    if (P) {
      const de = N.index;
      de !== null && P.version < de.version && u(N);
    } else u(N);
    return o.get(N);
  }
  return { get: l, update: c, getWireframeAttribute: p };
}
function WebGLIndexedBufferRenderer(n, e, t) {
  let r;
  function s(P) {
    r = P;
  }
  let o, a;
  function l(P) {
    (o = P.type), (a = P.bytesPerElement);
  }
  function c(P, de) {
    n.drawElements(r, de, o, P * a), t.update(de, r, 1);
  }
  function u(P, de, me) {
    me !== 0 &&
      (n.drawElementsInstanced(r, de, o, P * a, me), t.update(de, r, me));
  }
  function p(P, de, me) {
    if (me === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, de, 0, o, P, 0, me);
    let nt = 0;
    for (let Be = 0; Be < me; Be++) nt += de[Be];
    t.update(nt, r, 1);
  }
  function N(P, de, me, Ye) {
    if (me === 0) return;
    const nt = e.get("WEBGL_multi_draw");
    if (nt === null)
      for (let Be = 0; Be < P.length; Be++) u(P[Be] / a, de[Be], Ye[Be]);
    else {
      nt.multiDrawElementsInstancedWEBGL(r, de, 0, o, P, 0, Ye, 0, me);
      let Be = 0;
      for (let ot = 0; ot < me; ot++) Be += de[ot] * Ye[ot];
      t.update(Be, r, 1);
    }
  }
  (this.setMode = s),
    (this.setIndex = l),
    (this.render = c),
    (this.renderInstances = u),
    (this.renderMultiDraw = p),
    (this.renderMultiDrawInstances = N);
}
function WebGLInfo(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(o, a, l) {
    switch ((t.calls++, a)) {
      case n.TRIANGLES:
        t.triangles += l * (o / 3);
        break;
      case n.LINES:
        t.lines += l * (o / 2);
        break;
      case n.LINE_STRIP:
        t.lines += l * (o - 1);
        break;
      case n.LINE_LOOP:
        t.lines += l * o;
        break;
      case n.POINTS:
        t.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function s() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: s,
    update: r,
  };
}
function WebGLMorphtargets(n, e, t) {
  const r = new WeakMap(),
    s = new Vector4();
  function o(a, l, c) {
    const u = a.morphTargetInfluences,
      p =
        l.morphAttributes.position ||
        l.morphAttributes.normal ||
        l.morphAttributes.color,
      N = p !== void 0 ? p.length : 0;
    let P = r.get(l);
    if (P === void 0 || P.count !== N) {
      let Ct = function () {
        bt.dispose(), r.delete(l), l.removeEventListener("dispose", Ct);
      };
      var de = Ct;
      P !== void 0 && P.texture.dispose();
      const me = l.morphAttributes.position !== void 0,
        Ye = l.morphAttributes.normal !== void 0,
        nt = l.morphAttributes.color !== void 0,
        Be = l.morphAttributes.position || [],
        ot = l.morphAttributes.normal || [],
        st = l.morphAttributes.color || [];
      let vt = 0;
      me === !0 && (vt = 1), Ye === !0 && (vt = 2), nt === !0 && (vt = 3);
      let xt = l.attributes.position.count * vt,
        St = 1;
      xt > e.maxTextureSize &&
        ((St = Math.ceil(xt / e.maxTextureSize)), (xt = e.maxTextureSize));
      const wt = new Float32Array(xt * St * 4 * N),
        bt = new DataArrayTexture(wt, xt, St, N);
      (bt.type = FloatType), (bt.needsUpdate = !0);
      const Tt = vt * 4;
      for (let kt = 0; kt < N; kt++) {
        const Dt = Be[kt],
          Vt = ot[kt],
          Ht = st[kt],
          qt = xt * St * 4 * kt;
        for (let Ft = 0; Ft < Dt.count; Ft++) {
          const Bt = Ft * Tt;
          me === !0 &&
            (s.fromBufferAttribute(Dt, Ft),
            (wt[qt + Bt + 0] = s.x),
            (wt[qt + Bt + 1] = s.y),
            (wt[qt + Bt + 2] = s.z),
            (wt[qt + Bt + 3] = 0)),
            Ye === !0 &&
              (s.fromBufferAttribute(Vt, Ft),
              (wt[qt + Bt + 4] = s.x),
              (wt[qt + Bt + 5] = s.y),
              (wt[qt + Bt + 6] = s.z),
              (wt[qt + Bt + 7] = 0)),
            nt === !0 &&
              (s.fromBufferAttribute(Ht, Ft),
              (wt[qt + Bt + 8] = s.x),
              (wt[qt + Bt + 9] = s.y),
              (wt[qt + Bt + 10] = s.z),
              (wt[qt + Bt + 11] = Ht.itemSize === 4 ? s.w : 1));
        }
      }
      (P = { count: N, texture: bt, size: new Vector2(xt, St) }),
        r.set(l, P),
        l.addEventListener("dispose", Ct);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      c.getUniforms().setValue(n, "morphTexture", a.morphTexture, t);
    else {
      let me = 0;
      for (let nt = 0; nt < u.length; nt++) me += u[nt];
      const Ye = l.morphTargetsRelative ? 1 : 1 - me;
      c.getUniforms().setValue(n, "morphTargetBaseInfluence", Ye),
        c.getUniforms().setValue(n, "morphTargetInfluences", u);
    }
    c.getUniforms().setValue(n, "morphTargetsTexture", P.texture, t),
      c.getUniforms().setValue(n, "morphTargetsTextureSize", P.size);
  }
  return { update: o };
}
function WebGLObjects(n, e, t, r) {
  let s = new WeakMap();
  function o(c) {
    const u = r.render.frame,
      p = c.geometry,
      N = e.get(c, p);
    if (
      (s.get(N) !== u && (e.update(N), s.set(N, u)),
      c.isInstancedMesh &&
        (c.hasEventListener("dispose", l) === !1 &&
          c.addEventListener("dispose", l),
        s.get(c) !== u &&
          (t.update(c.instanceMatrix, n.ARRAY_BUFFER),
          c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER),
          s.set(c, u))),
      c.isSkinnedMesh)
    ) {
      const P = c.skeleton;
      s.get(P) !== u && (P.update(), s.set(P, u));
    }
    return N;
  }
  function a() {
    s = new WeakMap();
  }
  function l(c) {
    const u = c.target;
    u.removeEventListener("dispose", l),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return { update: o, dispose: a };
}
const emptyTexture = new Texture(),
  emptyShadowTexture = new DepthTexture(1, 1),
  emptyArrayTexture = new DataArrayTexture(),
  empty3dTexture = new Data3DTexture(),
  emptyCubeTexture = new CubeTexture(),
  arrayCacheF32 = [],
  arrayCacheI32 = [],
  mat4array = new Float32Array(16),
  mat3array = new Float32Array(9),
  mat2array = new Float32Array(4);
function flatten(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const s = e * t;
  let o = arrayCacheF32[s];
  if (
    (o === void 0 && ((o = new Float32Array(s)), (arrayCacheF32[s] = o)),
    e !== 0)
  ) {
    r.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a) (l += t), n[a].toArray(o, l);
  }
  return o;
}
function arraysEqual(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function copyArray(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function allocTexUnits(n, e) {
  let t = arrayCacheI32[e];
  t === void 0 && ((t = new Int32Array(e)), (arrayCacheI32[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function setValueV1f(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function setValueV2f(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform2fv(this.addr, e), copyArray(t, e);
  }
}
function setValueV3f(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform3fv(this.addr, e), copyArray(t, e);
  }
}
function setValueV4f(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform4fv(this.addr, e), copyArray(t, e);
  }
}
function setValueM2(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (arraysEqual(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), copyArray(t, e);
  } else {
    if (arraysEqual(t, r)) return;
    mat2array.set(r),
      n.uniformMatrix2fv(this.addr, !1, mat2array),
      copyArray(t, r);
  }
}
function setValueM3(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (arraysEqual(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), copyArray(t, e);
  } else {
    if (arraysEqual(t, r)) return;
    mat3array.set(r),
      n.uniformMatrix3fv(this.addr, !1, mat3array),
      copyArray(t, r);
  }
}
function setValueM4(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (arraysEqual(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), copyArray(t, e);
  } else {
    if (arraysEqual(t, r)) return;
    mat4array.set(r),
      n.uniformMatrix4fv(this.addr, !1, mat4array),
      copyArray(t, r);
  }
}
function setValueV1i(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function setValueV2i(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform2iv(this.addr, e), copyArray(t, e);
  }
}
function setValueV3i(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform3iv(this.addr, e), copyArray(t, e);
  }
}
function setValueV4i(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform4iv(this.addr, e), copyArray(t, e);
  }
}
function setValueV1ui(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function setValueV2ui(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform2uiv(this.addr, e), copyArray(t, e);
  }
}
function setValueV3ui(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform3uiv(this.addr, e), copyArray(t, e);
  }
}
function setValueV4ui(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (arraysEqual(t, e)) return;
    n.uniform4uiv(this.addr, e), copyArray(t, e);
  }
}
function setValueT1(n, e, t) {
  const r = this.cache,
    s = t.allocateTextureUnit();
  r[0] !== s && (n.uniform1i(this.addr, s), (r[0] = s));
  let o;
  this.type === n.SAMPLER_2D_SHADOW
    ? ((emptyShadowTexture.compareFunction = LessEqualCompare),
      (o = emptyShadowTexture))
    : (o = emptyTexture),
    t.setTexture2D(e || o, s);
}
function setValueT3D1(n, e, t) {
  const r = this.cache,
    s = t.allocateTextureUnit();
  r[0] !== s && (n.uniform1i(this.addr, s), (r[0] = s)),
    t.setTexture3D(e || empty3dTexture, s);
}
function setValueT6(n, e, t) {
  const r = this.cache,
    s = t.allocateTextureUnit();
  r[0] !== s && (n.uniform1i(this.addr, s), (r[0] = s)),
    t.setTextureCube(e || emptyCubeTexture, s);
}
function setValueT2DArray1(n, e, t) {
  const r = this.cache,
    s = t.allocateTextureUnit();
  r[0] !== s && (n.uniform1i(this.addr, s), (r[0] = s)),
    t.setTexture2DArray(e || emptyArrayTexture, s);
}
function getSingularSetter(n) {
  switch (n) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(n, e) {
  n.uniform1fv(this.addr, e);
}
function setValueV2fArray(n, e) {
  const t = flatten(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function setValueV3fArray(n, e) {
  const t = flatten(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function setValueV4fArray(n, e) {
  const t = flatten(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function setValueM2Array(n, e) {
  const t = flatten(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function setValueM3Array(n, e) {
  const t = flatten(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function setValueM4Array(n, e) {
  const t = flatten(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function setValueV1iArray(n, e) {
  n.uniform1iv(this.addr, e);
}
function setValueV2iArray(n, e) {
  n.uniform2iv(this.addr, e);
}
function setValueV3iArray(n, e) {
  n.uniform3iv(this.addr, e);
}
function setValueV4iArray(n, e) {
  n.uniform4iv(this.addr, e);
}
function setValueV1uiArray(n, e) {
  n.uniform1uiv(this.addr, e);
}
function setValueV2uiArray(n, e) {
  n.uniform2uiv(this.addr, e);
}
function setValueV3uiArray(n, e) {
  n.uniform3uiv(this.addr, e);
}
function setValueV4uiArray(n, e) {
  n.uniform4uiv(this.addr, e);
}
function setValueT1Array(n, e, t) {
  const r = this.cache,
    s = e.length,
    o = allocTexUnits(t, s);
  arraysEqual(r, o) || (n.uniform1iv(this.addr, o), copyArray(r, o));
  for (let a = 0; a !== s; ++a) t.setTexture2D(e[a] || emptyTexture, o[a]);
}
function setValueT3DArray(n, e, t) {
  const r = this.cache,
    s = e.length,
    o = allocTexUnits(t, s);
  arraysEqual(r, o) || (n.uniform1iv(this.addr, o), copyArray(r, o));
  for (let a = 0; a !== s; ++a) t.setTexture3D(e[a] || empty3dTexture, o[a]);
}
function setValueT6Array(n, e, t) {
  const r = this.cache,
    s = e.length,
    o = allocTexUnits(t, s);
  arraysEqual(r, o) || (n.uniform1iv(this.addr, o), copyArray(r, o));
  for (let a = 0; a !== s; ++a)
    t.setTextureCube(e[a] || emptyCubeTexture, o[a]);
}
function setValueT2DArrayArray(n, e, t) {
  const r = this.cache,
    s = e.length,
    o = allocTexUnits(t, s);
  arraysEqual(r, o) || (n.uniform1iv(this.addr, o), copyArray(r, o));
  for (let a = 0; a !== s; ++a)
    t.setTexture2DArray(e[a] || emptyArrayTexture, o[a]);
}
function getPureArraySetter(n) {
  switch (n) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = getSingularSetter(t.type));
  }
}
class PureArrayUniform {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = getPureArraySetter(t.type));
  }
}
class StructuredUniform {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const s = this.seq;
    for (let o = 0, a = s.length; o !== a; ++o) {
      const l = s[o];
      l.setValue(e, t[l.id], r);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function parseUniform(n, e, t) {
  const r = n.name,
    s = r.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const o = RePathPart.exec(r),
      a = RePathPart.lastIndex;
    let l = o[1];
    const c = o[2] === "]",
      u = o[3];
    if ((c && (l = l | 0), u === void 0 || (u === "[" && a + 2 === s))) {
      addUniform(
        t,
        u === void 0
          ? new SingleUniform(l, n, e)
          : new PureArrayUniform(l, n, e)
      );
      break;
    } else {
      let N = t.map[l];
      N === void 0 && ((N = new StructuredUniform(l)), addUniform(t, N)),
        (t = N);
    }
  }
}
class WebGLUniforms {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < r; ++s) {
      const o = e.getActiveUniform(t, s),
        a = e.getUniformLocation(t, o.name);
      parseUniform(o, a, this);
    }
  }
  setValue(e, t, r, s) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, r, s);
  }
  setOptional(e, t, r) {
    const s = t[r];
    s !== void 0 && this.setValue(e, r, s);
  }
  static upload(e, t, r, s) {
    for (let o = 0, a = t.length; o !== a; ++o) {
      const l = t[o],
        c = r[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, s);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let s = 0, o = e.length; s !== o; ++s) {
      const a = e[s];
      a.id in t && r.push(a);
    }
    return r;
  }
}
function WebGLShader(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(n, e) {
  const t = n.split(`
`),
    r = [],
    s = Math.max(e - 6, 0),
    o = Math.min(e + 6, t.length);
  for (let a = s; a < o; a++) {
    const l = a + 1;
    r.push(`${l === e ? ">" : " "} ${l}: ${t[a]}`);
  }
  return r.join(`
`);
}
const _m0 = new Matrix3();
function getEncodingComponents(n) {
  ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, n);
  const e = `mat3( ${_m0.elements.map((t) => t.toFixed(4))} )`;
  switch (ColorManagement.getTransfer(n)) {
    case LinearTransfer:
      return [e, "LinearTransferOETF"];
    case SRGBTransfer:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", n),
        [e, "LinearTransferOETF"]
      );
  }
}
function getShaderErrors(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    s = n.getShaderInfoLog(e).trim();
  if (r && s === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(s);
  if (o) {
    const a = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      s +
      `

` +
      handleSource(n.getShaderSource(e), a)
    );
  } else return s;
}
function getTexelEncodingFunction(n, e) {
  const t = getEncodingComponents(e);
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function getToneMappingFunction(n, e) {
  let t;
  switch (e) {
    case LinearToneMapping:
      t = "Linear";
      break;
    case ReinhardToneMapping:
      t = "Reinhard";
      break;
    case CineonToneMapping:
      t = "Cineon";
      break;
    case ACESFilmicToneMapping:
      t = "ACESFilmic";
      break;
    case AgXToneMapping:
      t = "AgX";
      break;
    case NeutralToneMapping:
      t = "Neutral";
      break;
    case CustomToneMapping:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const _v0 = new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0);
  const n = _v0.x.toFixed(4),
    e = _v0.y.toFixed(4),
    t = _v0.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function generateVertexExtensions(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(filterEmptyLine).join(`
`);
}
function generateDefines(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function fetchAttributeLocations(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < r; s++) {
    const o = n.getActiveAttrib(e, s),
      a = o.name;
    let l = 1;
    o.type === n.FLOAT_MAT2 && (l = 2),
      o.type === n.FLOAT_MAT3 && (l = 3),
      o.type === n.FLOAT_MAT4 && (l = 4),
      (t[a] = {
        type: o.type,
        location: n.getAttribLocation(e, a),
        locationSize: l,
      });
  }
  return t;
}
function filterEmptyLine(n) {
  return n !== "";
}
function replaceLightNums(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function replaceClippingPlaneNums(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(n) {
  return n.replace(includePattern, includeReplacer);
}
const shaderChunkMap = new Map();
function includeReplacer(n, e) {
  let t = ShaderChunk[e];
  if (t === void 0) {
    const r = shaderChunkMap.get(e);
    if (r !== void 0)
      (t = ShaderChunk[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return resolveIncludes(t);
}
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(n) {
  return n.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(n, e, t, r) {
  let s = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    s += r
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return s;
}
function generatePrecision(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function generateShadowMapTypeDefine(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === PCFShadowMap
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === PCFSoftShadowMap
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function generateEnvMapTypeDefine(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function generateEnvMapModeDefine(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case CubeRefractionMapping:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function generateEnvMapBlendingDefine(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case MultiplyOperation:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function generateCubeUVSize(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function WebGLProgram(n, e, t, r) {
  const s = n.getContext(),
    o = t.defines;
  let a = t.vertexShader,
    l = t.fragmentShader;
  const c = generateShadowMapTypeDefine(t),
    u = generateEnvMapTypeDefine(t),
    p = generateEnvMapModeDefine(t),
    N = generateEnvMapBlendingDefine(t),
    P = generateCubeUVSize(t),
    de = generateVertexExtensions(t),
    me = generateDefines(o),
    Ye = s.createProgram();
  let nt,
    Be,
    ot = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((nt = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        me,
      ].filter(filterEmptyLine).join(`
`)),
      nt.length > 0 &&
        (nt += `
`),
      (Be = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        me,
      ].filter(filterEmptyLine).join(`
`)),
      Be.length > 0 &&
        (Be += `
`))
    : ((nt = [
        generatePrecision(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        me,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + p : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + c : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(filterEmptyLine).join(`
`)),
      (Be = [
        generatePrecision(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        me,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + p : "",
        t.envMap ? "#define " + N : "",
        P ? "#define CUBEUV_TEXEL_WIDTH " + P.texelWidth : "",
        P ? "#define CUBEUV_TEXEL_HEIGHT " + P.texelHeight : "",
        P ? "#define CUBEUV_MAX_MIP " + P.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + c : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        t.toneMapping !== NoToneMapping
          ? ShaderChunk.tonemapping_pars_fragment
          : "",
        t.toneMapping !== NoToneMapping
          ? getToneMappingFunction("toneMapping", t.toneMapping)
          : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        ShaderChunk.colorspace_pars_fragment,
        getTexelEncodingFunction("linearToOutputTexel", t.outputColorSpace),
        getLuminanceFunction(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(filterEmptyLine).join(`
`))),
    (a = resolveIncludes(a)),
    (a = replaceLightNums(a, t)),
    (a = replaceClippingPlaneNums(a, t)),
    (l = resolveIncludes(l)),
    (l = replaceLightNums(l, t)),
    (l = replaceClippingPlaneNums(l, t)),
    (a = unrollLoops(a)),
    (l = unrollLoops(l)),
    t.isRawShaderMaterial !== !0 &&
      ((ot = `#version 300 es
`),
      (nt =
        [
          de,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        nt),
      (Be =
        [
          "#define varying in",
          t.glslVersion === GLSL3
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        Be));
  const st = ot + nt + a,
    vt = ot + Be + l,
    xt = WebGLShader(s, s.VERTEX_SHADER, st),
    St = WebGLShader(s, s.FRAGMENT_SHADER, vt);
  s.attachShader(Ye, xt),
    s.attachShader(Ye, St),
    t.index0AttributeName !== void 0
      ? s.bindAttribLocation(Ye, 0, t.index0AttributeName)
      : t.morphTargets === !0 && s.bindAttribLocation(Ye, 0, "position"),
    s.linkProgram(Ye);
  function wt(kt) {
    if (n.debug.checkShaderErrors) {
      const Dt = s.getProgramInfoLog(Ye).trim(),
        Vt = s.getShaderInfoLog(xt).trim(),
        Ht = s.getShaderInfoLog(St).trim();
      let qt = !0,
        Ft = !0;
      if (s.getProgramParameter(Ye, s.LINK_STATUS) === !1)
        if (((qt = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(s, Ye, xt, St);
        else {
          const Bt = getShaderErrors(s, xt, "vertex"),
            Mt = getShaderErrors(s, St, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              s.getError() +
              " - VALIDATE_STATUS " +
              s.getProgramParameter(Ye, s.VALIDATE_STATUS) +
              `

Material Name: ` +
              kt.name +
              `
Material Type: ` +
              kt.type +
              `

Program Info Log: ` +
              Dt +
              `
` +
              Bt +
              `
` +
              Mt
          );
        }
      else
        Dt !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", Dt)
          : (Vt === "" || Ht === "") && (Ft = !1);
      Ft &&
        (kt.diagnostics = {
          runnable: qt,
          programLog: Dt,
          vertexShader: { log: Vt, prefix: nt },
          fragmentShader: { log: Ht, prefix: Be },
        });
    }
    s.deleteShader(xt),
      s.deleteShader(St),
      (bt = new WebGLUniforms(s, Ye)),
      (Tt = fetchAttributeLocations(s, Ye));
  }
  let bt;
  this.getUniforms = function () {
    return bt === void 0 && wt(this), bt;
  };
  let Tt;
  this.getAttributes = function () {
    return Tt === void 0 && wt(this), Tt;
  };
  let Ct = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return (
        Ct === !1 && (Ct = s.getProgramParameter(Ye, COMPLETION_STATUS_KHR)), Ct
      );
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        s.deleteProgram(Ye),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = programIdCount++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = Ye),
    (this.vertexShader = xt),
    (this.fragmentShader = St),
    this
  );
}
let _id = 0;
class WebGLShaderCache {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      s = this._getShaderStage(t),
      o = this._getShaderStage(r),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      a.has(o) === !1 && (a.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new WebGLShaderStage(e)), t.set(e, r)), r;
  }
}
class WebGLShaderStage {
  constructor(e) {
    (this.id = _id++), (this.code = e), (this.usedTimes = 0);
  }
}
function WebGLPrograms(n, e, t, r, s, o, a) {
  const l = new Layers(),
    c = new WebGLShaderCache(),
    u = new Set(),
    p = [],
    N = s.logarithmicDepthBuffer,
    P = s.vertexTextures;
  let de = s.precision;
  const me = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function Ye(Tt) {
    return u.add(Tt), Tt === 0 ? "uv" : `uv${Tt}`;
  }
  function nt(Tt, Ct, kt, Dt, Vt) {
    const Ht = Dt.fog,
      qt = Vt.geometry,
      Ft = Tt.isMeshStandardMaterial ? Dt.environment : null,
      Bt = (Tt.isMeshStandardMaterial ? t : e).get(Tt.envMap || Ft),
      Mt =
        Bt && Bt.mapping === CubeUVReflectionMapping ? Bt.image.height : null,
      Pt = me[Tt.type];
    Tt.precision !== null &&
      ((de = s.getMaxPrecision(Tt.precision)),
      de !== Tt.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          Tt.precision,
          "not supported, using",
          de,
          "instead."
        ));
    const It =
        qt.morphAttributes.position ||
        qt.morphAttributes.normal ||
        qt.morphAttributes.color,
      Ot = It !== void 0 ? It.length : 0;
    let Xt = 0;
    qt.morphAttributes.position !== void 0 && (Xt = 1),
      qt.morphAttributes.normal !== void 0 && (Xt = 2),
      qt.morphAttributes.color !== void 0 && (Xt = 3);
    let sn, Kt, tn, pn;
    if (Pt) {
      const wr = ShaderLib[Pt];
      (sn = wr.vertexShader), (Kt = wr.fragmentShader);
    } else
      (sn = Tt.vertexShader),
        (Kt = Tt.fragmentShader),
        c.update(Tt),
        (tn = c.getVertexShaderID(Tt)),
        (pn = c.getFragmentShaderID(Tt));
    const _n = n.getRenderTarget(),
      bn = n.state.buffers.depth.getReversed(),
      $n = Vt.isInstancedMesh === !0,
      tr = Vt.isBatchedMesh === !0,
      ur = !!Tt.map,
      _r = !!Tt.matcap,
      Bn = !!Bt,
      jt = !!Tt.aoMap,
      Yn = !!Tt.lightMap,
      zn = !!Tt.bumpMap,
      rn = !!Tt.normalMap,
      In = !!Tt.displacementMap,
      or = !!Tt.emissiveMap,
      Gn = !!Tt.metalnessMap,
      Yt = !!Tt.roughnessMap,
      Gt = Tt.anisotropy > 0,
      hn = Tt.clearcoat > 0,
      En = Tt.dispersion > 0,
      Ln = Tt.iridescence > 0,
      mn = Tt.sheen > 0,
      Vn = Tt.transmission > 0,
      Fn = Gt && !!Tt.anisotropyMap,
      nr = hn && !!Tt.clearcoatMap,
      yr = hn && !!Tt.clearcoatNormalMap,
      qn = hn && !!Tt.clearcoatRoughnessMap,
      jn = Ln && !!Tt.iridescenceMap,
      Jn = Ln && !!Tt.iridescenceThicknessMap,
      mr = mn && !!Tt.sheenColorMap,
      Sr = mn && !!Tt.sheenRoughnessMap,
      Ur = !!Tt.specularMap,
      Pr = !!Tt.specularColorMap,
      Hr = !!Tt.specularIntensityMap,
      cn = Vn && !!Tt.transmissionMap,
      An = Vn && !!Tt.thicknessMap,
      Mn = !!Tt.gradientMap,
      Hn = !!Tt.alphaMap,
      hr = Tt.alphaTest > 0,
      pr = !!Tt.alphaHash,
      jr = !!Tt.extensions;
    let fi = NoToneMapping;
    Tt.toneMapped &&
      (_n === null || _n.isXRRenderTarget === !0) &&
      (fi = n.toneMapping);
    const wi = {
      shaderID: Pt,
      shaderType: Tt.type,
      shaderName: Tt.name,
      vertexShader: sn,
      fragmentShader: Kt,
      defines: Tt.defines,
      customVertexShaderID: tn,
      customFragmentShaderID: pn,
      isRawShaderMaterial: Tt.isRawShaderMaterial === !0,
      glslVersion: Tt.glslVersion,
      precision: de,
      batching: tr,
      batchingColor: tr && Vt._colorsTexture !== null,
      instancing: $n,
      instancingColor: $n && Vt.instanceColor !== null,
      instancingMorph: $n && Vt.morphTexture !== null,
      supportsVertexTextures: P,
      outputColorSpace:
        _n === null
          ? n.outputColorSpace
          : _n.isXRRenderTarget === !0
          ? _n.texture.colorSpace
          : LinearSRGBColorSpace,
      alphaToCoverage: !!Tt.alphaToCoverage,
      map: ur,
      matcap: _r,
      envMap: Bn,
      envMapMode: Bn && Bt.mapping,
      envMapCubeUVHeight: Mt,
      aoMap: jt,
      lightMap: Yn,
      bumpMap: zn,
      normalMap: rn,
      displacementMap: P && In,
      emissiveMap: or,
      normalMapObjectSpace: rn && Tt.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: rn && Tt.normalMapType === TangentSpaceNormalMap,
      metalnessMap: Gn,
      roughnessMap: Yt,
      anisotropy: Gt,
      anisotropyMap: Fn,
      clearcoat: hn,
      clearcoatMap: nr,
      clearcoatNormalMap: yr,
      clearcoatRoughnessMap: qn,
      dispersion: En,
      iridescence: Ln,
      iridescenceMap: jn,
      iridescenceThicknessMap: Jn,
      sheen: mn,
      sheenColorMap: mr,
      sheenRoughnessMap: Sr,
      specularMap: Ur,
      specularColorMap: Pr,
      specularIntensityMap: Hr,
      transmission: Vn,
      transmissionMap: cn,
      thicknessMap: An,
      gradientMap: Mn,
      opaque:
        Tt.transparent === !1 &&
        Tt.blending === NormalBlending &&
        Tt.alphaToCoverage === !1,
      alphaMap: Hn,
      alphaTest: hr,
      alphaHash: pr,
      combine: Tt.combine,
      mapUv: ur && Ye(Tt.map.channel),
      aoMapUv: jt && Ye(Tt.aoMap.channel),
      lightMapUv: Yn && Ye(Tt.lightMap.channel),
      bumpMapUv: zn && Ye(Tt.bumpMap.channel),
      normalMapUv: rn && Ye(Tt.normalMap.channel),
      displacementMapUv: In && Ye(Tt.displacementMap.channel),
      emissiveMapUv: or && Ye(Tt.emissiveMap.channel),
      metalnessMapUv: Gn && Ye(Tt.metalnessMap.channel),
      roughnessMapUv: Yt && Ye(Tt.roughnessMap.channel),
      anisotropyMapUv: Fn && Ye(Tt.anisotropyMap.channel),
      clearcoatMapUv: nr && Ye(Tt.clearcoatMap.channel),
      clearcoatNormalMapUv: yr && Ye(Tt.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: qn && Ye(Tt.clearcoatRoughnessMap.channel),
      iridescenceMapUv: jn && Ye(Tt.iridescenceMap.channel),
      iridescenceThicknessMapUv: Jn && Ye(Tt.iridescenceThicknessMap.channel),
      sheenColorMapUv: mr && Ye(Tt.sheenColorMap.channel),
      sheenRoughnessMapUv: Sr && Ye(Tt.sheenRoughnessMap.channel),
      specularMapUv: Ur && Ye(Tt.specularMap.channel),
      specularColorMapUv: Pr && Ye(Tt.specularColorMap.channel),
      specularIntensityMapUv: Hr && Ye(Tt.specularIntensityMap.channel),
      transmissionMapUv: cn && Ye(Tt.transmissionMap.channel),
      thicknessMapUv: An && Ye(Tt.thicknessMap.channel),
      alphaMapUv: Hn && Ye(Tt.alphaMap.channel),
      vertexTangents: !!qt.attributes.tangent && (rn || Gt),
      vertexColors: Tt.vertexColors,
      vertexAlphas:
        Tt.vertexColors === !0 &&
        !!qt.attributes.color &&
        qt.attributes.color.itemSize === 4,
      pointsUvs: Vt.isPoints === !0 && !!qt.attributes.uv && (ur || Hn),
      fog: !!Ht,
      useFog: Tt.fog === !0,
      fogExp2: !!Ht && Ht.isFogExp2,
      flatShading: Tt.flatShading === !0,
      sizeAttenuation: Tt.sizeAttenuation === !0,
      logarithmicDepthBuffer: N,
      reverseDepthBuffer: bn,
      skinning: Vt.isSkinnedMesh === !0,
      morphTargets: qt.morphAttributes.position !== void 0,
      morphNormals: qt.morphAttributes.normal !== void 0,
      morphColors: qt.morphAttributes.color !== void 0,
      morphTargetsCount: Ot,
      morphTextureStride: Xt,
      numDirLights: Ct.directional.length,
      numPointLights: Ct.point.length,
      numSpotLights: Ct.spot.length,
      numSpotLightMaps: Ct.spotLightMap.length,
      numRectAreaLights: Ct.rectArea.length,
      numHemiLights: Ct.hemi.length,
      numDirLightShadows: Ct.directionalShadowMap.length,
      numPointLightShadows: Ct.pointShadowMap.length,
      numSpotLightShadows: Ct.spotShadowMap.length,
      numSpotLightShadowsWithMaps: Ct.numSpotLightShadowsWithMaps,
      numLightProbes: Ct.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: Tt.dithering,
      shadowMapEnabled: n.shadowMap.enabled && kt.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: fi,
      decodeVideoTexture:
        ur &&
        Tt.map.isVideoTexture === !0 &&
        ColorManagement.getTransfer(Tt.map.colorSpace) === SRGBTransfer,
      decodeVideoTextureEmissive:
        or &&
        Tt.emissiveMap.isVideoTexture === !0 &&
        ColorManagement.getTransfer(Tt.emissiveMap.colorSpace) === SRGBTransfer,
      premultipliedAlpha: Tt.premultipliedAlpha,
      doubleSided: Tt.side === DoubleSide,
      flipSided: Tt.side === BackSide,
      useDepthPacking: Tt.depthPacking >= 0,
      depthPacking: Tt.depthPacking || 0,
      index0AttributeName: Tt.index0AttributeName,
      extensionClipCullDistance:
        jr &&
        Tt.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((jr && Tt.extensions.multiDraw === !0) || tr) &&
        r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: Tt.customProgramCacheKey(),
    };
    return (
      (wi.vertexUv1s = u.has(1)),
      (wi.vertexUv2s = u.has(2)),
      (wi.vertexUv3s = u.has(3)),
      u.clear(),
      wi
    );
  }
  function Be(Tt) {
    const Ct = [];
    if (
      (Tt.shaderID
        ? Ct.push(Tt.shaderID)
        : (Ct.push(Tt.customVertexShaderID),
          Ct.push(Tt.customFragmentShaderID)),
      Tt.defines !== void 0)
    )
      for (const kt in Tt.defines) Ct.push(kt), Ct.push(Tt.defines[kt]);
    return (
      Tt.isRawShaderMaterial === !1 &&
        (ot(Ct, Tt), st(Ct, Tt), Ct.push(n.outputColorSpace)),
      Ct.push(Tt.customProgramCacheKey),
      Ct.join()
    );
  }
  function ot(Tt, Ct) {
    Tt.push(Ct.precision),
      Tt.push(Ct.outputColorSpace),
      Tt.push(Ct.envMapMode),
      Tt.push(Ct.envMapCubeUVHeight),
      Tt.push(Ct.mapUv),
      Tt.push(Ct.alphaMapUv),
      Tt.push(Ct.lightMapUv),
      Tt.push(Ct.aoMapUv),
      Tt.push(Ct.bumpMapUv),
      Tt.push(Ct.normalMapUv),
      Tt.push(Ct.displacementMapUv),
      Tt.push(Ct.emissiveMapUv),
      Tt.push(Ct.metalnessMapUv),
      Tt.push(Ct.roughnessMapUv),
      Tt.push(Ct.anisotropyMapUv),
      Tt.push(Ct.clearcoatMapUv),
      Tt.push(Ct.clearcoatNormalMapUv),
      Tt.push(Ct.clearcoatRoughnessMapUv),
      Tt.push(Ct.iridescenceMapUv),
      Tt.push(Ct.iridescenceThicknessMapUv),
      Tt.push(Ct.sheenColorMapUv),
      Tt.push(Ct.sheenRoughnessMapUv),
      Tt.push(Ct.specularMapUv),
      Tt.push(Ct.specularColorMapUv),
      Tt.push(Ct.specularIntensityMapUv),
      Tt.push(Ct.transmissionMapUv),
      Tt.push(Ct.thicknessMapUv),
      Tt.push(Ct.combine),
      Tt.push(Ct.fogExp2),
      Tt.push(Ct.sizeAttenuation),
      Tt.push(Ct.morphTargetsCount),
      Tt.push(Ct.morphAttributeCount),
      Tt.push(Ct.numDirLights),
      Tt.push(Ct.numPointLights),
      Tt.push(Ct.numSpotLights),
      Tt.push(Ct.numSpotLightMaps),
      Tt.push(Ct.numHemiLights),
      Tt.push(Ct.numRectAreaLights),
      Tt.push(Ct.numDirLightShadows),
      Tt.push(Ct.numPointLightShadows),
      Tt.push(Ct.numSpotLightShadows),
      Tt.push(Ct.numSpotLightShadowsWithMaps),
      Tt.push(Ct.numLightProbes),
      Tt.push(Ct.shadowMapType),
      Tt.push(Ct.toneMapping),
      Tt.push(Ct.numClippingPlanes),
      Tt.push(Ct.numClipIntersection),
      Tt.push(Ct.depthPacking);
  }
  function st(Tt, Ct) {
    l.disableAll(),
      Ct.supportsVertexTextures && l.enable(0),
      Ct.instancing && l.enable(1),
      Ct.instancingColor && l.enable(2),
      Ct.instancingMorph && l.enable(3),
      Ct.matcap && l.enable(4),
      Ct.envMap && l.enable(5),
      Ct.normalMapObjectSpace && l.enable(6),
      Ct.normalMapTangentSpace && l.enable(7),
      Ct.clearcoat && l.enable(8),
      Ct.iridescence && l.enable(9),
      Ct.alphaTest && l.enable(10),
      Ct.vertexColors && l.enable(11),
      Ct.vertexAlphas && l.enable(12),
      Ct.vertexUv1s && l.enable(13),
      Ct.vertexUv2s && l.enable(14),
      Ct.vertexUv3s && l.enable(15),
      Ct.vertexTangents && l.enable(16),
      Ct.anisotropy && l.enable(17),
      Ct.alphaHash && l.enable(18),
      Ct.batching && l.enable(19),
      Ct.dispersion && l.enable(20),
      Ct.batchingColor && l.enable(21),
      Tt.push(l.mask),
      l.disableAll(),
      Ct.fog && l.enable(0),
      Ct.useFog && l.enable(1),
      Ct.flatShading && l.enable(2),
      Ct.logarithmicDepthBuffer && l.enable(3),
      Ct.reverseDepthBuffer && l.enable(4),
      Ct.skinning && l.enable(5),
      Ct.morphTargets && l.enable(6),
      Ct.morphNormals && l.enable(7),
      Ct.morphColors && l.enable(8),
      Ct.premultipliedAlpha && l.enable(9),
      Ct.shadowMapEnabled && l.enable(10),
      Ct.doubleSided && l.enable(11),
      Ct.flipSided && l.enable(12),
      Ct.useDepthPacking && l.enable(13),
      Ct.dithering && l.enable(14),
      Ct.transmission && l.enable(15),
      Ct.sheen && l.enable(16),
      Ct.opaque && l.enable(17),
      Ct.pointsUvs && l.enable(18),
      Ct.decodeVideoTexture && l.enable(19),
      Ct.decodeVideoTextureEmissive && l.enable(20),
      Ct.alphaToCoverage && l.enable(21),
      Tt.push(l.mask);
  }
  function vt(Tt) {
    const Ct = me[Tt.type];
    let kt;
    if (Ct) {
      const Dt = ShaderLib[Ct];
      kt = UniformsUtils.clone(Dt.uniforms);
    } else kt = Tt.uniforms;
    return kt;
  }
  function xt(Tt, Ct) {
    let kt;
    for (let Dt = 0, Vt = p.length; Dt < Vt; Dt++) {
      const Ht = p[Dt];
      if (Ht.cacheKey === Ct) {
        (kt = Ht), ++kt.usedTimes;
        break;
      }
    }
    return (
      kt === void 0 && ((kt = new WebGLProgram(n, Ct, Tt, o)), p.push(kt)), kt
    );
  }
  function St(Tt) {
    if (--Tt.usedTimes === 0) {
      const Ct = p.indexOf(Tt);
      (p[Ct] = p[p.length - 1]), p.pop(), Tt.destroy();
    }
  }
  function wt(Tt) {
    c.remove(Tt);
  }
  function bt() {
    c.dispose();
  }
  return {
    getParameters: nt,
    getProgramCacheKey: Be,
    getUniforms: vt,
    acquireProgram: xt,
    releaseProgram: St,
    releaseShaderCache: wt,
    programs: p,
    dispose: bt,
  };
}
function WebGLProperties() {
  let n = new WeakMap();
  function e(a) {
    return n.has(a);
  }
  function t(a) {
    let l = n.get(a);
    return l === void 0 && ((l = {}), n.set(a, l)), l;
  }
  function r(a) {
    n.delete(a);
  }
  function s(a, l, c) {
    n.get(a)[l] = c;
  }
  function o() {
    n = new WeakMap();
  }
  return { has: e, get: t, remove: r, update: s, dispose: o };
}
function painterSortStable(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function reversePainterSortStable(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function WebGLRenderList() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    s = [];
  function o() {
    (e = 0), (t.length = 0), (r.length = 0), (s.length = 0);
  }
  function a(N, P, de, me, Ye, nt) {
    let Be = n[e];
    return (
      Be === void 0
        ? ((Be = {
            id: N.id,
            object: N,
            geometry: P,
            material: de,
            groupOrder: me,
            renderOrder: N.renderOrder,
            z: Ye,
            group: nt,
          }),
          (n[e] = Be))
        : ((Be.id = N.id),
          (Be.object = N),
          (Be.geometry = P),
          (Be.material = de),
          (Be.groupOrder = me),
          (Be.renderOrder = N.renderOrder),
          (Be.z = Ye),
          (Be.group = nt)),
      e++,
      Be
    );
  }
  function l(N, P, de, me, Ye, nt) {
    const Be = a(N, P, de, me, Ye, nt);
    de.transmission > 0
      ? r.push(Be)
      : de.transparent === !0
      ? s.push(Be)
      : t.push(Be);
  }
  function c(N, P, de, me, Ye, nt) {
    const Be = a(N, P, de, me, Ye, nt);
    de.transmission > 0
      ? r.unshift(Be)
      : de.transparent === !0
      ? s.unshift(Be)
      : t.unshift(Be);
  }
  function u(N, P) {
    t.length > 1 && t.sort(N || painterSortStable),
      r.length > 1 && r.sort(P || reversePainterSortStable),
      s.length > 1 && s.sort(P || reversePainterSortStable);
  }
  function p() {
    for (let N = e, P = n.length; N < P; N++) {
      const de = n[N];
      if (de.id === null) break;
      (de.id = null),
        (de.object = null),
        (de.geometry = null),
        (de.material = null),
        (de.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: s,
    init: o,
    push: l,
    unshift: c,
    finish: p,
    sort: u,
  };
}
function WebGLRenderLists() {
  let n = new WeakMap();
  function e(r, s) {
    const o = n.get(r);
    let a;
    return (
      o === void 0
        ? ((a = new WebGLRenderList()), n.set(r, [a]))
        : s >= o.length
        ? ((a = new WebGLRenderList()), o.push(a))
        : (a = o[s]),
      a
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function UniformsCache() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new Vector3(), color: new Color() };
          break;
        case "SpotLight":
          t = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color(),
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function ShadowUniformsCache() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function WebGLLights(n) {
  const e = new UniformsCache(),
    t = ShadowUniformsCache(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let u = 0; u < 9; u++) r.probe.push(new Vector3());
  const s = new Vector3(),
    o = new Matrix4(),
    a = new Matrix4();
  function l(u) {
    let p = 0,
      N = 0,
      P = 0;
    for (let Tt = 0; Tt < 9; Tt++) r.probe[Tt].set(0, 0, 0);
    let de = 0,
      me = 0,
      Ye = 0,
      nt = 0,
      Be = 0,
      ot = 0,
      st = 0,
      vt = 0,
      xt = 0,
      St = 0,
      wt = 0;
    u.sort(shadowCastingAndTexturingLightsFirst);
    for (let Tt = 0, Ct = u.length; Tt < Ct; Tt++) {
      const kt = u[Tt],
        Dt = kt.color,
        Vt = kt.intensity,
        Ht = kt.distance,
        qt = kt.shadow && kt.shadow.map ? kt.shadow.map.texture : null;
      if (kt.isAmbientLight)
        (p += Dt.r * Vt), (N += Dt.g * Vt), (P += Dt.b * Vt);
      else if (kt.isLightProbe) {
        for (let Ft = 0; Ft < 9; Ft++)
          r.probe[Ft].addScaledVector(kt.sh.coefficients[Ft], Vt);
        wt++;
      } else if (kt.isDirectionalLight) {
        const Ft = e.get(kt);
        if (
          (Ft.color.copy(kt.color).multiplyScalar(kt.intensity), kt.castShadow)
        ) {
          const Bt = kt.shadow,
            Mt = t.get(kt);
          (Mt.shadowIntensity = Bt.intensity),
            (Mt.shadowBias = Bt.bias),
            (Mt.shadowNormalBias = Bt.normalBias),
            (Mt.shadowRadius = Bt.radius),
            (Mt.shadowMapSize = Bt.mapSize),
            (r.directionalShadow[de] = Mt),
            (r.directionalShadowMap[de] = qt),
            (r.directionalShadowMatrix[de] = kt.shadow.matrix),
            ot++;
        }
        (r.directional[de] = Ft), de++;
      } else if (kt.isSpotLight) {
        const Ft = e.get(kt);
        Ft.position.setFromMatrixPosition(kt.matrixWorld),
          Ft.color.copy(Dt).multiplyScalar(Vt),
          (Ft.distance = Ht),
          (Ft.coneCos = Math.cos(kt.angle)),
          (Ft.penumbraCos = Math.cos(kt.angle * (1 - kt.penumbra))),
          (Ft.decay = kt.decay),
          (r.spot[Ye] = Ft);
        const Bt = kt.shadow;
        if (
          (kt.map &&
            ((r.spotLightMap[xt] = kt.map),
            xt++,
            Bt.updateMatrices(kt),
            kt.castShadow && St++),
          (r.spotLightMatrix[Ye] = Bt.matrix),
          kt.castShadow)
        ) {
          const Mt = t.get(kt);
          (Mt.shadowIntensity = Bt.intensity),
            (Mt.shadowBias = Bt.bias),
            (Mt.shadowNormalBias = Bt.normalBias),
            (Mt.shadowRadius = Bt.radius),
            (Mt.shadowMapSize = Bt.mapSize),
            (r.spotShadow[Ye] = Mt),
            (r.spotShadowMap[Ye] = qt),
            vt++;
        }
        Ye++;
      } else if (kt.isRectAreaLight) {
        const Ft = e.get(kt);
        Ft.color.copy(Dt).multiplyScalar(Vt),
          Ft.halfWidth.set(kt.width * 0.5, 0, 0),
          Ft.halfHeight.set(0, kt.height * 0.5, 0),
          (r.rectArea[nt] = Ft),
          nt++;
      } else if (kt.isPointLight) {
        const Ft = e.get(kt);
        if (
          (Ft.color.copy(kt.color).multiplyScalar(kt.intensity),
          (Ft.distance = kt.distance),
          (Ft.decay = kt.decay),
          kt.castShadow)
        ) {
          const Bt = kt.shadow,
            Mt = t.get(kt);
          (Mt.shadowIntensity = Bt.intensity),
            (Mt.shadowBias = Bt.bias),
            (Mt.shadowNormalBias = Bt.normalBias),
            (Mt.shadowRadius = Bt.radius),
            (Mt.shadowMapSize = Bt.mapSize),
            (Mt.shadowCameraNear = Bt.camera.near),
            (Mt.shadowCameraFar = Bt.camera.far),
            (r.pointShadow[me] = Mt),
            (r.pointShadowMap[me] = qt),
            (r.pointShadowMatrix[me] = kt.shadow.matrix),
            st++;
        }
        (r.point[me] = Ft), me++;
      } else if (kt.isHemisphereLight) {
        const Ft = e.get(kt);
        Ft.skyColor.copy(kt.color).multiplyScalar(Vt),
          Ft.groundColor.copy(kt.groundColor).multiplyScalar(Vt),
          (r.hemi[Be] = Ft),
          Be++;
      }
    }
    nt > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1),
          (r.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = UniformsLib.LTC_HALF_1),
          (r.rectAreaLTC2 = UniformsLib.LTC_HALF_2))),
      (r.ambient[0] = p),
      (r.ambient[1] = N),
      (r.ambient[2] = P);
    const bt = r.hash;
    (bt.directionalLength !== de ||
      bt.pointLength !== me ||
      bt.spotLength !== Ye ||
      bt.rectAreaLength !== nt ||
      bt.hemiLength !== Be ||
      bt.numDirectionalShadows !== ot ||
      bt.numPointShadows !== st ||
      bt.numSpotShadows !== vt ||
      bt.numSpotMaps !== xt ||
      bt.numLightProbes !== wt) &&
      ((r.directional.length = de),
      (r.spot.length = Ye),
      (r.rectArea.length = nt),
      (r.point.length = me),
      (r.hemi.length = Be),
      (r.directionalShadow.length = ot),
      (r.directionalShadowMap.length = ot),
      (r.pointShadow.length = st),
      (r.pointShadowMap.length = st),
      (r.spotShadow.length = vt),
      (r.spotShadowMap.length = vt),
      (r.directionalShadowMatrix.length = ot),
      (r.pointShadowMatrix.length = st),
      (r.spotLightMatrix.length = vt + xt - St),
      (r.spotLightMap.length = xt),
      (r.numSpotLightShadowsWithMaps = St),
      (r.numLightProbes = wt),
      (bt.directionalLength = de),
      (bt.pointLength = me),
      (bt.spotLength = Ye),
      (bt.rectAreaLength = nt),
      (bt.hemiLength = Be),
      (bt.numDirectionalShadows = ot),
      (bt.numPointShadows = st),
      (bt.numSpotShadows = vt),
      (bt.numSpotMaps = xt),
      (bt.numLightProbes = wt),
      (r.version = nextVersion++));
  }
  function c(u, p) {
    let N = 0,
      P = 0,
      de = 0,
      me = 0,
      Ye = 0;
    const nt = p.matrixWorldInverse;
    for (let Be = 0, ot = u.length; Be < ot; Be++) {
      const st = u[Be];
      if (st.isDirectionalLight) {
        const vt = r.directional[N];
        vt.direction.setFromMatrixPosition(st.matrixWorld),
          s.setFromMatrixPosition(st.target.matrixWorld),
          vt.direction.sub(s),
          vt.direction.transformDirection(nt),
          N++;
      } else if (st.isSpotLight) {
        const vt = r.spot[de];
        vt.position.setFromMatrixPosition(st.matrixWorld),
          vt.position.applyMatrix4(nt),
          vt.direction.setFromMatrixPosition(st.matrixWorld),
          s.setFromMatrixPosition(st.target.matrixWorld),
          vt.direction.sub(s),
          vt.direction.transformDirection(nt),
          de++;
      } else if (st.isRectAreaLight) {
        const vt = r.rectArea[me];
        vt.position.setFromMatrixPosition(st.matrixWorld),
          vt.position.applyMatrix4(nt),
          a.identity(),
          o.copy(st.matrixWorld),
          o.premultiply(nt),
          a.extractRotation(o),
          vt.halfWidth.set(st.width * 0.5, 0, 0),
          vt.halfHeight.set(0, st.height * 0.5, 0),
          vt.halfWidth.applyMatrix4(a),
          vt.halfHeight.applyMatrix4(a),
          me++;
      } else if (st.isPointLight) {
        const vt = r.point[P];
        vt.position.setFromMatrixPosition(st.matrixWorld),
          vt.position.applyMatrix4(nt),
          P++;
      } else if (st.isHemisphereLight) {
        const vt = r.hemi[Ye];
        vt.direction.setFromMatrixPosition(st.matrixWorld),
          vt.direction.transformDirection(nt),
          Ye++;
      }
    }
  }
  return { setup: l, setupView: c, state: r };
}
function WebGLRenderState(n) {
  const e = new WebGLLights(n),
    t = [],
    r = [];
  function s(p) {
    (u.camera = p), (t.length = 0), (r.length = 0);
  }
  function o(p) {
    t.push(p);
  }
  function a(p) {
    r.push(p);
  }
  function l() {
    e.setup(t);
  }
  function c(p) {
    e.setupView(t, p);
  }
  const u = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: s,
    state: u,
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a,
  };
}
function WebGLRenderStates(n) {
  let e = new WeakMap();
  function t(s, o = 0) {
    const a = e.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new WebGLRenderState(n)), e.set(s, [l]))
        : o >= a.length
        ? ((l = new WebGLRenderState(n)), a.push(l))
        : (l = a[o]),
      l
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: t, dispose: r };
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(n, e, t) {
  let r = new Frustum();
  const s = new Vector2(),
    o = new Vector2(),
    a = new Vector4(),
    l = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
    c = new MeshDistanceMaterial(),
    u = {},
    p = t.maxTextureSize,
    N = {
      [FrontSide]: BackSide,
      [BackSide]: FrontSide,
      [DoubleSide]: DoubleSide,
    },
    P = new ShaderMaterial({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 },
      },
      vertexShader: vertex,
      fragmentShader: fragment,
    }),
    de = P.clone();
  de.defines.HORIZONTAL_PASS = 1;
  const me = new BufferGeometry();
  me.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const Ye = new Mesh(me, P),
    nt = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = PCFShadowMap);
  let Be = this.type;
  this.render = function (St, wt, bt) {
    if (
      nt.enabled === !1 ||
      (nt.autoUpdate === !1 && nt.needsUpdate === !1) ||
      St.length === 0
    )
      return;
    const Tt = n.getRenderTarget(),
      Ct = n.getActiveCubeFace(),
      kt = n.getActiveMipmapLevel(),
      Dt = n.state;
    Dt.setBlending(NoBlending),
      Dt.buffers.color.setClear(1, 1, 1, 1),
      Dt.buffers.depth.setTest(!0),
      Dt.setScissorTest(!1);
    const Vt = Be !== VSMShadowMap && this.type === VSMShadowMap,
      Ht = Be === VSMShadowMap && this.type !== VSMShadowMap;
    for (let qt = 0, Ft = St.length; qt < Ft; qt++) {
      const Bt = St[qt],
        Mt = Bt.shadow;
      if (Mt === void 0) {
        console.warn("THREE.WebGLShadowMap:", Bt, "has no shadow.");
        continue;
      }
      if (Mt.autoUpdate === !1 && Mt.needsUpdate === !1) continue;
      s.copy(Mt.mapSize);
      const Pt = Mt.getFrameExtents();
      if (
        (s.multiply(Pt),
        o.copy(Mt.mapSize),
        (s.x > p || s.y > p) &&
          (s.x > p &&
            ((o.x = Math.floor(p / Pt.x)),
            (s.x = o.x * Pt.x),
            (Mt.mapSize.x = o.x)),
          s.y > p &&
            ((o.y = Math.floor(p / Pt.y)),
            (s.y = o.y * Pt.y),
            (Mt.mapSize.y = o.y))),
        Mt.map === null || Vt === !0 || Ht === !0)
      ) {
        const Ot =
          this.type !== VSMShadowMap
            ? { minFilter: NearestFilter, magFilter: NearestFilter }
            : {};
        Mt.map !== null && Mt.map.dispose(),
          (Mt.map = new WebGLRenderTarget(s.x, s.y, Ot)),
          (Mt.map.texture.name = Bt.name + ".shadowMap"),
          Mt.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(Mt.map), n.clear();
      const It = Mt.getViewportCount();
      for (let Ot = 0; Ot < It; Ot++) {
        const Xt = Mt.getViewport(Ot);
        a.set(o.x * Xt.x, o.y * Xt.y, o.x * Xt.z, o.y * Xt.w),
          Dt.viewport(a),
          Mt.updateMatrices(Bt, Ot),
          (r = Mt.getFrustum()),
          vt(wt, bt, Mt.camera, Bt, this.type);
      }
      Mt.isPointLightShadow !== !0 && this.type === VSMShadowMap && ot(Mt, bt),
        (Mt.needsUpdate = !1);
    }
    (Be = this.type), (nt.needsUpdate = !1), n.setRenderTarget(Tt, Ct, kt);
  };
  function ot(St, wt) {
    const bt = e.update(Ye);
    P.defines.VSM_SAMPLES !== St.blurSamples &&
      ((P.defines.VSM_SAMPLES = St.blurSamples),
      (de.defines.VSM_SAMPLES = St.blurSamples),
      (P.needsUpdate = !0),
      (de.needsUpdate = !0)),
      St.mapPass === null && (St.mapPass = new WebGLRenderTarget(s.x, s.y)),
      (P.uniforms.shadow_pass.value = St.map.texture),
      (P.uniforms.resolution.value = St.mapSize),
      (P.uniforms.radius.value = St.radius),
      n.setRenderTarget(St.mapPass),
      n.clear(),
      n.renderBufferDirect(wt, null, bt, P, Ye, null),
      (de.uniforms.shadow_pass.value = St.mapPass.texture),
      (de.uniforms.resolution.value = St.mapSize),
      (de.uniforms.radius.value = St.radius),
      n.setRenderTarget(St.map),
      n.clear(),
      n.renderBufferDirect(wt, null, bt, de, Ye, null);
  }
  function st(St, wt, bt, Tt) {
    let Ct = null;
    const kt =
      bt.isPointLight === !0
        ? St.customDistanceMaterial
        : St.customDepthMaterial;
    if (kt !== void 0) Ct = kt;
    else if (
      ((Ct = bt.isPointLight === !0 ? c : l),
      (n.localClippingEnabled &&
        wt.clipShadows === !0 &&
        Array.isArray(wt.clippingPlanes) &&
        wt.clippingPlanes.length !== 0) ||
        (wt.displacementMap && wt.displacementScale !== 0) ||
        (wt.alphaMap && wt.alphaTest > 0) ||
        (wt.map && wt.alphaTest > 0) ||
        wt.alphaToCoverage === !0)
    ) {
      const Dt = Ct.uuid,
        Vt = wt.uuid;
      let Ht = u[Dt];
      Ht === void 0 && ((Ht = {}), (u[Dt] = Ht));
      let qt = Ht[Vt];
      qt === void 0 &&
        ((qt = Ct.clone()), (Ht[Vt] = qt), wt.addEventListener("dispose", xt)),
        (Ct = qt);
    }
    if (
      ((Ct.visible = wt.visible),
      (Ct.wireframe = wt.wireframe),
      Tt === VSMShadowMap
        ? (Ct.side = wt.shadowSide !== null ? wt.shadowSide : wt.side)
        : (Ct.side = wt.shadowSide !== null ? wt.shadowSide : N[wt.side]),
      (Ct.alphaMap = wt.alphaMap),
      (Ct.alphaTest = wt.alphaToCoverage === !0 ? 0.5 : wt.alphaTest),
      (Ct.map = wt.map),
      (Ct.clipShadows = wt.clipShadows),
      (Ct.clippingPlanes = wt.clippingPlanes),
      (Ct.clipIntersection = wt.clipIntersection),
      (Ct.displacementMap = wt.displacementMap),
      (Ct.displacementScale = wt.displacementScale),
      (Ct.displacementBias = wt.displacementBias),
      (Ct.wireframeLinewidth = wt.wireframeLinewidth),
      (Ct.linewidth = wt.linewidth),
      bt.isPointLight === !0 && Ct.isMeshDistanceMaterial === !0)
    ) {
      const Dt = n.properties.get(Ct);
      Dt.light = bt;
    }
    return Ct;
  }
  function vt(St, wt, bt, Tt, Ct) {
    if (St.visible === !1) return;
    if (
      St.layers.test(wt.layers) &&
      (St.isMesh || St.isLine || St.isPoints) &&
      (St.castShadow || (St.receiveShadow && Ct === VSMShadowMap)) &&
      (!St.frustumCulled || r.intersectsObject(St))
    ) {
      St.modelViewMatrix.multiplyMatrices(
        bt.matrixWorldInverse,
        St.matrixWorld
      );
      const Vt = e.update(St),
        Ht = St.material;
      if (Array.isArray(Ht)) {
        const qt = Vt.groups;
        for (let Ft = 0, Bt = qt.length; Ft < Bt; Ft++) {
          const Mt = qt[Ft],
            Pt = Ht[Mt.materialIndex];
          if (Pt && Pt.visible) {
            const It = st(St, Pt, Tt, Ct);
            St.onBeforeShadow(n, St, wt, bt, Vt, It, Mt),
              n.renderBufferDirect(bt, null, Vt, It, St, Mt),
              St.onAfterShadow(n, St, wt, bt, Vt, It, Mt);
          }
        }
      } else if (Ht.visible) {
        const qt = st(St, Ht, Tt, Ct);
        St.onBeforeShadow(n, St, wt, bt, Vt, qt, null),
          n.renderBufferDirect(bt, null, Vt, qt, St, null),
          St.onAfterShadow(n, St, wt, bt, Vt, qt, null);
      }
    }
    const Dt = St.children;
    for (let Vt = 0, Ht = Dt.length; Vt < Ht; Vt++) vt(Dt[Vt], wt, bt, Tt, Ct);
  }
  function xt(St) {
    St.target.removeEventListener("dispose", xt);
    for (const bt in u) {
      const Tt = u[bt],
        Ct = St.target.uuid;
      Ct in Tt && (Tt[Ct].dispose(), delete Tt[Ct]);
    }
  }
}
const reversedFuncs = {
  [NeverDepth]: AlwaysDepth,
  [LessDepth]: GreaterDepth,
  [EqualDepth]: NotEqualDepth,
  [LessEqualDepth]: GreaterEqualDepth,
  [AlwaysDepth]: NeverDepth,
  [GreaterDepth]: LessDepth,
  [NotEqualDepth]: EqualDepth,
  [GreaterEqualDepth]: LessEqualDepth,
};
function WebGLState(n, e) {
  function t() {
    let cn = !1;
    const An = new Vector4();
    let Mn = null;
    const Hn = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (hr) {
        Mn !== hr && !cn && (n.colorMask(hr, hr, hr, hr), (Mn = hr));
      },
      setLocked: function (hr) {
        cn = hr;
      },
      setClear: function (hr, pr, jr, fi, wi) {
        wi === !0 && ((hr *= fi), (pr *= fi), (jr *= fi)),
          An.set(hr, pr, jr, fi),
          Hn.equals(An) === !1 && (n.clearColor(hr, pr, jr, fi), Hn.copy(An));
      },
      reset: function () {
        (cn = !1), (Mn = null), Hn.set(-1, 0, 0, 0);
      },
    };
  }
  function r() {
    let cn = !1,
      An = !1,
      Mn = null,
      Hn = null,
      hr = null;
    return {
      setReversed: function (pr) {
        if (An !== pr) {
          const jr = e.get("EXT_clip_control");
          pr
            ? jr.clipControlEXT(jr.LOWER_LEFT_EXT, jr.ZERO_TO_ONE_EXT)
            : jr.clipControlEXT(jr.LOWER_LEFT_EXT, jr.NEGATIVE_ONE_TO_ONE_EXT),
            (An = pr);
          const fi = hr;
          (hr = null), this.setClear(fi);
        }
      },
      getReversed: function () {
        return An;
      },
      setTest: function (pr) {
        pr ? _n(n.DEPTH_TEST) : bn(n.DEPTH_TEST);
      },
      setMask: function (pr) {
        Mn !== pr && !cn && (n.depthMask(pr), (Mn = pr));
      },
      setFunc: function (pr) {
        if ((An && (pr = reversedFuncs[pr]), Hn !== pr)) {
          switch (pr) {
            case NeverDepth:
              n.depthFunc(n.NEVER);
              break;
            case AlwaysDepth:
              n.depthFunc(n.ALWAYS);
              break;
            case LessDepth:
              n.depthFunc(n.LESS);
              break;
            case LessEqualDepth:
              n.depthFunc(n.LEQUAL);
              break;
            case EqualDepth:
              n.depthFunc(n.EQUAL);
              break;
            case GreaterEqualDepth:
              n.depthFunc(n.GEQUAL);
              break;
            case GreaterDepth:
              n.depthFunc(n.GREATER);
              break;
            case NotEqualDepth:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Hn = pr;
        }
      },
      setLocked: function (pr) {
        cn = pr;
      },
      setClear: function (pr) {
        hr !== pr && (An && (pr = 1 - pr), n.clearDepth(pr), (hr = pr));
      },
      reset: function () {
        (cn = !1), (Mn = null), (Hn = null), (hr = null), (An = !1);
      },
    };
  }
  function s() {
    let cn = !1,
      An = null,
      Mn = null,
      Hn = null,
      hr = null,
      pr = null,
      jr = null,
      fi = null,
      wi = null;
    return {
      setTest: function (wr) {
        cn || (wr ? _n(n.STENCIL_TEST) : bn(n.STENCIL_TEST));
      },
      setMask: function (wr) {
        An !== wr && !cn && (n.stencilMask(wr), (An = wr));
      },
      setFunc: function (wr, Rr, $r) {
        (Mn !== wr || Hn !== Rr || hr !== $r) &&
          (n.stencilFunc(wr, Rr, $r), (Mn = wr), (Hn = Rr), (hr = $r));
      },
      setOp: function (wr, Rr, $r) {
        (pr !== wr || jr !== Rr || fi !== $r) &&
          (n.stencilOp(wr, Rr, $r), (pr = wr), (jr = Rr), (fi = $r));
      },
      setLocked: function (wr) {
        cn = wr;
      },
      setClear: function (wr) {
        wi !== wr && (n.clearStencil(wr), (wi = wr));
      },
      reset: function () {
        (cn = !1),
          (An = null),
          (Mn = null),
          (Hn = null),
          (hr = null),
          (pr = null),
          (jr = null),
          (fi = null),
          (wi = null);
      },
    };
  }
  const o = new t(),
    a = new r(),
    l = new s(),
    c = new WeakMap(),
    u = new WeakMap();
  let p = {},
    N = {},
    P = new WeakMap(),
    de = [],
    me = null,
    Ye = !1,
    nt = null,
    Be = null,
    ot = null,
    st = null,
    vt = null,
    xt = null,
    St = null,
    wt = new Color(0, 0, 0),
    bt = 0,
    Tt = !1,
    Ct = null,
    kt = null,
    Dt = null,
    Vt = null,
    Ht = null;
  const qt = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Ft = !1,
    Bt = 0;
  const Mt = n.getParameter(n.VERSION);
  Mt.indexOf("WebGL") !== -1
    ? ((Bt = parseFloat(/^WebGL (\d)/.exec(Mt)[1])), (Ft = Bt >= 1))
    : Mt.indexOf("OpenGL ES") !== -1 &&
      ((Bt = parseFloat(/^OpenGL ES (\d)/.exec(Mt)[1])), (Ft = Bt >= 2));
  let Pt = null,
    It = {};
  const Ot = n.getParameter(n.SCISSOR_BOX),
    Xt = n.getParameter(n.VIEWPORT),
    sn = new Vector4().fromArray(Ot),
    Kt = new Vector4().fromArray(Xt);
  function tn(cn, An, Mn, Hn) {
    const hr = new Uint8Array(4),
      pr = n.createTexture();
    n.bindTexture(cn, pr),
      n.texParameteri(cn, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(cn, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let jr = 0; jr < Mn; jr++)
      cn === n.TEXTURE_3D || cn === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(An, 0, n.RGBA, 1, 1, Hn, 0, n.RGBA, n.UNSIGNED_BYTE, hr)
        : n.texImage2D(
            An + jr,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            hr
          );
    return pr;
  }
  const pn = {};
  (pn[n.TEXTURE_2D] = tn(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (pn[n.TEXTURE_CUBE_MAP] = tn(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (pn[n.TEXTURE_2D_ARRAY] = tn(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (pn[n.TEXTURE_3D] = tn(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    o.setClear(0, 0, 0, 1),
    a.setClear(1),
    l.setClear(0),
    _n(n.DEPTH_TEST),
    a.setFunc(LessEqualDepth),
    zn(!1),
    rn(CullFaceBack),
    _n(n.CULL_FACE),
    jt(NoBlending);
  function _n(cn) {
    p[cn] !== !0 && (n.enable(cn), (p[cn] = !0));
  }
  function bn(cn) {
    p[cn] !== !1 && (n.disable(cn), (p[cn] = !1));
  }
  function $n(cn, An) {
    return N[cn] !== An
      ? (n.bindFramebuffer(cn, An),
        (N[cn] = An),
        cn === n.DRAW_FRAMEBUFFER && (N[n.FRAMEBUFFER] = An),
        cn === n.FRAMEBUFFER && (N[n.DRAW_FRAMEBUFFER] = An),
        !0)
      : !1;
  }
  function tr(cn, An) {
    let Mn = de,
      Hn = !1;
    if (cn) {
      (Mn = P.get(An)), Mn === void 0 && ((Mn = []), P.set(An, Mn));
      const hr = cn.textures;
      if (Mn.length !== hr.length || Mn[0] !== n.COLOR_ATTACHMENT0) {
        for (let pr = 0, jr = hr.length; pr < jr; pr++)
          Mn[pr] = n.COLOR_ATTACHMENT0 + pr;
        (Mn.length = hr.length), (Hn = !0);
      }
    } else Mn[0] !== n.BACK && ((Mn[0] = n.BACK), (Hn = !0));
    Hn && n.drawBuffers(Mn);
  }
  function ur(cn) {
    return me !== cn ? (n.useProgram(cn), (me = cn), !0) : !1;
  }
  const _r = {
    [AddEquation]: n.FUNC_ADD,
    [SubtractEquation]: n.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: n.FUNC_REVERSE_SUBTRACT,
  };
  (_r[MinEquation] = n.MIN), (_r[MaxEquation] = n.MAX);
  const Bn = {
    [ZeroFactor]: n.ZERO,
    [OneFactor]: n.ONE,
    [SrcColorFactor]: n.SRC_COLOR,
    [SrcAlphaFactor]: n.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: n.SRC_ALPHA_SATURATE,
    [DstColorFactor]: n.DST_COLOR,
    [DstAlphaFactor]: n.DST_ALPHA,
    [OneMinusSrcColorFactor]: n.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: n.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: n.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: n.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: n.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: n.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: n.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function jt(cn, An, Mn, Hn, hr, pr, jr, fi, wi, wr) {
    if (cn === NoBlending) {
      Ye === !0 && (bn(n.BLEND), (Ye = !1));
      return;
    }
    if ((Ye === !1 && (_n(n.BLEND), (Ye = !0)), cn !== CustomBlending)) {
      if (cn !== nt || wr !== Tt) {
        if (
          ((Be !== AddEquation || vt !== AddEquation) &&
            (n.blendEquation(n.FUNC_ADD),
            (Be = AddEquation),
            (vt = AddEquation)),
          wr)
        )
          switch (cn) {
            case NormalBlending:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case SubtractiveBlending:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case MultiplyBlending:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", cn);
              break;
          }
        else
          switch (cn) {
            case NormalBlending:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case SubtractiveBlending:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case MultiplyBlending:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", cn);
              break;
          }
        (ot = null),
          (st = null),
          (xt = null),
          (St = null),
          wt.set(0, 0, 0),
          (bt = 0),
          (nt = cn),
          (Tt = wr);
      }
      return;
    }
    (hr = hr || An),
      (pr = pr || Mn),
      (jr = jr || Hn),
      (An !== Be || hr !== vt) &&
        (n.blendEquationSeparate(_r[An], _r[hr]), (Be = An), (vt = hr)),
      (Mn !== ot || Hn !== st || pr !== xt || jr !== St) &&
        (n.blendFuncSeparate(Bn[Mn], Bn[Hn], Bn[pr], Bn[jr]),
        (ot = Mn),
        (st = Hn),
        (xt = pr),
        (St = jr)),
      (fi.equals(wt) === !1 || wi !== bt) &&
        (n.blendColor(fi.r, fi.g, fi.b, wi), wt.copy(fi), (bt = wi)),
      (nt = cn),
      (Tt = !1);
  }
  function Yn(cn, An) {
    cn.side === DoubleSide ? bn(n.CULL_FACE) : _n(n.CULL_FACE);
    let Mn = cn.side === BackSide;
    An && (Mn = !Mn),
      zn(Mn),
      cn.blending === NormalBlending && cn.transparent === !1
        ? jt(NoBlending)
        : jt(
            cn.blending,
            cn.blendEquation,
            cn.blendSrc,
            cn.blendDst,
            cn.blendEquationAlpha,
            cn.blendSrcAlpha,
            cn.blendDstAlpha,
            cn.blendColor,
            cn.blendAlpha,
            cn.premultipliedAlpha
          ),
      a.setFunc(cn.depthFunc),
      a.setTest(cn.depthTest),
      a.setMask(cn.depthWrite),
      o.setMask(cn.colorWrite);
    const Hn = cn.stencilWrite;
    l.setTest(Hn),
      Hn &&
        (l.setMask(cn.stencilWriteMask),
        l.setFunc(cn.stencilFunc, cn.stencilRef, cn.stencilFuncMask),
        l.setOp(cn.stencilFail, cn.stencilZFail, cn.stencilZPass)),
      or(cn.polygonOffset, cn.polygonOffsetFactor, cn.polygonOffsetUnits),
      cn.alphaToCoverage === !0
        ? _n(n.SAMPLE_ALPHA_TO_COVERAGE)
        : bn(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function zn(cn) {
    Ct !== cn && (cn ? n.frontFace(n.CW) : n.frontFace(n.CCW), (Ct = cn));
  }
  function rn(cn) {
    cn !== CullFaceNone
      ? (_n(n.CULL_FACE),
        cn !== kt &&
          (cn === CullFaceBack
            ? n.cullFace(n.BACK)
            : cn === CullFaceFront
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : bn(n.CULL_FACE),
      (kt = cn);
  }
  function In(cn) {
    cn !== Dt && (Ft && n.lineWidth(cn), (Dt = cn));
  }
  function or(cn, An, Mn) {
    cn
      ? (_n(n.POLYGON_OFFSET_FILL),
        (Vt !== An || Ht !== Mn) &&
          (n.polygonOffset(An, Mn), (Vt = An), (Ht = Mn)))
      : bn(n.POLYGON_OFFSET_FILL);
  }
  function Gn(cn) {
    cn ? _n(n.SCISSOR_TEST) : bn(n.SCISSOR_TEST);
  }
  function Yt(cn) {
    cn === void 0 && (cn = n.TEXTURE0 + qt - 1),
      Pt !== cn && (n.activeTexture(cn), (Pt = cn));
  }
  function Gt(cn, An, Mn) {
    Mn === void 0 && (Pt === null ? (Mn = n.TEXTURE0 + qt - 1) : (Mn = Pt));
    let Hn = It[Mn];
    Hn === void 0 && ((Hn = { type: void 0, texture: void 0 }), (It[Mn] = Hn)),
      (Hn.type !== cn || Hn.texture !== An) &&
        (Pt !== Mn && (n.activeTexture(Mn), (Pt = Mn)),
        n.bindTexture(cn, An || pn[cn]),
        (Hn.type = cn),
        (Hn.texture = An));
  }
  function hn() {
    const cn = It[Pt];
    cn !== void 0 &&
      cn.type !== void 0 &&
      (n.bindTexture(cn.type, null), (cn.type = void 0), (cn.texture = void 0));
  }
  function En() {
    try {
      n.compressedTexImage2D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function Ln() {
    try {
      n.compressedTexImage3D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function mn() {
    try {
      n.texSubImage2D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function Vn() {
    try {
      n.texSubImage3D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function Fn() {
    try {
      n.compressedTexSubImage2D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function nr() {
    try {
      n.compressedTexSubImage3D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function yr() {
    try {
      n.texStorage2D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function qn() {
    try {
      n.texStorage3D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function jn() {
    try {
      n.texImage2D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function Jn() {
    try {
      n.texImage3D(...arguments);
    } catch (cn) {
      console.error("THREE.WebGLState:", cn);
    }
  }
  function mr(cn) {
    sn.equals(cn) === !1 && (n.scissor(cn.x, cn.y, cn.z, cn.w), sn.copy(cn));
  }
  function Sr(cn) {
    Kt.equals(cn) === !1 && (n.viewport(cn.x, cn.y, cn.z, cn.w), Kt.copy(cn));
  }
  function Ur(cn, An) {
    let Mn = u.get(An);
    Mn === void 0 && ((Mn = new WeakMap()), u.set(An, Mn));
    let Hn = Mn.get(cn);
    Hn === void 0 &&
      ((Hn = n.getUniformBlockIndex(An, cn.name)), Mn.set(cn, Hn));
  }
  function Pr(cn, An) {
    const Hn = u.get(An).get(cn);
    c.get(An) !== Hn &&
      (n.uniformBlockBinding(An, Hn, cn.__bindingPointIndex), c.set(An, Hn));
  }
  function Hr() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      a.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (p = {}),
      (Pt = null),
      (It = {}),
      (N = {}),
      (P = new WeakMap()),
      (de = []),
      (me = null),
      (Ye = !1),
      (nt = null),
      (Be = null),
      (ot = null),
      (st = null),
      (vt = null),
      (xt = null),
      (St = null),
      (wt = new Color(0, 0, 0)),
      (bt = 0),
      (Tt = !1),
      (Ct = null),
      (kt = null),
      (Dt = null),
      (Vt = null),
      (Ht = null),
      sn.set(0, 0, n.canvas.width, n.canvas.height),
      Kt.set(0, 0, n.canvas.width, n.canvas.height),
      o.reset(),
      a.reset(),
      l.reset();
  }
  return {
    buffers: { color: o, depth: a, stencil: l },
    enable: _n,
    disable: bn,
    bindFramebuffer: $n,
    drawBuffers: tr,
    useProgram: ur,
    setBlending: jt,
    setMaterial: Yn,
    setFlipSided: zn,
    setCullFace: rn,
    setLineWidth: In,
    setPolygonOffset: or,
    setScissorTest: Gn,
    activeTexture: Yt,
    bindTexture: Gt,
    unbindTexture: hn,
    compressedTexImage2D: En,
    compressedTexImage3D: Ln,
    texImage2D: jn,
    texImage3D: Jn,
    updateUBOMapping: Ur,
    uniformBlockBinding: Pr,
    texStorage2D: yr,
    texStorage3D: qn,
    texSubImage2D: mn,
    texSubImage3D: Vn,
    compressedTexSubImage2D: Fn,
    compressedTexSubImage3D: nr,
    scissor: mr,
    viewport: Sr,
    reset: Hr,
  };
}
function WebGLTextures(n, e, t, r, s, o, a) {
  const l = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    c =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    u = new Vector2(),
    p = new WeakMap();
  let N;
  const P = new WeakMap();
  let de = !1;
  try {
    de =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function me(Yt, Gt) {
    return de ? new OffscreenCanvas(Yt, Gt) : createElementNS("canvas");
  }
  function Ye(Yt, Gt, hn) {
    let En = 1;
    const Ln = Gn(Yt);
    if (
      ((Ln.width > hn || Ln.height > hn) &&
        (En = hn / Math.max(Ln.width, Ln.height)),
      En < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && Yt instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && Yt instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && Yt instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && Yt instanceof VideoFrame)
      ) {
        const mn = Math.floor(En * Ln.width),
          Vn = Math.floor(En * Ln.height);
        N === void 0 && (N = me(mn, Vn));
        const Fn = Gt ? me(mn, Vn) : N;
        return (
          (Fn.width = mn),
          (Fn.height = Vn),
          Fn.getContext("2d").drawImage(Yt, 0, 0, mn, Vn),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              Ln.width +
              "x" +
              Ln.height +
              ") to (" +
              mn +
              "x" +
              Vn +
              ")."
          ),
          Fn
        );
      } else
        return (
          "data" in Yt &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                Ln.width +
                "x" +
                Ln.height +
                ")."
            ),
          Yt
        );
    return Yt;
  }
  function nt(Yt) {
    return Yt.generateMipmaps;
  }
  function Be(Yt) {
    n.generateMipmap(Yt);
  }
  function ot(Yt) {
    return Yt.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : Yt.isWebGL3DRenderTarget
      ? n.TEXTURE_3D
      : Yt.isWebGLArrayRenderTarget || Yt.isCompressedArrayTexture
      ? n.TEXTURE_2D_ARRAY
      : n.TEXTURE_2D;
  }
  function st(Yt, Gt, hn, En, Ln = !1) {
    if (Yt !== null) {
      if (n[Yt] !== void 0) return n[Yt];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          Yt +
          "'"
      );
    }
    let mn = Gt;
    if (
      (Gt === n.RED &&
        (hn === n.FLOAT && (mn = n.R32F),
        hn === n.HALF_FLOAT && (mn = n.R16F),
        hn === n.UNSIGNED_BYTE && (mn = n.R8)),
      Gt === n.RED_INTEGER &&
        (hn === n.UNSIGNED_BYTE && (mn = n.R8UI),
        hn === n.UNSIGNED_SHORT && (mn = n.R16UI),
        hn === n.UNSIGNED_INT && (mn = n.R32UI),
        hn === n.BYTE && (mn = n.R8I),
        hn === n.SHORT && (mn = n.R16I),
        hn === n.INT && (mn = n.R32I)),
      Gt === n.RG &&
        (hn === n.FLOAT && (mn = n.RG32F),
        hn === n.HALF_FLOAT && (mn = n.RG16F),
        hn === n.UNSIGNED_BYTE && (mn = n.RG8)),
      Gt === n.RG_INTEGER &&
        (hn === n.UNSIGNED_BYTE && (mn = n.RG8UI),
        hn === n.UNSIGNED_SHORT && (mn = n.RG16UI),
        hn === n.UNSIGNED_INT && (mn = n.RG32UI),
        hn === n.BYTE && (mn = n.RG8I),
        hn === n.SHORT && (mn = n.RG16I),
        hn === n.INT && (mn = n.RG32I)),
      Gt === n.RGB_INTEGER &&
        (hn === n.UNSIGNED_BYTE && (mn = n.RGB8UI),
        hn === n.UNSIGNED_SHORT && (mn = n.RGB16UI),
        hn === n.UNSIGNED_INT && (mn = n.RGB32UI),
        hn === n.BYTE && (mn = n.RGB8I),
        hn === n.SHORT && (mn = n.RGB16I),
        hn === n.INT && (mn = n.RGB32I)),
      Gt === n.RGBA_INTEGER &&
        (hn === n.UNSIGNED_BYTE && (mn = n.RGBA8UI),
        hn === n.UNSIGNED_SHORT && (mn = n.RGBA16UI),
        hn === n.UNSIGNED_INT && (mn = n.RGBA32UI),
        hn === n.BYTE && (mn = n.RGBA8I),
        hn === n.SHORT && (mn = n.RGBA16I),
        hn === n.INT && (mn = n.RGBA32I)),
      Gt === n.RGB && hn === n.UNSIGNED_INT_5_9_9_9_REV && (mn = n.RGB9_E5),
      Gt === n.RGBA)
    ) {
      const Vn = Ln ? LinearTransfer : ColorManagement.getTransfer(En);
      hn === n.FLOAT && (mn = n.RGBA32F),
        hn === n.HALF_FLOAT && (mn = n.RGBA16F),
        hn === n.UNSIGNED_BYTE &&
          (mn = Vn === SRGBTransfer ? n.SRGB8_ALPHA8 : n.RGBA8),
        hn === n.UNSIGNED_SHORT_4_4_4_4 && (mn = n.RGBA4),
        hn === n.UNSIGNED_SHORT_5_5_5_1 && (mn = n.RGB5_A1);
    }
    return (
      (mn === n.R16F ||
        mn === n.R32F ||
        mn === n.RG16F ||
        mn === n.RG32F ||
        mn === n.RGBA16F ||
        mn === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      mn
    );
  }
  function vt(Yt, Gt) {
    let hn;
    return (
      Yt
        ? Gt === null || Gt === UnsignedIntType || Gt === UnsignedInt248Type
          ? (hn = n.DEPTH24_STENCIL8)
          : Gt === FloatType
          ? (hn = n.DEPTH32F_STENCIL8)
          : Gt === UnsignedShortType &&
            ((hn = n.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : Gt === null || Gt === UnsignedIntType || Gt === UnsignedInt248Type
        ? (hn = n.DEPTH_COMPONENT24)
        : Gt === FloatType
        ? (hn = n.DEPTH_COMPONENT32F)
        : Gt === UnsignedShortType && (hn = n.DEPTH_COMPONENT16),
      hn
    );
  }
  function xt(Yt, Gt) {
    return nt(Yt) === !0 ||
      (Yt.isFramebufferTexture &&
        Yt.minFilter !== NearestFilter &&
        Yt.minFilter !== LinearFilter)
      ? Math.log2(Math.max(Gt.width, Gt.height)) + 1
      : Yt.mipmaps !== void 0 && Yt.mipmaps.length > 0
      ? Yt.mipmaps.length
      : Yt.isCompressedTexture && Array.isArray(Yt.image)
      ? Gt.mipmaps.length
      : 1;
  }
  function St(Yt) {
    const Gt = Yt.target;
    Gt.removeEventListener("dispose", St),
      bt(Gt),
      Gt.isVideoTexture && p.delete(Gt);
  }
  function wt(Yt) {
    const Gt = Yt.target;
    Gt.removeEventListener("dispose", wt), Ct(Gt);
  }
  function bt(Yt) {
    const Gt = r.get(Yt);
    if (Gt.__webglInit === void 0) return;
    const hn = Yt.source,
      En = P.get(hn);
    if (En) {
      const Ln = En[Gt.__cacheKey];
      Ln.usedTimes--,
        Ln.usedTimes === 0 && Tt(Yt),
        Object.keys(En).length === 0 && P.delete(hn);
    }
    r.remove(Yt);
  }
  function Tt(Yt) {
    const Gt = r.get(Yt);
    n.deleteTexture(Gt.__webglTexture);
    const hn = Yt.source,
      En = P.get(hn);
    delete En[Gt.__cacheKey], a.memory.textures--;
  }
  function Ct(Yt) {
    const Gt = r.get(Yt);
    if (
      (Yt.depthTexture &&
        (Yt.depthTexture.dispose(), r.remove(Yt.depthTexture)),
      Yt.isWebGLCubeRenderTarget)
    )
      for (let En = 0; En < 6; En++) {
        if (Array.isArray(Gt.__webglFramebuffer[En]))
          for (let Ln = 0; Ln < Gt.__webglFramebuffer[En].length; Ln++)
            n.deleteFramebuffer(Gt.__webglFramebuffer[En][Ln]);
        else n.deleteFramebuffer(Gt.__webglFramebuffer[En]);
        Gt.__webglDepthbuffer &&
          n.deleteRenderbuffer(Gt.__webglDepthbuffer[En]);
      }
    else {
      if (Array.isArray(Gt.__webglFramebuffer))
        for (let En = 0; En < Gt.__webglFramebuffer.length; En++)
          n.deleteFramebuffer(Gt.__webglFramebuffer[En]);
      else n.deleteFramebuffer(Gt.__webglFramebuffer);
      if (
        (Gt.__webglDepthbuffer && n.deleteRenderbuffer(Gt.__webglDepthbuffer),
        Gt.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(Gt.__webglMultisampledFramebuffer),
        Gt.__webglColorRenderbuffer)
      )
        for (let En = 0; En < Gt.__webglColorRenderbuffer.length; En++)
          Gt.__webglColorRenderbuffer[En] &&
            n.deleteRenderbuffer(Gt.__webglColorRenderbuffer[En]);
      Gt.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(Gt.__webglDepthRenderbuffer);
    }
    const hn = Yt.textures;
    for (let En = 0, Ln = hn.length; En < Ln; En++) {
      const mn = r.get(hn[En]);
      mn.__webglTexture &&
        (n.deleteTexture(mn.__webglTexture), a.memory.textures--),
        r.remove(hn[En]);
    }
    r.remove(Yt);
  }
  let kt = 0;
  function Dt() {
    kt = 0;
  }
  function Vt() {
    const Yt = kt;
    return (
      Yt >= s.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            Yt +
            " texture units while this GPU supports only " +
            s.maxTextures
        ),
      (kt += 1),
      Yt
    );
  }
  function Ht(Yt) {
    const Gt = [];
    return (
      Gt.push(Yt.wrapS),
      Gt.push(Yt.wrapT),
      Gt.push(Yt.wrapR || 0),
      Gt.push(Yt.magFilter),
      Gt.push(Yt.minFilter),
      Gt.push(Yt.anisotropy),
      Gt.push(Yt.internalFormat),
      Gt.push(Yt.format),
      Gt.push(Yt.type),
      Gt.push(Yt.generateMipmaps),
      Gt.push(Yt.premultiplyAlpha),
      Gt.push(Yt.flipY),
      Gt.push(Yt.unpackAlignment),
      Gt.push(Yt.colorSpace),
      Gt.join()
    );
  }
  function qt(Yt, Gt) {
    const hn = r.get(Yt);
    if (
      (Yt.isVideoTexture && In(Yt),
      Yt.isRenderTargetTexture === !1 &&
        Yt.version > 0 &&
        hn.__version !== Yt.version)
    ) {
      const En = Yt.image;
      if (En === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (En.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Kt(hn, Yt, Gt);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, hn.__webglTexture, n.TEXTURE0 + Gt);
  }
  function Ft(Yt, Gt) {
    const hn = r.get(Yt);
    if (Yt.version > 0 && hn.__version !== Yt.version) {
      Kt(hn, Yt, Gt);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, hn.__webglTexture, n.TEXTURE0 + Gt);
  }
  function Bt(Yt, Gt) {
    const hn = r.get(Yt);
    if (Yt.version > 0 && hn.__version !== Yt.version) {
      Kt(hn, Yt, Gt);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, hn.__webglTexture, n.TEXTURE0 + Gt);
  }
  function Mt(Yt, Gt) {
    const hn = r.get(Yt);
    if (Yt.version > 0 && hn.__version !== Yt.version) {
      tn(hn, Yt, Gt);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, hn.__webglTexture, n.TEXTURE0 + Gt);
  }
  const Pt = {
      [RepeatWrapping]: n.REPEAT,
      [ClampToEdgeWrapping]: n.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: n.MIRRORED_REPEAT,
    },
    It = {
      [NearestFilter]: n.NEAREST,
      [NearestMipmapNearestFilter]: n.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: n.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: n.LINEAR,
      [LinearMipmapNearestFilter]: n.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: n.LINEAR_MIPMAP_LINEAR,
    },
    Ot = {
      [NeverCompare]: n.NEVER,
      [AlwaysCompare]: n.ALWAYS,
      [LessCompare]: n.LESS,
      [LessEqualCompare]: n.LEQUAL,
      [EqualCompare]: n.EQUAL,
      [GreaterEqualCompare]: n.GEQUAL,
      [GreaterCompare]: n.GREATER,
      [NotEqualCompare]: n.NOTEQUAL,
    };
  function Xt(Yt, Gt) {
    if (
      (Gt.type === FloatType &&
        e.has("OES_texture_float_linear") === !1 &&
        (Gt.magFilter === LinearFilter ||
          Gt.magFilter === LinearMipmapNearestFilter ||
          Gt.magFilter === NearestMipmapLinearFilter ||
          Gt.magFilter === LinearMipmapLinearFilter ||
          Gt.minFilter === LinearFilter ||
          Gt.minFilter === LinearMipmapNearestFilter ||
          Gt.minFilter === NearestMipmapLinearFilter ||
          Gt.minFilter === LinearMipmapLinearFilter) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(Yt, n.TEXTURE_WRAP_S, Pt[Gt.wrapS]),
      n.texParameteri(Yt, n.TEXTURE_WRAP_T, Pt[Gt.wrapT]),
      (Yt === n.TEXTURE_3D || Yt === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(Yt, n.TEXTURE_WRAP_R, Pt[Gt.wrapR]),
      n.texParameteri(Yt, n.TEXTURE_MAG_FILTER, It[Gt.magFilter]),
      n.texParameteri(Yt, n.TEXTURE_MIN_FILTER, It[Gt.minFilter]),
      Gt.compareFunction &&
        (n.texParameteri(Yt, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(Yt, n.TEXTURE_COMPARE_FUNC, Ot[Gt.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        Gt.magFilter === NearestFilter ||
        (Gt.minFilter !== NearestMipmapLinearFilter &&
          Gt.minFilter !== LinearMipmapLinearFilter) ||
        (Gt.type === FloatType && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (Gt.anisotropy > 1 || r.get(Gt).__currentAnisotropy) {
        const hn = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          Yt,
          hn.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(Gt.anisotropy, s.getMaxAnisotropy())
        ),
          (r.get(Gt).__currentAnisotropy = Gt.anisotropy);
      }
    }
  }
  function sn(Yt, Gt) {
    let hn = !1;
    Yt.__webglInit === void 0 &&
      ((Yt.__webglInit = !0), Gt.addEventListener("dispose", St));
    const En = Gt.source;
    let Ln = P.get(En);
    Ln === void 0 && ((Ln = {}), P.set(En, Ln));
    const mn = Ht(Gt);
    if (mn !== Yt.__cacheKey) {
      Ln[mn] === void 0 &&
        ((Ln[mn] = { texture: n.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (hn = !0)),
        Ln[mn].usedTimes++;
      const Vn = Ln[Yt.__cacheKey];
      Vn !== void 0 &&
        (Ln[Yt.__cacheKey].usedTimes--, Vn.usedTimes === 0 && Tt(Gt)),
        (Yt.__cacheKey = mn),
        (Yt.__webglTexture = Ln[mn].texture);
    }
    return hn;
  }
  function Kt(Yt, Gt, hn) {
    let En = n.TEXTURE_2D;
    (Gt.isDataArrayTexture || Gt.isCompressedArrayTexture) &&
      (En = n.TEXTURE_2D_ARRAY),
      Gt.isData3DTexture && (En = n.TEXTURE_3D);
    const Ln = sn(Yt, Gt),
      mn = Gt.source;
    t.bindTexture(En, Yt.__webglTexture, n.TEXTURE0 + hn);
    const Vn = r.get(mn);
    if (mn.version !== Vn.__version || Ln === !0) {
      t.activeTexture(n.TEXTURE0 + hn);
      const Fn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        nr =
          Gt.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(Gt.colorSpace),
        yr =
          Gt.colorSpace === NoColorSpace || Fn === nr
            ? n.NONE
            : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, Gt.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Gt.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, Gt.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, yr);
      let qn = Ye(Gt.image, !1, s.maxTextureSize);
      qn = or(Gt, qn);
      const jn = o.convert(Gt.format, Gt.colorSpace),
        Jn = o.convert(Gt.type);
      let mr = st(Gt.internalFormat, jn, Jn, Gt.colorSpace, Gt.isVideoTexture);
      Xt(En, Gt);
      let Sr;
      const Ur = Gt.mipmaps,
        Pr = Gt.isVideoTexture !== !0,
        Hr = Vn.__version === void 0 || Ln === !0,
        cn = mn.dataReady,
        An = xt(Gt, qn);
      if (Gt.isDepthTexture)
        (mr = vt(Gt.format === DepthStencilFormat, Gt.type)),
          Hr &&
            (Pr
              ? t.texStorage2D(n.TEXTURE_2D, 1, mr, qn.width, qn.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  mr,
                  qn.width,
                  qn.height,
                  0,
                  jn,
                  Jn,
                  null
                ));
      else if (Gt.isDataTexture)
        if (Ur.length > 0) {
          Pr &&
            Hr &&
            t.texStorage2D(n.TEXTURE_2D, An, mr, Ur[0].width, Ur[0].height);
          for (let Mn = 0, Hn = Ur.length; Mn < Hn; Mn++)
            (Sr = Ur[Mn]),
              Pr
                ? cn &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Mn,
                    0,
                    0,
                    Sr.width,
                    Sr.height,
                    jn,
                    Jn,
                    Sr.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Mn,
                    mr,
                    Sr.width,
                    Sr.height,
                    0,
                    jn,
                    Jn,
                    Sr.data
                  );
          Gt.generateMipmaps = !1;
        } else
          Pr
            ? (Hr && t.texStorage2D(n.TEXTURE_2D, An, mr, qn.width, qn.height),
              cn &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  qn.width,
                  qn.height,
                  jn,
                  Jn,
                  qn.data
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                mr,
                qn.width,
                qn.height,
                0,
                jn,
                Jn,
                qn.data
              );
      else if (Gt.isCompressedTexture)
        if (Gt.isCompressedArrayTexture) {
          Pr &&
            Hr &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              An,
              mr,
              Ur[0].width,
              Ur[0].height,
              qn.depth
            );
          for (let Mn = 0, Hn = Ur.length; Mn < Hn; Mn++)
            if (((Sr = Ur[Mn]), Gt.format !== RGBAFormat))
              if (jn !== null)
                if (Pr) {
                  if (cn)
                    if (Gt.layerUpdates.size > 0) {
                      const hr = getByteLength(
                        Sr.width,
                        Sr.height,
                        Gt.format,
                        Gt.type
                      );
                      for (const pr of Gt.layerUpdates) {
                        const jr = Sr.data.subarray(
                          (pr * hr) / Sr.data.BYTES_PER_ELEMENT,
                          ((pr + 1) * hr) / Sr.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Mn,
                          0,
                          0,
                          pr,
                          Sr.width,
                          Sr.height,
                          1,
                          jn,
                          jr
                        );
                      }
                      Gt.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Mn,
                        0,
                        0,
                        0,
                        Sr.width,
                        Sr.height,
                        qn.depth,
                        jn,
                        Sr.data
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Mn,
                    mr,
                    Sr.width,
                    Sr.height,
                    qn.depth,
                    0,
                    Sr.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              Pr
                ? cn &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Mn,
                    0,
                    0,
                    0,
                    Sr.width,
                    Sr.height,
                    qn.depth,
                    jn,
                    Jn,
                    Sr.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Mn,
                    mr,
                    Sr.width,
                    Sr.height,
                    qn.depth,
                    0,
                    jn,
                    Jn,
                    Sr.data
                  );
        } else {
          Pr &&
            Hr &&
            t.texStorage2D(n.TEXTURE_2D, An, mr, Ur[0].width, Ur[0].height);
          for (let Mn = 0, Hn = Ur.length; Mn < Hn; Mn++)
            (Sr = Ur[Mn]),
              Gt.format !== RGBAFormat
                ? jn !== null
                  ? Pr
                    ? cn &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Mn,
                        0,
                        0,
                        Sr.width,
                        Sr.height,
                        jn,
                        Sr.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Mn,
                        mr,
                        Sr.width,
                        Sr.height,
                        0,
                        Sr.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Pr
                ? cn &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Mn,
                    0,
                    0,
                    Sr.width,
                    Sr.height,
                    jn,
                    Jn,
                    Sr.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Mn,
                    mr,
                    Sr.width,
                    Sr.height,
                    0,
                    jn,
                    Jn,
                    Sr.data
                  );
        }
      else if (Gt.isDataArrayTexture)
        if (Pr) {
          if (
            (Hr &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                An,
                mr,
                qn.width,
                qn.height,
                qn.depth
              ),
            cn)
          )
            if (Gt.layerUpdates.size > 0) {
              const Mn = getByteLength(qn.width, qn.height, Gt.format, Gt.type);
              for (const Hn of Gt.layerUpdates) {
                const hr = qn.data.subarray(
                  (Hn * Mn) / qn.data.BYTES_PER_ELEMENT,
                  ((Hn + 1) * Mn) / qn.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Hn,
                  qn.width,
                  qn.height,
                  1,
                  jn,
                  Jn,
                  hr
                );
              }
              Gt.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                qn.width,
                qn.height,
                qn.depth,
                jn,
                Jn,
                qn.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            mr,
            qn.width,
            qn.height,
            qn.depth,
            0,
            jn,
            Jn,
            qn.data
          );
      else if (Gt.isData3DTexture)
        Pr
          ? (Hr &&
              t.texStorage3D(
                n.TEXTURE_3D,
                An,
                mr,
                qn.width,
                qn.height,
                qn.depth
              ),
            cn &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                qn.width,
                qn.height,
                qn.depth,
                jn,
                Jn,
                qn.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              mr,
              qn.width,
              qn.height,
              qn.depth,
              0,
              jn,
              Jn,
              qn.data
            );
      else if (Gt.isFramebufferTexture) {
        if (Hr)
          if (Pr) t.texStorage2D(n.TEXTURE_2D, An, mr, qn.width, qn.height);
          else {
            let Mn = qn.width,
              Hn = qn.height;
            for (let hr = 0; hr < An; hr++)
              t.texImage2D(n.TEXTURE_2D, hr, mr, Mn, Hn, 0, jn, Jn, null),
                (Mn >>= 1),
                (Hn >>= 1);
          }
      } else if (Ur.length > 0) {
        if (Pr && Hr) {
          const Mn = Gn(Ur[0]);
          t.texStorage2D(n.TEXTURE_2D, An, mr, Mn.width, Mn.height);
        }
        for (let Mn = 0, Hn = Ur.length; Mn < Hn; Mn++)
          (Sr = Ur[Mn]),
            Pr
              ? cn && t.texSubImage2D(n.TEXTURE_2D, Mn, 0, 0, jn, Jn, Sr)
              : t.texImage2D(n.TEXTURE_2D, Mn, mr, jn, Jn, Sr);
        Gt.generateMipmaps = !1;
      } else if (Pr) {
        if (Hr) {
          const Mn = Gn(qn);
          t.texStorage2D(n.TEXTURE_2D, An, mr, Mn.width, Mn.height);
        }
        cn && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, jn, Jn, qn);
      } else t.texImage2D(n.TEXTURE_2D, 0, mr, jn, Jn, qn);
      nt(Gt) && Be(En),
        (Vn.__version = mn.version),
        Gt.onUpdate && Gt.onUpdate(Gt);
    }
    Yt.__version = Gt.version;
  }
  function tn(Yt, Gt, hn) {
    if (Gt.image.length !== 6) return;
    const En = sn(Yt, Gt),
      Ln = Gt.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, Yt.__webglTexture, n.TEXTURE0 + hn);
    const mn = r.get(Ln);
    if (Ln.version !== mn.__version || En === !0) {
      t.activeTexture(n.TEXTURE0 + hn);
      const Vn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        Fn =
          Gt.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(Gt.colorSpace),
        nr =
          Gt.colorSpace === NoColorSpace || Vn === Fn
            ? n.NONE
            : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, Gt.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Gt.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, Gt.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, nr);
      const yr = Gt.isCompressedTexture || Gt.image[0].isCompressedTexture,
        qn = Gt.image[0] && Gt.image[0].isDataTexture,
        jn = [];
      for (let Hn = 0; Hn < 6; Hn++)
        !yr && !qn
          ? (jn[Hn] = Ye(Gt.image[Hn], !0, s.maxCubemapSize))
          : (jn[Hn] = qn ? Gt.image[Hn].image : Gt.image[Hn]),
          (jn[Hn] = or(Gt, jn[Hn]));
      const Jn = jn[0],
        mr = o.convert(Gt.format, Gt.colorSpace),
        Sr = o.convert(Gt.type),
        Ur = st(Gt.internalFormat, mr, Sr, Gt.colorSpace),
        Pr = Gt.isVideoTexture !== !0,
        Hr = mn.__version === void 0 || En === !0,
        cn = Ln.dataReady;
      let An = xt(Gt, Jn);
      Xt(n.TEXTURE_CUBE_MAP, Gt);
      let Mn;
      if (yr) {
        Pr &&
          Hr &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, An, Ur, Jn.width, Jn.height);
        for (let Hn = 0; Hn < 6; Hn++) {
          Mn = jn[Hn].mipmaps;
          for (let hr = 0; hr < Mn.length; hr++) {
            const pr = Mn[hr];
            Gt.format !== RGBAFormat
              ? mr !== null
                ? Pr
                  ? cn &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                      hr,
                      0,
                      0,
                      pr.width,
                      pr.height,
                      mr,
                      pr.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                      hr,
                      Ur,
                      pr.width,
                      pr.height,
                      0,
                      pr.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Pr
              ? cn &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                  hr,
                  0,
                  0,
                  pr.width,
                  pr.height,
                  mr,
                  Sr,
                  pr.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                  hr,
                  Ur,
                  pr.width,
                  pr.height,
                  0,
                  mr,
                  Sr,
                  pr.data
                );
          }
        }
      } else {
        if (((Mn = Gt.mipmaps), Pr && Hr)) {
          Mn.length > 0 && An++;
          const Hn = Gn(jn[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, An, Ur, Hn.width, Hn.height);
        }
        for (let Hn = 0; Hn < 6; Hn++)
          if (qn) {
            Pr
              ? cn &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                  0,
                  0,
                  0,
                  jn[Hn].width,
                  jn[Hn].height,
                  mr,
                  Sr,
                  jn[Hn].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                  0,
                  Ur,
                  jn[Hn].width,
                  jn[Hn].height,
                  0,
                  mr,
                  Sr,
                  jn[Hn].data
                );
            for (let hr = 0; hr < Mn.length; hr++) {
              const jr = Mn[hr].image[Hn].image;
              Pr
                ? cn &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                    hr + 1,
                    0,
                    0,
                    jr.width,
                    jr.height,
                    mr,
                    Sr,
                    jr.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                    hr + 1,
                    Ur,
                    jr.width,
                    jr.height,
                    0,
                    mr,
                    Sr,
                    jr.data
                  );
            }
          } else {
            Pr
              ? cn &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                  0,
                  0,
                  0,
                  mr,
                  Sr,
                  jn[Hn]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                  0,
                  Ur,
                  mr,
                  Sr,
                  jn[Hn]
                );
            for (let hr = 0; hr < Mn.length; hr++) {
              const pr = Mn[hr];
              Pr
                ? cn &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                    hr + 1,
                    0,
                    0,
                    mr,
                    Sr,
                    pr.image[Hn]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Hn,
                    hr + 1,
                    Ur,
                    mr,
                    Sr,
                    pr.image[Hn]
                  );
            }
          }
      }
      nt(Gt) && Be(n.TEXTURE_CUBE_MAP),
        (mn.__version = Ln.version),
        Gt.onUpdate && Gt.onUpdate(Gt);
    }
    Yt.__version = Gt.version;
  }
  function pn(Yt, Gt, hn, En, Ln, mn) {
    const Vn = o.convert(hn.format, hn.colorSpace),
      Fn = o.convert(hn.type),
      nr = st(hn.internalFormat, Vn, Fn, hn.colorSpace),
      yr = r.get(Gt),
      qn = r.get(hn);
    if (((qn.__renderTarget = Gt), !yr.__hasExternalTextures)) {
      const jn = Math.max(1, Gt.width >> mn),
        Jn = Math.max(1, Gt.height >> mn);
      Ln === n.TEXTURE_3D || Ln === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(Ln, mn, nr, jn, Jn, Gt.depth, 0, Vn, Fn, null)
        : t.texImage2D(Ln, mn, nr, jn, Jn, 0, Vn, Fn, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, Yt),
      rn(Gt)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            En,
            Ln,
            qn.__webglTexture,
            0,
            zn(Gt)
          )
        : (Ln === n.TEXTURE_2D ||
            (Ln >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Ln <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, En, Ln, qn.__webglTexture, mn),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function _n(Yt, Gt, hn) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, Yt), Gt.depthBuffer)) {
      const En = Gt.depthTexture,
        Ln = En && En.isDepthTexture ? En.type : null,
        mn = vt(Gt.stencilBuffer, Ln),
        Vn = Gt.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Fn = zn(Gt);
      rn(Gt)
        ? l.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Fn,
            mn,
            Gt.width,
            Gt.height
          )
        : hn
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Fn,
            mn,
            Gt.width,
            Gt.height
          )
        : n.renderbufferStorage(n.RENDERBUFFER, mn, Gt.width, Gt.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, Vn, n.RENDERBUFFER, Yt);
    } else {
      const En = Gt.textures;
      for (let Ln = 0; Ln < En.length; Ln++) {
        const mn = En[Ln],
          Vn = o.convert(mn.format, mn.colorSpace),
          Fn = o.convert(mn.type),
          nr = st(mn.internalFormat, Vn, Fn, mn.colorSpace),
          yr = zn(Gt);
        hn && rn(Gt) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              yr,
              nr,
              Gt.width,
              Gt.height
            )
          : rn(Gt)
          ? l.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              yr,
              nr,
              Gt.width,
              Gt.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, nr, Gt.width, Gt.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function bn(Yt, Gt) {
    if (Gt && Gt.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, Yt),
      !(Gt.depthTexture && Gt.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const En = r.get(Gt.depthTexture);
    (En.__renderTarget = Gt),
      (!En.__webglTexture ||
        Gt.depthTexture.image.width !== Gt.width ||
        Gt.depthTexture.image.height !== Gt.height) &&
        ((Gt.depthTexture.image.width = Gt.width),
        (Gt.depthTexture.image.height = Gt.height),
        (Gt.depthTexture.needsUpdate = !0)),
      qt(Gt.depthTexture, 0);
    const Ln = En.__webglTexture,
      mn = zn(Gt);
    if (Gt.depthTexture.format === DepthFormat)
      rn(Gt)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Ln,
            0,
            mn
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Ln,
            0
          );
    else if (Gt.depthTexture.format === DepthStencilFormat)
      rn(Gt)
        ? l.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Ln,
            0,
            mn
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Ln,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function $n(Yt) {
    const Gt = r.get(Yt),
      hn = Yt.isWebGLCubeRenderTarget === !0;
    if (Gt.__boundDepthTexture !== Yt.depthTexture) {
      const En = Yt.depthTexture;
      if ((Gt.__depthDisposeCallback && Gt.__depthDisposeCallback(), En)) {
        const Ln = () => {
          delete Gt.__boundDepthTexture,
            delete Gt.__depthDisposeCallback,
            En.removeEventListener("dispose", Ln);
        };
        En.addEventListener("dispose", Ln), (Gt.__depthDisposeCallback = Ln);
      }
      Gt.__boundDepthTexture = En;
    }
    if (Yt.depthTexture && !Gt.__autoAllocateDepthBuffer) {
      if (hn)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      const En = Yt.texture.mipmaps;
      En && En.length > 0
        ? bn(Gt.__webglFramebuffer[0], Yt)
        : bn(Gt.__webglFramebuffer, Yt);
    } else if (hn) {
      Gt.__webglDepthbuffer = [];
      for (let En = 0; En < 6; En++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, Gt.__webglFramebuffer[En]),
          Gt.__webglDepthbuffer[En] === void 0)
        )
          (Gt.__webglDepthbuffer[En] = n.createRenderbuffer()),
            _n(Gt.__webglDepthbuffer[En], Yt, !1);
        else {
          const Ln = Yt.stencilBuffer
              ? n.DEPTH_STENCIL_ATTACHMENT
              : n.DEPTH_ATTACHMENT,
            mn = Gt.__webglDepthbuffer[En];
          n.bindRenderbuffer(n.RENDERBUFFER, mn),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, Ln, n.RENDERBUFFER, mn);
        }
    } else {
      const En = Yt.texture.mipmaps;
      if (
        (En && En.length > 0
          ? t.bindFramebuffer(n.FRAMEBUFFER, Gt.__webglFramebuffer[0])
          : t.bindFramebuffer(n.FRAMEBUFFER, Gt.__webglFramebuffer),
        Gt.__webglDepthbuffer === void 0)
      )
        (Gt.__webglDepthbuffer = n.createRenderbuffer()),
          _n(Gt.__webglDepthbuffer, Yt, !1);
      else {
        const Ln = Yt.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          mn = Gt.__webglDepthbuffer;
        n.bindRenderbuffer(n.RENDERBUFFER, mn),
          n.framebufferRenderbuffer(n.FRAMEBUFFER, Ln, n.RENDERBUFFER, mn);
      }
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function tr(Yt, Gt, hn) {
    const En = r.get(Yt);
    Gt !== void 0 &&
      pn(
        En.__webglFramebuffer,
        Yt,
        Yt.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      hn !== void 0 && $n(Yt);
  }
  function ur(Yt) {
    const Gt = Yt.texture,
      hn = r.get(Yt),
      En = r.get(Gt);
    Yt.addEventListener("dispose", wt);
    const Ln = Yt.textures,
      mn = Yt.isWebGLCubeRenderTarget === !0,
      Vn = Ln.length > 1;
    if (
      (Vn ||
        (En.__webglTexture === void 0 &&
          (En.__webglTexture = n.createTexture()),
        (En.__version = Gt.version),
        a.memory.textures++),
      mn)
    ) {
      hn.__webglFramebuffer = [];
      for (let Fn = 0; Fn < 6; Fn++)
        if (Gt.mipmaps && Gt.mipmaps.length > 0) {
          hn.__webglFramebuffer[Fn] = [];
          for (let nr = 0; nr < Gt.mipmaps.length; nr++)
            hn.__webglFramebuffer[Fn][nr] = n.createFramebuffer();
        } else hn.__webglFramebuffer[Fn] = n.createFramebuffer();
    } else {
      if (Gt.mipmaps && Gt.mipmaps.length > 0) {
        hn.__webglFramebuffer = [];
        for (let Fn = 0; Fn < Gt.mipmaps.length; Fn++)
          hn.__webglFramebuffer[Fn] = n.createFramebuffer();
      } else hn.__webglFramebuffer = n.createFramebuffer();
      if (Vn)
        for (let Fn = 0, nr = Ln.length; Fn < nr; Fn++) {
          const yr = r.get(Ln[Fn]);
          yr.__webglTexture === void 0 &&
            ((yr.__webglTexture = n.createTexture()), a.memory.textures++);
        }
      if (Yt.samples > 0 && rn(Yt) === !1) {
        (hn.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (hn.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, hn.__webglMultisampledFramebuffer);
        for (let Fn = 0; Fn < Ln.length; Fn++) {
          const nr = Ln[Fn];
          (hn.__webglColorRenderbuffer[Fn] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, hn.__webglColorRenderbuffer[Fn]);
          const yr = o.convert(nr.format, nr.colorSpace),
            qn = o.convert(nr.type),
            jn = st(
              nr.internalFormat,
              yr,
              qn,
              nr.colorSpace,
              Yt.isXRRenderTarget === !0
            ),
            Jn = zn(Yt);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Jn,
            jn,
            Yt.width,
            Yt.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Fn,
              n.RENDERBUFFER,
              hn.__webglColorRenderbuffer[Fn]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          Yt.depthBuffer &&
            ((hn.__webglDepthRenderbuffer = n.createRenderbuffer()),
            _n(hn.__webglDepthRenderbuffer, Yt, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (mn) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, En.__webglTexture),
        Xt(n.TEXTURE_CUBE_MAP, Gt);
      for (let Fn = 0; Fn < 6; Fn++)
        if (Gt.mipmaps && Gt.mipmaps.length > 0)
          for (let nr = 0; nr < Gt.mipmaps.length; nr++)
            pn(
              hn.__webglFramebuffer[Fn][nr],
              Yt,
              Gt,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Fn,
              nr
            );
        else
          pn(
            hn.__webglFramebuffer[Fn],
            Yt,
            Gt,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Fn,
            0
          );
      nt(Gt) && Be(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Vn) {
      for (let Fn = 0, nr = Ln.length; Fn < nr; Fn++) {
        const yr = Ln[Fn],
          qn = r.get(yr);
        t.bindTexture(n.TEXTURE_2D, qn.__webglTexture),
          Xt(n.TEXTURE_2D, yr),
          pn(
            hn.__webglFramebuffer,
            Yt,
            yr,
            n.COLOR_ATTACHMENT0 + Fn,
            n.TEXTURE_2D,
            0
          ),
          nt(yr) && Be(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Fn = n.TEXTURE_2D;
      if (
        ((Yt.isWebGL3DRenderTarget || Yt.isWebGLArrayRenderTarget) &&
          (Fn = Yt.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Fn, En.__webglTexture),
        Xt(Fn, Gt),
        Gt.mipmaps && Gt.mipmaps.length > 0)
      )
        for (let nr = 0; nr < Gt.mipmaps.length; nr++)
          pn(hn.__webglFramebuffer[nr], Yt, Gt, n.COLOR_ATTACHMENT0, Fn, nr);
      else pn(hn.__webglFramebuffer, Yt, Gt, n.COLOR_ATTACHMENT0, Fn, 0);
      nt(Gt) && Be(Fn), t.unbindTexture();
    }
    Yt.depthBuffer && $n(Yt);
  }
  function _r(Yt) {
    const Gt = Yt.textures;
    for (let hn = 0, En = Gt.length; hn < En; hn++) {
      const Ln = Gt[hn];
      if (nt(Ln)) {
        const mn = ot(Yt),
          Vn = r.get(Ln).__webglTexture;
        t.bindTexture(mn, Vn), Be(mn), t.unbindTexture();
      }
    }
  }
  const Bn = [],
    jt = [];
  function Yn(Yt) {
    if (Yt.samples > 0) {
      if (rn(Yt) === !1) {
        const Gt = Yt.textures,
          hn = Yt.width,
          En = Yt.height;
        let Ln = n.COLOR_BUFFER_BIT;
        const mn = Yt.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          Vn = r.get(Yt),
          Fn = Gt.length > 1;
        if (Fn)
          for (let yr = 0; yr < Gt.length; yr++)
            t.bindFramebuffer(n.FRAMEBUFFER, Vn.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + yr,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, Vn.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + yr,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          Vn.__webglMultisampledFramebuffer
        );
        const nr = Yt.texture.mipmaps;
        nr && nr.length > 0
          ? t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Vn.__webglFramebuffer[0])
          : t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Vn.__webglFramebuffer);
        for (let yr = 0; yr < Gt.length; yr++) {
          if (
            (Yt.resolveDepthBuffer &&
              (Yt.depthBuffer && (Ln |= n.DEPTH_BUFFER_BIT),
              Yt.stencilBuffer &&
                Yt.resolveStencilBuffer &&
                (Ln |= n.STENCIL_BUFFER_BIT)),
            Fn)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Vn.__webglColorRenderbuffer[yr]
            );
            const qn = r.get(Gt[yr]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              qn,
              0
            );
          }
          n.blitFramebuffer(0, 0, hn, En, 0, 0, hn, En, Ln, n.NEAREST),
            c === !0 &&
              ((Bn.length = 0),
              (jt.length = 0),
              Bn.push(n.COLOR_ATTACHMENT0 + yr),
              Yt.depthBuffer &&
                Yt.resolveDepthBuffer === !1 &&
                (Bn.push(mn),
                jt.push(mn),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, jt)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Bn));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Fn)
        )
          for (let yr = 0; yr < Gt.length; yr++) {
            t.bindFramebuffer(n.FRAMEBUFFER, Vn.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + yr,
                n.RENDERBUFFER,
                Vn.__webglColorRenderbuffer[yr]
              );
            const qn = r.get(Gt[yr]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, Vn.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + yr,
                n.TEXTURE_2D,
                qn,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          Vn.__webglMultisampledFramebuffer
        );
      } else if (Yt.depthBuffer && Yt.resolveDepthBuffer === !1 && c) {
        const Gt = Yt.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Gt]);
      }
    }
  }
  function zn(Yt) {
    return Math.min(s.maxSamples, Yt.samples);
  }
  function rn(Yt) {
    const Gt = r.get(Yt);
    return (
      Yt.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      Gt.__useRenderToTexture !== !1
    );
  }
  function In(Yt) {
    const Gt = a.render.frame;
    p.get(Yt) !== Gt && (p.set(Yt, Gt), Yt.update());
  }
  function or(Yt, Gt) {
    const hn = Yt.colorSpace,
      En = Yt.format,
      Ln = Yt.type;
    return (
      Yt.isCompressedTexture === !0 ||
        Yt.isVideoTexture === !0 ||
        (hn !== LinearSRGBColorSpace &&
          hn !== NoColorSpace &&
          (ColorManagement.getTransfer(hn) === SRGBTransfer
            ? (En !== RGBAFormat || Ln !== UnsignedByteType) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                hn
              ))),
      Gt
    );
  }
  function Gn(Yt) {
    return (
      typeof HTMLImageElement < "u" && Yt instanceof HTMLImageElement
        ? ((u.width = Yt.naturalWidth || Yt.width),
          (u.height = Yt.naturalHeight || Yt.height))
        : typeof VideoFrame < "u" && Yt instanceof VideoFrame
        ? ((u.width = Yt.displayWidth), (u.height = Yt.displayHeight))
        : ((u.width = Yt.width), (u.height = Yt.height)),
      u
    );
  }
  (this.allocateTextureUnit = Vt),
    (this.resetTextureUnits = Dt),
    (this.setTexture2D = qt),
    (this.setTexture2DArray = Ft),
    (this.setTexture3D = Bt),
    (this.setTextureCube = Mt),
    (this.rebindTextures = tr),
    (this.setupRenderTarget = ur),
    (this.updateRenderTargetMipmap = _r),
    (this.updateMultisampleRenderTarget = Yn),
    (this.setupDepthRenderbuffer = $n),
    (this.setupFrameBufferTexture = pn),
    (this.useMultisampledRTT = rn);
}
function WebGLUtils(n, e) {
  function t(r, s = NoColorSpace) {
    let o;
    const a = ColorManagement.getTransfer(s);
    if (r === UnsignedByteType) return n.UNSIGNED_BYTE;
    if (r === UnsignedShort4444Type) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === UnsignedShort5551Type) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === UnsignedInt5999Type) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === ByteType) return n.BYTE;
    if (r === ShortType) return n.SHORT;
    if (r === UnsignedShortType) return n.UNSIGNED_SHORT;
    if (r === IntType) return n.INT;
    if (r === UnsignedIntType) return n.UNSIGNED_INT;
    if (r === FloatType) return n.FLOAT;
    if (r === HalfFloatType) return n.HALF_FLOAT;
    if (r === AlphaFormat) return n.ALPHA;
    if (r === RGBFormat) return n.RGB;
    if (r === RGBAFormat) return n.RGBA;
    if (r === DepthFormat) return n.DEPTH_COMPONENT;
    if (r === DepthStencilFormat) return n.DEPTH_STENCIL;
    if (r === RedFormat) return n.RED;
    if (r === RedIntegerFormat) return n.RED_INTEGER;
    if (r === RGFormat) return n.RG;
    if (r === RGIntegerFormat) return n.RG_INTEGER;
    if (r === RGBAIntegerFormat) return n.RGBA_INTEGER;
    if (
      r === RGB_S3TC_DXT1_Format ||
      r === RGBA_S3TC_DXT1_Format ||
      r === RGBA_S3TC_DXT3_Format ||
      r === RGBA_S3TC_DXT5_Format
    )
      if (a === SRGBTransfer)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (r === RGB_S3TC_DXT1_Format)
            return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === RGBA_S3TC_DXT1_Format)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === RGBA_S3TC_DXT3_Format)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === RGBA_S3TC_DXT5_Format)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === RGB_S3TC_DXT1_Format) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === RGBA_S3TC_DXT1_Format) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === RGBA_S3TC_DXT3_Format) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === RGBA_S3TC_DXT5_Format) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (
      r === RGB_PVRTC_4BPPV1_Format ||
      r === RGB_PVRTC_2BPPV1_Format ||
      r === RGBA_PVRTC_4BPPV1_Format ||
      r === RGBA_PVRTC_2BPPV1_Format
    )
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === RGB_PVRTC_4BPPV1_Format)
          return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === RGB_PVRTC_2BPPV1_Format)
          return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === RGBA_PVRTC_4BPPV1_Format)
          return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === RGBA_PVRTC_2BPPV1_Format)
          return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (
      r === RGB_ETC1_Format ||
      r === RGB_ETC2_Format ||
      r === RGBA_ETC2_EAC_Format
    )
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (r === RGB_ETC1_Format || r === RGB_ETC2_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ETC2
            : o.COMPRESSED_RGB8_ETC2;
        if (r === RGBA_ETC2_EAC_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === RGBA_ASTC_4x4_Format ||
      r === RGBA_ASTC_5x4_Format ||
      r === RGBA_ASTC_5x5_Format ||
      r === RGBA_ASTC_6x5_Format ||
      r === RGBA_ASTC_6x6_Format ||
      r === RGBA_ASTC_8x5_Format ||
      r === RGBA_ASTC_8x6_Format ||
      r === RGBA_ASTC_8x8_Format ||
      r === RGBA_ASTC_10x5_Format ||
      r === RGBA_ASTC_10x6_Format ||
      r === RGBA_ASTC_10x8_Format ||
      r === RGBA_ASTC_10x10_Format ||
      r === RGBA_ASTC_12x10_Format ||
      r === RGBA_ASTC_12x12_Format
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (r === RGBA_ASTC_4x4_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === RGBA_ASTC_5x4_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === RGBA_ASTC_5x5_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === RGBA_ASTC_6x5_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === RGBA_ASTC_6x6_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === RGBA_ASTC_8x5_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === RGBA_ASTC_8x6_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === RGBA_ASTC_8x8_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === RGBA_ASTC_10x5_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === RGBA_ASTC_10x6_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === RGBA_ASTC_10x8_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === RGBA_ASTC_10x10_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === RGBA_ASTC_12x10_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === RGBA_ASTC_12x12_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (
      r === RGBA_BPTC_Format ||
      r === RGB_BPTC_SIGNED_Format ||
      r === RGB_BPTC_UNSIGNED_Format
    )
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (r === RGBA_BPTC_Format)
          return a === SRGBTransfer
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === RGB_BPTC_SIGNED_Format)
          return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === RGB_BPTC_UNSIGNED_Format)
          return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (
      r === RED_RGTC1_Format ||
      r === SIGNED_RED_RGTC1_Format ||
      r === RED_GREEN_RGTC2_Format ||
      r === SIGNED_RED_GREEN_RGTC2_Format
    )
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (r === RGBA_BPTC_Format) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === SIGNED_RED_RGTC1_Format)
          return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === RED_GREEN_RGTC2_Format)
          return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === SIGNED_RED_GREEN_RGTC2_Format)
          return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === UnsignedInt248Type
      ? n.UNSIGNED_INT_24_8
      : n[r] !== void 0
      ? n[r]
      : null;
  }
  return { convert: t };
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, r) {
    if (this.texture === null) {
      const s = new Texture(),
        o = e.properties.get(s);
      (o.__webglTexture = t.texture),
        (t.depthNear !== r.depthNear || t.depthFar !== r.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = s);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        r = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new Mesh(new PlaneGeometry(20, 20), r);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(e, t) {
    super();
    const r = this;
    let s = null,
      o = 1,
      a = null,
      l = "local-floor",
      c = 1,
      u = null,
      p = null,
      N = null,
      P = null,
      de = null,
      me = null;
    const Ye = new WebXRDepthSensing(),
      nt = t.getContextAttributes();
    let Be = null,
      ot = null;
    const st = [],
      vt = [],
      xt = new Vector2();
    let St = null;
    const wt = new PerspectiveCamera();
    wt.viewport = new Vector4();
    const bt = new PerspectiveCamera();
    bt.viewport = new Vector4();
    const Tt = [wt, bt],
      Ct = new ArrayCamera();
    let kt = null,
      Dt = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Kt) {
        let tn = st[Kt];
        return (
          tn === void 0 && ((tn = new WebXRController()), (st[Kt] = tn)),
          tn.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (Kt) {
        let tn = st[Kt];
        return (
          tn === void 0 && ((tn = new WebXRController()), (st[Kt] = tn)),
          tn.getGripSpace()
        );
      }),
      (this.getHand = function (Kt) {
        let tn = st[Kt];
        return (
          tn === void 0 && ((tn = new WebXRController()), (st[Kt] = tn)),
          tn.getHandSpace()
        );
      });
    function Vt(Kt) {
      const tn = vt.indexOf(Kt.inputSource);
      if (tn === -1) return;
      const pn = st[tn];
      pn !== void 0 &&
        (pn.update(Kt.inputSource, Kt.frame, u || a),
        pn.dispatchEvent({ type: Kt.type, data: Kt.inputSource }));
    }
    function Ht() {
      s.removeEventListener("select", Vt),
        s.removeEventListener("selectstart", Vt),
        s.removeEventListener("selectend", Vt),
        s.removeEventListener("squeeze", Vt),
        s.removeEventListener("squeezestart", Vt),
        s.removeEventListener("squeezeend", Vt),
        s.removeEventListener("end", Ht),
        s.removeEventListener("inputsourceschange", qt);
      for (let Kt = 0; Kt < st.length; Kt++) {
        const tn = vt[Kt];
        tn !== null && ((vt[Kt] = null), st[Kt].disconnect(tn));
      }
      (kt = null),
        (Dt = null),
        Ye.reset(),
        e.setRenderTarget(Be),
        (de = null),
        (P = null),
        (N = null),
        (s = null),
        (ot = null),
        sn.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(St),
        e.setSize(xt.width, xt.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (Kt) {
      (o = Kt),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (Kt) {
        (l = Kt),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return u || a;
      }),
      (this.setReferenceSpace = function (Kt) {
        u = Kt;
      }),
      (this.getBaseLayer = function () {
        return P !== null ? P : de;
      }),
      (this.getBinding = function () {
        return N;
      }),
      (this.getFrame = function () {
        return me;
      }),
      (this.getSession = function () {
        return s;
      }),
      (this.setSession = async function (Kt) {
        if (((s = Kt), s !== null)) {
          if (
            ((Be = e.getRenderTarget()),
            s.addEventListener("select", Vt),
            s.addEventListener("selectstart", Vt),
            s.addEventListener("selectend", Vt),
            s.addEventListener("squeeze", Vt),
            s.addEventListener("squeezestart", Vt),
            s.addEventListener("squeezeend", Vt),
            s.addEventListener("end", Ht),
            s.addEventListener("inputsourceschange", qt),
            nt.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (St = e.getPixelRatio()),
            e.getSize(xt),
            typeof XRWebGLBinding < "u" &&
              "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let pn = null,
              _n = null,
              bn = null;
            nt.depth &&
              ((bn = nt.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (pn = nt.stencil ? DepthStencilFormat : DepthFormat),
              (_n = nt.stencil ? UnsignedInt248Type : UnsignedIntType));
            const $n = {
              colorFormat: t.RGBA8,
              depthFormat: bn,
              scaleFactor: o,
            };
            (N = new XRWebGLBinding(s, t)),
              (P = N.createProjectionLayer($n)),
              s.updateRenderState({ layers: [P] }),
              e.setPixelRatio(1),
              e.setSize(P.textureWidth, P.textureHeight, !1),
              (ot = new WebGLRenderTarget(P.textureWidth, P.textureHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(
                  P.textureWidth,
                  P.textureHeight,
                  _n,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  pn
                ),
                stencilBuffer: nt.stencil,
                colorSpace: e.outputColorSpace,
                samples: nt.antialias ? 4 : 0,
                resolveDepthBuffer: P.ignoreDepthValues === !1,
                resolveStencilBuffer: P.ignoreDepthValues === !1,
              }));
          } else {
            const pn = {
              antialias: nt.antialias,
              alpha: !0,
              depth: nt.depth,
              stencil: nt.stencil,
              framebufferScaleFactor: o,
            };
            (de = new XRWebGLLayer(s, t, pn)),
              s.updateRenderState({ baseLayer: de }),
              e.setPixelRatio(1),
              e.setSize(de.framebufferWidth, de.framebufferHeight, !1),
              (ot = new WebGLRenderTarget(
                de.framebufferWidth,
                de.framebufferHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: nt.stencil,
                  resolveDepthBuffer: de.ignoreDepthValues === !1,
                  resolveStencilBuffer: de.ignoreDepthValues === !1,
                }
              ));
          }
          (ot.isXRRenderTarget = !0),
            this.setFoveation(c),
            (u = null),
            (a = await s.requestReferenceSpace(l)),
            sn.setContext(s),
            sn.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (s !== null) return s.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return Ye.getDepthTexture();
      });
    function qt(Kt) {
      for (let tn = 0; tn < Kt.removed.length; tn++) {
        const pn = Kt.removed[tn],
          _n = vt.indexOf(pn);
        _n >= 0 && ((vt[_n] = null), st[_n].disconnect(pn));
      }
      for (let tn = 0; tn < Kt.added.length; tn++) {
        const pn = Kt.added[tn];
        let _n = vt.indexOf(pn);
        if (_n === -1) {
          for (let $n = 0; $n < st.length; $n++)
            if ($n >= vt.length) {
              vt.push(pn), (_n = $n);
              break;
            } else if (vt[$n] === null) {
              (vt[$n] = pn), (_n = $n);
              break;
            }
          if (_n === -1) break;
        }
        const bn = st[_n];
        bn && bn.connect(pn);
      }
    }
    const Ft = new Vector3(),
      Bt = new Vector3();
    function Mt(Kt, tn, pn) {
      Ft.setFromMatrixPosition(tn.matrixWorld),
        Bt.setFromMatrixPosition(pn.matrixWorld);
      const _n = Ft.distanceTo(Bt),
        bn = tn.projectionMatrix.elements,
        $n = pn.projectionMatrix.elements,
        tr = bn[14] / (bn[10] - 1),
        ur = bn[14] / (bn[10] + 1),
        _r = (bn[9] + 1) / bn[5],
        Bn = (bn[9] - 1) / bn[5],
        jt = (bn[8] - 1) / bn[0],
        Yn = ($n[8] + 1) / $n[0],
        zn = tr * jt,
        rn = tr * Yn,
        In = _n / (-jt + Yn),
        or = In * -jt;
      if (
        (tn.matrixWorld.decompose(Kt.position, Kt.quaternion, Kt.scale),
        Kt.translateX(or),
        Kt.translateZ(In),
        Kt.matrixWorld.compose(Kt.position, Kt.quaternion, Kt.scale),
        Kt.matrixWorldInverse.copy(Kt.matrixWorld).invert(),
        bn[10] === -1)
      )
        Kt.projectionMatrix.copy(tn.projectionMatrix),
          Kt.projectionMatrixInverse.copy(tn.projectionMatrixInverse);
      else {
        const Gn = tr + In,
          Yt = ur + In,
          Gt = zn - or,
          hn = rn + (_n - or),
          En = ((_r * ur) / Yt) * Gn,
          Ln = ((Bn * ur) / Yt) * Gn;
        Kt.projectionMatrix.makePerspective(Gt, hn, En, Ln, Gn, Yt),
          Kt.projectionMatrixInverse.copy(Kt.projectionMatrix).invert();
      }
    }
    function Pt(Kt, tn) {
      tn === null
        ? Kt.matrixWorld.copy(Kt.matrix)
        : Kt.matrixWorld.multiplyMatrices(tn.matrixWorld, Kt.matrix),
        Kt.matrixWorldInverse.copy(Kt.matrixWorld).invert();
    }
    this.updateCamera = function (Kt) {
      if (s === null) return;
      let tn = Kt.near,
        pn = Kt.far;
      Ye.texture !== null &&
        (Ye.depthNear > 0 && (tn = Ye.depthNear),
        Ye.depthFar > 0 && (pn = Ye.depthFar)),
        (Ct.near = bt.near = wt.near = tn),
        (Ct.far = bt.far = wt.far = pn),
        (kt !== Ct.near || Dt !== Ct.far) &&
          (s.updateRenderState({ depthNear: Ct.near, depthFar: Ct.far }),
          (kt = Ct.near),
          (Dt = Ct.far)),
        (wt.layers.mask = Kt.layers.mask | 2),
        (bt.layers.mask = Kt.layers.mask | 4),
        (Ct.layers.mask = wt.layers.mask | bt.layers.mask);
      const _n = Kt.parent,
        bn = Ct.cameras;
      Pt(Ct, _n);
      for (let $n = 0; $n < bn.length; $n++) Pt(bn[$n], _n);
      bn.length === 2
        ? Mt(Ct, wt, bt)
        : Ct.projectionMatrix.copy(wt.projectionMatrix),
        It(Kt, Ct, _n);
    };
    function It(Kt, tn, pn) {
      pn === null
        ? Kt.matrix.copy(tn.matrixWorld)
        : (Kt.matrix.copy(pn.matrixWorld),
          Kt.matrix.invert(),
          Kt.matrix.multiply(tn.matrixWorld)),
        Kt.matrix.decompose(Kt.position, Kt.quaternion, Kt.scale),
        Kt.updateMatrixWorld(!0),
        Kt.projectionMatrix.copy(tn.projectionMatrix),
        Kt.projectionMatrixInverse.copy(tn.projectionMatrixInverse),
        Kt.isPerspectiveCamera &&
          ((Kt.fov =
            RAD2DEG * 2 * Math.atan(1 / Kt.projectionMatrix.elements[5])),
          (Kt.zoom = 1));
    }
    (this.getCamera = function () {
      return Ct;
    }),
      (this.getFoveation = function () {
        if (!(P === null && de === null)) return c;
      }),
      (this.setFoveation = function (Kt) {
        (c = Kt),
          P !== null && (P.fixedFoveation = Kt),
          de !== null &&
            de.fixedFoveation !== void 0 &&
            (de.fixedFoveation = Kt);
      }),
      (this.hasDepthSensing = function () {
        return Ye.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return Ye.getMesh(Ct);
      });
    let Ot = null;
    function Xt(Kt, tn) {
      if (((p = tn.getViewerPose(u || a)), (me = tn), p !== null)) {
        const pn = p.views;
        de !== null &&
          (e.setRenderTargetFramebuffer(ot, de.framebuffer),
          e.setRenderTarget(ot));
        let _n = !1;
        pn.length !== Ct.cameras.length && ((Ct.cameras.length = 0), (_n = !0));
        for (let tr = 0; tr < pn.length; tr++) {
          const ur = pn[tr];
          let _r = null;
          if (de !== null) _r = de.getViewport(ur);
          else {
            const jt = N.getViewSubImage(P, ur);
            (_r = jt.viewport),
              tr === 0 &&
                (e.setRenderTargetTextures(
                  ot,
                  jt.colorTexture,
                  jt.depthStencilTexture
                ),
                e.setRenderTarget(ot));
          }
          let Bn = Tt[tr];
          Bn === void 0 &&
            ((Bn = new PerspectiveCamera()),
            Bn.layers.enable(tr),
            (Bn.viewport = new Vector4()),
            (Tt[tr] = Bn)),
            Bn.matrix.fromArray(ur.transform.matrix),
            Bn.matrix.decompose(Bn.position, Bn.quaternion, Bn.scale),
            Bn.projectionMatrix.fromArray(ur.projectionMatrix),
            Bn.projectionMatrixInverse.copy(Bn.projectionMatrix).invert(),
            Bn.viewport.set(_r.x, _r.y, _r.width, _r.height),
            tr === 0 &&
              (Ct.matrix.copy(Bn.matrix),
              Ct.matrix.decompose(Ct.position, Ct.quaternion, Ct.scale)),
            _n === !0 && Ct.cameras.push(Bn);
        }
        const bn = s.enabledFeatures;
        if (
          bn &&
          bn.includes("depth-sensing") &&
          s.depthUsage == "gpu-optimized" &&
          N
        ) {
          const tr = N.getDepthInformation(pn[0]);
          tr && tr.isValid && tr.texture && Ye.init(e, tr, s.renderState);
        }
      }
      for (let pn = 0; pn < st.length; pn++) {
        const _n = vt[pn],
          bn = st[pn];
        _n !== null && bn !== void 0 && bn.update(_n, tn, u || a);
      }
      Ot && Ot(Kt, tn),
        tn.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: tn }),
        (me = null);
    }
    const sn = new WebGLAnimation();
    sn.setAnimationLoop(Xt),
      (this.setAnimationLoop = function (Kt) {
        Ot = Kt;
      }),
      (this.dispose = function () {});
  }
}
const _e1 = new Euler(),
  _m1 = new Matrix4();
function WebGLMaterials(n, e) {
  function t(nt, Be) {
    nt.matrixAutoUpdate === !0 && nt.updateMatrix(), Be.value.copy(nt.matrix);
  }
  function r(nt, Be) {
    Be.color.getRGB(nt.fogColor.value, getUnlitUniformColorSpace(n)),
      Be.isFog
        ? ((nt.fogNear.value = Be.near), (nt.fogFar.value = Be.far))
        : Be.isFogExp2 && (nt.fogDensity.value = Be.density);
  }
  function s(nt, Be, ot, st, vt) {
    Be.isMeshBasicMaterial || Be.isMeshLambertMaterial
      ? o(nt, Be)
      : Be.isMeshToonMaterial
      ? (o(nt, Be), N(nt, Be))
      : Be.isMeshPhongMaterial
      ? (o(nt, Be), p(nt, Be))
      : Be.isMeshStandardMaterial
      ? (o(nt, Be), P(nt, Be), Be.isMeshPhysicalMaterial && de(nt, Be, vt))
      : Be.isMeshMatcapMaterial
      ? (o(nt, Be), me(nt, Be))
      : Be.isMeshDepthMaterial
      ? o(nt, Be)
      : Be.isMeshDistanceMaterial
      ? (o(nt, Be), Ye(nt, Be))
      : Be.isMeshNormalMaterial
      ? o(nt, Be)
      : Be.isLineBasicMaterial
      ? (a(nt, Be), Be.isLineDashedMaterial && l(nt, Be))
      : Be.isPointsMaterial
      ? c(nt, Be, ot, st)
      : Be.isSpriteMaterial
      ? u(nt, Be)
      : Be.isShadowMaterial
      ? (nt.color.value.copy(Be.color), (nt.opacity.value = Be.opacity))
      : Be.isShaderMaterial && (Be.uniformsNeedUpdate = !1);
  }
  function o(nt, Be) {
    (nt.opacity.value = Be.opacity),
      Be.color && nt.diffuse.value.copy(Be.color),
      Be.emissive &&
        nt.emissive.value
          .copy(Be.emissive)
          .multiplyScalar(Be.emissiveIntensity),
      Be.map && ((nt.map.value = Be.map), t(Be.map, nt.mapTransform)),
      Be.alphaMap &&
        ((nt.alphaMap.value = Be.alphaMap),
        t(Be.alphaMap, nt.alphaMapTransform)),
      Be.bumpMap &&
        ((nt.bumpMap.value = Be.bumpMap),
        t(Be.bumpMap, nt.bumpMapTransform),
        (nt.bumpScale.value = Be.bumpScale),
        Be.side === BackSide && (nt.bumpScale.value *= -1)),
      Be.normalMap &&
        ((nt.normalMap.value = Be.normalMap),
        t(Be.normalMap, nt.normalMapTransform),
        nt.normalScale.value.copy(Be.normalScale),
        Be.side === BackSide && nt.normalScale.value.negate()),
      Be.displacementMap &&
        ((nt.displacementMap.value = Be.displacementMap),
        t(Be.displacementMap, nt.displacementMapTransform),
        (nt.displacementScale.value = Be.displacementScale),
        (nt.displacementBias.value = Be.displacementBias)),
      Be.emissiveMap &&
        ((nt.emissiveMap.value = Be.emissiveMap),
        t(Be.emissiveMap, nt.emissiveMapTransform)),
      Be.specularMap &&
        ((nt.specularMap.value = Be.specularMap),
        t(Be.specularMap, nt.specularMapTransform)),
      Be.alphaTest > 0 && (nt.alphaTest.value = Be.alphaTest);
    const ot = e.get(Be),
      st = ot.envMap,
      vt = ot.envMapRotation;
    st &&
      ((nt.envMap.value = st),
      _e1.copy(vt),
      (_e1.x *= -1),
      (_e1.y *= -1),
      (_e1.z *= -1),
      st.isCubeTexture &&
        st.isRenderTargetTexture === !1 &&
        ((_e1.y *= -1), (_e1.z *= -1)),
      nt.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),
      (nt.flipEnvMap.value =
        st.isCubeTexture && st.isRenderTargetTexture === !1 ? -1 : 1),
      (nt.reflectivity.value = Be.reflectivity),
      (nt.ior.value = Be.ior),
      (nt.refractionRatio.value = Be.refractionRatio)),
      Be.lightMap &&
        ((nt.lightMap.value = Be.lightMap),
        (nt.lightMapIntensity.value = Be.lightMapIntensity),
        t(Be.lightMap, nt.lightMapTransform)),
      Be.aoMap &&
        ((nt.aoMap.value = Be.aoMap),
        (nt.aoMapIntensity.value = Be.aoMapIntensity),
        t(Be.aoMap, nt.aoMapTransform));
  }
  function a(nt, Be) {
    nt.diffuse.value.copy(Be.color),
      (nt.opacity.value = Be.opacity),
      Be.map && ((nt.map.value = Be.map), t(Be.map, nt.mapTransform));
  }
  function l(nt, Be) {
    (nt.dashSize.value = Be.dashSize),
      (nt.totalSize.value = Be.dashSize + Be.gapSize),
      (nt.scale.value = Be.scale);
  }
  function c(nt, Be, ot, st) {
    nt.diffuse.value.copy(Be.color),
      (nt.opacity.value = Be.opacity),
      (nt.size.value = Be.size * ot),
      (nt.scale.value = st * 0.5),
      Be.map && ((nt.map.value = Be.map), t(Be.map, nt.uvTransform)),
      Be.alphaMap &&
        ((nt.alphaMap.value = Be.alphaMap),
        t(Be.alphaMap, nt.alphaMapTransform)),
      Be.alphaTest > 0 && (nt.alphaTest.value = Be.alphaTest);
  }
  function u(nt, Be) {
    nt.diffuse.value.copy(Be.color),
      (nt.opacity.value = Be.opacity),
      (nt.rotation.value = Be.rotation),
      Be.map && ((nt.map.value = Be.map), t(Be.map, nt.mapTransform)),
      Be.alphaMap &&
        ((nt.alphaMap.value = Be.alphaMap),
        t(Be.alphaMap, nt.alphaMapTransform)),
      Be.alphaTest > 0 && (nt.alphaTest.value = Be.alphaTest);
  }
  function p(nt, Be) {
    nt.specular.value.copy(Be.specular),
      (nt.shininess.value = Math.max(Be.shininess, 1e-4));
  }
  function N(nt, Be) {
    Be.gradientMap && (nt.gradientMap.value = Be.gradientMap);
  }
  function P(nt, Be) {
    (nt.metalness.value = Be.metalness),
      Be.metalnessMap &&
        ((nt.metalnessMap.value = Be.metalnessMap),
        t(Be.metalnessMap, nt.metalnessMapTransform)),
      (nt.roughness.value = Be.roughness),
      Be.roughnessMap &&
        ((nt.roughnessMap.value = Be.roughnessMap),
        t(Be.roughnessMap, nt.roughnessMapTransform)),
      Be.envMap && (nt.envMapIntensity.value = Be.envMapIntensity);
  }
  function de(nt, Be, ot) {
    (nt.ior.value = Be.ior),
      Be.sheen > 0 &&
        (nt.sheenColor.value.copy(Be.sheenColor).multiplyScalar(Be.sheen),
        (nt.sheenRoughness.value = Be.sheenRoughness),
        Be.sheenColorMap &&
          ((nt.sheenColorMap.value = Be.sheenColorMap),
          t(Be.sheenColorMap, nt.sheenColorMapTransform)),
        Be.sheenRoughnessMap &&
          ((nt.sheenRoughnessMap.value = Be.sheenRoughnessMap),
          t(Be.sheenRoughnessMap, nt.sheenRoughnessMapTransform))),
      Be.clearcoat > 0 &&
        ((nt.clearcoat.value = Be.clearcoat),
        (nt.clearcoatRoughness.value = Be.clearcoatRoughness),
        Be.clearcoatMap &&
          ((nt.clearcoatMap.value = Be.clearcoatMap),
          t(Be.clearcoatMap, nt.clearcoatMapTransform)),
        Be.clearcoatRoughnessMap &&
          ((nt.clearcoatRoughnessMap.value = Be.clearcoatRoughnessMap),
          t(Be.clearcoatRoughnessMap, nt.clearcoatRoughnessMapTransform)),
        Be.clearcoatNormalMap &&
          ((nt.clearcoatNormalMap.value = Be.clearcoatNormalMap),
          t(Be.clearcoatNormalMap, nt.clearcoatNormalMapTransform),
          nt.clearcoatNormalScale.value.copy(Be.clearcoatNormalScale),
          Be.side === BackSide && nt.clearcoatNormalScale.value.negate())),
      Be.dispersion > 0 && (nt.dispersion.value = Be.dispersion),
      Be.iridescence > 0 &&
        ((nt.iridescence.value = Be.iridescence),
        (nt.iridescenceIOR.value = Be.iridescenceIOR),
        (nt.iridescenceThicknessMinimum.value =
          Be.iridescenceThicknessRange[0]),
        (nt.iridescenceThicknessMaximum.value =
          Be.iridescenceThicknessRange[1]),
        Be.iridescenceMap &&
          ((nt.iridescenceMap.value = Be.iridescenceMap),
          t(Be.iridescenceMap, nt.iridescenceMapTransform)),
        Be.iridescenceThicknessMap &&
          ((nt.iridescenceThicknessMap.value = Be.iridescenceThicknessMap),
          t(Be.iridescenceThicknessMap, nt.iridescenceThicknessMapTransform))),
      Be.transmission > 0 &&
        ((nt.transmission.value = Be.transmission),
        (nt.transmissionSamplerMap.value = ot.texture),
        nt.transmissionSamplerSize.value.set(ot.width, ot.height),
        Be.transmissionMap &&
          ((nt.transmissionMap.value = Be.transmissionMap),
          t(Be.transmissionMap, nt.transmissionMapTransform)),
        (nt.thickness.value = Be.thickness),
        Be.thicknessMap &&
          ((nt.thicknessMap.value = Be.thicknessMap),
          t(Be.thicknessMap, nt.thicknessMapTransform)),
        (nt.attenuationDistance.value = Be.attenuationDistance),
        nt.attenuationColor.value.copy(Be.attenuationColor)),
      Be.anisotropy > 0 &&
        (nt.anisotropyVector.value.set(
          Be.anisotropy * Math.cos(Be.anisotropyRotation),
          Be.anisotropy * Math.sin(Be.anisotropyRotation)
        ),
        Be.anisotropyMap &&
          ((nt.anisotropyMap.value = Be.anisotropyMap),
          t(Be.anisotropyMap, nt.anisotropyMapTransform))),
      (nt.specularIntensity.value = Be.specularIntensity),
      nt.specularColor.value.copy(Be.specularColor),
      Be.specularColorMap &&
        ((nt.specularColorMap.value = Be.specularColorMap),
        t(Be.specularColorMap, nt.specularColorMapTransform)),
      Be.specularIntensityMap &&
        ((nt.specularIntensityMap.value = Be.specularIntensityMap),
        t(Be.specularIntensityMap, nt.specularIntensityMapTransform));
  }
  function me(nt, Be) {
    Be.matcap && (nt.matcap.value = Be.matcap);
  }
  function Ye(nt, Be) {
    const ot = e.get(Be).light;
    nt.referencePosition.value.setFromMatrixPosition(ot.matrixWorld),
      (nt.nearDistance.value = ot.shadow.camera.near),
      (nt.farDistance.value = ot.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: s };
}
function WebGLUniformsGroups(n, e, t, r) {
  let s = {},
    o = {},
    a = [];
  const l = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(ot, st) {
    const vt = st.program;
    r.uniformBlockBinding(ot, vt);
  }
  function u(ot, st) {
    let vt = s[ot.id];
    vt === void 0 &&
      (me(ot),
      (vt = p(ot)),
      (s[ot.id] = vt),
      ot.addEventListener("dispose", nt));
    const xt = st.program;
    r.updateUBOMapping(ot, xt);
    const St = e.render.frame;
    o[ot.id] !== St && (P(ot), (o[ot.id] = St));
  }
  function p(ot) {
    const st = N();
    ot.__bindingPointIndex = st;
    const vt = n.createBuffer(),
      xt = ot.__size,
      St = ot.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, vt),
      n.bufferData(n.UNIFORM_BUFFER, xt, St),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, st, vt),
      vt
    );
  }
  function N() {
    for (let ot = 0; ot < l; ot++)
      if (a.indexOf(ot) === -1) return a.push(ot), ot;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function P(ot) {
    const st = s[ot.id],
      vt = ot.uniforms,
      xt = ot.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, st);
    for (let St = 0, wt = vt.length; St < wt; St++) {
      const bt = Array.isArray(vt[St]) ? vt[St] : [vt[St]];
      for (let Tt = 0, Ct = bt.length; Tt < Ct; Tt++) {
        const kt = bt[Tt];
        if (de(kt, St, Tt, xt) === !0) {
          const Dt = kt.__offset,
            Vt = Array.isArray(kt.value) ? kt.value : [kt.value];
          let Ht = 0;
          for (let qt = 0; qt < Vt.length; qt++) {
            const Ft = Vt[qt],
              Bt = Ye(Ft);
            typeof Ft == "number" || typeof Ft == "boolean"
              ? ((kt.__data[0] = Ft),
                n.bufferSubData(n.UNIFORM_BUFFER, Dt + Ht, kt.__data))
              : Ft.isMatrix3
              ? ((kt.__data[0] = Ft.elements[0]),
                (kt.__data[1] = Ft.elements[1]),
                (kt.__data[2] = Ft.elements[2]),
                (kt.__data[3] = 0),
                (kt.__data[4] = Ft.elements[3]),
                (kt.__data[5] = Ft.elements[4]),
                (kt.__data[6] = Ft.elements[5]),
                (kt.__data[7] = 0),
                (kt.__data[8] = Ft.elements[6]),
                (kt.__data[9] = Ft.elements[7]),
                (kt.__data[10] = Ft.elements[8]),
                (kt.__data[11] = 0))
              : (Ft.toArray(kt.__data, Ht),
                (Ht += Bt.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, Dt, kt.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function de(ot, st, vt, xt) {
    const St = ot.value,
      wt = st + "_" + vt;
    if (xt[wt] === void 0)
      return (
        typeof St == "number" || typeof St == "boolean"
          ? (xt[wt] = St)
          : (xt[wt] = St.clone()),
        !0
      );
    {
      const bt = xt[wt];
      if (typeof St == "number" || typeof St == "boolean") {
        if (bt !== St) return (xt[wt] = St), !0;
      } else if (bt.equals(St) === !1) return bt.copy(St), !0;
    }
    return !1;
  }
  function me(ot) {
    const st = ot.uniforms;
    let vt = 0;
    const xt = 16;
    for (let wt = 0, bt = st.length; wt < bt; wt++) {
      const Tt = Array.isArray(st[wt]) ? st[wt] : [st[wt]];
      for (let Ct = 0, kt = Tt.length; Ct < kt; Ct++) {
        const Dt = Tt[Ct],
          Vt = Array.isArray(Dt.value) ? Dt.value : [Dt.value];
        for (let Ht = 0, qt = Vt.length; Ht < qt; Ht++) {
          const Ft = Vt[Ht],
            Bt = Ye(Ft),
            Mt = vt % xt,
            Pt = Mt % Bt.boundary,
            It = Mt + Pt;
          (vt += Pt),
            It !== 0 && xt - It < Bt.storage && (vt += xt - It),
            (Dt.__data = new Float32Array(
              Bt.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (Dt.__offset = vt),
            (vt += Bt.storage);
        }
      }
    }
    const St = vt % xt;
    return St > 0 && (vt += xt - St), (ot.__size = vt), (ot.__cache = {}), this;
  }
  function Ye(ot) {
    const st = { boundary: 0, storage: 0 };
    return (
      typeof ot == "number" || typeof ot == "boolean"
        ? ((st.boundary = 4), (st.storage = 4))
        : ot.isVector2
        ? ((st.boundary = 8), (st.storage = 8))
        : ot.isVector3 || ot.isColor
        ? ((st.boundary = 16), (st.storage = 12))
        : ot.isVector4
        ? ((st.boundary = 16), (st.storage = 16))
        : ot.isMatrix3
        ? ((st.boundary = 48), (st.storage = 48))
        : ot.isMatrix4
        ? ((st.boundary = 64), (st.storage = 64))
        : ot.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            ot
          ),
      st
    );
  }
  function nt(ot) {
    const st = ot.target;
    st.removeEventListener("dispose", nt);
    const vt = a.indexOf(st.__bindingPointIndex);
    a.splice(vt, 1), n.deleteBuffer(s[st.id]), delete s[st.id], delete o[st.id];
  }
  function Be() {
    for (const ot in s) n.deleteBuffer(s[ot]);
    (a = []), (s = {}), (o = {});
  }
  return { bind: c, update: u, dispose: Be };
}
class WebGLRenderer {
  constructor(e = {}) {
    const {
      canvas: t = createCanvasElement(),
      context: r = null,
      depth: s = !0,
      stencil: o = !1,
      alpha: a = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: p = "default",
      failIfMajorPerformanceCaveat: N = !1,
      reverseDepthBuffer: P = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let de;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      de = r.getContextAttributes().alpha;
    } else de = a;
    const me = new Uint32Array(4),
      Ye = new Int32Array(4);
    let nt = null,
      Be = null;
    const ot = [],
      st = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = NoToneMapping),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1);
    const vt = this;
    let xt = !1;
    this._outputColorSpace = SRGBColorSpace;
    let St = 0,
      wt = 0,
      bt = null,
      Tt = -1,
      Ct = null;
    const kt = new Vector4(),
      Dt = new Vector4();
    let Vt = null;
    const Ht = new Color(0);
    let qt = 0,
      Ft = t.width,
      Bt = t.height,
      Mt = 1,
      Pt = null,
      It = null;
    const Ot = new Vector4(0, 0, Ft, Bt),
      Xt = new Vector4(0, 0, Ft, Bt);
    let sn = !1;
    const Kt = new Frustum();
    let tn = !1,
      pn = !1;
    const _n = new Matrix4(),
      bn = new Matrix4(),
      $n = new Vector3(),
      tr = new Vector4(),
      ur = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let _r = !1;
    function Bn() {
      return bt === null ? Mt : 1;
    }
    let jt = r;
    function Yn(zt, Zt) {
      return t.getContext(zt, Zt);
    }
    try {
      const zt = {
        alpha: !0,
        depth: s,
        stencil: o,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: p,
        failIfMajorPerformanceCaveat: N,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${REVISION}`),
        t.addEventListener("webglcontextlost", Hn, !1),
        t.addEventListener("webglcontextrestored", hr, !1),
        t.addEventListener("webglcontextcreationerror", pr, !1),
        jt === null)
      ) {
        const Zt = "webgl2";
        if (((jt = Yn(Zt, zt)), jt === null))
          throw Yn(Zt)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (zt) {
      throw (console.error("THREE.WebGLRenderer: " + zt.message), zt);
    }
    let zn,
      rn,
      In,
      or,
      Gn,
      Yt,
      Gt,
      hn,
      En,
      Ln,
      mn,
      Vn,
      Fn,
      nr,
      yr,
      qn,
      jn,
      Jn,
      mr,
      Sr,
      Ur,
      Pr,
      Hr,
      cn;
    function An() {
      (zn = new WebGLExtensions(jt)),
        zn.init(),
        (Pr = new WebGLUtils(jt, zn)),
        (rn = new WebGLCapabilities(jt, zn, e, Pr)),
        (In = new WebGLState(jt, zn)),
        rn.reverseDepthBuffer && P && In.buffers.depth.setReversed(!0),
        (or = new WebGLInfo(jt)),
        (Gn = new WebGLProperties()),
        (Yt = new WebGLTextures(jt, zn, In, Gn, rn, Pr, or)),
        (Gt = new WebGLCubeMaps(vt)),
        (hn = new WebGLCubeUVMaps(vt)),
        (En = new WebGLAttributes(jt)),
        (Hr = new WebGLBindingStates(jt, En)),
        (Ln = new WebGLGeometries(jt, En, or, Hr)),
        (mn = new WebGLObjects(jt, Ln, En, or)),
        (mr = new WebGLMorphtargets(jt, rn, Yt)),
        (qn = new WebGLClipping(Gn)),
        (Vn = new WebGLPrograms(vt, Gt, hn, zn, rn, Hr, qn)),
        (Fn = new WebGLMaterials(vt, Gn)),
        (nr = new WebGLRenderLists()),
        (yr = new WebGLRenderStates(zn)),
        (Jn = new WebGLBackground(vt, Gt, hn, In, mn, de, c)),
        (jn = new WebGLShadowMap(vt, mn, rn)),
        (cn = new WebGLUniformsGroups(jt, or, rn, In)),
        (Sr = new WebGLBufferRenderer(jt, zn, or)),
        (Ur = new WebGLIndexedBufferRenderer(jt, zn, or)),
        (or.programs = Vn.programs),
        (vt.capabilities = rn),
        (vt.extensions = zn),
        (vt.properties = Gn),
        (vt.renderLists = nr),
        (vt.shadowMap = jn),
        (vt.state = In),
        (vt.info = or);
    }
    An();
    const Mn = new WebXRManager(vt, jt);
    (this.xr = Mn),
      (this.getContext = function () {
        return jt;
      }),
      (this.getContextAttributes = function () {
        return jt.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const zt = zn.get("WEBGL_lose_context");
        zt && zt.loseContext();
      }),
      (this.forceContextRestore = function () {
        const zt = zn.get("WEBGL_lose_context");
        zt && zt.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Mt;
      }),
      (this.setPixelRatio = function (zt) {
        zt !== void 0 && ((Mt = zt), this.setSize(Ft, Bt, !1));
      }),
      (this.getSize = function (zt) {
        return zt.set(Ft, Bt);
      }),
      (this.setSize = function (zt, Zt, an = !0) {
        if (Mn.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Ft = zt),
          (Bt = Zt),
          (t.width = Math.floor(zt * Mt)),
          (t.height = Math.floor(Zt * Mt)),
          an === !0 &&
            ((t.style.width = zt + "px"), (t.style.height = Zt + "px")),
          this.setViewport(0, 0, zt, Zt);
      }),
      (this.getDrawingBufferSize = function (zt) {
        return zt.set(Ft * Mt, Bt * Mt).floor();
      }),
      (this.setDrawingBufferSize = function (zt, Zt, an) {
        (Ft = zt),
          (Bt = Zt),
          (Mt = an),
          (t.width = Math.floor(zt * an)),
          (t.height = Math.floor(Zt * an)),
          this.setViewport(0, 0, zt, Zt);
      }),
      (this.getCurrentViewport = function (zt) {
        return zt.copy(kt);
      }),
      (this.getViewport = function (zt) {
        return zt.copy(Ot);
      }),
      (this.setViewport = function (zt, Zt, an, Qt) {
        zt.isVector4 ? Ot.set(zt.x, zt.y, zt.z, zt.w) : Ot.set(zt, Zt, an, Qt),
          In.viewport(kt.copy(Ot).multiplyScalar(Mt).round());
      }),
      (this.getScissor = function (zt) {
        return zt.copy(Xt);
      }),
      (this.setScissor = function (zt, Zt, an, Qt) {
        zt.isVector4 ? Xt.set(zt.x, zt.y, zt.z, zt.w) : Xt.set(zt, Zt, an, Qt),
          In.scissor(Dt.copy(Xt).multiplyScalar(Mt).round());
      }),
      (this.getScissorTest = function () {
        return sn;
      }),
      (this.setScissorTest = function (zt) {
        In.setScissorTest((sn = zt));
      }),
      (this.setOpaqueSort = function (zt) {
        Pt = zt;
      }),
      (this.setTransparentSort = function (zt) {
        It = zt;
      }),
      (this.getClearColor = function (zt) {
        return zt.copy(Jn.getClearColor());
      }),
      (this.setClearColor = function () {
        Jn.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return Jn.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Jn.setClearAlpha(...arguments);
      }),
      (this.clear = function (zt = !0, Zt = !0, an = !0) {
        let Qt = 0;
        if (zt) {
          let fn = !1;
          if (bt !== null) {
            const wn = bt.texture.format;
            fn =
              wn === RGBAIntegerFormat ||
              wn === RGIntegerFormat ||
              wn === RedIntegerFormat;
          }
          if (fn) {
            const wn = bt.texture.type,
              On =
                wn === UnsignedByteType ||
                wn === UnsignedIntType ||
                wn === UnsignedShortType ||
                wn === UnsignedInt248Type ||
                wn === UnsignedShort4444Type ||
                wn === UnsignedShort5551Type,
              Kn = Jn.getClearColor(),
              Zn = Jn.getClearAlpha(),
              ar = Kn.r,
              cr = Kn.g,
              Qn = Kn.b;
            On
              ? ((me[0] = ar),
                (me[1] = cr),
                (me[2] = Qn),
                (me[3] = Zn),
                jt.clearBufferuiv(jt.COLOR, 0, me))
              : ((Ye[0] = ar),
                (Ye[1] = cr),
                (Ye[2] = Qn),
                (Ye[3] = Zn),
                jt.clearBufferiv(jt.COLOR, 0, Ye));
          } else Qt |= jt.COLOR_BUFFER_BIT;
        }
        Zt && (Qt |= jt.DEPTH_BUFFER_BIT),
          an &&
            ((Qt |= jt.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          jt.clear(Qt);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Hn, !1),
          t.removeEventListener("webglcontextrestored", hr, !1),
          t.removeEventListener("webglcontextcreationerror", pr, !1),
          Jn.dispose(),
          nr.dispose(),
          yr.dispose(),
          Gn.dispose(),
          Gt.dispose(),
          hn.dispose(),
          mn.dispose(),
          Hr.dispose(),
          cn.dispose(),
          Vn.dispose(),
          Mn.dispose(),
          Mn.removeEventListener("sessionstart", xr),
          Mn.removeEventListener("sessionend", Fr),
          Cr.stop();
      });
    function Hn(zt) {
      zt.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (xt = !0);
    }
    function hr() {
      console.log("THREE.WebGLRenderer: Context Restored."), (xt = !1);
      const zt = or.autoReset,
        Zt = jn.enabled,
        an = jn.autoUpdate,
        Qt = jn.needsUpdate,
        fn = jn.type;
      An(),
        (or.autoReset = zt),
        (jn.enabled = Zt),
        (jn.autoUpdate = an),
        (jn.needsUpdate = Qt),
        (jn.type = fn);
    }
    function pr(zt) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        zt.statusMessage
      );
    }
    function jr(zt) {
      const Zt = zt.target;
      Zt.removeEventListener("dispose", jr), fi(Zt);
    }
    function fi(zt) {
      wi(zt), Gn.remove(zt);
    }
    function wi(zt) {
      const Zt = Gn.get(zt).programs;
      Zt !== void 0 &&
        (Zt.forEach(function (an) {
          Vn.releaseProgram(an);
        }),
        zt.isShaderMaterial && Vn.releaseShaderCache(zt));
    }
    this.renderBufferDirect = function (zt, Zt, an, Qt, fn, wn) {
      Zt === null && (Zt = ur);
      const On = fn.isMesh && fn.matrixWorld.determinant() < 0,
        Kn = un(zt, Zt, an, Qt, fn);
      In.setMaterial(Qt, On);
      let Zn = an.index,
        ar = 1;
      if (Qt.wireframe === !0) {
        if (((Zn = Ln.getWireframeAttribute(an)), Zn === void 0)) return;
        ar = 2;
      }
      const cr = an.drawRange,
        Qn = an.attributes.position;
      let gr = cr.start * ar,
        Tr = (cr.start + cr.count) * ar;
      wn !== null &&
        ((gr = Math.max(gr, wn.start * ar)),
        (Tr = Math.min(Tr, (wn.start + wn.count) * ar))),
        Zn !== null
          ? ((gr = Math.max(gr, 0)), (Tr = Math.min(Tr, Zn.count)))
          : Qn != null &&
            ((gr = Math.max(gr, 0)), (Tr = Math.min(Tr, Qn.count)));
      const Qr = Tr - gr;
      if (Qr < 0 || Qr === 1 / 0) return;
      Hr.setup(fn, Qt, Kn, an, Zn);
      let Dr,
        Br = Sr;
      if (
        (Zn !== null && ((Dr = En.get(Zn)), (Br = Ur), Br.setIndex(Dr)),
        fn.isMesh)
      )
        Qt.wireframe === !0
          ? (In.setLineWidth(Qt.wireframeLinewidth * Bn()),
            Br.setMode(jt.LINES))
          : Br.setMode(jt.TRIANGLES);
      else if (fn.isLine) {
        let Mr = Qt.linewidth;
        Mr === void 0 && (Mr = 1),
          In.setLineWidth(Mr * Bn()),
          fn.isLineSegments
            ? Br.setMode(jt.LINES)
            : fn.isLineLoop
            ? Br.setMode(jt.LINE_LOOP)
            : Br.setMode(jt.LINE_STRIP);
      } else
        fn.isPoints
          ? Br.setMode(jt.POINTS)
          : fn.isSprite && Br.setMode(jt.TRIANGLES);
      if (fn.isBatchedMesh)
        if (fn._multiDrawInstances !== null)
          warnOnce(
            "THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
          ),
            Br.renderMultiDrawInstances(
              fn._multiDrawStarts,
              fn._multiDrawCounts,
              fn._multiDrawCount,
              fn._multiDrawInstances
            );
        else if (zn.get("WEBGL_multi_draw"))
          Br.renderMultiDraw(
            fn._multiDrawStarts,
            fn._multiDrawCounts,
            fn._multiDrawCount
          );
        else {
          const Mr = fn._multiDrawStarts,
            oi = fn._multiDrawCounts,
            Xr = fn._multiDrawCount,
            ti = Zn ? En.get(Zn).bytesPerElement : 1,
            bi = Gn.get(Qt).currentProgram.getUniforms();
          for (let ni = 0; ni < Xr; ni++)
            bi.setValue(jt, "_gl_DrawID", ni), Br.render(Mr[ni] / ti, oi[ni]);
        }
      else if (fn.isInstancedMesh) Br.renderInstances(gr, Qr, fn.count);
      else if (an.isInstancedBufferGeometry) {
        const Mr =
            an._maxInstanceCount !== void 0 ? an._maxInstanceCount : 1 / 0,
          oi = Math.min(an.instanceCount, Mr);
        Br.renderInstances(gr, Qr, oi);
      } else Br.render(gr, Qr);
    };
    function wr(zt, Zt, an) {
      zt.transparent === !0 &&
      zt.side === DoubleSide &&
      zt.forceSinglePass === !1
        ? ((zt.side = BackSide),
          (zt.needsUpdate = !0),
          mi(zt, Zt, an),
          (zt.side = FrontSide),
          (zt.needsUpdate = !0),
          mi(zt, Zt, an),
          (zt.side = DoubleSide))
        : mi(zt, Zt, an);
    }
    (this.compile = function (zt, Zt, an = null) {
      an === null && (an = zt),
        (Be = yr.get(an)),
        Be.init(Zt),
        st.push(Be),
        an.traverseVisible(function (fn) {
          fn.isLight &&
            fn.layers.test(Zt.layers) &&
            (Be.pushLight(fn), fn.castShadow && Be.pushShadow(fn));
        }),
        zt !== an &&
          zt.traverseVisible(function (fn) {
            fn.isLight &&
              fn.layers.test(Zt.layers) &&
              (Be.pushLight(fn), fn.castShadow && Be.pushShadow(fn));
          }),
        Be.setupLights();
      const Qt = new Set();
      return (
        zt.traverse(function (fn) {
          if (!(fn.isMesh || fn.isPoints || fn.isLine || fn.isSprite)) return;
          const wn = fn.material;
          if (wn)
            if (Array.isArray(wn))
              for (let On = 0; On < wn.length; On++) {
                const Kn = wn[On];
                wr(Kn, an, fn), Qt.add(Kn);
              }
            else wr(wn, an, fn), Qt.add(wn);
        }),
        (Be = st.pop()),
        Qt
      );
    }),
      (this.compileAsync = function (zt, Zt, an = null) {
        const Qt = this.compile(zt, Zt, an);
        return new Promise((fn) => {
          function wn() {
            if (
              (Qt.forEach(function (On) {
                Gn.get(On).currentProgram.isReady() && Qt.delete(On);
              }),
              Qt.size === 0)
            ) {
              fn(zt);
              return;
            }
            setTimeout(wn, 10);
          }
          zn.get("KHR_parallel_shader_compile") !== null
            ? wn()
            : setTimeout(wn, 10);
        });
      });
    let Rr = null;
    function $r(zt) {
      Rr && Rr(zt);
    }
    function xr() {
      Cr.stop();
    }
    function Fr() {
      Cr.start();
    }
    const Cr = new WebGLAnimation();
    Cr.setAnimationLoop($r),
      typeof self < "u" && Cr.setContext(self),
      (this.setAnimationLoop = function (zt) {
        (Rr = zt),
          Mn.setAnimationLoop(zt),
          zt === null ? Cr.stop() : Cr.start();
      }),
      Mn.addEventListener("sessionstart", xr),
      Mn.addEventListener("sessionend", Fr),
      (this.render = function (zt, Zt) {
        if (Zt !== void 0 && Zt.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (xt === !0) return;
        if (
          (zt.matrixWorldAutoUpdate === !0 && zt.updateMatrixWorld(),
          Zt.parent === null &&
            Zt.matrixWorldAutoUpdate === !0 &&
            Zt.updateMatrixWorld(),
          Mn.enabled === !0 &&
            Mn.isPresenting === !0 &&
            (Mn.cameraAutoUpdate === !0 && Mn.updateCamera(Zt),
            (Zt = Mn.getCamera())),
          zt.isScene === !0 && zt.onBeforeRender(vt, zt, Zt, bt),
          (Be = yr.get(zt, st.length)),
          Be.init(Zt),
          st.push(Be),
          bn.multiplyMatrices(Zt.projectionMatrix, Zt.matrixWorldInverse),
          Kt.setFromProjectionMatrix(bn),
          (pn = this.localClippingEnabled),
          (tn = qn.init(this.clippingPlanes, pn)),
          (nt = nr.get(zt, ot.length)),
          nt.init(),
          ot.push(nt),
          Mn.enabled === !0 && Mn.isPresenting === !0)
        ) {
          const wn = vt.xr.getDepthSensingMesh();
          wn !== null && zr(wn, Zt, -1 / 0, vt.sortObjects);
        }
        zr(zt, Zt, 0, vt.sortObjects),
          nt.finish(),
          vt.sortObjects === !0 && nt.sort(Pt, It),
          (_r =
            Mn.enabled === !1 ||
            Mn.isPresenting === !1 ||
            Mn.hasDepthSensing() === !1),
          _r && Jn.addToRenderList(nt, zt),
          this.info.render.frame++,
          tn === !0 && qn.beginShadows();
        const an = Be.state.shadowsArray;
        jn.render(an, zt, Zt),
          tn === !0 && qn.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Qt = nt.opaque,
          fn = nt.transmissive;
        if ((Be.setupLights(), Zt.isArrayCamera)) {
          const wn = Zt.cameras;
          if (fn.length > 0)
            for (let On = 0, Kn = wn.length; On < Kn; On++) {
              const Zn = wn[On];
              qr(Qt, fn, zt, Zn);
            }
          _r && Jn.render(zt);
          for (let On = 0, Kn = wn.length; On < Kn; On++) {
            const Zn = wn[On];
            pi(nt, zt, Zn, Zn.viewport);
          }
        } else
          fn.length > 0 && qr(Qt, fn, zt, Zt),
            _r && Jn.render(zt),
            pi(nt, zt, Zt);
        bt !== null &&
          wt === 0 &&
          (Yt.updateMultisampleRenderTarget(bt),
          Yt.updateRenderTargetMipmap(bt)),
          zt.isScene === !0 && zt.onAfterRender(vt, zt, Zt),
          Hr.resetDefaultState(),
          (Tt = -1),
          (Ct = null),
          st.pop(),
          st.length > 0
            ? ((Be = st[st.length - 1]),
              tn === !0 &&
                qn.setGlobalState(vt.clippingPlanes, Be.state.camera))
            : (Be = null),
          ot.pop(),
          ot.length > 0 ? (nt = ot[ot.length - 1]) : (nt = null);
      });
    function zr(zt, Zt, an, Qt) {
      if (zt.visible === !1) return;
      if (zt.layers.test(Zt.layers)) {
        if (zt.isGroup) an = zt.renderOrder;
        else if (zt.isLOD) zt.autoUpdate === !0 && zt.update(Zt);
        else if (zt.isLight)
          Be.pushLight(zt), zt.castShadow && Be.pushShadow(zt);
        else if (zt.isSprite) {
          if (!zt.frustumCulled || Kt.intersectsSprite(zt)) {
            Qt && tr.setFromMatrixPosition(zt.matrixWorld).applyMatrix4(bn);
            const On = mn.update(zt),
              Kn = zt.material;
            Kn.visible && nt.push(zt, On, Kn, an, tr.z, null);
          }
        } else if (
          (zt.isMesh || zt.isLine || zt.isPoints) &&
          (!zt.frustumCulled || Kt.intersectsObject(zt))
        ) {
          const On = mn.update(zt),
            Kn = zt.material;
          if (
            (Qt &&
              (zt.boundingSphere !== void 0
                ? (zt.boundingSphere === null && zt.computeBoundingSphere(),
                  tr.copy(zt.boundingSphere.center))
                : (On.boundingSphere === null && On.computeBoundingSphere(),
                  tr.copy(On.boundingSphere.center)),
              tr.applyMatrix4(zt.matrixWorld).applyMatrix4(bn)),
            Array.isArray(Kn))
          ) {
            const Zn = On.groups;
            for (let ar = 0, cr = Zn.length; ar < cr; ar++) {
              const Qn = Zn[ar],
                gr = Kn[Qn.materialIndex];
              gr && gr.visible && nt.push(zt, On, gr, an, tr.z, Qn);
            }
          } else Kn.visible && nt.push(zt, On, Kn, an, tr.z, null);
        }
      }
      const wn = zt.children;
      for (let On = 0, Kn = wn.length; On < Kn; On++) zr(wn[On], Zt, an, Qt);
    }
    function pi(zt, Zt, an, Qt) {
      const fn = zt.opaque,
        wn = zt.transmissive,
        On = zt.transparent;
      Be.setupLightsView(an),
        tn === !0 && qn.setGlobalState(vt.clippingPlanes, an),
        Qt && In.viewport(kt.copy(Qt)),
        fn.length > 0 && Ir(fn, Zt, an),
        wn.length > 0 && Ir(wn, Zt, an),
        On.length > 0 && Ir(On, Zt, an),
        In.buffers.depth.setTest(!0),
        In.buffers.depth.setMask(!0),
        In.buffers.color.setMask(!0),
        In.setPolygonOffset(!1);
    }
    function qr(zt, Zt, an, Qt) {
      if ((an.isScene === !0 ? an.overrideMaterial : null) !== null) return;
      Be.state.transmissionRenderTarget[Qt.id] === void 0 &&
        (Be.state.transmissionRenderTarget[Qt.id] = new WebGLRenderTarget(
          1,
          1,
          {
            generateMipmaps: !0,
            type:
              zn.has("EXT_color_buffer_half_float") ||
              zn.has("EXT_color_buffer_float")
                ? HalfFloatType
                : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: 4,
            stencilBuffer: o,
            resolveDepthBuffer: !1,
            resolveStencilBuffer: !1,
            colorSpace: ColorManagement.workingColorSpace,
          }
        ));
      const wn = Be.state.transmissionRenderTarget[Qt.id],
        On = Qt.viewport || kt;
      wn.setSize(
        On.z * vt.transmissionResolutionScale,
        On.w * vt.transmissionResolutionScale
      );
      const Kn = vt.getRenderTarget();
      vt.setRenderTarget(wn),
        vt.getClearColor(Ht),
        (qt = vt.getClearAlpha()),
        qt < 1 && vt.setClearColor(16777215, 0.5),
        vt.clear(),
        _r && Jn.render(an);
      const Zn = vt.toneMapping;
      vt.toneMapping = NoToneMapping;
      const ar = Qt.viewport;
      if (
        (Qt.viewport !== void 0 && (Qt.viewport = void 0),
        Be.setupLightsView(Qt),
        tn === !0 && qn.setGlobalState(vt.clippingPlanes, Qt),
        Ir(zt, an, Qt),
        Yt.updateMultisampleRenderTarget(wn),
        Yt.updateRenderTargetMipmap(wn),
        zn.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let cr = !1;
        for (let Qn = 0, gr = Zt.length; Qn < gr; Qn++) {
          const Tr = Zt[Qn],
            Qr = Tr.object,
            Dr = Tr.geometry,
            Br = Tr.material,
            Mr = Tr.group;
          if (Br.side === DoubleSide && Qr.layers.test(Qt.layers)) {
            const oi = Br.side;
            (Br.side = BackSide),
              (Br.needsUpdate = !0),
              Pi(Qr, an, Qt, Dr, Br, Mr),
              (Br.side = oi),
              (Br.needsUpdate = !0),
              (cr = !0);
          }
        }
        cr === !0 &&
          (Yt.updateMultisampleRenderTarget(wn),
          Yt.updateRenderTargetMipmap(wn));
      }
      vt.setRenderTarget(Kn),
        vt.setClearColor(Ht, qt),
        ar !== void 0 && (Qt.viewport = ar),
        (vt.toneMapping = Zn);
    }
    function Ir(zt, Zt, an) {
      const Qt = Zt.isScene === !0 ? Zt.overrideMaterial : null;
      for (let fn = 0, wn = zt.length; fn < wn; fn++) {
        const On = zt[fn],
          Kn = On.object,
          Zn = On.geometry,
          ar = On.group;
        let cr = On.material;
        cr.allowOverride === !0 && Qt !== null && (cr = Qt),
          Kn.layers.test(an.layers) && Pi(Kn, Zt, an, Zn, cr, ar);
      }
    }
    function Pi(zt, Zt, an, Qt, fn, wn) {
      zt.onBeforeRender(vt, Zt, an, Qt, fn, wn),
        zt.modelViewMatrix.multiplyMatrices(
          an.matrixWorldInverse,
          zt.matrixWorld
        ),
        zt.normalMatrix.getNormalMatrix(zt.modelViewMatrix),
        fn.onBeforeRender(vt, Zt, an, Qt, zt, wn),
        fn.transparent === !0 &&
        fn.side === DoubleSide &&
        fn.forceSinglePass === !1
          ? ((fn.side = BackSide),
            (fn.needsUpdate = !0),
            vt.renderBufferDirect(an, Zt, Qt, fn, zt, wn),
            (fn.side = FrontSide),
            (fn.needsUpdate = !0),
            vt.renderBufferDirect(an, Zt, Qt, fn, zt, wn),
            (fn.side = DoubleSide))
          : vt.renderBufferDirect(an, Zt, Qt, fn, zt, wn),
        zt.onAfterRender(vt, Zt, an, Qt, fn, wn);
    }
    function mi(zt, Zt, an) {
      Zt.isScene !== !0 && (Zt = ur);
      const Qt = Gn.get(zt),
        fn = Be.state.lights,
        wn = Be.state.shadowsArray,
        On = fn.state.version,
        Kn = Vn.getParameters(zt, fn.state, wn, Zt, an),
        Zn = Vn.getProgramCacheKey(Kn);
      let ar = Qt.programs;
      (Qt.environment = zt.isMeshStandardMaterial ? Zt.environment : null),
        (Qt.fog = Zt.fog),
        (Qt.envMap = (zt.isMeshStandardMaterial ? hn : Gt).get(
          zt.envMap || Qt.environment
        )),
        (Qt.envMapRotation =
          Qt.environment !== null && zt.envMap === null
            ? Zt.environmentRotation
            : zt.envMapRotation),
        ar === void 0 &&
          (zt.addEventListener("dispose", jr),
          (ar = new Map()),
          (Qt.programs = ar));
      let cr = ar.get(Zn);
      if (cr !== void 0) {
        if (Qt.currentProgram === cr && Qt.lightsStateVersion === On)
          return $t(zt, Kn), cr;
      } else
        (Kn.uniforms = Vn.getUniforms(zt)),
          zt.onBeforeCompile(Kn, vt),
          (cr = Vn.acquireProgram(Kn, Zn)),
          ar.set(Zn, cr),
          (Qt.uniforms = Kn.uniforms);
      const Qn = Qt.uniforms;
      return (
        ((!zt.isShaderMaterial && !zt.isRawShaderMaterial) ||
          zt.clipping === !0) &&
          (Qn.clippingPlanes = qn.uniform),
        $t(zt, Kn),
        (Qt.needsLights = Rn(zt)),
        (Qt.lightsStateVersion = On),
        Qt.needsLights &&
          ((Qn.ambientLightColor.value = fn.state.ambient),
          (Qn.lightProbe.value = fn.state.probe),
          (Qn.directionalLights.value = fn.state.directional),
          (Qn.directionalLightShadows.value = fn.state.directionalShadow),
          (Qn.spotLights.value = fn.state.spot),
          (Qn.spotLightShadows.value = fn.state.spotShadow),
          (Qn.rectAreaLights.value = fn.state.rectArea),
          (Qn.ltc_1.value = fn.state.rectAreaLTC1),
          (Qn.ltc_2.value = fn.state.rectAreaLTC2),
          (Qn.pointLights.value = fn.state.point),
          (Qn.pointLightShadows.value = fn.state.pointShadow),
          (Qn.hemisphereLights.value = fn.state.hemi),
          (Qn.directionalShadowMap.value = fn.state.directionalShadowMap),
          (Qn.directionalShadowMatrix.value = fn.state.directionalShadowMatrix),
          (Qn.spotShadowMap.value = fn.state.spotShadowMap),
          (Qn.spotLightMatrix.value = fn.state.spotLightMatrix),
          (Qn.spotLightMap.value = fn.state.spotLightMap),
          (Qn.pointShadowMap.value = fn.state.pointShadowMap),
          (Qn.pointShadowMatrix.value = fn.state.pointShadowMatrix)),
        (Qt.currentProgram = cr),
        (Qt.uniformsList = null),
        cr
      );
    }
    function Ut(zt) {
      if (zt.uniformsList === null) {
        const Zt = zt.currentProgram.getUniforms();
        zt.uniformsList = WebGLUniforms.seqWithValue(Zt.seq, zt.uniforms);
      }
      return zt.uniformsList;
    }
    function $t(zt, Zt) {
      const an = Gn.get(zt);
      (an.outputColorSpace = Zt.outputColorSpace),
        (an.batching = Zt.batching),
        (an.batchingColor = Zt.batchingColor),
        (an.instancing = Zt.instancing),
        (an.instancingColor = Zt.instancingColor),
        (an.instancingMorph = Zt.instancingMorph),
        (an.skinning = Zt.skinning),
        (an.morphTargets = Zt.morphTargets),
        (an.morphNormals = Zt.morphNormals),
        (an.morphColors = Zt.morphColors),
        (an.morphTargetsCount = Zt.morphTargetsCount),
        (an.numClippingPlanes = Zt.numClippingPlanes),
        (an.numIntersection = Zt.numClipIntersection),
        (an.vertexAlphas = Zt.vertexAlphas),
        (an.vertexTangents = Zt.vertexTangents),
        (an.toneMapping = Zt.toneMapping);
    }
    function un(zt, Zt, an, Qt, fn) {
      Zt.isScene !== !0 && (Zt = ur), Yt.resetTextureUnits();
      const wn = Zt.fog,
        On = Qt.isMeshStandardMaterial ? Zt.environment : null,
        Kn =
          bt === null
            ? vt.outputColorSpace
            : bt.isXRRenderTarget === !0
            ? bt.texture.colorSpace
            : LinearSRGBColorSpace,
        Zn = (Qt.isMeshStandardMaterial ? hn : Gt).get(Qt.envMap || On),
        ar =
          Qt.vertexColors === !0 &&
          !!an.attributes.color &&
          an.attributes.color.itemSize === 4,
        cr = !!an.attributes.tangent && (!!Qt.normalMap || Qt.anisotropy > 0),
        Qn = !!an.morphAttributes.position,
        gr = !!an.morphAttributes.normal,
        Tr = !!an.morphAttributes.color;
      let Qr = NoToneMapping;
      Qt.toneMapped &&
        (bt === null || bt.isXRRenderTarget === !0) &&
        (Qr = vt.toneMapping);
      const Dr =
          an.morphAttributes.position ||
          an.morphAttributes.normal ||
          an.morphAttributes.color,
        Br = Dr !== void 0 ? Dr.length : 0,
        Mr = Gn.get(Qt),
        oi = Be.state.lights;
      if (tn === !0 && (pn === !0 || zt !== Ct)) {
        const Mi = zt === Ct && Qt.id === Tt;
        qn.setState(Qt, zt, Mi);
      }
      let Xr = !1;
      Qt.version === Mr.__version
        ? ((Mr.needsLights && Mr.lightsStateVersion !== oi.state.version) ||
            Mr.outputColorSpace !== Kn ||
            (fn.isBatchedMesh && Mr.batching === !1) ||
            (!fn.isBatchedMesh && Mr.batching === !0) ||
            (fn.isBatchedMesh &&
              Mr.batchingColor === !0 &&
              fn.colorTexture === null) ||
            (fn.isBatchedMesh &&
              Mr.batchingColor === !1 &&
              fn.colorTexture !== null) ||
            (fn.isInstancedMesh && Mr.instancing === !1) ||
            (!fn.isInstancedMesh && Mr.instancing === !0) ||
            (fn.isSkinnedMesh && Mr.skinning === !1) ||
            (!fn.isSkinnedMesh && Mr.skinning === !0) ||
            (fn.isInstancedMesh &&
              Mr.instancingColor === !0 &&
              fn.instanceColor === null) ||
            (fn.isInstancedMesh &&
              Mr.instancingColor === !1 &&
              fn.instanceColor !== null) ||
            (fn.isInstancedMesh &&
              Mr.instancingMorph === !0 &&
              fn.morphTexture === null) ||
            (fn.isInstancedMesh &&
              Mr.instancingMorph === !1 &&
              fn.morphTexture !== null) ||
            Mr.envMap !== Zn ||
            (Qt.fog === !0 && Mr.fog !== wn) ||
            (Mr.numClippingPlanes !== void 0 &&
              (Mr.numClippingPlanes !== qn.numPlanes ||
                Mr.numIntersection !== qn.numIntersection)) ||
            Mr.vertexAlphas !== ar ||
            Mr.vertexTangents !== cr ||
            Mr.morphTargets !== Qn ||
            Mr.morphNormals !== gr ||
            Mr.morphColors !== Tr ||
            Mr.toneMapping !== Qr ||
            Mr.morphTargetsCount !== Br) &&
          (Xr = !0)
        : ((Xr = !0), (Mr.__version = Qt.version));
      let ti = Mr.currentProgram;
      Xr === !0 && (ti = mi(Qt, Zt, fn));
      let bi = !1,
        ni = !1,
        ai = !1;
      const Kr = ti.getUniforms(),
        Ii = Mr.uniforms;
      if (
        (In.useProgram(ti.program) && ((bi = !0), (ni = !0), (ai = !0)),
        Qt.id !== Tt && ((Tt = Qt.id), (ni = !0)),
        bi || Ct !== zt)
      ) {
        In.buffers.depth.getReversed()
          ? (_n.copy(zt.projectionMatrix),
            toNormalizedProjectionMatrix(_n),
            toReversedProjectionMatrix(_n),
            Kr.setValue(jt, "projectionMatrix", _n))
          : Kr.setValue(jt, "projectionMatrix", zt.projectionMatrix),
          Kr.setValue(jt, "viewMatrix", zt.matrixWorldInverse);
        const Ui = Kr.map.cameraPosition;
        Ui !== void 0 &&
          Ui.setValue(jt, $n.setFromMatrixPosition(zt.matrixWorld)),
          rn.logarithmicDepthBuffer &&
            Kr.setValue(
              jt,
              "logDepthBufFC",
              2 / (Math.log(zt.far + 1) / Math.LN2)
            ),
          (Qt.isMeshPhongMaterial ||
            Qt.isMeshToonMaterial ||
            Qt.isMeshLambertMaterial ||
            Qt.isMeshBasicMaterial ||
            Qt.isMeshStandardMaterial ||
            Qt.isShaderMaterial) &&
            Kr.setValue(jt, "isOrthographic", zt.isOrthographicCamera === !0),
          Ct !== zt && ((Ct = zt), (ni = !0), (ai = !0));
      }
      if (fn.isSkinnedMesh) {
        Kr.setOptional(jt, fn, "bindMatrix"),
          Kr.setOptional(jt, fn, "bindMatrixInverse");
        const Mi = fn.skeleton;
        Mi &&
          (Mi.boneTexture === null && Mi.computeBoneTexture(),
          Kr.setValue(jt, "boneTexture", Mi.boneTexture, Yt));
      }
      fn.isBatchedMesh &&
        (Kr.setOptional(jt, fn, "batchingTexture"),
        Kr.setValue(jt, "batchingTexture", fn._matricesTexture, Yt),
        Kr.setOptional(jt, fn, "batchingIdTexture"),
        Kr.setValue(jt, "batchingIdTexture", fn._indirectTexture, Yt),
        Kr.setOptional(jt, fn, "batchingColorTexture"),
        fn._colorsTexture !== null &&
          Kr.setValue(jt, "batchingColorTexture", fn._colorsTexture, Yt));
      const gi = an.morphAttributes;
      if (
        ((gi.position !== void 0 ||
          gi.normal !== void 0 ||
          gi.color !== void 0) &&
          mr.update(fn, an, ti),
        (ni || Mr.receiveShadow !== fn.receiveShadow) &&
          ((Mr.receiveShadow = fn.receiveShadow),
          Kr.setValue(jt, "receiveShadow", fn.receiveShadow)),
        Qt.isMeshGouraudMaterial &&
          Qt.envMap !== null &&
          ((Ii.envMap.value = Zn),
          (Ii.flipEnvMap.value =
            Zn.isCubeTexture && Zn.isRenderTargetTexture === !1 ? -1 : 1)),
        Qt.isMeshStandardMaterial &&
          Qt.envMap === null &&
          Zt.environment !== null &&
          (Ii.envMapIntensity.value = Zt.environmentIntensity),
        ni &&
          (Kr.setValue(jt, "toneMappingExposure", vt.toneMappingExposure),
          Mr.needsLights && yn(Ii, ai),
          wn && Qt.fog === !0 && Fn.refreshFogUniforms(Ii, wn),
          Fn.refreshMaterialUniforms(
            Ii,
            Qt,
            Mt,
            Bt,
            Be.state.transmissionRenderTarget[zt.id]
          ),
          WebGLUniforms.upload(jt, Ut(Mr), Ii, Yt)),
        Qt.isShaderMaterial &&
          Qt.uniformsNeedUpdate === !0 &&
          (WebGLUniforms.upload(jt, Ut(Mr), Ii, Yt),
          (Qt.uniformsNeedUpdate = !1)),
        Qt.isSpriteMaterial && Kr.setValue(jt, "center", fn.center),
        Kr.setValue(jt, "modelViewMatrix", fn.modelViewMatrix),
        Kr.setValue(jt, "normalMatrix", fn.normalMatrix),
        Kr.setValue(jt, "modelMatrix", fn.matrixWorld),
        Qt.isShaderMaterial || Qt.isRawShaderMaterial)
      ) {
        const Mi = Qt.uniformsGroups;
        for (let Ui = 0, di = Mi.length; Ui < di; Ui++) {
          const ps = Mi[Ui];
          cn.update(ps, ti), cn.bind(ps, ti);
        }
      }
      return ti;
    }
    function yn(zt, Zt) {
      (zt.ambientLightColor.needsUpdate = Zt),
        (zt.lightProbe.needsUpdate = Zt),
        (zt.directionalLights.needsUpdate = Zt),
        (zt.directionalLightShadows.needsUpdate = Zt),
        (zt.pointLights.needsUpdate = Zt),
        (zt.pointLightShadows.needsUpdate = Zt),
        (zt.spotLights.needsUpdate = Zt),
        (zt.spotLightShadows.needsUpdate = Zt),
        (zt.rectAreaLights.needsUpdate = Zt),
        (zt.hemisphereLights.needsUpdate = Zt);
    }
    function Rn(zt) {
      return (
        zt.isMeshLambertMaterial ||
        zt.isMeshToonMaterial ||
        zt.isMeshPhongMaterial ||
        zt.isMeshStandardMaterial ||
        zt.isShadowMaterial ||
        (zt.isShaderMaterial && zt.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return St;
    }),
      (this.getActiveMipmapLevel = function () {
        return wt;
      }),
      (this.getRenderTarget = function () {
        return bt;
      }),
      (this.setRenderTargetTextures = function (zt, Zt, an) {
        const Qt = Gn.get(zt);
        (Qt.__autoAllocateDepthBuffer = zt.resolveDepthBuffer === !1),
          Qt.__autoAllocateDepthBuffer === !1 && (Qt.__useRenderToTexture = !1),
          (Gn.get(zt.texture).__webglTexture = Zt),
          (Gn.get(zt.depthTexture).__webglTexture = Qt.__autoAllocateDepthBuffer
            ? void 0
            : an),
          (Qt.__hasExternalTextures = !0);
      }),
      (this.setRenderTargetFramebuffer = function (zt, Zt) {
        const an = Gn.get(zt);
        (an.__webglFramebuffer = Zt),
          (an.__useDefaultFramebuffer = Zt === void 0);
      });
    const kn = jt.createFramebuffer();
    (this.setRenderTarget = function (zt, Zt = 0, an = 0) {
      (bt = zt), (St = Zt), (wt = an);
      let Qt = !0,
        fn = null,
        wn = !1,
        On = !1;
      if (zt) {
        const Zn = Gn.get(zt);
        if (Zn.__useDefaultFramebuffer !== void 0)
          In.bindFramebuffer(jt.FRAMEBUFFER, null), (Qt = !1);
        else if (Zn.__webglFramebuffer === void 0) Yt.setupRenderTarget(zt);
        else if (Zn.__hasExternalTextures)
          Yt.rebindTextures(
            zt,
            Gn.get(zt.texture).__webglTexture,
            Gn.get(zt.depthTexture).__webglTexture
          );
        else if (zt.depthBuffer) {
          const Qn = zt.depthTexture;
          if (Zn.__boundDepthTexture !== Qn) {
            if (
              Qn !== null &&
              Gn.has(Qn) &&
              (zt.width !== Qn.image.width || zt.height !== Qn.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
              );
            Yt.setupDepthRenderbuffer(zt);
          }
        }
        const ar = zt.texture;
        (ar.isData3DTexture ||
          ar.isDataArrayTexture ||
          ar.isCompressedArrayTexture) &&
          (On = !0);
        const cr = Gn.get(zt).__webglFramebuffer;
        zt.isWebGLCubeRenderTarget
          ? (Array.isArray(cr[Zt]) ? (fn = cr[Zt][an]) : (fn = cr[Zt]),
            (wn = !0))
          : zt.samples > 0 && Yt.useMultisampledRTT(zt) === !1
          ? (fn = Gn.get(zt).__webglMultisampledFramebuffer)
          : Array.isArray(cr)
          ? (fn = cr[an])
          : (fn = cr),
          kt.copy(zt.viewport),
          Dt.copy(zt.scissor),
          (Vt = zt.scissorTest);
      } else
        kt.copy(Ot).multiplyScalar(Mt).floor(),
          Dt.copy(Xt).multiplyScalar(Mt).floor(),
          (Vt = sn);
      if (
        (an !== 0 && (fn = kn),
        In.bindFramebuffer(jt.FRAMEBUFFER, fn) && Qt && In.drawBuffers(zt, fn),
        In.viewport(kt),
        In.scissor(Dt),
        In.setScissorTest(Vt),
        wn)
      ) {
        const Zn = Gn.get(zt.texture);
        jt.framebufferTexture2D(
          jt.FRAMEBUFFER,
          jt.COLOR_ATTACHMENT0,
          jt.TEXTURE_CUBE_MAP_POSITIVE_X + Zt,
          Zn.__webglTexture,
          an
        );
      } else if (On) {
        const Zn = Gn.get(zt.texture),
          ar = Zt;
        jt.framebufferTextureLayer(
          jt.FRAMEBUFFER,
          jt.COLOR_ATTACHMENT0,
          Zn.__webglTexture,
          an,
          ar
        );
      } else if (zt !== null && an !== 0) {
        const Zn = Gn.get(zt.texture);
        jt.framebufferTexture2D(
          jt.FRAMEBUFFER,
          jt.COLOR_ATTACHMENT0,
          jt.TEXTURE_2D,
          Zn.__webglTexture,
          an
        );
      }
      Tt = -1;
    }),
      (this.readRenderTargetPixels = function (zt, Zt, an, Qt, fn, wn, On) {
        if (!(zt && zt.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Kn = Gn.get(zt).__webglFramebuffer;
        if (
          (zt.isWebGLCubeRenderTarget && On !== void 0 && (Kn = Kn[On]), Kn)
        ) {
          In.bindFramebuffer(jt.FRAMEBUFFER, Kn);
          try {
            const Zn = zt.texture,
              ar = Zn.format,
              cr = Zn.type;
            if (!rn.textureFormatReadable(ar)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!rn.textureTypeReadable(cr)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            Zt >= 0 &&
              Zt <= zt.width - Qt &&
              an >= 0 &&
              an <= zt.height - fn &&
              jt.readPixels(Zt, an, Qt, fn, Pr.convert(ar), Pr.convert(cr), wn);
          } finally {
            const Zn = bt !== null ? Gn.get(bt).__webglFramebuffer : null;
            In.bindFramebuffer(jt.FRAMEBUFFER, Zn);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        zt,
        Zt,
        an,
        Qt,
        fn,
        wn,
        On
      ) {
        if (!(zt && zt.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let Kn = Gn.get(zt).__webglFramebuffer;
        if ((zt.isWebGLCubeRenderTarget && On !== void 0 && (Kn = Kn[On]), Kn))
          if (
            Zt >= 0 &&
            Zt <= zt.width - Qt &&
            an >= 0 &&
            an <= zt.height - fn
          ) {
            In.bindFramebuffer(jt.FRAMEBUFFER, Kn);
            const Zn = zt.texture,
              ar = Zn.format,
              cr = Zn.type;
            if (!rn.textureFormatReadable(ar))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!rn.textureTypeReadable(cr))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            const Qn = jt.createBuffer();
            jt.bindBuffer(jt.PIXEL_PACK_BUFFER, Qn),
              jt.bufferData(
                jt.PIXEL_PACK_BUFFER,
                wn.byteLength,
                jt.STREAM_READ
              ),
              jt.readPixels(Zt, an, Qt, fn, Pr.convert(ar), Pr.convert(cr), 0);
            const gr = bt !== null ? Gn.get(bt).__webglFramebuffer : null;
            In.bindFramebuffer(jt.FRAMEBUFFER, gr);
            const Tr = jt.fenceSync(jt.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              jt.flush(),
              await probeAsync(jt, Tr, 4),
              jt.bindBuffer(jt.PIXEL_PACK_BUFFER, Qn),
              jt.getBufferSubData(jt.PIXEL_PACK_BUFFER, 0, wn),
              jt.deleteBuffer(Qn),
              jt.deleteSync(Tr),
              wn
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
      }),
      (this.copyFramebufferToTexture = function (zt, Zt = null, an = 0) {
        const Qt = Math.pow(2, -an),
          fn = Math.floor(zt.image.width * Qt),
          wn = Math.floor(zt.image.height * Qt),
          On = Zt !== null ? Zt.x : 0,
          Kn = Zt !== null ? Zt.y : 0;
        Yt.setTexture2D(zt, 0),
          jt.copyTexSubImage2D(jt.TEXTURE_2D, an, 0, 0, On, Kn, fn, wn),
          In.unbindTexture();
      });
    const er = jt.createFramebuffer(),
      Xn = jt.createFramebuffer();
    (this.copyTextureToTexture = function (
      zt,
      Zt,
      an = null,
      Qt = null,
      fn = 0,
      wn = null
    ) {
      wn === null &&
        (fn !== 0
          ? (warnOnce(
              "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."
            ),
            (wn = fn),
            (fn = 0))
          : (wn = 0));
      let On, Kn, Zn, ar, cr, Qn, gr, Tr, Qr;
      const Dr = zt.isCompressedTexture ? zt.mipmaps[wn] : zt.image;
      if (an !== null)
        (On = an.max.x - an.min.x),
          (Kn = an.max.y - an.min.y),
          (Zn = an.isBox3 ? an.max.z - an.min.z : 1),
          (ar = an.min.x),
          (cr = an.min.y),
          (Qn = an.isBox3 ? an.min.z : 0);
      else {
        const gi = Math.pow(2, -fn);
        (On = Math.floor(Dr.width * gi)),
          (Kn = Math.floor(Dr.height * gi)),
          zt.isDataArrayTexture
            ? (Zn = Dr.depth)
            : zt.isData3DTexture
            ? (Zn = Math.floor(Dr.depth * gi))
            : (Zn = 1),
          (ar = 0),
          (cr = 0),
          (Qn = 0);
      }
      Qt !== null
        ? ((gr = Qt.x), (Tr = Qt.y), (Qr = Qt.z))
        : ((gr = 0), (Tr = 0), (Qr = 0));
      const Br = Pr.convert(Zt.format),
        Mr = Pr.convert(Zt.type);
      let oi;
      Zt.isData3DTexture
        ? (Yt.setTexture3D(Zt, 0), (oi = jt.TEXTURE_3D))
        : Zt.isDataArrayTexture || Zt.isCompressedArrayTexture
        ? (Yt.setTexture2DArray(Zt, 0), (oi = jt.TEXTURE_2D_ARRAY))
        : (Yt.setTexture2D(Zt, 0), (oi = jt.TEXTURE_2D)),
        jt.pixelStorei(jt.UNPACK_FLIP_Y_WEBGL, Zt.flipY),
        jt.pixelStorei(jt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Zt.premultiplyAlpha),
        jt.pixelStorei(jt.UNPACK_ALIGNMENT, Zt.unpackAlignment);
      const Xr = jt.getParameter(jt.UNPACK_ROW_LENGTH),
        ti = jt.getParameter(jt.UNPACK_IMAGE_HEIGHT),
        bi = jt.getParameter(jt.UNPACK_SKIP_PIXELS),
        ni = jt.getParameter(jt.UNPACK_SKIP_ROWS),
        ai = jt.getParameter(jt.UNPACK_SKIP_IMAGES);
      jt.pixelStorei(jt.UNPACK_ROW_LENGTH, Dr.width),
        jt.pixelStorei(jt.UNPACK_IMAGE_HEIGHT, Dr.height),
        jt.pixelStorei(jt.UNPACK_SKIP_PIXELS, ar),
        jt.pixelStorei(jt.UNPACK_SKIP_ROWS, cr),
        jt.pixelStorei(jt.UNPACK_SKIP_IMAGES, Qn);
      const Kr = zt.isDataArrayTexture || zt.isData3DTexture,
        Ii = Zt.isDataArrayTexture || Zt.isData3DTexture;
      if (zt.isDepthTexture) {
        const gi = Gn.get(zt),
          Mi = Gn.get(Zt),
          Ui = Gn.get(gi.__renderTarget),
          di = Gn.get(Mi.__renderTarget);
        In.bindFramebuffer(jt.READ_FRAMEBUFFER, Ui.__webglFramebuffer),
          In.bindFramebuffer(jt.DRAW_FRAMEBUFFER, di.__webglFramebuffer);
        for (let ps = 0; ps < Zn; ps++)
          Kr &&
            (jt.framebufferTextureLayer(
              jt.READ_FRAMEBUFFER,
              jt.COLOR_ATTACHMENT0,
              Gn.get(zt).__webglTexture,
              fn,
              Qn + ps
            ),
            jt.framebufferTextureLayer(
              jt.DRAW_FRAMEBUFFER,
              jt.COLOR_ATTACHMENT0,
              Gn.get(Zt).__webglTexture,
              wn,
              Qr + ps
            )),
            jt.blitFramebuffer(
              ar,
              cr,
              On,
              Kn,
              gr,
              Tr,
              On,
              Kn,
              jt.DEPTH_BUFFER_BIT,
              jt.NEAREST
            );
        In.bindFramebuffer(jt.READ_FRAMEBUFFER, null),
          In.bindFramebuffer(jt.DRAW_FRAMEBUFFER, null);
      } else if (fn !== 0 || zt.isRenderTargetTexture || Gn.has(zt)) {
        const gi = Gn.get(zt),
          Mi = Gn.get(Zt);
        In.bindFramebuffer(jt.READ_FRAMEBUFFER, er),
          In.bindFramebuffer(jt.DRAW_FRAMEBUFFER, Xn);
        for (let Ui = 0; Ui < Zn; Ui++)
          Kr
            ? jt.framebufferTextureLayer(
                jt.READ_FRAMEBUFFER,
                jt.COLOR_ATTACHMENT0,
                gi.__webglTexture,
                fn,
                Qn + Ui
              )
            : jt.framebufferTexture2D(
                jt.READ_FRAMEBUFFER,
                jt.COLOR_ATTACHMENT0,
                jt.TEXTURE_2D,
                gi.__webglTexture,
                fn
              ),
            Ii
              ? jt.framebufferTextureLayer(
                  jt.DRAW_FRAMEBUFFER,
                  jt.COLOR_ATTACHMENT0,
                  Mi.__webglTexture,
                  wn,
                  Qr + Ui
                )
              : jt.framebufferTexture2D(
                  jt.DRAW_FRAMEBUFFER,
                  jt.COLOR_ATTACHMENT0,
                  jt.TEXTURE_2D,
                  Mi.__webglTexture,
                  wn
                ),
            fn !== 0
              ? jt.blitFramebuffer(
                  ar,
                  cr,
                  On,
                  Kn,
                  gr,
                  Tr,
                  On,
                  Kn,
                  jt.COLOR_BUFFER_BIT,
                  jt.NEAREST
                )
              : Ii
              ? jt.copyTexSubImage3D(oi, wn, gr, Tr, Qr + Ui, ar, cr, On, Kn)
              : jt.copyTexSubImage2D(oi, wn, gr, Tr, ar, cr, On, Kn);
        In.bindFramebuffer(jt.READ_FRAMEBUFFER, null),
          In.bindFramebuffer(jt.DRAW_FRAMEBUFFER, null);
      } else
        Ii
          ? zt.isDataTexture || zt.isData3DTexture
            ? jt.texSubImage3D(oi, wn, gr, Tr, Qr, On, Kn, Zn, Br, Mr, Dr.data)
            : Zt.isCompressedArrayTexture
            ? jt.compressedTexSubImage3D(
                oi,
                wn,
                gr,
                Tr,
                Qr,
                On,
                Kn,
                Zn,
                Br,
                Dr.data
              )
            : jt.texSubImage3D(oi, wn, gr, Tr, Qr, On, Kn, Zn, Br, Mr, Dr)
          : zt.isDataTexture
          ? jt.texSubImage2D(jt.TEXTURE_2D, wn, gr, Tr, On, Kn, Br, Mr, Dr.data)
          : zt.isCompressedTexture
          ? jt.compressedTexSubImage2D(
              jt.TEXTURE_2D,
              wn,
              gr,
              Tr,
              Dr.width,
              Dr.height,
              Br,
              Dr.data
            )
          : jt.texSubImage2D(jt.TEXTURE_2D, wn, gr, Tr, On, Kn, Br, Mr, Dr);
      jt.pixelStorei(jt.UNPACK_ROW_LENGTH, Xr),
        jt.pixelStorei(jt.UNPACK_IMAGE_HEIGHT, ti),
        jt.pixelStorei(jt.UNPACK_SKIP_PIXELS, bi),
        jt.pixelStorei(jt.UNPACK_SKIP_ROWS, ni),
        jt.pixelStorei(jt.UNPACK_SKIP_IMAGES, ai),
        wn === 0 && Zt.generateMipmaps && jt.generateMipmap(oi),
        In.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        zt,
        Zt,
        an = null,
        Qt = null,
        fn = 0
      ) {
        return (
          warnOnce(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(zt, Zt, an, Qt, fn)
        );
      }),
      (this.initRenderTarget = function (zt) {
        Gn.get(zt).__webglFramebuffer === void 0 && Yt.setupRenderTarget(zt);
      }),
      (this.initTexture = function (zt) {
        zt.isCubeTexture
          ? Yt.setTextureCube(zt, 0)
          : zt.isData3DTexture
          ? Yt.setTexture3D(zt, 0)
          : zt.isDataArrayTexture || zt.isCompressedArrayTexture
          ? Yt.setTexture2DArray(zt, 0)
          : Yt.setTexture2D(zt, 0),
          In.unbindTexture();
      }),
      (this.resetState = function () {
        (St = 0), (wt = 0), (bt = null), In.reset(), Hr.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace =
      ColorManagement._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = ColorManagement._getUnpackColorSpace());
  }
}
const THREE = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ACESFilmicToneMapping,
        AddEquation,
        AddOperation,
        AdditiveAnimationBlendMode,
        AdditiveBlending,
        AgXToneMapping,
        AlphaFormat,
        AlwaysCompare,
        AlwaysDepth,
        AlwaysStencilFunc,
        AmbientLight,
        AnimationAction,
        AnimationClip,
        AnimationLoader,
        AnimationMixer,
        AnimationObjectGroup,
        AnimationUtils,
        ArcCurve,
        ArrayCamera,
        ArrowHelper,
        AttachedBindMode,
        Audio,
        AudioAnalyser,
        AudioContext,
        AudioListener,
        AudioLoader,
        AxesHelper,
        BackSide,
        BasicDepthPacking,
        BasicShadowMap,
        BatchedMesh,
        Bone,
        BooleanKeyframeTrack,
        Box2,
        Box3,
        Box3Helper,
        BoxGeometry,
        BoxHelper,
        BufferAttribute,
        BufferGeometry,
        BufferGeometryLoader,
        ByteType,
        Cache,
        Camera,
        CameraHelper,
        CanvasTexture,
        CapsuleGeometry,
        CatmullRomCurve3,
        CineonToneMapping,
        CircleGeometry,
        ClampToEdgeWrapping,
        Clock,
        Color,
        ColorKeyframeTrack,
        ColorManagement,
        CompressedArrayTexture,
        CompressedCubeTexture,
        CompressedTexture,
        CompressedTextureLoader,
        ConeGeometry,
        ConstantAlphaFactor,
        ConstantColorFactor,
        Controls,
        CubeCamera,
        CubeReflectionMapping,
        CubeRefractionMapping,
        CubeTexture,
        CubeTextureLoader,
        CubeUVReflectionMapping,
        CubicBezierCurve,
        CubicBezierCurve3,
        CubicInterpolant,
        CullFaceBack,
        CullFaceFront,
        CullFaceFrontBack,
        CullFaceNone,
        Curve,
        CurvePath,
        CustomBlending,
        CustomToneMapping,
        CylinderGeometry,
        Cylindrical,
        Data3DTexture,
        DataArrayTexture,
        DataTexture,
        DataTextureLoader,
        DataUtils,
        DecrementStencilOp,
        DecrementWrapStencilOp,
        DefaultLoadingManager,
        DepthArrayTexture,
        DepthFormat,
        DepthStencilFormat,
        DepthTexture,
        DetachedBindMode,
        DirectionalLight,
        DirectionalLightHelper,
        DiscreteInterpolant,
        DodecahedronGeometry,
        DoubleSide,
        DstAlphaFactor,
        DstColorFactor,
        DynamicCopyUsage,
        DynamicDrawUsage,
        DynamicReadUsage,
        EdgesGeometry,
        EllipseCurve,
        EqualCompare,
        EqualDepth,
        EqualStencilFunc,
        EquirectangularReflectionMapping,
        EquirectangularRefractionMapping,
        Euler,
        EventDispatcher,
        ExtrudeGeometry,
        FileLoader,
        Float16BufferAttribute,
        Float32BufferAttribute,
        FloatType,
        Fog,
        FogExp2,
        FramebufferTexture,
        FrontSide,
        Frustum,
        FrustumArray,
        GLBufferAttribute,
        GLSL1,
        GLSL3,
        GreaterCompare,
        GreaterDepth,
        GreaterEqualCompare,
        GreaterEqualDepth,
        GreaterEqualStencilFunc,
        GreaterStencilFunc,
        GridHelper,
        Group,
        HalfFloatType,
        HemisphereLight,
        HemisphereLightHelper,
        IcosahedronGeometry,
        ImageBitmapLoader,
        ImageLoader,
        ImageUtils,
        IncrementStencilOp,
        IncrementWrapStencilOp,
        InstancedBufferAttribute,
        InstancedBufferGeometry,
        InstancedInterleavedBuffer,
        InstancedMesh,
        Int16BufferAttribute,
        Int32BufferAttribute,
        Int8BufferAttribute,
        IntType,
        InterleavedBuffer,
        InterleavedBufferAttribute,
        Interpolant,
        InterpolateDiscrete,
        InterpolateLinear,
        InterpolateSmooth,
        InterpolationSamplingMode,
        InterpolationSamplingType,
        InvertStencilOp,
        KeepStencilOp,
        KeyframeTrack,
        LOD,
        LatheGeometry,
        Layers,
        LessCompare,
        LessDepth,
        LessEqualCompare,
        LessEqualDepth,
        LessEqualStencilFunc,
        LessStencilFunc,
        Light,
        LightProbe,
        Line,
        Line3,
        LineBasicMaterial,
        LineCurve,
        LineCurve3,
        LineDashedMaterial,
        LineLoop,
        LineSegments,
        LinearFilter,
        LinearInterpolant,
        LinearMipMapLinearFilter,
        LinearMipMapNearestFilter,
        LinearMipmapLinearFilter,
        LinearMipmapNearestFilter,
        LinearSRGBColorSpace,
        LinearToneMapping,
        LinearTransfer,
        Loader: Loader$2,
        LoaderUtils,
        LoadingManager,
        LoopOnce,
        LoopPingPong,
        LoopRepeat,
        MOUSE,
        Material,
        MaterialLoader,
        MathUtils,
        Matrix2,
        Matrix3,
        Matrix4,
        MaxEquation,
        Mesh,
        MeshBasicMaterial,
        MeshDepthMaterial,
        MeshDistanceMaterial,
        MeshLambertMaterial,
        MeshMatcapMaterial,
        MeshNormalMaterial,
        MeshPhongMaterial,
        MeshPhysicalMaterial,
        MeshStandardMaterial,
        MeshToonMaterial,
        MinEquation,
        MirroredRepeatWrapping,
        MixOperation,
        MultiplyBlending,
        MultiplyOperation,
        NearestFilter,
        NearestMipMapLinearFilter,
        NearestMipMapNearestFilter,
        NearestMipmapLinearFilter,
        NearestMipmapNearestFilter,
        NeutralToneMapping,
        NeverCompare,
        NeverDepth,
        NeverStencilFunc,
        NoBlending,
        NoColorSpace,
        NoToneMapping,
        NormalAnimationBlendMode,
        NormalBlending,
        NotEqualCompare,
        NotEqualDepth,
        NotEqualStencilFunc,
        NumberKeyframeTrack,
        Object3D,
        ObjectLoader,
        ObjectSpaceNormalMap,
        OctahedronGeometry,
        OneFactor,
        OneMinusConstantAlphaFactor,
        OneMinusConstantColorFactor,
        OneMinusDstAlphaFactor,
        OneMinusDstColorFactor,
        OneMinusSrcAlphaFactor,
        OneMinusSrcColorFactor,
        OrthographicCamera,
        PCFShadowMap,
        PCFSoftShadowMap,
        PMREMGenerator,
        Path,
        PerspectiveCamera,
        Plane,
        PlaneGeometry,
        PlaneHelper,
        PointLight,
        PointLightHelper,
        Points,
        PointsMaterial,
        PolarGridHelper,
        PolyhedronGeometry,
        PositionalAudio,
        PropertyBinding,
        PropertyMixer,
        QuadraticBezierCurve,
        QuadraticBezierCurve3,
        Quaternion,
        QuaternionKeyframeTrack,
        QuaternionLinearInterpolant,
        RED_GREEN_RGTC2_Format,
        RED_RGTC1_Format,
        REVISION,
        RGBADepthPacking,
        RGBAFormat,
        RGBAIntegerFormat,
        RGBA_ASTC_10x10_Format,
        RGBA_ASTC_10x5_Format,
        RGBA_ASTC_10x6_Format,
        RGBA_ASTC_10x8_Format,
        RGBA_ASTC_12x10_Format,
        RGBA_ASTC_12x12_Format,
        RGBA_ASTC_4x4_Format,
        RGBA_ASTC_5x4_Format,
        RGBA_ASTC_5x5_Format,
        RGBA_ASTC_6x5_Format,
        RGBA_ASTC_6x6_Format,
        RGBA_ASTC_8x5_Format,
        RGBA_ASTC_8x6_Format,
        RGBA_ASTC_8x8_Format,
        RGBA_BPTC_Format,
        RGBA_ETC2_EAC_Format,
        RGBA_PVRTC_2BPPV1_Format,
        RGBA_PVRTC_4BPPV1_Format,
        RGBA_S3TC_DXT1_Format,
        RGBA_S3TC_DXT3_Format,
        RGBA_S3TC_DXT5_Format,
        RGBDepthPacking,
        RGBFormat,
        RGBIntegerFormat,
        RGB_BPTC_SIGNED_Format,
        RGB_BPTC_UNSIGNED_Format,
        RGB_ETC1_Format,
        RGB_ETC2_Format,
        RGB_PVRTC_2BPPV1_Format,
        RGB_PVRTC_4BPPV1_Format,
        RGB_S3TC_DXT1_Format,
        RGDepthPacking,
        RGFormat,
        RGIntegerFormat,
        RawShaderMaterial,
        Ray,
        Raycaster,
        RectAreaLight,
        RedFormat,
        RedIntegerFormat,
        ReinhardToneMapping,
        RenderTarget,
        RenderTarget3D,
        RenderTargetArray,
        RepeatWrapping,
        ReplaceStencilOp,
        ReverseSubtractEquation,
        RingGeometry,
        SIGNED_RED_GREEN_RGTC2_Format,
        SIGNED_RED_RGTC1_Format,
        SRGBColorSpace,
        SRGBTransfer,
        Scene,
        ShaderChunk,
        ShaderLib,
        ShaderMaterial,
        ShadowMaterial,
        Shape,
        ShapeGeometry,
        ShapePath,
        ShapeUtils,
        ShortType,
        Skeleton,
        SkeletonHelper,
        SkinnedMesh,
        Source,
        Sphere,
        SphereGeometry,
        Spherical,
        SphericalHarmonics3,
        SplineCurve,
        SpotLight,
        SpotLightHelper,
        Sprite,
        SpriteMaterial,
        SrcAlphaFactor,
        SrcAlphaSaturateFactor,
        SrcColorFactor,
        StaticCopyUsage,
        StaticDrawUsage,
        StaticReadUsage,
        StereoCamera,
        StreamCopyUsage,
        StreamDrawUsage,
        StreamReadUsage,
        StringKeyframeTrack,
        SubtractEquation,
        SubtractiveBlending,
        TOUCH,
        TangentSpaceNormalMap,
        TetrahedronGeometry,
        Texture,
        TextureLoader,
        TextureUtils,
        TimestampQuery,
        TorusGeometry,
        TorusKnotGeometry,
        Triangle,
        TriangleFanDrawMode,
        TriangleStripDrawMode,
        TrianglesDrawMode,
        TubeGeometry,
        UVMapping,
        Uint16BufferAttribute,
        Uint32BufferAttribute,
        Uint8BufferAttribute,
        Uint8ClampedBufferAttribute,
        Uniform,
        UniformsGroup,
        UniformsLib,
        UniformsUtils,
        UnsignedByteType,
        UnsignedInt248Type,
        UnsignedInt5999Type,
        UnsignedIntType,
        UnsignedShort4444Type,
        UnsignedShort5551Type,
        UnsignedShortType,
        VSMShadowMap,
        Vector2,
        Vector3,
        Vector4,
        VectorKeyframeTrack,
        VideoFrameTexture,
        VideoTexture,
        WebGL3DRenderTarget,
        WebGLArrayRenderTarget,
        WebGLCoordinateSystem,
        WebGLCubeRenderTarget,
        WebGLRenderTarget,
        WebGLRenderer,
        WebGLUtils,
        WebGPUCoordinateSystem,
        WebXRController,
        WireframeGeometry,
        WrapAroundEnding,
        ZeroCurvatureEnding,
        ZeroFactor,
        ZeroSlopeEnding,
        ZeroStencilOp,
        createCanvasElement,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  sintPosition = {
    desktop: {
      mainBlock: {
        rotation: { x: 0, y: -Math.PI / 18, z: 0 },
        pos: { x: 0.25, y: -9, z: -1 },
      },
      videoBlock: {
        rotation: { x: 0, y: -Math.PI / 18, z: 0 },
        pos: { x: 0.5, y: -9, z: -4 },
      },
      legend: {
        rotation: { x: 0, y: -Math.PI / 6 + 2 * Math.PI, z: 0 },
        pos: { x: 3, y: -7.5, z: -10 },
      },
      howItWorks: {
        rotation: { x: 0, y: 0, z: 0 },
        pos: { x: 0, y: -6, z: -30 },
      },
      features: {
        rotation: { x: 0, y: Math.PI / 10 - 2 * Math.PI, z: 0 },
        pos: { x: -1, y: -7, z: -3 },
      },
      roadmap: {
        rotation: { x: 0, y: Math.PI, z: 0 },
        pos: { x: 0, y: -9.3, z: -30 },
      },
      workWithUs: {
        rotation: { x: 0, y: 0, z: 0 },
        pos: { x: 0, y: -8.5, z: 0 },
      },
    },
    mobile: {
      mainBlock: {
        rotation: { x: 0, y: -Math.PI / 15, z: 0 },
        pos: { x: 0, y: -8.5, z: -2 },
      },
      videoBlock: {
        rotation: { x: 0, y: -Math.PI / 15, z: 0 },
        pos: { x: 0.5, y: -8.5, z: -4 },
      },
      legend: {
        rotation: { x: 0, y: -Math.PI / 6, z: 0 },
        pos: { x: 1, y: -9, z: -7 },
      },
      howItWorks: {
        rotation: { x: 0, y: 0, z: 0 },
        pos: { x: 0, y: -5, z: -33 },
      },
      features: {
        rotation: { x: 0, y: Math.PI / 10, z: 0 },
        pos: { x: -0.5, y: -7.75, z: -5 },
      },
      roadmap: {
        rotation: { x: 0, y: 0, z: 0 },
        pos: { x: 0, y: -9.5, z: -30 },
      },
      workWithUs: {
        rotation: { x: 0, y: 0, z: 0 },
        pos: { x: 0, y: -8.5, z: -5 },
      },
    },
  },
  particlesPosition = {
    desktop: {
      mainBlock: { rotation: { x: 0, y: 0, z: 0 }, pos: { x: 0, y: 0, z: 0 } },
      videoBlock: { rotation: { x: 0, y: 0, z: 0 }, pos: { x: 0, y: 0, z: 0 } },
      legend: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0.5, y: 0, z: 0.5 },
      },
      howItWorks: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0, y: 0, z: -3.5 },
      },
      features: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0, y: 0, z: 0 },
      },
      roadmap: {
        rotation: { x: 0, y: Math.PI / 10, z: 0 },
        pos: { x: 0, y: 0, z: -3 },
      },
      workWithUs: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0, y: 0, z: 0 },
      },
    },
    mobile: {
      mainBlock: { rotation: { x: 0, y: 0, z: 0 }, pos: { x: 0, y: 0, z: 0 } },
      videoBlock: { rotation: { x: 0, y: 0, z: 0 }, pos: { x: 0, y: 0, z: 0 } },
      legend: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0.5, y: 0, z: 0.5 },
      },
      howItWorks: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0, y: 0, z: -3.5 },
      },
      features: {
        rotation: { x: 0, y: Math.PI / 20, z: 0 },
        pos: { x: 0, y: 0, z: 0 },
      },
      roadmap: {
        rotation: { x: 0, y: Math.PI / 10, z: 0 },
        pos: { x: 0, y: 0, z: 0 },
      },
      workWithUs: {
        rotation: { x: 0, y: Math.PI / 10, z: 0 },
        pos: { x: 0, y: 0, z: 2 },
      },
    },
  },
  gradientPosition = {
    mainBlock: { x: 50, y: 50, z: 45 },
    videoBlock: { x: 50, y: 50, z: 45 },
    legend: { x: 75, y: 75, z: 25 },
    howItWorks: { x: 50, y: 50, z: 25 },
    features: { x: 40, y: 50, z: 35 },
    roadmap: { x: 50, y: 50, z: 15 },
    workWithUs: { x: 50, y: 50, z: 50 },
  },
  snakeCameraFactor = {
    mainBlock: 0.5,
    videoBlock: 0.5,
    legend: 0.5,
    howItWorks: 0.5,
    features: 0.2,
    roadmap: 0.3,
    workWithUs: 0.5,
  };
function toTrianglesDrawMode(n, e) {
  if (e === TrianglesDrawMode)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      n
    );
  if (e === TriangleFanDrawMode || e === TriangleStripDrawMode) {
    let t = n.getIndex();
    if (t === null) {
      const a = [],
        l = n.getAttribute("position");
      if (l !== void 0) {
        for (let c = 0; c < l.count; c++) a.push(c);
        n.setIndex(a), (t = n.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        );
    }
    const r = t.count - 2,
      s = [];
    if (e === TriangleFanDrawMode)
      for (let a = 1; a <= r; a++)
        s.push(t.getX(0)), s.push(t.getX(a)), s.push(t.getX(a + 1));
    else
      for (let a = 0; a < r; a++)
        a % 2 === 0
          ? (s.push(t.getX(a)), s.push(t.getX(a + 1)), s.push(t.getX(a + 2)))
          : (s.push(t.getX(a + 2)), s.push(t.getX(a + 1)), s.push(t.getX(a)));
    s.length / 3 !== r &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const o = n.clone();
    return o.setIndex(s), o.clearGroups(), o;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      n
    );
}
class GLTFLoader extends Loader$2 {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new GLTFMaterialsClearcoatExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsDispersionExtension(t);
      }),
      this.register(function (t) {
        return new GLTFTextureBasisUExtension(t);
      }),
      this.register(function (t) {
        return new GLTFTextureWebPExtension(t);
      }),
      this.register(function (t) {
        return new GLTFTextureAVIFExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsSheenExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsTransmissionExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsVolumeExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsIorExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsEmissiveStrengthExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsSpecularExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsIridescenceExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsAnisotropyExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMaterialsBumpExtension(t);
      }),
      this.register(function (t) {
        return new GLTFLightsExtension(t);
      }),
      this.register(function (t) {
        return new GLTFMeshoptCompression(t);
      }),
      this.register(function (t) {
        return new GLTFMeshGpuInstancing(t);
      });
  }
  load(e, t, r, s) {
    const o = this;
    let a;
    if (this.resourcePath !== "") a = this.resourcePath;
    else if (this.path !== "") {
      const u = LoaderUtils.extractUrlBase(e);
      a = LoaderUtils.resolveURL(u, this.path);
    } else a = LoaderUtils.extractUrlBase(e);
    this.manager.itemStart(e);
    const l = function (u) {
        s ? s(u) : console.error(u),
          o.manager.itemError(e),
          o.manager.itemEnd(e);
      },
      c = new FileLoader(this.manager);
    c.setPath(this.path),
      c.setResponseType("arraybuffer"),
      c.setRequestHeader(this.requestHeader),
      c.setWithCredentials(this.withCredentials),
      c.load(
        e,
        function (u) {
          try {
            o.parse(
              u,
              a,
              function (p) {
                t(p), o.manager.itemEnd(e);
              },
              l
            );
          } catch (p) {
            l(p);
          }
        },
        r,
        l
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, r, s) {
    let o;
    const a = {},
      l = {},
      c = new TextDecoder();
    if (typeof e == "string") o = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (c.decode(new Uint8Array(e, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          a[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e);
        } catch (N) {
          s && s(N);
          return;
        }
        o = JSON.parse(a[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else o = JSON.parse(c.decode(e));
    else o = e;
    if (o.asset === void 0 || o.asset.version[0] < 2) {
      s &&
        s(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const u = new GLTFParser(o, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    u.fileLoader.setRequestHeader(this.requestHeader);
    for (let p = 0; p < this.pluginCallbacks.length; p++) {
      const N = this.pluginCallbacks[p](u);
      N.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (l[N.name] = N),
        (a[N.name] = !0);
    }
    if (o.extensionsUsed)
      for (let p = 0; p < o.extensionsUsed.length; ++p) {
        const N = o.extensionsUsed[p],
          P = o.extensionsRequired || [];
        switch (N) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            a[N] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            a[N] = new GLTFDracoMeshCompressionExtension(o, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            a[N] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            a[N] = new GLTFMeshQuantizationExtension();
            break;
          default:
            P.indexOf(N) >= 0 &&
              l[N] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + N + '".');
        }
      }
    u.setExtensions(a), u.setPlugins(l), u.parse(r, s);
  }
  parseAsync(e, t) {
    const r = this;
    return new Promise(function (s, o) {
      r.parse(e, t, s, o);
    });
  }
}
function GLTFRegistry() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class GLTFLightsExtension {
  constructor(e) {
    (this.parser = e),
      (this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      o.extensions &&
        o.extensions[this.name] &&
        o.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, o.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      r = "light:" + e;
    let s = t.cache.get(r);
    if (s) return s;
    const o = t.json,
      c = (((o.extensions && o.extensions[this.name]) || {}).lights || [])[e];
    let u;
    const p = new Color(16777215);
    c.color !== void 0 &&
      p.setRGB(c.color[0], c.color[1], c.color[2], LinearSRGBColorSpace);
    const N = c.range !== void 0 ? c.range : 0;
    switch (c.type) {
      case "directional":
        (u = new DirectionalLight(p)),
          u.target.position.set(0, 0, -1),
          u.add(u.target);
        break;
      case "point":
        (u = new PointLight(p)), (u.distance = N);
        break;
      case "spot":
        (u = new SpotLight(p)),
          (u.distance = N),
          (c.spot = c.spot || {}),
          (c.spot.innerConeAngle =
            c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0),
          (c.spot.outerConeAngle =
            c.spot.outerConeAngle !== void 0
              ? c.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = c.spot.outerConeAngle),
          (u.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
    }
    return (
      u.position.set(0, 0, 0),
      assignExtrasToUserData(u, c),
      c.intensity !== void 0 && (u.intensity = c.intensity),
      (u.name = t.createUniqueName(c.name || "light_" + e)),
      (s = Promise.resolve(u)),
      t.cache.add(r, s),
      s
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      r = this.parser,
      o = r.json.nodes[e],
      l = ((o.extensions && o.extensions[this.name]) || {}).light;
    return l === void 0
      ? null
      : this._loadLight(l).then(function (c) {
          return r._getNodeRef(t.cache, l, c);
        });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(e, t, r) {
    const s = [];
    (e.color = new Color(1, 1, 1)), (e.opacity = 1);
    const o = t.pbrMetallicRoughness;
    if (o) {
      if (Array.isArray(o.baseColorFactor)) {
        const a = o.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], LinearSRGBColorSpace),
          (e.opacity = a[3]);
      }
      o.baseColorTexture !== void 0 &&
        s.push(r.assignTexture(e, "map", o.baseColorTexture, SRGBColorSpace));
    }
    return Promise.all(s);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = s.extensions[this.name].emissiveStrength;
    return o !== void 0 && (t.emissiveIntensity = o), Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        o.push(r.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        o.push(
          r.assignTexture(
            t,
            "clearcoatRoughnessMap",
            a.clearcoatRoughnessTexture
          )
        ),
      a.clearcoatNormalTexture !== void 0 &&
        (o.push(
          r.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
        ),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const l = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Vector2(l, l);
    }
    return Promise.all(o);
  }
}
class GLTFMaterialsDispersionExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = s.extensions[this.name];
    return (
      (t.dispersion = o.dispersion !== void 0 ? o.dispersion : 0),
      Promise.resolve()
    );
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        o.push(r.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        o.push(
          r.assignTexture(
            t,
            "iridescenceThicknessMap",
            a.iridescenceThicknessTexture
          )
        ),
      Promise.all(o)
    );
  }
}
class GLTFMaterialsSheenExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [];
    (t.sheenColor = new Color(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = s.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const l = a.sheenColorFactor;
      t.sheenColor.setRGB(l[0], l[1], l[2], LinearSRGBColorSpace);
    }
    return (
      a.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        o.push(
          r.assignTexture(
            t,
            "sheenColorMap",
            a.sheenColorTexture,
            SRGBColorSpace
          )
        ),
      a.sheenRoughnessTexture !== void 0 &&
        o.push(
          r.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
        ),
      Promise.all(o)
    );
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 &&
        (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        o.push(r.assignTexture(t, "transmissionMap", a.transmissionTexture)),
      Promise.all(o)
    );
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        o.push(r.assignTexture(t, "thicknessMap", a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const l = a.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new Color().setRGB(
        l[0],
        l[1],
        l[2],
        LinearSRGBColorSpace
      )),
      Promise.all(o)
    );
  }
}
class GLTFMaterialsIorExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = s.extensions[this.name];
    return (t.ior = o.ior !== void 0 ? o.ior : 1.5), Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        o.push(r.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const l = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Color().setRGB(
        l[0],
        l[1],
        l[2],
        LinearSRGBColorSpace
      )),
      a.specularColorTexture !== void 0 &&
        o.push(
          r.assignTexture(
            t,
            "specularColorMap",
            a.specularColorTexture,
            SRGBColorSpace
          )
        ),
      Promise.all(o)
    );
  }
}
class GLTFMaterialsBumpExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    return (
      (t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1),
      a.bumpTexture !== void 0 &&
        o.push(r.assignTexture(t, "bumpMap", a.bumpTexture)),
      Promise.all(o)
    );
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name]
      ? null
      : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      s = r.json.materials[e];
    if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = s.extensions[this.name];
    return (
      a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength),
      a.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = a.anisotropyRotation),
      a.anisotropyTexture !== void 0 &&
        o.push(r.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
      Promise.all(o)
    );
  }
}
class GLTFTextureBasisUExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      r = t.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[this.name]) return null;
    const o = s.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, o.source, a);
  }
}
class GLTFTextureWebPExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.EXT_TEXTURE_WEBP);
  }
  loadTexture(e) {
    const t = this.name,
      r = this.parser,
      s = r.json,
      o = s.textures[e];
    if (!o.extensions || !o.extensions[t]) return null;
    const a = o.extensions[t],
      l = s.images[a.source];
    let c = r.textureLoader;
    if (l.uri) {
      const u = r.options.manager.getHandler(l.uri);
      u !== null && (c = u);
    }
    return r.loadTextureImage(e, a.source, c);
  }
}
class GLTFTextureAVIFExtension {
  constructor(e) {
    (this.parser = e), (this.name = EXTENSIONS.EXT_TEXTURE_AVIF);
  }
  loadTexture(e) {
    const t = this.name,
      r = this.parser,
      s = r.json,
      o = s.textures[e];
    if (!o.extensions || !o.extensions[t]) return null;
    const a = o.extensions[t],
      l = s.images[a.source];
    let c = r.textureLoader;
    if (l.uri) {
      const u = r.options.manager.getHandler(l.uri);
      u !== null && (c = u);
    }
    return r.loadTextureImage(e, a.source, c);
  }
}
class GLTFMeshoptCompression {
  constructor(e) {
    (this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      r = t.bufferViews[e];
    if (r.extensions && r.extensions[this.name]) {
      const s = r.extensions[this.name],
        o = this.parser.getDependency("buffer", s.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return o.then(function (l) {
        const c = s.byteOffset || 0,
          u = s.byteLength || 0,
          p = s.count,
          N = s.byteStride,
          P = new Uint8Array(l, c, u);
        return a.decodeGltfBufferAsync
          ? a
              .decodeGltfBufferAsync(p, N, P, s.mode, s.filter)
              .then(function (de) {
                return de.buffer;
              })
          : a.ready.then(function () {
              const de = new ArrayBuffer(p * N);
              return (
                a.decodeGltfBuffer(
                  new Uint8Array(de),
                  p,
                  N,
                  P,
                  s.mode,
                  s.filter
                ),
                de
              );
            });
      });
    } else return null;
  }
}
class GLTFMeshGpuInstancing {
  constructor(e) {
    (this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      r = t.nodes[e];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const s = t.meshes[r.mesh];
    for (const u of s.primitives)
      if (
        u.mode !== WEBGL_CONSTANTS.TRIANGLES &&
        u.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
        u.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
        u.mode !== void 0
      )
        return null;
    const a = r.extensions[this.name].attributes,
      l = [],
      c = {};
    for (const u in a)
      l.push(
        this.parser
          .getDependency("accessor", a[u])
          .then((p) => ((c[u] = p), c[u]))
      );
    return l.length < 1
      ? null
      : (l.push(this.parser.createNodeMesh(e)),
        Promise.all(l).then((u) => {
          const p = u.pop(),
            N = p.isGroup ? p.children : [p],
            P = u[0].count,
            de = [];
          for (const me of N) {
            const Ye = new Matrix4(),
              nt = new Vector3(),
              Be = new Quaternion(),
              ot = new Vector3(1, 1, 1),
              st = new InstancedMesh(me.geometry, me.material, P);
            for (let vt = 0; vt < P; vt++)
              c.TRANSLATION && nt.fromBufferAttribute(c.TRANSLATION, vt),
                c.ROTATION && Be.fromBufferAttribute(c.ROTATION, vt),
                c.SCALE && ot.fromBufferAttribute(c.SCALE, vt),
                st.setMatrixAt(vt, Ye.compose(nt, Be, ot));
            for (const vt in c)
              if (vt === "_COLOR_0") {
                const xt = c[vt];
                st.instanceColor = new InstancedBufferAttribute(
                  xt.array,
                  xt.itemSize,
                  xt.normalized
                );
              } else
                vt !== "TRANSLATION" &&
                  vt !== "ROTATION" &&
                  vt !== "SCALE" &&
                  me.geometry.setAttribute(vt, c[vt]);
            Object3D.prototype.copy.call(st, me),
              this.parser.assignFinalMaterial(st),
              de.push(st);
          }
          return p.isGroup ? (p.clear(), p.add(...de), p) : de[0];
        }));
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF",
  BINARY_EXTENSION_HEADER_LENGTH = 12,
  BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(e) {
    (this.name = EXTENSIONS.KHR_BINARY_GLTF),
      (this.content = null),
      (this.body = null);
    const t = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH),
      r = new TextDecoder();
    if (
      ((this.header = {
        magic: r.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - BINARY_EXTENSION_HEADER_LENGTH,
      o = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH);
    let a = 0;
    for (; a < s; ) {
      const l = o.getUint32(a, !0);
      a += 4;
      const c = o.getUint32(a, !0);
      if (((a += 4), c === BINARY_EXTENSION_CHUNK_TYPES.JSON)) {
        const u = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + a, l);
        this.content = r.decode(u);
      } else if (c === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const u = BINARY_EXTENSION_HEADER_LENGTH + a;
        this.body = e.slice(u, u + l);
      }
      a += l;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const r = this.json,
      s = this.dracoLoader,
      o = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      l = {},
      c = {},
      u = {};
    for (const p in a) {
      const N = ATTRIBUTES[p] || p.toLowerCase();
      l[N] = a[p];
    }
    for (const p in e.attributes) {
      const N = ATTRIBUTES[p] || p.toLowerCase();
      if (a[p] !== void 0) {
        const P = r.accessors[e.attributes[p]],
          de = WEBGL_COMPONENT_TYPES[P.componentType];
        (u[N] = de.name), (c[N] = P.normalized === !0);
      }
    }
    return t.getDependency("bufferView", o).then(function (p) {
      return new Promise(function (N, P) {
        s.decodeDracoFile(
          p,
          function (de) {
            for (const me in de.attributes) {
              const Ye = de.attributes[me],
                nt = c[me];
              nt !== void 0 && (Ye.normalized = nt);
            }
            N(de);
          },
          l,
          u,
          LinearSRGBColorSpace,
          P
        );
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(e, t, r, s) {
    super(e, t, r, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      s = this.valueSize,
      o = e * s * 3 + s;
    for (let a = 0; a !== s; a++) t[a] = r[o + a];
    return t;
  }
  interpolate_(e, t, r, s) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = l * 2,
      u = l * 3,
      p = s - t,
      N = (r - t) / p,
      P = N * N,
      de = P * N,
      me = e * u,
      Ye = me - u,
      nt = -2 * de + 3 * P,
      Be = de - P,
      ot = 1 - nt,
      st = Be - P + N;
    for (let vt = 0; vt !== l; vt++) {
      const xt = a[Ye + vt + l],
        St = a[Ye + vt + c] * p,
        wt = a[me + vt + l],
        bt = a[me + vt] * p;
      o[vt] = ot * xt + st * St + nt * wt + Be * bt;
    }
    return o;
  }
}
const _quaternion = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(e, t, r, s) {
    const o = super.interpolate_(e, t, r, s);
    return _quaternion.fromArray(o).normalize().toArray(o), o;
  }
}
const WEBGL_CONSTANTS = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
  },
  WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter,
  },
  WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping,
  },
  WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
  },
  ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete,
  },
  ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function createDefaultMaterial(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: FrontSide,
      })),
    n.DefaultMaterial
  );
}
function addUnknownExtensionsToUserData(n, e, t) {
  for (const r in t.extensions)
    n[r] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[r] = t.extensions[r]));
}
function assignExtrasToUserData(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function addMorphTargets(n, e, t) {
  let r = !1,
    s = !1,
    o = !1;
  for (let u = 0, p = e.length; u < p; u++) {
    const N = e[u];
    if (
      (N.POSITION !== void 0 && (r = !0),
      N.NORMAL !== void 0 && (s = !0),
      N.COLOR_0 !== void 0 && (o = !0),
      r && s && o)
    )
      break;
  }
  if (!r && !s && !o) return Promise.resolve(n);
  const a = [],
    l = [],
    c = [];
  for (let u = 0, p = e.length; u < p; u++) {
    const N = e[u];
    if (r) {
      const P =
        N.POSITION !== void 0
          ? t.getDependency("accessor", N.POSITION)
          : n.attributes.position;
      a.push(P);
    }
    if (s) {
      const P =
        N.NORMAL !== void 0
          ? t.getDependency("accessor", N.NORMAL)
          : n.attributes.normal;
      l.push(P);
    }
    if (o) {
      const P =
        N.COLOR_0 !== void 0
          ? t.getDependency("accessor", N.COLOR_0)
          : n.attributes.color;
      c.push(P);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(l), Promise.all(c)]).then(
    function (u) {
      const p = u[0],
        N = u[1],
        P = u[2];
      return (
        r && (n.morphAttributes.position = p),
        s && (n.morphAttributes.normal = N),
        o && (n.morphAttributes.color = P),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function updateMorphTargets(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, r = e.weights.length; t < r; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let r = 0, s = t.length; r < s; r++)
        n.morphTargetDictionary[t[r]] = r;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function createPrimitiveKey(n) {
  let e;
  const t = n.extensions && n.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e =
          "draco:" +
          t.bufferView +
          ":" +
          t.indices +
          ":" +
          createAttributesKey(t.attributes))
      : (e =
          n.indices + ":" + createAttributesKey(n.attributes) + ":" + n.mode),
    n.targets !== void 0)
  )
    for (let r = 0, s = n.targets.length; r < s; r++)
      e += ":" + createAttributesKey(n.targets[r]);
  return e;
}
function createAttributesKey(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let r = 0, s = t.length; r < s; r++) e += t[r] + ":" + n[t[r]] + ";";
  return e;
}
function getNormalizedComponentScale(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function getImageURIMimeType(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : n.search(/\.ktx2($|\?)/i) > 0 || n.search(/^data\:image\/ktx2/) === 0
    ? "image/ktx2"
    : "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new GLTFRegistry()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let r = !1,
      s = -1,
      o = !1,
      a = -1;
    if (typeof navigator < "u") {
      const l = navigator.userAgent;
      r = /^((?!chrome|android).)*safari/i.test(l) === !0;
      const c = l.match(/Version\/(\d+)/);
      (s = r && c ? parseInt(c[1], 10) : -1),
        (o = l.indexOf("Firefox") > -1),
        (a = o ? l.match(/Firefox\/([0-9]+)\./)[1] : -1);
    }
    typeof createImageBitmap > "u" || (r && s < 17) || (o && a < 98)
      ? (this.textureLoader = new TextureLoader(this.options.manager))
      : (this.textureLoader = new ImageBitmapLoader(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new FileLoader(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const r = this,
      s = this.json,
      o = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            r.getDependencies("scene"),
            r.getDependencies("animation"),
            r.getDependencies("camera"),
          ]);
        })
        .then(function (a) {
          const l = {
            scene: a[0][s.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: s.asset,
            parser: r,
            userData: {},
          };
          return (
            addUnknownExtensionsToUserData(o, l, s),
            assignExtrasToUserData(l, s),
            Promise.all(
              r._invokeAll(function (c) {
                return c.afterRoot && c.afterRoot(l);
              })
            ).then(function () {
              for (const c of l.scenes) c.updateMatrixWorld();
              e(l);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      r = this.json.meshes || [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s].joints;
      for (let l = 0, c = a.length; l < c; l++) e[a[l]].isBone = !0;
    }
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (r[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1) return r;
    const s = r.clone(),
      o = (a, l) => {
        const c = this.associations.get(a);
        c != null && this.associations.set(l, c);
        for (const [u, p] of a.children.entries()) o(p, l.children[u]);
      };
    return o(r, s), (s.name += "_instance_" + e.uses[t]++), s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      if (s) return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const r = [];
    for (let s = 0; s < t.length; s++) {
      const o = e(t[s]);
      o && r.push(o);
    }
    return r;
  }
  getDependency(e, t) {
    const r = e + ":" + t;
    let s = this.cache.get(r);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function (o) {
            return o.loadNode && o.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function (o) {
            return o.loadMesh && o.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function (o) {
            return o.loadBufferView && o.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function (o) {
            return o.loadMaterial && o.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function (o) {
            return o.loadTexture && o.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function (o) {
            return o.loadAnimation && o.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (
            ((s = this._invokeOne(function (o) {
              return o != this && o.getDependency && o.getDependency(e, t);
            })),
            !s)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(r, s);
    }
    return s;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const r = this,
        s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        s.map(function (o, a) {
          return r.getDependency(e, a);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function (o, a) {
      r.load(LoaderUtils.resolveURL(t.uri, s.path), o, void 0, function () {
        a(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (r) {
      const s = t.byteLength || 0,
        o = t.byteOffset || 0;
      return r.slice(o, o + s);
    });
  }
  loadAccessor(e) {
    const t = this,
      r = this.json,
      s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const a = WEBGL_TYPE_SIZES[s.type],
        l = WEBGL_COMPONENT_TYPES[s.componentType],
        c = s.normalized === !0,
        u = new l(s.count * a);
      return Promise.resolve(new BufferAttribute(u, a, c));
    }
    const o = [];
    return (
      s.bufferView !== void 0
        ? o.push(this.getDependency("bufferView", s.bufferView))
        : o.push(null),
      s.sparse !== void 0 &&
        (o.push(this.getDependency("bufferView", s.sparse.indices.bufferView)),
        o.push(this.getDependency("bufferView", s.sparse.values.bufferView))),
      Promise.all(o).then(function (a) {
        const l = a[0],
          c = WEBGL_TYPE_SIZES[s.type],
          u = WEBGL_COMPONENT_TYPES[s.componentType],
          p = u.BYTES_PER_ELEMENT,
          N = p * c,
          P = s.byteOffset || 0,
          de =
            s.bufferView !== void 0
              ? r.bufferViews[s.bufferView].byteStride
              : void 0,
          me = s.normalized === !0;
        let Ye, nt;
        if (de && de !== N) {
          const Be = Math.floor(P / de),
            ot =
              "InterleavedBuffer:" +
              s.bufferView +
              ":" +
              s.componentType +
              ":" +
              Be +
              ":" +
              s.count;
          let st = t.cache.get(ot);
          st ||
            ((Ye = new u(l, Be * de, (s.count * de) / p)),
            (st = new InterleavedBuffer(Ye, de / p)),
            t.cache.add(ot, st)),
            (nt = new InterleavedBufferAttribute(st, c, (P % de) / p, me));
        } else l === null ? (Ye = new u(s.count * c)) : (Ye = new u(l, P, s.count * c)), (nt = new BufferAttribute(Ye, c, me));
        if (s.sparse !== void 0) {
          const Be = WEBGL_TYPE_SIZES.SCALAR,
            ot = WEBGL_COMPONENT_TYPES[s.sparse.indices.componentType],
            st = s.sparse.indices.byteOffset || 0,
            vt = s.sparse.values.byteOffset || 0,
            xt = new ot(a[1], st, s.sparse.count * Be),
            St = new u(a[2], vt, s.sparse.count * c);
          l !== null &&
            (nt = new BufferAttribute(
              nt.array.slice(),
              nt.itemSize,
              nt.normalized
            )),
            (nt.normalized = !1);
          for (let wt = 0, bt = xt.length; wt < bt; wt++) {
            const Tt = xt[wt];
            if (
              (nt.setX(Tt, St[wt * c]),
              c >= 2 && nt.setY(Tt, St[wt * c + 1]),
              c >= 3 && nt.setZ(Tt, St[wt * c + 2]),
              c >= 4 && nt.setW(Tt, St[wt * c + 3]),
              c >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
          nt.normalized = me;
        }
        return nt;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      r = this.options,
      o = t.textures[e].source,
      a = t.images[o];
    let l = this.textureLoader;
    if (a.uri) {
      const c = r.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.loadTextureImage(e, o, l);
  }
  loadTextureImage(e, t, r) {
    const s = this,
      o = this.json,
      a = o.textures[e],
      l = o.images[t],
      c = (l.uri || l.bufferView) + ":" + a.sampler;
    if (this.textureCache[c]) return this.textureCache[c];
    const u = this.loadImageSource(t, r)
      .then(function (p) {
        (p.flipY = !1),
          (p.name = a.name || l.name || ""),
          p.name === "" &&
            typeof l.uri == "string" &&
            l.uri.startsWith("data:image/") === !1 &&
            (p.name = l.uri);
        const P = (o.samplers || {})[a.sampler] || {};
        return (
          (p.magFilter = WEBGL_FILTERS[P.magFilter] || LinearFilter),
          (p.minFilter =
            WEBGL_FILTERS[P.minFilter] || LinearMipmapLinearFilter),
          (p.wrapS = WEBGL_WRAPPINGS[P.wrapS] || RepeatWrapping),
          (p.wrapT = WEBGL_WRAPPINGS[P.wrapT] || RepeatWrapping),
          (p.generateMipmaps =
            !p.isCompressedTexture &&
            p.minFilter !== NearestFilter &&
            p.minFilter !== LinearFilter),
          s.associations.set(p, { textures: e }),
          p
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[c] = u), u;
  }
  loadImageSource(e, t) {
    const r = this,
      s = this.json,
      o = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((N) => N.clone());
    const a = s.images[e],
      l = self.URL || self.webkitURL;
    let c = a.uri || "",
      u = !1;
    if (a.bufferView !== void 0)
      c = r.getDependency("bufferView", a.bufferView).then(function (N) {
        u = !0;
        const P = new Blob([N], { type: a.mimeType });
        return (c = l.createObjectURL(P)), c;
      });
    else if (a.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const p = Promise.resolve(c)
      .then(function (N) {
        return new Promise(function (P, de) {
          let me = P;
          t.isImageBitmapLoader === !0 &&
            (me = function (Ye) {
              const nt = new Texture(Ye);
              (nt.needsUpdate = !0), P(nt);
            }),
            t.load(LoaderUtils.resolveURL(N, o.path), me, void 0, de);
        });
      })
      .then(function (N) {
        return (
          u === !0 && l.revokeObjectURL(c),
          assignExtrasToUserData(N, a),
          (N.userData.mimeType = a.mimeType || getImageURIMimeType(a.uri)),
          N
        );
      })
      .catch(function (N) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", c), N);
      });
    return (this.sourceCache[e] = p), p;
  }
  assignTexture(e, t, r, s) {
    const o = this;
    return this.getDependency("texture", r.index).then(function (a) {
      if (!a) return null;
      if (
        (r.texCoord !== void 0 &&
          r.texCoord > 0 &&
          ((a = a.clone()), (a.channel = r.texCoord)),
        o.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM])
      ) {
        const l =
          r.extensions !== void 0
            ? r.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (l) {
          const c = o.associations.get(a);
          (a = o.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(
            a,
            l
          )),
            o.associations.set(a, c);
        }
      }
      return s !== void 0 && (a.colorSpace = s), (e[t] = a), a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let r = e.material;
    const s = t.attributes.tangent === void 0,
      o = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const l = "PointsMaterial:" + r.uuid;
      let c = this.cache.get(l);
      c ||
        ((c = new PointsMaterial()),
        Material.prototype.copy.call(c, r),
        c.color.copy(r.color),
        (c.map = r.map),
        (c.sizeAttenuation = !1),
        this.cache.add(l, c)),
        (r = c);
    } else if (e.isLine) {
      const l = "LineBasicMaterial:" + r.uuid;
      let c = this.cache.get(l);
      c ||
        ((c = new LineBasicMaterial()),
        Material.prototype.copy.call(c, r),
        c.color.copy(r.color),
        (c.map = r.map),
        this.cache.add(l, c)),
        (r = c);
    }
    if (s || o || a) {
      let l = "ClonedMaterial:" + r.uuid + ":";
      s && (l += "derivative-tangents:"),
        o && (l += "vertex-colors:"),
        a && (l += "flat-shading:");
      let c = this.cache.get(l);
      c ||
        ((c = r.clone()),
        o && (c.vertexColors = !0),
        a && (c.flatShading = !0),
        s &&
          (c.normalScale && (c.normalScale.y *= -1),
          c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)),
        this.cache.add(l, c),
        this.associations.set(c, this.associations.get(r))),
        (r = c);
    }
    e.material = r;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(e) {
    const t = this,
      r = this.json,
      s = this.extensions,
      o = r.materials[e];
    let a;
    const l = {},
      c = o.extensions || {},
      u = [];
    if (c[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const N = s[EXTENSIONS.KHR_MATERIALS_UNLIT];
      (a = N.getMaterialType()), u.push(N.extendParams(l, o, t));
    } else {
      const N = o.pbrMetallicRoughness || {};
      if (
        ((l.color = new Color(1, 1, 1)),
        (l.opacity = 1),
        Array.isArray(N.baseColorFactor))
      ) {
        const P = N.baseColorFactor;
        l.color.setRGB(P[0], P[1], P[2], LinearSRGBColorSpace),
          (l.opacity = P[3]);
      }
      N.baseColorTexture !== void 0 &&
        u.push(t.assignTexture(l, "map", N.baseColorTexture, SRGBColorSpace)),
        (l.metalness = N.metallicFactor !== void 0 ? N.metallicFactor : 1),
        (l.roughness = N.roughnessFactor !== void 0 ? N.roughnessFactor : 1),
        N.metallicRoughnessTexture !== void 0 &&
          (u.push(
            t.assignTexture(l, "metalnessMap", N.metallicRoughnessTexture)
          ),
          u.push(
            t.assignTexture(l, "roughnessMap", N.metallicRoughnessTexture)
          )),
        (a = this._invokeOne(function (P) {
          return P.getMaterialType && P.getMaterialType(e);
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (P) {
              return P.extendMaterialParams && P.extendMaterialParams(e, l);
            })
          )
        );
    }
    o.doubleSided === !0 && (l.side = DoubleSide);
    const p = o.alphaMode || ALPHA_MODES.OPAQUE;
    if (
      (p === ALPHA_MODES.BLEND
        ? ((l.transparent = !0), (l.depthWrite = !1))
        : ((l.transparent = !1),
          p === ALPHA_MODES.MASK &&
            (l.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : 0.5)),
      o.normalTexture !== void 0 &&
        a !== MeshBasicMaterial &&
        (u.push(t.assignTexture(l, "normalMap", o.normalTexture)),
        (l.normalScale = new Vector2(1, 1)),
        o.normalTexture.scale !== void 0))
    ) {
      const N = o.normalTexture.scale;
      l.normalScale.set(N, N);
    }
    if (
      (o.occlusionTexture !== void 0 &&
        a !== MeshBasicMaterial &&
        (u.push(t.assignTexture(l, "aoMap", o.occlusionTexture)),
        o.occlusionTexture.strength !== void 0 &&
          (l.aoMapIntensity = o.occlusionTexture.strength)),
      o.emissiveFactor !== void 0 && a !== MeshBasicMaterial)
    ) {
      const N = o.emissiveFactor;
      l.emissive = new Color().setRGB(N[0], N[1], N[2], LinearSRGBColorSpace);
    }
    return (
      o.emissiveTexture !== void 0 &&
        a !== MeshBasicMaterial &&
        u.push(
          t.assignTexture(l, "emissiveMap", o.emissiveTexture, SRGBColorSpace)
        ),
      Promise.all(u).then(function () {
        const N = new a(l);
        return (
          o.name && (N.name = o.name),
          assignExtrasToUserData(N, o),
          t.associations.set(N, { materials: e }),
          o.extensions && addUnknownExtensionsToUserData(s, N, o),
          N
        );
      })
    );
  }
  createUniqueName(e) {
    const t = PropertyBinding.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      r = this.extensions,
      s = this.primitiveCache;
    function o(l) {
      return r[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(l, t)
        .then(function (c) {
          return addPrimitiveAttributes(c, l, t);
        });
    }
    const a = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const u = e[l],
        p = createPrimitiveKey(u),
        N = s[p];
      if (N) a.push(N.promise);
      else {
        let P;
        u.extensions && u.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
          ? (P = o(u))
          : (P = addPrimitiveAttributes(new BufferGeometry(), u, t)),
          (s[p] = { primitive: u, promise: P }),
          a.push(P);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      r = this.json,
      s = this.extensions,
      o = r.meshes[e],
      a = o.primitives,
      l = [];
    for (let c = 0, u = a.length; c < u; c++) {
      const p =
        a[c].material === void 0
          ? createDefaultMaterial(this.cache)
          : this.getDependency("material", a[c].material);
      l.push(p);
    }
    return (
      l.push(t.loadGeometries(a)),
      Promise.all(l).then(function (c) {
        const u = c.slice(0, c.length - 1),
          p = c[c.length - 1],
          N = [];
        for (let de = 0, me = p.length; de < me; de++) {
          const Ye = p[de],
            nt = a[de];
          let Be;
          const ot = u[de];
          if (
            nt.mode === WEBGL_CONSTANTS.TRIANGLES ||
            nt.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
            nt.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
            nt.mode === void 0
          )
            (Be =
              o.isSkinnedMesh === !0
                ? new SkinnedMesh(Ye, ot)
                : new Mesh(Ye, ot)),
              Be.isSkinnedMesh === !0 && Be.normalizeSkinWeights(),
              nt.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP
                ? (Be.geometry = toTrianglesDrawMode(
                    Be.geometry,
                    TriangleStripDrawMode
                  ))
                : nt.mode === WEBGL_CONSTANTS.TRIANGLE_FAN &&
                  (Be.geometry = toTrianglesDrawMode(
                    Be.geometry,
                    TriangleFanDrawMode
                  ));
          else if (nt.mode === WEBGL_CONSTANTS.LINES)
            Be = new LineSegments(Ye, ot);
          else if (nt.mode === WEBGL_CONSTANTS.LINE_STRIP)
            Be = new Line(Ye, ot);
          else if (nt.mode === WEBGL_CONSTANTS.LINE_LOOP)
            Be = new LineLoop(Ye, ot);
          else if (nt.mode === WEBGL_CONSTANTS.POINTS) Be = new Points(Ye, ot);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + nt.mode
            );
          Object.keys(Be.geometry.morphAttributes).length > 0 &&
            updateMorphTargets(Be, o),
            (Be.name = t.createUniqueName(o.name || "mesh_" + e)),
            assignExtrasToUserData(Be, o),
            nt.extensions && addUnknownExtensionsToUserData(s, Be, nt),
            t.assignFinalMaterial(Be),
            N.push(Be);
        }
        for (let de = 0, me = N.length; de < me; de++)
          t.associations.set(N[de], { meshes: e, primitives: de });
        if (N.length === 1)
          return (
            o.extensions && addUnknownExtensionsToUserData(s, N[0], o), N[0]
          );
        const P = new Group();
        o.extensions && addUnknownExtensionsToUserData(s, P, o),
          t.associations.set(P, { meshes: e });
        for (let de = 0, me = N.length; de < me; de++) P.add(N[de]);
        return P;
      })
    );
  }
  loadCamera(e) {
    let t;
    const r = this.json.cameras[e],
      s = r[r.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      r.type === "perspective"
        ? (t = new PerspectiveCamera(
            MathUtils.radToDeg(s.yfov),
            s.aspectRatio || 1,
            s.znear || 1,
            s.zfar || 2e6
          ))
        : r.type === "orthographic" &&
          (t = new OrthographicCamera(
            -s.xmag,
            s.xmag,
            s.ymag,
            -s.ymag,
            s.znear,
            s.zfar
          )),
      r.name && (t.name = this.createUniqueName(r.name)),
      assignExtrasToUserData(t, r),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      r = [];
    for (let s = 0, o = t.joints.length; s < o; s++)
      r.push(this._loadNodeShallow(t.joints[s]));
    return (
      t.inverseBindMatrices !== void 0
        ? r.push(this.getDependency("accessor", t.inverseBindMatrices))
        : r.push(null),
      Promise.all(r).then(function (s) {
        const o = s.pop(),
          a = s,
          l = [],
          c = [];
        for (let u = 0, p = a.length; u < p; u++) {
          const N = a[u];
          if (N) {
            l.push(N);
            const P = new Matrix4();
            o !== null && P.fromArray(o.array, u * 16), c.push(P);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[u]
            );
        }
        return new Skeleton(l, c);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      r = this,
      s = t.animations[e],
      o = s.name ? s.name : "animation_" + e,
      a = [],
      l = [],
      c = [],
      u = [],
      p = [];
    for (let N = 0, P = s.channels.length; N < P; N++) {
      const de = s.channels[N],
        me = s.samplers[de.sampler],
        Ye = de.target,
        nt = Ye.node,
        Be = s.parameters !== void 0 ? s.parameters[me.input] : me.input,
        ot = s.parameters !== void 0 ? s.parameters[me.output] : me.output;
      Ye.node !== void 0 &&
        (a.push(this.getDependency("node", nt)),
        l.push(this.getDependency("accessor", Be)),
        c.push(this.getDependency("accessor", ot)),
        u.push(me),
        p.push(Ye));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u),
      Promise.all(p),
    ]).then(function (N) {
      const P = N[0],
        de = N[1],
        me = N[2],
        Ye = N[3],
        nt = N[4],
        Be = [];
      for (let ot = 0, st = P.length; ot < st; ot++) {
        const vt = P[ot],
          xt = de[ot],
          St = me[ot],
          wt = Ye[ot],
          bt = nt[ot];
        if (vt === void 0) continue;
        vt.updateMatrix && vt.updateMatrix();
        const Tt = r._createAnimationTracks(vt, xt, St, wt, bt);
        if (Tt) for (let Ct = 0; Ct < Tt.length; Ct++) Be.push(Tt[Ct]);
      }
      return new AnimationClip(o, void 0, Be);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      r = this,
      s = t.nodes[e];
    return s.mesh === void 0
      ? null
      : r.getDependency("mesh", s.mesh).then(function (o) {
          const a = r._getNodeRef(r.meshCache, s.mesh, o);
          return (
            s.weights !== void 0 &&
              a.traverse(function (l) {
                if (l.isMesh)
                  for (let c = 0, u = s.weights.length; c < u; c++)
                    l.morphTargetInfluences[c] = s.weights[c];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      r = this,
      s = t.nodes[e],
      o = r._loadNodeShallow(e),
      a = [],
      l = s.children || [];
    for (let u = 0, p = l.length; u < p; u++)
      a.push(r.getDependency("node", l[u]));
    const c =
      s.skin === void 0
        ? Promise.resolve(null)
        : r.getDependency("skin", s.skin);
    return Promise.all([o, Promise.all(a), c]).then(function (u) {
      const p = u[0],
        N = u[1],
        P = u[2];
      P !== null &&
        p.traverse(function (de) {
          de.isSkinnedMesh && de.bind(P, _identityMatrix);
        });
      for (let de = 0, me = N.length; de < me; de++) p.add(N[de]);
      return p;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      r = this.extensions,
      s = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const o = t.nodes[e],
      a = o.name ? s.createUniqueName(o.name) : "",
      l = [],
      c = s._invokeOne(function (u) {
        return u.createNodeMesh && u.createNodeMesh(e);
      });
    return (
      c && l.push(c),
      o.camera !== void 0 &&
        l.push(
          s.getDependency("camera", o.camera).then(function (u) {
            return s._getNodeRef(s.cameraCache, o.camera, u);
          })
        ),
      s
        ._invokeAll(function (u) {
          return u.createNodeAttachment && u.createNodeAttachment(e);
        })
        .forEach(function (u) {
          l.push(u);
        }),
      (this.nodeCache[e] = Promise.all(l).then(function (u) {
        let p;
        if (
          (o.isBone === !0
            ? (p = new Bone())
            : u.length > 1
            ? (p = new Group())
            : u.length === 1
            ? (p = u[0])
            : (p = new Object3D()),
          p !== u[0])
        )
          for (let N = 0, P = u.length; N < P; N++) p.add(u[N]);
        if (
          (o.name && ((p.userData.name = o.name), (p.name = a)),
          assignExtrasToUserData(p, o),
          o.extensions && addUnknownExtensionsToUserData(r, p, o),
          o.matrix !== void 0)
        ) {
          const N = new Matrix4();
          N.fromArray(o.matrix), p.applyMatrix4(N);
        } else o.translation !== void 0 && p.position.fromArray(o.translation), o.rotation !== void 0 && p.quaternion.fromArray(o.rotation), o.scale !== void 0 && p.scale.fromArray(o.scale);
        return (
          s.associations.has(p) || s.associations.set(p, {}),
          (s.associations.get(p).nodes = e),
          p
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      r = this.json.scenes[e],
      s = this,
      o = new Group();
    r.name && (o.name = s.createUniqueName(r.name)),
      assignExtrasToUserData(o, r),
      r.extensions && addUnknownExtensionsToUserData(t, o, r);
    const a = r.nodes || [],
      l = [];
    for (let c = 0, u = a.length; c < u; c++)
      l.push(s.getDependency("node", a[c]));
    return Promise.all(l).then(function (c) {
      for (let p = 0, N = c.length; p < N; p++) o.add(c[p]);
      const u = (p) => {
        const N = new Map();
        for (const [P, de] of s.associations)
          (P instanceof Material || P instanceof Texture) && N.set(P, de);
        return (
          p.traverse((P) => {
            const de = s.associations.get(P);
            de != null && N.set(P, de);
          }),
          N
        );
      };
      return (s.associations = u(o)), o;
    });
  }
  _createAnimationTracks(e, t, r, s, o) {
    const a = [],
      l = e.name ? e.name : e.uuid,
      c = [];
    PATH_PROPERTIES[o.path] === PATH_PROPERTIES.weights
      ? e.traverse(function (P) {
          P.morphTargetInfluences && c.push(P.name ? P.name : P.uuid);
        })
      : c.push(l);
    let u;
    switch (PATH_PROPERTIES[o.path]) {
      case PATH_PROPERTIES.weights:
        u = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        u = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.translation:
      case PATH_PROPERTIES.scale:
        u = VectorKeyframeTrack;
        break;
      default:
        switch (r.itemSize) {
          case 1:
            u = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            u = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const p =
        s.interpolation !== void 0
          ? INTERPOLATION[s.interpolation]
          : InterpolateLinear,
      N = this._getArrayFromAccessor(r);
    for (let P = 0, de = c.length; P < de; P++) {
      const me = new u(c[P] + "." + PATH_PROPERTIES[o.path], t.array, N, p);
      s.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(me),
        a.push(me);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const r = getNormalizedComponentScale(t.constructor),
        s = new Float32Array(t.length);
      for (let o = 0, a = t.length; o < a; o++) s[o] = t[o] * r;
      t = s;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (r) {
      const s =
        this instanceof QuaternionKeyframeTrack
          ? GLTFCubicSplineQuaternionInterpolant
          : GLTFCubicSplineInterpolant;
      return new s(this.times, this.values, this.getValueSize() / 3, r);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function computeBounds(n, e, t) {
  const r = e.attributes,
    s = new Box3();
  if (r.POSITION !== void 0) {
    const l = t.json.accessors[r.POSITION],
      c = l.min,
      u = l.max;
    if (c !== void 0 && u !== void 0) {
      if (
        (s.set(new Vector3(c[0], c[1], c[2]), new Vector3(u[0], u[1], u[2])),
        l.normalized)
      ) {
        const p = getNormalizedComponentScale(
          WEBGL_COMPONENT_TYPES[l.componentType]
        );
        s.min.multiplyScalar(p), s.max.multiplyScalar(p);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const o = e.targets;
  if (o !== void 0) {
    const l = new Vector3(),
      c = new Vector3();
    for (let u = 0, p = o.length; u < p; u++) {
      const N = o[u];
      if (N.POSITION !== void 0) {
        const P = t.json.accessors[N.POSITION],
          de = P.min,
          me = P.max;
        if (de !== void 0 && me !== void 0) {
          if (
            (c.setX(Math.max(Math.abs(de[0]), Math.abs(me[0]))),
            c.setY(Math.max(Math.abs(de[1]), Math.abs(me[1]))),
            c.setZ(Math.max(Math.abs(de[2]), Math.abs(me[2]))),
            P.normalized)
          ) {
            const Ye = getNormalizedComponentScale(
              WEBGL_COMPONENT_TYPES[P.componentType]
            );
            c.multiplyScalar(Ye);
          }
          l.max(c);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    s.expandByVector(l);
  }
  n.boundingBox = s;
  const a = new Sphere();
  s.getCenter(a.center),
    (a.radius = s.min.distanceTo(s.max) / 2),
    (n.boundingSphere = a);
}
function addPrimitiveAttributes(n, e, t) {
  const r = e.attributes,
    s = [];
  function o(a, l) {
    return t.getDependency("accessor", a).then(function (c) {
      n.setAttribute(l, c);
    });
  }
  for (const a in r) {
    const l = ATTRIBUTES[a] || a.toLowerCase();
    l in n.attributes || s.push(o(r[a], l));
  }
  if (e.indices !== void 0 && !n.index) {
    const a = t.getDependency("accessor", e.indices).then(function (l) {
      n.setIndex(l);
    });
    s.push(a);
  }
  return (
    ColorManagement.workingColorSpace !== LinearSRGBColorSpace &&
      "COLOR_0" in r &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`
      ),
    assignExtrasToUserData(n, e),
    computeBounds(n, e, t),
    Promise.all(s).then(function () {
      return e.targets !== void 0 ? addMorphTargets(n, e.targets, t) : n;
    })
  );
}
const _taskCache = new WeakMap();
class DRACOLoader extends Loader$2 {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, r, s) {
    const o = new FileLoader(this.manager);
    o.setPath(this.path),
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        (a) => {
          this.parse(a, t, s);
        },
        r,
        s
      );
  }
  parse(e, t, r = () => {}) {
    this.decodeDracoFile(e, t, null, null, SRGBColorSpace, r).catch(r);
  }
  decodeDracoFile(e, t, r, s, o = LinearSRGBColorSpace, a = () => {}) {
    const l = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
      vertexColorSpace: o,
    };
    return this.decodeGeometry(e, l).then(t).catch(a);
  }
  decodeGeometry(e, t) {
    const r = JSON.stringify(t);
    if (_taskCache.has(e)) {
      const c = _taskCache.get(e);
      if (c.key === r) return c.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const o = this.workerNextTaskID++,
      a = e.byteLength,
      l = this._getWorker(o, a)
        .then(
          (c) => (
            (s = c),
            new Promise((u, p) => {
              (s._callbacks[o] = { resolve: u, reject: p }),
                s.postMessage(
                  { type: "decode", id: o, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((c) => this._createGeometry(c.geometry));
    return (
      l
        .catch(() => !0)
        .then(() => {
          s && o && this._releaseTask(s, o);
        }),
      _taskCache.set(e, { key: r, promise: l }),
      l
    );
  }
  _createGeometry(e) {
    const t = new BufferGeometry();
    e.index && t.setIndex(new BufferAttribute(e.index.array, 1));
    for (let r = 0; r < e.attributes.length; r++) {
      const s = e.attributes[r],
        o = s.name,
        a = s.array,
        l = s.itemSize,
        c = new BufferAttribute(a, l);
      o === "color" &&
        (this._assignVertexColorSpace(c, s.vertexColorSpace),
        (c.normalized = !(a instanceof Float32Array))),
        t.setAttribute(o, c);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== SRGBColorSpace) return;
    const r = new Color();
    for (let s = 0, o = e.count; s < o; s++)
      r.fromBufferAttribute(e, s),
        ColorManagement.toWorkingColorSpace(r, SRGBColorSpace),
        e.setXYZ(s, r.r, r.g, r.b);
  }
  _loadLibrary(e, t) {
    const r = new FileLoader(this.manager);
    return (
      r.setPath(this.decoderPath),
      r.setResponseType(t),
      r.setWithCredentials(this.withCredentials),
      new Promise((s, o) => {
        r.load(e, s, void 0, o);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((r) => {
        const s = r[0];
        e || (this.decoderConfig.wasmBinary = r[1]);
        const o = DRACOWorker.toString(),
          a = [
            "/* draco decoder */",
            s,
            "",
            "/* worker */",
            o.substring(o.indexOf("{") + 1, o.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([a]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        (s._callbacks = {}),
          (s._taskCosts = {}),
          (s._taskLoad = 0),
          s.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (s.onmessage = function (o) {
            const a = o.data;
            switch (a.type) {
              case "decode":
                s._callbacks[a.id].resolve(a);
                break;
              case "error":
                s._callbacks[a.id].reject(a);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + a.type + '"'
                );
            }
          }),
          this.workerPool.push(s);
      } else
        this.workerPool.sort(function (s, o) {
          return s._taskLoad > o._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return (r._taskCosts[e] = t), (r._taskLoad += t), r;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (
      (this.workerPool.length = 0),
      this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL),
      this
    );
  }
}
function DRACOWorker() {
  let n, e;
  onmessage = function (a) {
    const l = a.data;
    switch (l.type) {
      case "init":
        (n = l.decoderConfig),
          (e = new Promise(function (p) {
            (n.onModuleLoaded = function (N) {
              p({ draco: N });
            }),
              DracoDecoderModule(n);
          }));
        break;
      case "decode":
        const c = l.buffer,
          u = l.taskConfig;
        e.then((p) => {
          const N = p.draco,
            P = new N.Decoder();
          try {
            const de = t(N, P, new Int8Array(c), u),
              me = de.attributes.map((Ye) => Ye.array.buffer);
            de.index && me.push(de.index.array.buffer),
              self.postMessage({ type: "decode", id: l.id, geometry: de }, me);
          } catch (de) {
            console.error(de),
              self.postMessage({ type: "error", id: l.id, error: de.message });
          } finally {
            N.destroy(P);
          }
        });
        break;
    }
  };
  function t(a, l, c, u) {
    const p = u.attributeIDs,
      N = u.attributeTypes;
    let P, de;
    const me = l.GetEncodedGeometryType(c);
    if (me === a.TRIANGULAR_MESH)
      (P = new a.Mesh()), (de = l.DecodeArrayToMesh(c, c.byteLength, P));
    else if (me === a.POINT_CLOUD)
      (P = new a.PointCloud()),
        (de = l.DecodeArrayToPointCloud(c, c.byteLength, P));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!de.ok() || P.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + de.error_msg());
    const Ye = { index: null, attributes: [] };
    for (const nt in p) {
      const Be = self[N[nt]];
      let ot, st;
      if (u.useUniqueIDs) (st = p[nt]), (ot = l.GetAttributeByUniqueId(P, st));
      else {
        if (((st = l.GetAttributeId(P, a[p[nt]])), st === -1)) continue;
        ot = l.GetAttribute(P, st);
      }
      const vt = s(a, l, P, nt, Be, ot);
      nt === "color" && (vt.vertexColorSpace = u.vertexColorSpace),
        Ye.attributes.push(vt);
    }
    return (
      me === a.TRIANGULAR_MESH && (Ye.index = r(a, l, P)), a.destroy(P), Ye
    );
  }
  function r(a, l, c) {
    const p = c.num_faces() * 3,
      N = p * 4,
      P = a._malloc(N);
    l.GetTrianglesUInt32Array(c, N, P);
    const de = new Uint32Array(a.HEAPF32.buffer, P, p).slice();
    return a._free(P), { array: de, itemSize: 1 };
  }
  function s(a, l, c, u, p, N) {
    const P = N.num_components(),
      me = c.num_points() * P,
      Ye = me * p.BYTES_PER_ELEMENT,
      nt = o(a, p),
      Be = a._malloc(Ye);
    l.GetAttributeDataArrayForAllPoints(c, N, nt, Ye, Be);
    const ot = new p(a.HEAPF32.buffer, Be, me).slice();
    return a._free(Be), { name: u, array: ot, itemSize: P };
  }
  function o(a, l) {
    switch (l) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
const LandingModelContext = reactExports.createContext(void 0),
  LandingContextProvider = ({ children: n }) => {
    const [e, t] = reactExports.useState(!0),
      [r, s] = reactExports.useState(!1),
      { deviceType: o, isTouchDevices: a } = useDeviceType(),
      [l, c] = reactExports.useState(snakeCameraFactor.mainBlock),
      u = reactExports.useRef(0.05),
      [p, N] = reactExports.useState("IDLE"),
      [P, de] = reactExports.useState(null),
      [me, Ye] = reactExports.useState([]),
      [nt, Be] = reactExports.useState(
        a ? "/model/draco/SINT_mobile.glb" : "/model/draco/SINT_desktop.glb"
      ),
      ot = (st) => {
        setTimeout(() => {
          P &&
            (console.log(22222, { deviceTypeDetected: o, block: st }),
            P.rotation.set(
              sintPosition[o][st].rotation.x,
              sintPosition[o][st].rotation.y,
              sintPosition[o][st].rotation.z
            ),
            P.position.set(
              sintPosition[o][st].pos.x,
              sintPosition[o][st].pos.y,
              sintPosition[o][st].pos.z
            ));
        }, 25);
      };
    return (
      reactExports.useLayoutEffect(() => {
        const st = new GLTFLoader(),
          vt = new DRACOLoader();
        return (
          vt.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"),
          vt.setDecoderConfig({ type: "js" }),
          st.setDRACOLoader(vt),
          (async () => {
            t(!0);
            try {
              const St = await new Promise((bt, Tt) => {
                  st.load(nt, bt, void 0, Tt);
                }),
                wt = St.scene;
              wt.scale.set(6.5, 6.5, 6.5),
                wt.rotation.set(
                  sintPosition[o].mainBlock.rotation.x,
                  sintPosition[o].mainBlock.rotation.y,
                  sintPosition[o].mainBlock.rotation.z
                ),
                wt.position.set(
                  sintPosition[o].mainBlock.pos.x,
                  sintPosition[o].mainBlock.pos.y,
                  sintPosition[o].mainBlock.pos.z
                ),
                de(wt),
                Ye(St.animations || []);
            } catch (St) {
              console.error("Error loading model or textures: " + St);
            } finally {
              setTimeout(() => {
                t(!1);
              }, 1e3);
            }
          })(),
          () => {
            de(null), vt.dispose();
          }
        );
      }, [nt]),
      jsxRuntimeExports.jsx(LandingModelContext.Provider, {
        value: {
          isModelRendered: r,
          setIsModelRendered: s,
          isLoading: e,
          setIsLoading: t,
          snakeCameraFactor: l,
          setSnakeCameraFactor: c,
          snakeCameraSmoothness: u.current,
          modelUrl: nt,
          setModelUrl: Be,
          activeAnimation: p,
          setActiveAnimation: N,
          model: P,
          animations: me,
          moveModelToPosition: ot,
        },
        children: n,
      })
    );
  },
  useLandingContext = () => {
    const n = reactExports.useContext(LandingModelContext);
    if (!n)
      throw new Error(
        "useLandingContext must be used within a LandingContextProvider"
      );
    return n;
  };
function Model() {
  const {
      isLoading: n,
      setIsModelRendered: e,
      model: t,
      animations: r,
      isModelRendered: s,
    } = useLandingContext(),
    { isTouchDevices: o } = useDeviceType(),
    a = reactExports.useRef(null),
    l = reactExports.useRef(null),
    c = reactExports.useRef(null),
    u = reactExports.useRef(new Clock()),
    p = reactExports.useRef(!1);
  return (
    reactExports.useCallback(
      (N, P) => {
        if (t) {
          const de = t.getObjectByName(N);
          de && de instanceof Mesh && (de.material.blending = P);
        }
      },
      [t]
    ),
    reactExports.useLayoutEffect(() => {
      if (t) {
        if (n) {
          console.log("Model is loading, skipping animation setup.");
          return;
        }
        return (
          t &&
            t.traverse((N) => {
              N instanceof Material &&
                ((N.depthWrite = !0), (N.depthTest = !0));
            }),
          (c.current = new AnimationMixer(t)),
          r.length > 0 && !o
            ? r.forEach((N) => {
                var de;
                const P = (de = c.current) == null ? void 0 : de.clipAction(N);
                P
                  ? (P.reset(), P.play())
                  : console.warn(
                      `Animation "${N.name}" not found in the mixer.`
                    );
              })
            : console.warn("No animations found in the loaded model."),
          () => {
            c.current &&
              !o &&
              (c.current.stopAllAction(),
              c.current.uncacheRoot(t),
              (c.current = null));
          }
        );
      }
    }, [t, n, r, o]),
    reactExports.useLayoutEffect(() => {
      if (t && !n && !o && s) {
        const N = () => {
          (l.current = requestAnimationFrame(N)),
            c.current &&
              u.current &&
              !p.current &&
              c.current.update(u.current.getDelta());
        };
        return (
          N(),
          () => {
            l.current &&
              (cancelAnimationFrame(l.current),
              (l.current = null),
              (u.current = null));
          }
        );
      }
    }, [t, n, s]),
    reactExports.useEffect(() => {
      if (!o) {
        const N = document.getElementById("howItWorks");
        if (!N) return;
        const P = (me) => {
            var nt;
            me[0].isIntersecting
              ? ((p.current = !0),
                (nt = c.current) == null || nt.stopAllAction())
              : ((p.current = !1),
                r.forEach((Be) => {
                  var st;
                  const ot =
                    (st = c.current) == null ? void 0 : st.clipAction(Be);
                  ot && ot.play();
                }));
          },
          de = new IntersectionObserver(P, { threshold: 0.5 });
        return (
          de.observe(N),
          () => {
            de.disconnect();
          }
        );
      }
    }, [r]),
    reactExports.useEffect(() => {
      a && a.current ? (console.log("MODEL-RENDERED"), e(!0)) : e(!1);
    }, [a, n, !o]),
    jsxRuntimeExports.jsxs("group", {
      children: [
        t && jsxRuntimeExports.jsx("primitive", { ref: a, object: t }),
        " ",
      ],
    })
  );
}
var constants = { exports: {} },
  reactReconcilerConstants_production_min = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactReconcilerConstants_production_min;
function requireReactReconcilerConstants_production_min() {
  return (
    hasRequiredReactReconcilerConstants_production_min ||
      ((hasRequiredReactReconcilerConstants_production_min = 1),
      (reactReconcilerConstants_production_min.ConcurrentRoot = 1),
      (reactReconcilerConstants_production_min.ContinuousEventPriority = 4),
      (reactReconcilerConstants_production_min.DefaultEventPriority = 16),
      (reactReconcilerConstants_production_min.DiscreteEventPriority = 1),
      (reactReconcilerConstants_production_min.IdleEventPriority = 536870912),
      (reactReconcilerConstants_production_min.LegacyRoot = 0)),
    reactReconcilerConstants_production_min
  );
}
var hasRequiredConstants;
function requireConstants() {
  return (
    hasRequiredConstants ||
      ((hasRequiredConstants = 1),
      (constants.exports = requireReactReconcilerConstants_production_min())),
    constants.exports
  );
}
var constantsExports = requireConstants();
function createStore$1(n) {
  let e;
  const t = new Set(),
    r = (u, p) => {
      const N = typeof u == "function" ? u(e) : u;
      if (N !== e) {
        const P = e;
        (e = p ? N : Object.assign({}, e, N)), t.forEach((de) => de(e, P));
      }
    },
    s = () => e,
    o = (u, p = s, N = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let P = p(e);
      function de() {
        const me = p(e);
        if (!N(P, me)) {
          const Ye = P;
          u((P = me), Ye);
        }
      }
      return t.add(de), () => t.delete(de);
    },
    c = {
      setState: r,
      getState: s,
      subscribe: (u, p, N) =>
        p || N ? o(u, p, N) : (t.add(u), () => t.delete(u)),
      destroy: () => t.clear(),
    };
  return (e = n(r, s, c)), c;
}
const isSSR =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  useIsomorphicLayoutEffect$1 = isSSR
    ? reactExports.useEffect
    : reactExports.useLayoutEffect;
function create(n) {
  const e = typeof n == "function" ? createStore$1(n) : n,
    t = (r = e.getState, s = Object.is) => {
      const [, o] = reactExports.useReducer((nt) => nt + 1, 0),
        a = e.getState(),
        l = reactExports.useRef(a),
        c = reactExports.useRef(r),
        u = reactExports.useRef(s),
        p = reactExports.useRef(!1),
        N = reactExports.useRef();
      N.current === void 0 && (N.current = r(a));
      let P,
        de = !1;
      (l.current !== a || c.current !== r || u.current !== s || p.current) &&
        ((P = r(a)), (de = !s(N.current, P))),
        useIsomorphicLayoutEffect$1(() => {
          de && (N.current = P),
            (l.current = a),
            (c.current = r),
            (u.current = s),
            (p.current = !1);
        });
      const me = reactExports.useRef(a);
      useIsomorphicLayoutEffect$1(() => {
        const nt = () => {
            try {
              const ot = e.getState(),
                st = c.current(ot);
              u.current(N.current, st) ||
                ((l.current = ot), (N.current = st), o());
            } catch {
              (p.current = !0), o();
            }
          },
          Be = e.subscribe(nt);
        return e.getState() !== me.current && nt(), Be;
      }, []);
      const Ye = de ? P : N.current;
      return reactExports.useDebugValue(Ye), Ye;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const s = r.length <= 0;
          return { value: r.shift(), done: s };
        },
      };
    }),
    t
  );
}
const isPromise = (n) => typeof n == "object" && typeof n.then == "function",
  globalCache = [];
function shallowEqualArrays(n, e, t = (r, s) => r === s) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const r = n.length;
  if (e.length !== r) return !1;
  for (let s = 0; s < r; s++) if (!t(n[s], e[s])) return !1;
  return !0;
}
function query(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const o of globalCache)
    if (shallowEqualArrays(e, o.keys, o.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout),
            (o.timeout = setTimeout(o.remove, r.lifespan))),
          o.response
        );
      if (!t) throw o.promise;
    }
  const s = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = globalCache.indexOf(s);
      o !== -1 && globalCache.splice(o, 1);
    },
    promise: (isPromise(n) ? n : n(...e))
      .then((o) => {
        (s.response = o),
          r.lifespan &&
            r.lifespan > 0 &&
            (s.timeout = setTimeout(s.remove, r.lifespan));
      })
      .catch((o) => (s.error = o)),
  };
  if ((globalCache.push(s), !t)) throw s.promise;
}
const suspend = (n, e, t) => query(n, e, !1, t),
  preload = (n, e, t) => void query(n, e, !0, t),
  clear = (n) => {
    if (n === void 0 || n.length === 0)
      globalCache.splice(0, globalCache.length);
    else {
      const e = globalCache.find((t) => shallowEqualArrays(n, t.keys, t.equal));
      e && e.remove();
    }
  };
var reactReconciler = { exports: {} },
  scheduler = { exports: {} },
  scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  return (
    hasRequiredScheduler_production_min ||
      ((hasRequiredScheduler_production_min = 1),
      (function (n) {
        function e(Mt, Pt) {
          var It = Mt.length;
          Mt.push(Pt);
          e: for (; 0 < It; ) {
            var Ot = (It - 1) >>> 1,
              Xt = Mt[Ot];
            if (0 < s(Xt, Pt)) (Mt[Ot] = Pt), (Mt[It] = Xt), (It = Ot);
            else break e;
          }
        }
        function t(Mt) {
          return Mt.length === 0 ? null : Mt[0];
        }
        function r(Mt) {
          if (Mt.length === 0) return null;
          var Pt = Mt[0],
            It = Mt.pop();
          if (It !== Pt) {
            Mt[0] = It;
            e: for (var Ot = 0, Xt = Mt.length, sn = Xt >>> 1; Ot < sn; ) {
              var Kt = 2 * (Ot + 1) - 1,
                tn = Mt[Kt],
                pn = Kt + 1,
                _n = Mt[pn];
              if (0 > s(tn, It))
                pn < Xt && 0 > s(_n, tn)
                  ? ((Mt[Ot] = _n), (Mt[pn] = It), (Ot = pn))
                  : ((Mt[Ot] = tn), (Mt[Kt] = It), (Ot = Kt));
              else if (pn < Xt && 0 > s(_n, It))
                (Mt[Ot] = _n), (Mt[pn] = It), (Ot = pn);
              else break e;
            }
          }
          return Pt;
        }
        function s(Mt, Pt) {
          var It = Mt.sortIndex - Pt.sortIndex;
          return It !== 0 ? It : Mt.id - Pt.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var o = performance;
          n.unstable_now = function () {
            return o.now();
          };
        } else {
          var a = Date,
            l = a.now();
          n.unstable_now = function () {
            return a.now() - l;
          };
        }
        var c = [],
          u = [],
          p = 1,
          N = null,
          P = 3,
          de = !1,
          me = !1,
          Ye = !1,
          nt = typeof setTimeout == "function" ? setTimeout : null,
          Be = typeof clearTimeout == "function" ? clearTimeout : null,
          ot = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function st(Mt) {
          for (var Pt = t(u); Pt !== null; ) {
            if (Pt.callback === null) r(u);
            else if (Pt.startTime <= Mt)
              r(u), (Pt.sortIndex = Pt.expirationTime), e(c, Pt);
            else break;
            Pt = t(u);
          }
        }
        function vt(Mt) {
          if (((Ye = !1), st(Mt), !me))
            if (t(c) !== null) (me = !0), Ft(xt);
            else {
              var Pt = t(u);
              Pt !== null && Bt(vt, Pt.startTime - Mt);
            }
        }
        function xt(Mt, Pt) {
          (me = !1), Ye && ((Ye = !1), Be(bt), (bt = -1)), (de = !0);
          var It = P;
          try {
            for (
              st(Pt), N = t(c);
              N !== null && (!(N.expirationTime > Pt) || (Mt && !kt()));

            ) {
              var Ot = N.callback;
              if (typeof Ot == "function") {
                (N.callback = null), (P = N.priorityLevel);
                var Xt = Ot(N.expirationTime <= Pt);
                (Pt = n.unstable_now()),
                  typeof Xt == "function"
                    ? (N.callback = Xt)
                    : N === t(c) && r(c),
                  st(Pt);
              } else r(c);
              N = t(c);
            }
            if (N !== null) var sn = !0;
            else {
              var Kt = t(u);
              Kt !== null && Bt(vt, Kt.startTime - Pt), (sn = !1);
            }
            return sn;
          } finally {
            (N = null), (P = It), (de = !1);
          }
        }
        var St = !1,
          wt = null,
          bt = -1,
          Tt = 5,
          Ct = -1;
        function kt() {
          return !(n.unstable_now() - Ct < Tt);
        }
        function Dt() {
          if (wt !== null) {
            var Mt = n.unstable_now();
            Ct = Mt;
            var Pt = !0;
            try {
              Pt = wt(!0, Mt);
            } finally {
              Pt ? Vt() : ((St = !1), (wt = null));
            }
          } else St = !1;
        }
        var Vt;
        if (typeof ot == "function")
          Vt = function () {
            ot(Dt);
          };
        else if (typeof MessageChannel < "u") {
          var Ht = new MessageChannel(),
            qt = Ht.port2;
          (Ht.port1.onmessage = Dt),
            (Vt = function () {
              qt.postMessage(null);
            });
        } else
          Vt = function () {
            nt(Dt, 0);
          };
        function Ft(Mt) {
          (wt = Mt), St || ((St = !0), Vt());
        }
        function Bt(Mt, Pt) {
          bt = nt(function () {
            Mt(n.unstable_now());
          }, Pt);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (Mt) {
            Mt.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            me || de || ((me = !0), Ft(xt));
          }),
          (n.unstable_forceFrameRate = function (Mt) {
            0 > Mt || 125 < Mt
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (Tt = 0 < Mt ? Math.floor(1e3 / Mt) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return P;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(c);
          }),
          (n.unstable_next = function (Mt) {
            switch (P) {
              case 1:
              case 2:
              case 3:
                var Pt = 3;
                break;
              default:
                Pt = P;
            }
            var It = P;
            P = Pt;
            try {
              return Mt();
            } finally {
              P = It;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (Mt, Pt) {
            switch (Mt) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                Mt = 3;
            }
            var It = P;
            P = Mt;
            try {
              return Pt();
            } finally {
              P = It;
            }
          }),
          (n.unstable_scheduleCallback = function (Mt, Pt, It) {
            var Ot = n.unstable_now();
            switch (
              (typeof It == "object" && It !== null
                ? ((It = It.delay),
                  (It = typeof It == "number" && 0 < It ? Ot + It : Ot))
                : (It = Ot),
              Mt)
            ) {
              case 1:
                var Xt = -1;
                break;
              case 2:
                Xt = 250;
                break;
              case 5:
                Xt = 1073741823;
                break;
              case 4:
                Xt = 1e4;
                break;
              default:
                Xt = 5e3;
            }
            return (
              (Xt = It + Xt),
              (Mt = {
                id: p++,
                callback: Pt,
                priorityLevel: Mt,
                startTime: It,
                expirationTime: Xt,
                sortIndex: -1,
              }),
              It > Ot
                ? ((Mt.sortIndex = It),
                  e(u, Mt),
                  t(c) === null &&
                    Mt === t(u) &&
                    (Ye ? (Be(bt), (bt = -1)) : (Ye = !0), Bt(vt, It - Ot)))
                : ((Mt.sortIndex = Xt),
                  e(c, Mt),
                  me || de || ((me = !0), Ft(xt))),
              Mt
            );
          }),
          (n.unstable_shouldYield = kt),
          (n.unstable_wrapCallback = function (Mt) {
            var Pt = P;
            return function () {
              var It = P;
              P = Pt;
              try {
                return Mt.apply(this, arguments);
              } finally {
                P = It;
              }
            };
          });
      })(scheduler_production_min)),
    scheduler_production_min
  );
}
var hasRequiredScheduler;
function requireScheduler() {
  return (
    hasRequiredScheduler ||
      ((hasRequiredScheduler = 1),
      (scheduler.exports = requireScheduler_production_min())),
    scheduler.exports
  );
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var reactReconciler_production_min,
  hasRequiredReactReconciler_production_min;
function requireReactReconciler_production_min() {
  return (
    hasRequiredReactReconciler_production_min ||
      ((hasRequiredReactReconciler_production_min = 1),
      (reactReconciler_production_min = function (e) {
        var t = {},
          r = requireReact(),
          s = requireScheduler(),
          o = Object.assign;
        function a(Le) {
          for (
            var tt =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + Le,
              _t = 1;
            _t < arguments.length;
            _t++
          )
            tt += "&args[]=" + encodeURIComponent(arguments[_t]);
          return (
            "Minified React error #" +
            Le +
            "; visit " +
            tt +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var l = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          c = Symbol.for("react.element"),
          u = Symbol.for("react.portal"),
          p = Symbol.for("react.fragment"),
          N = Symbol.for("react.strict_mode"),
          P = Symbol.for("react.profiler"),
          de = Symbol.for("react.provider"),
          me = Symbol.for("react.context"),
          Ye = Symbol.for("react.forward_ref"),
          nt = Symbol.for("react.suspense"),
          Be = Symbol.for("react.suspense_list"),
          ot = Symbol.for("react.memo"),
          st = Symbol.for("react.lazy"),
          vt = Symbol.for("react.offscreen"),
          xt = Symbol.iterator;
        function St(Le) {
          return Le === null || typeof Le != "object"
            ? null
            : ((Le = (xt && Le[xt]) || Le["@@iterator"]),
              typeof Le == "function" ? Le : null);
        }
        function wt(Le) {
          if (Le == null) return null;
          if (typeof Le == "function") return Le.displayName || Le.name || null;
          if (typeof Le == "string") return Le;
          switch (Le) {
            case p:
              return "Fragment";
            case u:
              return "Portal";
            case P:
              return "Profiler";
            case N:
              return "StrictMode";
            case nt:
              return "Suspense";
            case Be:
              return "SuspenseList";
          }
          if (typeof Le == "object")
            switch (Le.$$typeof) {
              case me:
                return (Le.displayName || "Context") + ".Consumer";
              case de:
                return (Le._context.displayName || "Context") + ".Provider";
              case Ye:
                var tt = Le.render;
                return (
                  (Le = Le.displayName),
                  Le ||
                    ((Le = tt.displayName || tt.name || ""),
                    (Le = Le !== "" ? "ForwardRef(" + Le + ")" : "ForwardRef")),
                  Le
                );
              case ot:
                return (
                  (tt = Le.displayName || null),
                  tt !== null ? tt : wt(Le.type) || "Memo"
                );
              case st:
                (tt = Le._payload), (Le = Le._init);
                try {
                  return wt(Le(tt));
                } catch {}
            }
          return null;
        }
        function bt(Le) {
          var tt = Le.type;
          switch (Le.tag) {
            case 24:
              return "Cache";
            case 9:
              return (tt.displayName || "Context") + ".Consumer";
            case 10:
              return (tt._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (Le = tt.render),
                (Le = Le.displayName || Le.name || ""),
                tt.displayName ||
                  (Le !== "" ? "ForwardRef(" + Le + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return tt;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return wt(tt);
            case 8:
              return tt === N ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof tt == "function")
                return tt.displayName || tt.name || null;
              if (typeof tt == "string") return tt;
          }
          return null;
        }
        function Tt(Le) {
          var tt = Le,
            _t = Le;
          if (Le.alternate) for (; tt.return; ) tt = tt.return;
          else {
            Le = tt;
            do
              (tt = Le),
                (tt.flags & 4098) !== 0 && (_t = tt.return),
                (Le = tt.return);
            while (Le);
          }
          return tt.tag === 3 ? _t : null;
        }
        function Ct(Le) {
          if (Tt(Le) !== Le) throw Error(a(188));
        }
        function kt(Le) {
          var tt = Le.alternate;
          if (!tt) {
            if (((tt = Tt(Le)), tt === null)) throw Error(a(188));
            return tt !== Le ? null : Le;
          }
          for (var _t = Le, Et = tt; ; ) {
            var Rt = _t.return;
            if (Rt === null) break;
            var Nt = Rt.alternate;
            if (Nt === null) {
              if (((Et = Rt.return), Et !== null)) {
                _t = Et;
                continue;
              }
              break;
            }
            if (Rt.child === Nt.child) {
              for (Nt = Rt.child; Nt; ) {
                if (Nt === _t) return Ct(Rt), Le;
                if (Nt === Et) return Ct(Rt), tt;
                Nt = Nt.sibling;
              }
              throw Error(a(188));
            }
            if (_t.return !== Et.return) (_t = Rt), (Et = Nt);
            else {
              for (var Jt = !1, vn = Rt.child; vn; ) {
                if (vn === _t) {
                  (Jt = !0), (_t = Rt), (Et = Nt);
                  break;
                }
                if (vn === Et) {
                  (Jt = !0), (Et = Rt), (_t = Nt);
                  break;
                }
                vn = vn.sibling;
              }
              if (!Jt) {
                for (vn = Nt.child; vn; ) {
                  if (vn === _t) {
                    (Jt = !0), (_t = Nt), (Et = Rt);
                    break;
                  }
                  if (vn === Et) {
                    (Jt = !0), (Et = Nt), (_t = Rt);
                    break;
                  }
                  vn = vn.sibling;
                }
                if (!Jt) throw Error(a(189));
              }
            }
            if (_t.alternate !== Et) throw Error(a(190));
          }
          if (_t.tag !== 3) throw Error(a(188));
          return _t.stateNode.current === _t ? Le : tt;
        }
        function Dt(Le) {
          return (Le = kt(Le)), Le !== null ? Vt(Le) : null;
        }
        function Vt(Le) {
          if (Le.tag === 5 || Le.tag === 6) return Le;
          for (Le = Le.child; Le !== null; ) {
            var tt = Vt(Le);
            if (tt !== null) return tt;
            Le = Le.sibling;
          }
          return null;
        }
        function Ht(Le) {
          if (Le.tag === 5 || Le.tag === 6) return Le;
          for (Le = Le.child; Le !== null; ) {
            if (Le.tag !== 4) {
              var tt = Ht(Le);
              if (tt !== null) return tt;
            }
            Le = Le.sibling;
          }
          return null;
        }
        var qt = Array.isArray,
          Ft = e.getPublicInstance,
          Bt = e.getRootHostContext,
          Mt = e.getChildHostContext,
          Pt = e.prepareForCommit,
          It = e.resetAfterCommit,
          Ot = e.createInstance,
          Xt = e.appendInitialChild,
          sn = e.finalizeInitialChildren,
          Kt = e.prepareUpdate,
          tn = e.shouldSetTextContent,
          pn = e.createTextInstance,
          _n = e.scheduleTimeout,
          bn = e.cancelTimeout,
          $n = e.noTimeout,
          tr = e.isPrimaryRenderer,
          ur = e.supportsMutation,
          _r = e.supportsPersistence,
          Bn = e.supportsHydration,
          jt = e.getInstanceFromNode,
          Yn = e.preparePortalMount,
          zn = e.getCurrentEventPriority,
          rn = e.detachDeletedInstance,
          In = e.supportsMicrotasks,
          or = e.scheduleMicrotask,
          Gn = e.supportsTestSelectors,
          Yt = e.findFiberRoot,
          Gt = e.getBoundingRect,
          hn = e.getTextContent,
          En = e.isHiddenSubtree,
          Ln = e.matchAccessibilityRole,
          mn = e.setFocusIfFocusable,
          Vn = e.setupIntersectionObserver,
          Fn = e.appendChild,
          nr = e.appendChildToContainer,
          yr = e.commitTextUpdate,
          qn = e.commitMount,
          jn = e.commitUpdate,
          Jn = e.insertBefore,
          mr = e.insertInContainerBefore,
          Sr = e.removeChild,
          Ur = e.removeChildFromContainer,
          Pr = e.resetTextContent,
          Hr = e.hideInstance,
          cn = e.hideTextInstance,
          An = e.unhideInstance,
          Mn = e.unhideTextInstance,
          Hn = e.clearContainer,
          hr = e.cloneInstance,
          pr = e.createContainerChildSet,
          jr = e.appendChildToContainerChildSet,
          fi = e.finalizeContainerChildren,
          wi = e.replaceContainerChildren,
          wr = e.cloneHiddenInstance,
          Rr = e.cloneHiddenTextInstance,
          $r = e.canHydrateInstance,
          xr = e.canHydrateTextInstance,
          Fr = e.canHydrateSuspenseInstance,
          Cr = e.isSuspenseInstancePending,
          zr = e.isSuspenseInstanceFallback,
          pi = e.registerSuspenseInstanceRetry,
          qr = e.getNextHydratableSibling,
          Ir = e.getFirstHydratableChild,
          Pi = e.getFirstHydratableChildWithinContainer,
          mi = e.getFirstHydratableChildWithinSuspenseInstance,
          Ut = e.hydrateInstance,
          $t = e.hydrateTextInstance,
          un = e.hydrateSuspenseInstance,
          yn = e.getNextHydratableInstanceAfterSuspenseInstance,
          Rn = e.commitHydratedContainer,
          kn = e.commitHydratedSuspenseInstance,
          er = e.clearSuspenseBoundary,
          Xn = e.clearSuspenseBoundaryFromContainer,
          zt = e.shouldDeleteUnhydratedTailInstances,
          Zt = e.didNotMatchHydratedContainerTextInstance,
          an = e.didNotMatchHydratedTextInstance,
          Qt;
        function fn(Le) {
          if (Qt === void 0)
            try {
              throw Error();
            } catch (_t) {
              var tt = _t.stack.trim().match(/\n( *(at )?)/);
              Qt = (tt && tt[1]) || "";
            }
          return (
            `
` +
            Qt +
            Le
          );
        }
        var wn = !1;
        function On(Le, tt) {
          if (!Le || wn) return "";
          wn = !0;
          var _t = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (tt)
              if (
                ((tt = function () {
                  throw Error();
                }),
                Object.defineProperty(tt.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(tt, []);
                } catch (dr) {
                  var Et = dr;
                }
                Reflect.construct(Le, [], tt);
              } else {
                try {
                  tt.call();
                } catch (dr) {
                  Et = dr;
                }
                Le.call(tt.prototype);
              }
            else {
              try {
                throw Error();
              } catch (dr) {
                Et = dr;
              }
              Le();
            }
          } catch (dr) {
            if (dr && Et && typeof dr.stack == "string") {
              for (
                var Rt = dr.stack.split(`
`),
                  Nt = Et.stack.split(`
`),
                  Jt = Rt.length - 1,
                  vn = Nt.length - 1;
                1 <= Jt && 0 <= vn && Rt[Jt] !== Nt[vn];

              )
                vn--;
              for (; 1 <= Jt && 0 <= vn; Jt--, vn--)
                if (Rt[Jt] !== Nt[vn]) {
                  if (Jt !== 1 || vn !== 1)
                    do
                      if ((Jt--, vn--, 0 > vn || Rt[Jt] !== Nt[vn])) {
                        var Wn =
                          `
` + Rt[Jt].replace(" at new ", " at ");
                        return (
                          Le.displayName &&
                            Wn.includes("<anonymous>") &&
                            (Wn = Wn.replace("<anonymous>", Le.displayName)),
                          Wn
                        );
                      }
                    while (1 <= Jt && 0 <= vn);
                  break;
                }
            }
          } finally {
            (wn = !1), (Error.prepareStackTrace = _t);
          }
          return (Le = Le ? Le.displayName || Le.name : "") ? fn(Le) : "";
        }
        var Kn = Object.prototype.hasOwnProperty,
          Zn = [],
          ar = -1;
        function cr(Le) {
          return { current: Le };
        }
        function Qn(Le) {
          0 > ar || ((Le.current = Zn[ar]), (Zn[ar] = null), ar--);
        }
        function gr(Le, tt) {
          ar++, (Zn[ar] = Le.current), (Le.current = tt);
        }
        var Tr = {},
          Qr = cr(Tr),
          Dr = cr(!1),
          Br = Tr;
        function Mr(Le, tt) {
          var _t = Le.type.contextTypes;
          if (!_t) return Tr;
          var Et = Le.stateNode;
          if (Et && Et.__reactInternalMemoizedUnmaskedChildContext === tt)
            return Et.__reactInternalMemoizedMaskedChildContext;
          var Rt = {},
            Nt;
          for (Nt in _t) Rt[Nt] = tt[Nt];
          return (
            Et &&
              ((Le = Le.stateNode),
              (Le.__reactInternalMemoizedUnmaskedChildContext = tt),
              (Le.__reactInternalMemoizedMaskedChildContext = Rt)),
            Rt
          );
        }
        function oi(Le) {
          return (Le = Le.childContextTypes), Le != null;
        }
        function Xr() {
          Qn(Dr), Qn(Qr);
        }
        function ti(Le, tt, _t) {
          if (Qr.current !== Tr) throw Error(a(168));
          gr(Qr, tt), gr(Dr, _t);
        }
        function bi(Le, tt, _t) {
          var Et = Le.stateNode;
          if (
            ((tt = tt.childContextTypes),
            typeof Et.getChildContext != "function")
          )
            return _t;
          Et = Et.getChildContext();
          for (var Rt in Et)
            if (!(Rt in tt)) throw Error(a(108, bt(Le) || "Unknown", Rt));
          return o({}, _t, Et);
        }
        function ni(Le) {
          return (
            (Le =
              ((Le = Le.stateNode) &&
                Le.__reactInternalMemoizedMergedChildContext) ||
              Tr),
            (Br = Qr.current),
            gr(Qr, Le),
            gr(Dr, Dr.current),
            !0
          );
        }
        function ai(Le, tt, _t) {
          var Et = Le.stateNode;
          if (!Et) throw Error(a(169));
          _t
            ? ((Le = bi(Le, tt, Br)),
              (Et.__reactInternalMemoizedMergedChildContext = Le),
              Qn(Dr),
              Qn(Qr),
              gr(Qr, Le))
            : Qn(Dr),
            gr(Dr, _t);
        }
        var Kr = Math.clz32 ? Math.clz32 : Mi,
          Ii = Math.log,
          gi = Math.LN2;
        function Mi(Le) {
          return (Le >>>= 0), Le === 0 ? 32 : (31 - ((Ii(Le) / gi) | 0)) | 0;
        }
        var Ui = 64,
          di = 4194304;
        function ps(Le) {
          switch (Le & -Le) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return Le & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return Le & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return Le;
          }
        }
        function la(Le, tt) {
          var _t = Le.pendingLanes;
          if (_t === 0) return 0;
          var Et = 0,
            Rt = Le.suspendedLanes,
            Nt = Le.pingedLanes,
            Jt = _t & 268435455;
          if (Jt !== 0) {
            var vn = Jt & ~Rt;
            vn !== 0 ? (Et = ps(vn)) : ((Nt &= Jt), Nt !== 0 && (Et = ps(Nt)));
          } else
            (Jt = _t & ~Rt),
              Jt !== 0 ? (Et = ps(Jt)) : Nt !== 0 && (Et = ps(Nt));
          if (Et === 0) return 0;
          if (
            tt !== 0 &&
            tt !== Et &&
            (tt & Rt) === 0 &&
            ((Rt = Et & -Et),
            (Nt = tt & -tt),
            Rt >= Nt || (Rt === 16 && (Nt & 4194240) !== 0))
          )
            return tt;
          if (
            ((Et & 4) !== 0 && (Et |= _t & 16),
            (tt = Le.entangledLanes),
            tt !== 0)
          )
            for (Le = Le.entanglements, tt &= Et; 0 < tt; )
              (_t = 31 - Kr(tt)), (Rt = 1 << _t), (Et |= Le[_t]), (tt &= ~Rt);
          return Et;
        }
        function El(Le, tt) {
          switch (Le) {
            case 1:
            case 2:
            case 4:
              return tt + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return tt + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function oc(Le, tt) {
          for (
            var _t = Le.suspendedLanes,
              Et = Le.pingedLanes,
              Rt = Le.expirationTimes,
              Nt = Le.pendingLanes;
            0 < Nt;

          ) {
            var Jt = 31 - Kr(Nt),
              vn = 1 << Jt,
              Wn = Rt[Jt];
            Wn === -1
              ? ((vn & _t) === 0 || (vn & Et) !== 0) && (Rt[Jt] = El(vn, tt))
              : Wn <= tt && (Le.expiredLanes |= vn),
              (Nt &= ~vn);
          }
        }
        function za(Le) {
          return (
            (Le = Le.pendingLanes & -1073741825),
            Le !== 0 ? Le : Le & 1073741824 ? 1073741824 : 0
          );
        }
        function Va(Le) {
          for (var tt = [], _t = 0; 31 > _t; _t++) tt.push(Le);
          return tt;
        }
        function Eo(Le, tt, _t) {
          (Le.pendingLanes |= tt),
            tt !== 536870912 && ((Le.suspendedLanes = 0), (Le.pingedLanes = 0)),
            (Le = Le.eventTimes),
            (tt = 31 - Kr(tt)),
            (Le[tt] = _t);
        }
        function Ga(Le, tt) {
          var _t = Le.pendingLanes & ~tt;
          (Le.pendingLanes = tt),
            (Le.suspendedLanes = 0),
            (Le.pingedLanes = 0),
            (Le.expiredLanes &= tt),
            (Le.mutableReadLanes &= tt),
            (Le.entangledLanes &= tt),
            (tt = Le.entanglements);
          var Et = Le.eventTimes;
          for (Le = Le.expirationTimes; 0 < _t; ) {
            var Rt = 31 - Kr(_t),
              Nt = 1 << Rt;
            (tt[Rt] = 0), (Et[Rt] = -1), (Le[Rt] = -1), (_t &= ~Nt);
          }
        }
        function qs(Le, tt) {
          var _t = (Le.entangledLanes |= tt);
          for (Le = Le.entanglements; _t; ) {
            var Et = 31 - Kr(_t),
              Rt = 1 << Et;
            (Rt & tt) | (Le[Et] & tt) && (Le[Et] |= tt), (_t &= ~Rt);
          }
        }
        var ci = 0;
        function ro(Le) {
          return (
            (Le &= -Le),
            1 < Le
              ? 4 < Le
                ? (Le & 268435455) !== 0
                  ? 16
                  : 536870912
                : 4
              : 1
          );
        }
        var To = s.unstable_scheduleCallback,
          Xo = s.unstable_cancelCallback,
          po = s.unstable_shouldYield,
          Zc = s.unstable_requestPaint,
          ji = s.unstable_now,
          bo = s.unstable_ImmediatePriority,
          ac = s.unstable_UserBlockingPriority,
          Ha = s.unstable_NormalPriority,
          Sn = s.unstable_IdlePriority,
          en = null,
          ln = null;
        function Un(Le) {
          if (ln && typeof ln.onCommitFiberRoot == "function")
            try {
              ln.onCommitFiberRoot(
                en,
                Le,
                void 0,
                (Le.current.flags & 128) === 128
              );
            } catch {}
        }
        function rr(Le, tt) {
          return (
            (Le === tt && (Le !== 0 || 1 / Le === 1 / tt)) ||
            (Le !== Le && tt !== tt)
          );
        }
        var Yr = typeof Object.is == "function" ? Object.is : rr,
          yi = null,
          Zi = !1,
          Yo = !1;
        function Wa(Le) {
          yi === null ? (yi = [Le]) : yi.push(Le);
        }
        function ja(Le) {
          (Zi = !0), Wa(Le);
        }
        function xs() {
          if (!Yo && yi !== null) {
            Yo = !0;
            var Le = 0,
              tt = ci;
            try {
              var _t = yi;
              for (ci = 1; Le < _t.length; Le++) {
                var Et = _t[Le];
                do Et = Et(!0);
                while (Et !== null);
              }
              (yi = null), (Zi = !1);
            } catch (Rt) {
              throw (yi !== null && (yi = yi.slice(Le + 1)), To(bo, xs), Rt);
            } finally {
              (ci = tt), (Yo = !1);
            }
          }
          return null;
        }
        var Tl = l.ReactCurrentBatchConfig;
        function Ps(Le, tt) {
          if (Yr(Le, tt)) return !0;
          if (
            typeof Le != "object" ||
            Le === null ||
            typeof tt != "object" ||
            tt === null
          )
            return !1;
          var _t = Object.keys(Le),
            Et = Object.keys(tt);
          if (_t.length !== Et.length) return !1;
          for (Et = 0; Et < _t.length; Et++) {
            var Rt = _t[Et];
            if (!Kn.call(tt, Rt) || !Yr(Le[Rt], tt[Rt])) return !1;
          }
          return !0;
        }
        function $a(Le) {
          switch (Le.tag) {
            case 5:
              return fn(Le.type);
            case 16:
              return fn("Lazy");
            case 13:
              return fn("Suspense");
            case 19:
              return fn("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (Le = On(Le.type, !1)), Le;
            case 11:
              return (Le = On(Le.type.render, !1)), Le;
            case 1:
              return (Le = On(Le.type, !0)), Le;
            default:
              return "";
          }
        }
        function Rs(Le, tt) {
          if (Le && Le.defaultProps) {
            (tt = o({}, tt)), (Le = Le.defaultProps);
            for (var _t in Le) tt[_t] === void 0 && (tt[_t] = Le[_t]);
            return tt;
          }
          return tt;
        }
        var bl = cr(null),
          ca = null,
          Mo = null,
          lc = null;
        function Ss() {
          lc = Mo = ca = null;
        }
        function ua(Le, tt, _t) {
          tr
            ? (gr(bl, tt._currentValue), (tt._currentValue = _t))
            : (gr(bl, tt._currentValue2), (tt._currentValue2 = _t));
        }
        function Ml(Le) {
          var tt = bl.current;
          Qn(bl), tr ? (Le._currentValue = tt) : (Le._currentValue2 = tt);
        }
        function fa(Le, tt, _t) {
          for (; Le !== null; ) {
            var Et = Le.alternate;
            if (
              ((Le.childLanes & tt) !== tt
                ? ((Le.childLanes |= tt), Et !== null && (Et.childLanes |= tt))
                : Et !== null &&
                  (Et.childLanes & tt) !== tt &&
                  (Et.childLanes |= tt),
              Le === _t)
            )
              break;
            Le = Le.return;
          }
        }
        function qa(Le, tt) {
          (ca = Le),
            (lc = Mo = null),
            (Le = Le.dependencies),
            Le !== null &&
              Le.firstContext !== null &&
              ((Le.lanes & tt) !== 0 && (rs = !0), (Le.firstContext = null));
        }
        function Is(Le) {
          var tt = tr ? Le._currentValue : Le._currentValue2;
          if (lc !== Le)
            if (
              ((Le = { context: Le, memoizedValue: tt, next: null }),
              Mo === null)
            ) {
              if (ca === null) throw Error(a(308));
              (Mo = Le), (ca.dependencies = { lanes: 0, firstContext: Le });
            } else Mo = Mo.next = Le;
          return tt;
        }
        var Xs = null,
          Ys = !1;
        function Xa(Le) {
          Le.updateQueue = {
            baseState: Le.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function Qc(Le, tt) {
          (Le = Le.updateQueue),
            tt.updateQueue === Le &&
              (tt.updateQueue = {
                baseState: Le.baseState,
                firstBaseUpdate: Le.firstBaseUpdate,
                lastBaseUpdate: Le.lastBaseUpdate,
                shared: Le.shared,
                effects: Le.effects,
              });
        }
        function Co(Le, tt) {
          return {
            eventTime: Le,
            lane: tt,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function Ko(Le, tt) {
          var _t = Le.updateQueue;
          _t !== null &&
            ((_t = _t.shared),
            qi !== null && (Le.mode & 1) !== 0 && (ui & 2) === 0
              ? ((Le = _t.interleaved),
                Le === null
                  ? ((tt.next = tt), Xs === null ? (Xs = [_t]) : Xs.push(_t))
                  : ((tt.next = Le.next), (Le.next = tt)),
                (_t.interleaved = tt))
              : ((Le = _t.pending),
                Le === null
                  ? (tt.next = tt)
                  : ((tt.next = Le.next), (Le.next = tt)),
                (_t.pending = tt)));
        }
        function cc(Le, tt, _t) {
          if (
            ((tt = tt.updateQueue),
            tt !== null && ((tt = tt.shared), (_t & 4194240) !== 0))
          ) {
            var Et = tt.lanes;
            (Et &= Le.pendingLanes), (_t |= Et), (tt.lanes = _t), qs(Le, _t);
          }
        }
        function uc(Le, tt) {
          var _t = Le.updateQueue,
            Et = Le.alternate;
          if (Et !== null && ((Et = Et.updateQueue), _t === Et)) {
            var Rt = null,
              Nt = null;
            if (((_t = _t.firstBaseUpdate), _t !== null)) {
              do {
                var Jt = {
                  eventTime: _t.eventTime,
                  lane: _t.lane,
                  tag: _t.tag,
                  payload: _t.payload,
                  callback: _t.callback,
                  next: null,
                };
                Nt === null ? (Rt = Nt = Jt) : (Nt = Nt.next = Jt),
                  (_t = _t.next);
              } while (_t !== null);
              Nt === null ? (Rt = Nt = tt) : (Nt = Nt.next = tt);
            } else Rt = Nt = tt;
            (_t = {
              baseState: Et.baseState,
              firstBaseUpdate: Rt,
              lastBaseUpdate: Nt,
              shared: Et.shared,
              effects: Et.effects,
            }),
              (Le.updateQueue = _t);
            return;
          }
          (Le = _t.lastBaseUpdate),
            Le === null ? (_t.firstBaseUpdate = tt) : (Le.next = tt),
            (_t.lastBaseUpdate = tt);
        }
        function fc(Le, tt, _t, Et) {
          var Rt = Le.updateQueue;
          Ys = !1;
          var Nt = Rt.firstBaseUpdate,
            Jt = Rt.lastBaseUpdate,
            vn = Rt.shared.pending;
          if (vn !== null) {
            Rt.shared.pending = null;
            var Wn = vn,
              dr = Wn.next;
            (Wn.next = null),
              Jt === null ? (Nt = dr) : (Jt.next = dr),
              (Jt = Wn);
            var kr = Le.alternate;
            kr !== null &&
              ((kr = kr.updateQueue),
              (vn = kr.lastBaseUpdate),
              vn !== Jt &&
                (vn === null ? (kr.firstBaseUpdate = dr) : (vn.next = dr),
                (kr.lastBaseUpdate = Wn)));
          }
          if (Nt !== null) {
            var ii = Rt.baseState;
            (Jt = 0), (kr = dr = Wn = null), (vn = Nt);
            do {
              var Zr = vn.lane,
                hi = vn.eventTime;
              if ((Et & Zr) === Zr) {
                kr !== null &&
                  (kr = kr.next =
                    {
                      eventTime: hi,
                      lane: 0,
                      tag: vn.tag,
                      payload: vn.payload,
                      callback: vn.callback,
                      next: null,
                    });
                e: {
                  var Ar = Le,
                    hs = vn;
                  switch (((Zr = tt), (hi = _t), hs.tag)) {
                    case 1:
                      if (((Ar = hs.payload), typeof Ar == "function")) {
                        ii = Ar.call(hi, ii, Zr);
                        break e;
                      }
                      ii = Ar;
                      break e;
                    case 3:
                      Ar.flags = (Ar.flags & -65537) | 128;
                    case 0:
                      if (
                        ((Ar = hs.payload),
                        (Zr =
                          typeof Ar == "function" ? Ar.call(hi, ii, Zr) : Ar),
                        Zr == null)
                      )
                        break e;
                      ii = o({}, ii, Zr);
                      break e;
                    case 2:
                      Ys = !0;
                  }
                }
                vn.callback !== null &&
                  vn.lane !== 0 &&
                  ((Le.flags |= 64),
                  (Zr = Rt.effects),
                  Zr === null ? (Rt.effects = [vn]) : Zr.push(vn));
              } else
                (hi = {
                  eventTime: hi,
                  lane: Zr,
                  tag: vn.tag,
                  payload: vn.payload,
                  callback: vn.callback,
                  next: null,
                }),
                  kr === null
                    ? ((dr = kr = hi), (Wn = ii))
                    : (kr = kr.next = hi),
                  (Jt |= Zr);
              if (((vn = vn.next), vn === null)) {
                if (((vn = Rt.shared.pending), vn === null)) break;
                (Zr = vn),
                  (vn = Zr.next),
                  (Zr.next = null),
                  (Rt.lastBaseUpdate = Zr),
                  (Rt.shared.pending = null);
              }
            } while (!0);
            if (
              (kr === null && (Wn = ii),
              (Rt.baseState = Wn),
              (Rt.firstBaseUpdate = dr),
              (Rt.lastBaseUpdate = kr),
              (tt = Rt.shared.interleaved),
              tt !== null)
            ) {
              Rt = tt;
              do (Jt |= Rt.lane), (Rt = Rt.next);
              while (Rt !== tt);
            } else Nt === null && (Rt.shared.lanes = 0);
            (_o |= Jt), (Le.lanes = Jt), (Le.memoizedState = ii);
          }
        }
        function Hu(Le, tt, _t) {
          if (((Le = tt.effects), (tt.effects = null), Le !== null))
            for (tt = 0; tt < Le.length; tt++) {
              var Et = Le[tt],
                Rt = Et.callback;
              if (Rt !== null) {
                if (((Et.callback = null), (Et = _t), typeof Rt != "function"))
                  throw Error(a(191, Rt));
                Rt.call(Et);
              }
            }
        }
        var Wu = new r.Component().refs;
        function Jc(Le, tt, _t, Et) {
          (tt = Le.memoizedState),
            (_t = _t(Et, tt)),
            (_t = _t == null ? tt : o({}, tt, _t)),
            (Le.memoizedState = _t),
            Le.lanes === 0 && (Le.updateQueue.baseState = _t);
        }
        var hc = {
          isMounted: function (Le) {
            return (Le = Le._reactInternals) ? Tt(Le) === Le : !1;
          },
          enqueueSetState: function (Le, tt, _t) {
            Le = Le._reactInternals;
            var Et = Si(),
              Rt = uo(Le),
              Nt = Co(Et, Rt);
            (Nt.payload = tt),
              _t != null && (Nt.callback = _t),
              Ko(Le, Nt),
              (tt = vs(Le, Rt, Et)),
              tt !== null && cc(tt, Le, Rt);
          },
          enqueueReplaceState: function (Le, tt, _t) {
            Le = Le._reactInternals;
            var Et = Si(),
              Rt = uo(Le),
              Nt = Co(Et, Rt);
            (Nt.tag = 1),
              (Nt.payload = tt),
              _t != null && (Nt.callback = _t),
              Ko(Le, Nt),
              (tt = vs(Le, Rt, Et)),
              tt !== null && cc(tt, Le, Rt);
          },
          enqueueForceUpdate: function (Le, tt) {
            Le = Le._reactInternals;
            var _t = Si(),
              Et = uo(Le),
              Rt = Co(_t, Et);
            (Rt.tag = 2),
              tt != null && (Rt.callback = tt),
              Ko(Le, Rt),
              (tt = vs(Le, Et, _t)),
              tt !== null && cc(tt, Le, Et);
          },
        };
        function eu(Le, tt, _t, Et, Rt, Nt, Jt) {
          return (
            (Le = Le.stateNode),
            typeof Le.shouldComponentUpdate == "function"
              ? Le.shouldComponentUpdate(Et, Nt, Jt)
              : tt.prototype && tt.prototype.isPureReactComponent
              ? !Ps(_t, Et) || !Ps(Rt, Nt)
              : !0
          );
        }
        function ju(Le, tt, _t) {
          var Et = !1,
            Rt = Tr,
            Nt = tt.contextType;
          return (
            typeof Nt == "object" && Nt !== null
              ? (Nt = Is(Nt))
              : ((Rt = oi(tt) ? Br : Qr.current),
                (Et = tt.contextTypes),
                (Nt = (Et = Et != null) ? Mr(Le, Rt) : Tr)),
            (tt = new tt(_t, Nt)),
            (Le.memoizedState =
              tt.state !== null && tt.state !== void 0 ? tt.state : null),
            (tt.updater = hc),
            (Le.stateNode = tt),
            (tt._reactInternals = Le),
            Et &&
              ((Le = Le.stateNode),
              (Le.__reactInternalMemoizedUnmaskedChildContext = Rt),
              (Le.__reactInternalMemoizedMaskedChildContext = Nt)),
            tt
          );
        }
        function $u(Le, tt, _t, Et) {
          (Le = tt.state),
            typeof tt.componentWillReceiveProps == "function" &&
              tt.componentWillReceiveProps(_t, Et),
            typeof tt.UNSAFE_componentWillReceiveProps == "function" &&
              tt.UNSAFE_componentWillReceiveProps(_t, Et),
            tt.state !== Le && hc.enqueueReplaceState(tt, tt.state, null);
        }
        function tu(Le, tt, _t, Et) {
          var Rt = Le.stateNode;
          (Rt.props = _t),
            (Rt.state = Le.memoizedState),
            (Rt.refs = Wu),
            Xa(Le);
          var Nt = tt.contextType;
          typeof Nt == "object" && Nt !== null
            ? (Rt.context = Is(Nt))
            : ((Nt = oi(tt) ? Br : Qr.current), (Rt.context = Mr(Le, Nt))),
            (Rt.state = Le.memoizedState),
            (Nt = tt.getDerivedStateFromProps),
            typeof Nt == "function" &&
              (Jc(Le, tt, Nt, _t), (Rt.state = Le.memoizedState)),
            typeof tt.getDerivedStateFromProps == "function" ||
              typeof Rt.getSnapshotBeforeUpdate == "function" ||
              (typeof Rt.UNSAFE_componentWillMount != "function" &&
                typeof Rt.componentWillMount != "function") ||
              ((tt = Rt.state),
              typeof Rt.componentWillMount == "function" &&
                Rt.componentWillMount(),
              typeof Rt.UNSAFE_componentWillMount == "function" &&
                Rt.UNSAFE_componentWillMount(),
              tt !== Rt.state && hc.enqueueReplaceState(Rt, Rt.state, null),
              fc(Le, _t, Rt, Et),
              (Rt.state = Le.memoizedState)),
            typeof Rt.componentDidMount == "function" && (Le.flags |= 4194308);
        }
        var Ya = [],
          Zo = 0,
          dc = null,
          pc = 0,
          Ks = [],
          Ns = 0,
          ha = null,
          Ao = 1,
          Po = "";
        function da(Le, tt) {
          (Ya[Zo++] = pc), (Ya[Zo++] = dc), (dc = Le), (pc = tt);
        }
        function qu(Le, tt, _t) {
          (Ks[Ns++] = Ao), (Ks[Ns++] = Po), (Ks[Ns++] = ha), (ha = Le);
          var Et = Ao;
          Le = Po;
          var Rt = 32 - Kr(Et) - 1;
          (Et &= ~(1 << Rt)), (_t += 1);
          var Nt = 32 - Kr(tt) + Rt;
          if (30 < Nt) {
            var Jt = Rt - (Rt % 5);
            (Nt = (Et & ((1 << Jt) - 1)).toString(32)),
              (Et >>= Jt),
              (Rt -= Jt),
              (Ao = (1 << (32 - Kr(tt) + Rt)) | (_t << Rt) | Et),
              (Po = Nt + Le);
          } else (Ao = (1 << Nt) | (_t << Rt) | Et), (Po = Le);
        }
        function nu(Le) {
          Le.return !== null && (da(Le, 1), qu(Le, 1, 0));
        }
        function ru(Le) {
          for (; Le === dc; )
            (dc = Ya[--Zo]), (Ya[Zo] = null), (pc = Ya[--Zo]), (Ya[Zo] = null);
          for (; Le === ha; )
            (ha = Ks[--Ns]),
              (Ks[Ns] = null),
              (Po = Ks[--Ns]),
              (Ks[Ns] = null),
              (Ao = Ks[--Ns]),
              (Ks[Ns] = null);
        }
        var ws = null,
          as = null,
          Ni = !1,
          Ka = !1,
          Zs = null;
        function iu(Le, tt) {
          var _t = Ws(5, null, null, 0);
          (_t.elementType = "DELETED"),
            (_t.stateNode = tt),
            (_t.return = Le),
            (tt = Le.deletions),
            tt === null
              ? ((Le.deletions = [_t]), (Le.flags |= 16))
              : tt.push(_t);
        }
        function su(Le, tt) {
          switch (Le.tag) {
            case 5:
              return (
                (tt = $r(tt, Le.type, Le.pendingProps)),
                tt !== null
                  ? ((Le.stateNode = tt), (ws = Le), (as = Ir(tt)), !0)
                  : !1
              );
            case 6:
              return (
                (tt = xr(tt, Le.pendingProps)),
                tt !== null
                  ? ((Le.stateNode = tt), (ws = Le), (as = null), !0)
                  : !1
              );
            case 13:
              if (((tt = Fr(tt)), tt !== null)) {
                var _t = ha !== null ? { id: Ao, overflow: Po } : null;
                return (
                  (Le.memoizedState = {
                    dehydrated: tt,
                    treeContext: _t,
                    retryLane: 1073741824,
                  }),
                  (_t = Ws(18, null, null, 0)),
                  (_t.stateNode = tt),
                  (_t.return = Le),
                  (Le.child = _t),
                  (ws = Le),
                  (as = null),
                  !0
                );
              }
              return !1;
            default:
              return !1;
          }
        }
        function mc(Le) {
          return (Le.mode & 1) !== 0 && (Le.flags & 128) === 0;
        }
        function Qo(Le) {
          if (Ni) {
            var tt = as;
            if (tt) {
              var _t = tt;
              if (!su(Le, tt)) {
                if (mc(Le)) throw Error(a(418));
                tt = qr(_t);
                var Et = ws;
                tt && su(Le, tt)
                  ? iu(Et, _t)
                  : ((Le.flags = (Le.flags & -4097) | 2), (Ni = !1), (ws = Le));
              }
            } else {
              if (mc(Le)) throw Error(a(418));
              (Le.flags = (Le.flags & -4097) | 2), (Ni = !1), (ws = Le);
            }
          }
        }
        function Xu(Le) {
          for (
            Le = Le.return;
            Le !== null && Le.tag !== 5 && Le.tag !== 3 && Le.tag !== 13;

          )
            Le = Le.return;
          ws = Le;
        }
        function Cl(Le) {
          if (!Bn || Le !== ws) return !1;
          if (!Ni) return Xu(Le), (Ni = !0), !1;
          if (
            Le.tag !== 3 &&
            (Le.tag !== 5 || (zt(Le.type) && !tn(Le.type, Le.memoizedProps)))
          ) {
            var tt = as;
            if (tt) {
              if (mc(Le)) {
                for (Le = as; Le; ) Le = qr(Le);
                throw Error(a(418));
              }
              for (; tt; ) iu(Le, tt), (tt = qr(tt));
            }
          }
          if ((Xu(Le), Le.tag === 13)) {
            if (!Bn) throw Error(a(316));
            if (
              ((Le = Le.memoizedState),
              (Le = Le !== null ? Le.dehydrated : null),
              !Le)
            )
              throw Error(a(317));
            as = yn(Le);
          } else as = ws ? qr(Le.stateNode) : null;
          return !0;
        }
        function Za() {
          Bn && ((as = ws = null), (Ka = Ni = !1));
        }
        function gc(Le) {
          Zs === null ? (Zs = [Le]) : Zs.push(Le);
        }
        function Qa(Le, tt, _t) {
          if (
            ((Le = _t.ref),
            Le !== null && typeof Le != "function" && typeof Le != "object")
          ) {
            if (_t._owner) {
              if (((_t = _t._owner), _t)) {
                if (_t.tag !== 1) throw Error(a(309));
                var Et = _t.stateNode;
              }
              if (!Et) throw Error(a(147, Le));
              var Rt = Et,
                Nt = "" + Le;
              return tt !== null &&
                tt.ref !== null &&
                typeof tt.ref == "function" &&
                tt.ref._stringRef === Nt
                ? tt.ref
                : ((tt = function (Jt) {
                    var vn = Rt.refs;
                    vn === Wu && (vn = Rt.refs = {}),
                      Jt === null ? delete vn[Nt] : (vn[Nt] = Jt);
                  }),
                  (tt._stringRef = Nt),
                  tt);
            }
            if (typeof Le != "string") throw Error(a(284));
            if (!_t._owner) throw Error(a(290, Le));
          }
          return Le;
        }
        function Jo(Le, tt) {
          throw (
            ((Le = Object.prototype.toString.call(tt)),
            Error(
              a(
                31,
                Le === "[object Object]"
                  ? "object with keys {" + Object.keys(tt).join(", ") + "}"
                  : Le
              )
            ))
          );
        }
        function Ja(Le) {
          var tt = Le._init;
          return tt(Le._payload);
        }
        function Yu(Le) {
          function tt(Pn, xn) {
            if (Le) {
              var Nn = Pn.deletions;
              Nn === null
                ? ((Pn.deletions = [xn]), (Pn.flags |= 16))
                : Nn.push(xn);
            }
          }
          function _t(Pn, xn) {
            if (!Le) return null;
            for (; xn !== null; ) tt(Pn, xn), (xn = xn.sibling);
            return null;
          }
          function Et(Pn, xn) {
            for (Pn = new Map(); xn !== null; )
              xn.key !== null ? Pn.set(xn.key, xn) : Pn.set(xn.index, xn),
                (xn = xn.sibling);
            return Pn;
          }
          function Rt(Pn, xn) {
            return (Pn = Ho(Pn, xn)), (Pn.index = 0), (Pn.sibling = null), Pn;
          }
          function Nt(Pn, xn, Nn) {
            return (
              (Pn.index = Nn),
              Le
                ? ((Nn = Pn.alternate),
                  Nn !== null
                    ? ((Nn = Nn.index), Nn < xn ? ((Pn.flags |= 2), xn) : Nn)
                    : ((Pn.flags |= 2), xn))
                : ((Pn.flags |= 1048576), xn)
            );
          }
          function Jt(Pn) {
            return Le && Pn.alternate === null && (Pn.flags |= 2), Pn;
          }
          function vn(Pn, xn, Nn, br) {
            return xn === null || xn.tag !== 6
              ? ((xn = Hc(Nn, Pn.mode, br)), (xn.return = Pn), xn)
              : ((xn = Rt(xn, Nn)), (xn.return = Pn), xn);
          }
          function Wn(Pn, xn, Nn, br) {
            var Gr = Nn.type;
            return Gr === p
              ? kr(Pn, xn, Nn.props.children, br, Nn.key)
              : xn !== null &&
                (xn.elementType === Gr ||
                  (typeof Gr == "object" &&
                    Gr !== null &&
                    Gr.$$typeof === st &&
                    Ja(Gr) === xn.type))
              ? ((br = Rt(xn, Nn.props)),
                (br.ref = Qa(Pn, xn, Nn)),
                (br.return = Pn),
                br)
              : ((br = Gc(Nn.type, Nn.key, Nn.props, null, Pn.mode, br)),
                (br.ref = Qa(Pn, xn, Nn)),
                (br.return = Pn),
                br);
          }
          function dr(Pn, xn, Nn, br) {
            return xn === null ||
              xn.tag !== 4 ||
              xn.stateNode.containerInfo !== Nn.containerInfo ||
              xn.stateNode.implementation !== Nn.implementation
              ? ((xn = Wc(Nn, Pn.mode, br)), (xn.return = Pn), xn)
              : ((xn = Rt(xn, Nn.children || [])), (xn.return = Pn), xn);
          }
          function kr(Pn, xn, Nn, br, Gr) {
            return xn === null || xn.tag !== 7
              ? ((xn = Oa(Nn, Pn.mode, br, Gr)), (xn.return = Pn), xn)
              : ((xn = Rt(xn, Nn)), (xn.return = Pn), xn);
          }
          function ii(Pn, xn, Nn) {
            if ((typeof xn == "string" && xn !== "") || typeof xn == "number")
              return (xn = Hc("" + xn, Pn.mode, Nn)), (xn.return = Pn), xn;
            if (typeof xn == "object" && xn !== null) {
              switch (xn.$$typeof) {
                case c:
                  return (
                    (Nn = Gc(xn.type, xn.key, xn.props, null, Pn.mode, Nn)),
                    (Nn.ref = Qa(Pn, null, xn)),
                    (Nn.return = Pn),
                    Nn
                  );
                case u:
                  return (xn = Wc(xn, Pn.mode, Nn)), (xn.return = Pn), xn;
                case st:
                  var br = xn._init;
                  return ii(Pn, br(xn._payload), Nn);
              }
              if (qt(xn) || St(xn))
                return (xn = Oa(xn, Pn.mode, Nn, null)), (xn.return = Pn), xn;
              Jo(Pn, xn);
            }
            return null;
          }
          function Zr(Pn, xn, Nn, br) {
            var Gr = xn !== null ? xn.key : null;
            if ((typeof Nn == "string" && Nn !== "") || typeof Nn == "number")
              return Gr !== null ? null : vn(Pn, xn, "" + Nn, br);
            if (typeof Nn == "object" && Nn !== null) {
              switch (Nn.$$typeof) {
                case c:
                  return Nn.key === Gr ? Wn(Pn, xn, Nn, br) : null;
                case u:
                  return Nn.key === Gr ? dr(Pn, xn, Nn, br) : null;
                case st:
                  return (Gr = Nn._init), Zr(Pn, xn, Gr(Nn._payload), br);
              }
              if (qt(Nn) || St(Nn))
                return Gr !== null ? null : kr(Pn, xn, Nn, br, null);
              Jo(Pn, Nn);
            }
            return null;
          }
          function hi(Pn, xn, Nn, br, Gr) {
            if ((typeof br == "string" && br !== "") || typeof br == "number")
              return (Pn = Pn.get(Nn) || null), vn(xn, Pn, "" + br, Gr);
            if (typeof br == "object" && br !== null) {
              switch (br.$$typeof) {
                case c:
                  return (
                    (Pn = Pn.get(br.key === null ? Nn : br.key) || null),
                    Wn(xn, Pn, br, Gr)
                  );
                case u:
                  return (
                    (Pn = Pn.get(br.key === null ? Nn : br.key) || null),
                    dr(xn, Pn, br, Gr)
                  );
                case st:
                  var li = br._init;
                  return hi(Pn, xn, Nn, li(br._payload), Gr);
              }
              if (qt(br) || St(br))
                return (Pn = Pn.get(Nn) || null), kr(xn, Pn, br, Gr, null);
              Jo(xn, br);
            }
            return null;
          }
          function Ar(Pn, xn, Nn, br) {
            for (
              var Gr = null, li = null, si = xn, xi = (xn = 0), Yi = null;
              si !== null && xi < Nn.length;
              xi++
            ) {
              si.index > xi ? ((Yi = si), (si = null)) : (Yi = si.sibling);
              var vi = Zr(Pn, si, Nn[xi], br);
              if (vi === null) {
                si === null && (si = Yi);
                break;
              }
              Le && si && vi.alternate === null && tt(Pn, si),
                (xn = Nt(vi, xn, xi)),
                li === null ? (Gr = vi) : (li.sibling = vi),
                (li = vi),
                (si = Yi);
            }
            if (xi === Nn.length) return _t(Pn, si), Ni && da(Pn, xi), Gr;
            if (si === null) {
              for (; xi < Nn.length; xi++)
                (si = ii(Pn, Nn[xi], br)),
                  si !== null &&
                    ((xn = Nt(si, xn, xi)),
                    li === null ? (Gr = si) : (li.sibling = si),
                    (li = si));
              return Ni && da(Pn, xi), Gr;
            }
            for (si = Et(Pn, si); xi < Nn.length; xi++)
              (Yi = hi(si, Pn, xi, Nn[xi], br)),
                Yi !== null &&
                  (Le &&
                    Yi.alternate !== null &&
                    si.delete(Yi.key === null ? xi : Yi.key),
                  (xn = Nt(Yi, xn, xi)),
                  li === null ? (Gr = Yi) : (li.sibling = Yi),
                  (li = Yi));
            return (
              Le &&
                si.forEach(function (Wo) {
                  return tt(Pn, Wo);
                }),
              Ni && da(Pn, xi),
              Gr
            );
          }
          function hs(Pn, xn, Nn, br) {
            var Gr = St(Nn);
            if (typeof Gr != "function") throw Error(a(150));
            if (((Nn = Gr.call(Nn)), Nn == null)) throw Error(a(151));
            for (
              var li = (Gr = null),
                si = xn,
                xi = (xn = 0),
                Yi = null,
                vi = Nn.next();
              si !== null && !vi.done;
              xi++, vi = Nn.next()
            ) {
              si.index > xi ? ((Yi = si), (si = null)) : (Yi = si.sibling);
              var Wo = Zr(Pn, si, vi.value, br);
              if (Wo === null) {
                si === null && (si = Yi);
                break;
              }
              Le && si && Wo.alternate === null && tt(Pn, si),
                (xn = Nt(Wo, xn, xi)),
                li === null ? (Gr = Wo) : (li.sibling = Wo),
                (li = Wo),
                (si = Yi);
            }
            if (vi.done) return _t(Pn, si), Ni && da(Pn, xi), Gr;
            if (si === null) {
              for (; !vi.done; xi++, vi = Nn.next())
                (vi = ii(Pn, vi.value, br)),
                  vi !== null &&
                    ((xn = Nt(vi, xn, xi)),
                    li === null ? (Gr = vi) : (li.sibling = vi),
                    (li = vi));
              return Ni && da(Pn, xi), Gr;
            }
            for (si = Et(Pn, si); !vi.done; xi++, vi = Nn.next())
              (vi = hi(si, Pn, xi, vi.value, br)),
                vi !== null &&
                  (Le &&
                    vi.alternate !== null &&
                    si.delete(vi.key === null ? xi : vi.key),
                  (xn = Nt(vi, xn, xi)),
                  li === null ? (Gr = vi) : (li.sibling = vi),
                  (li = vi));
            return (
              Le &&
                si.forEach(function (Ou) {
                  return tt(Pn, Ou);
                }),
              Ni && da(Pn, xi),
              Gr
            );
          }
          function js(Pn, xn, Nn, br) {
            if (
              (typeof Nn == "object" &&
                Nn !== null &&
                Nn.type === p &&
                Nn.key === null &&
                (Nn = Nn.props.children),
              typeof Nn == "object" && Nn !== null)
            ) {
              switch (Nn.$$typeof) {
                case c:
                  e: {
                    for (var Gr = Nn.key, li = xn; li !== null; ) {
                      if (li.key === Gr) {
                        if (((Gr = Nn.type), Gr === p)) {
                          if (li.tag === 7) {
                            _t(Pn, li.sibling),
                              (xn = Rt(li, Nn.props.children)),
                              (xn.return = Pn),
                              (Pn = xn);
                            break e;
                          }
                        } else if (
                          li.elementType === Gr ||
                          (typeof Gr == "object" &&
                            Gr !== null &&
                            Gr.$$typeof === st &&
                            Ja(Gr) === li.type)
                        ) {
                          _t(Pn, li.sibling),
                            (xn = Rt(li, Nn.props)),
                            (xn.ref = Qa(Pn, li, Nn)),
                            (xn.return = Pn),
                            (Pn = xn);
                          break e;
                        }
                        _t(Pn, li);
                        break;
                      } else tt(Pn, li);
                      li = li.sibling;
                    }
                    Nn.type === p
                      ? ((xn = Oa(Nn.props.children, Pn.mode, br, Nn.key)),
                        (xn.return = Pn),
                        (Pn = xn))
                      : ((br = Gc(
                          Nn.type,
                          Nn.key,
                          Nn.props,
                          null,
                          Pn.mode,
                          br
                        )),
                        (br.ref = Qa(Pn, xn, Nn)),
                        (br.return = Pn),
                        (Pn = br));
                  }
                  return Jt(Pn);
                case u:
                  e: {
                    for (li = Nn.key; xn !== null; ) {
                      if (xn.key === li)
                        if (
                          xn.tag === 4 &&
                          xn.stateNode.containerInfo === Nn.containerInfo &&
                          xn.stateNode.implementation === Nn.implementation
                        ) {
                          _t(Pn, xn.sibling),
                            (xn = Rt(xn, Nn.children || [])),
                            (xn.return = Pn),
                            (Pn = xn);
                          break e;
                        } else {
                          _t(Pn, xn);
                          break;
                        }
                      else tt(Pn, xn);
                      xn = xn.sibling;
                    }
                    (xn = Wc(Nn, Pn.mode, br)), (xn.return = Pn), (Pn = xn);
                  }
                  return Jt(Pn);
                case st:
                  return (li = Nn._init), js(Pn, xn, li(Nn._payload), br);
              }
              if (qt(Nn)) return Ar(Pn, xn, Nn, br);
              if (St(Nn)) return hs(Pn, xn, Nn, br);
              Jo(Pn, Nn);
            }
            return (typeof Nn == "string" && Nn !== "") || typeof Nn == "number"
              ? ((Nn = "" + Nn),
                xn !== null && xn.tag === 6
                  ? (_t(Pn, xn.sibling),
                    (xn = Rt(xn, Nn)),
                    (xn.return = Pn),
                    (Pn = xn))
                  : (_t(Pn, xn),
                    (xn = Hc(Nn, Pn.mode, br)),
                    (xn.return = Pn),
                    (Pn = xn)),
                Jt(Pn))
              : _t(Pn, xn);
          }
          return js;
        }
        var Ro = Yu(!0),
          Ku = Yu(!1),
          el = {},
          Ls = cr(el),
          pa = cr(el),
          ma = cr(el);
        function io(Le) {
          if (Le === el) throw Error(a(174));
          return Le;
        }
        function vc(Le, tt) {
          gr(ma, tt), gr(pa, Le), gr(Ls, el), (Le = Bt(tt)), Qn(Ls), gr(Ls, Le);
        }
        function tl() {
          Qn(Ls), Qn(pa), Qn(ma);
        }
        function Zu(Le) {
          var tt = io(ma.current),
            _t = io(Ls.current);
          (tt = Mt(_t, Le.type, tt)), _t !== tt && (gr(pa, Le), gr(Ls, tt));
        }
        function ou(Le) {
          pa.current === Le && (Qn(Ls), Qn(pa));
        }
        var zi = cr(0);
        function _c(Le) {
          for (var tt = Le; tt !== null; ) {
            if (tt.tag === 13) {
              var _t = tt.memoizedState;
              if (
                _t !== null &&
                ((_t = _t.dehydrated), _t === null || Cr(_t) || zr(_t))
              )
                return tt;
            } else if (
              tt.tag === 19 &&
              tt.memoizedProps.revealOrder !== void 0
            ) {
              if ((tt.flags & 128) !== 0) return tt;
            } else if (tt.child !== null) {
              (tt.child.return = tt), (tt = tt.child);
              continue;
            }
            if (tt === Le) break;
            for (; tt.sibling === null; ) {
              if (tt.return === null || tt.return === Le) return null;
              tt = tt.return;
            }
            (tt.sibling.return = tt.return), (tt = tt.sibling);
          }
          return null;
        }
        var Bs = [];
        function ga() {
          for (var Le = 0; Le < Bs.length; Le++) {
            var tt = Bs[Le];
            tr
              ? (tt._workInProgressVersionPrimary = null)
              : (tt._workInProgressVersionSecondary = null);
          }
          Bs.length = 0;
        }
        var Al = l.ReactCurrentDispatcher,
          Us = l.ReactCurrentBatchConfig,
          va = 0,
          Vi = null,
          es = null,
          ts = null,
          yc = !1,
          mo = !1,
          ya = 0,
          Pl = 0;
        function ns() {
          throw Error(a(321));
        }
        function xc(Le, tt) {
          if (tt === null) return !1;
          for (var _t = 0; _t < tt.length && _t < Le.length; _t++)
            if (!Yr(Le[_t], tt[_t])) return !1;
          return !0;
        }
        function nl(Le, tt, _t, Et, Rt, Nt) {
          if (
            ((va = Nt),
            (Vi = tt),
            (tt.memoizedState = null),
            (tt.updateQueue = null),
            (tt.lanes = 0),
            (Al.current = Le === null || Le.memoizedState === null ? hu : du),
            (Le = _t(Et, Rt)),
            mo)
          ) {
            Nt = 0;
            do {
              if (((mo = !1), (ya = 0), 25 <= Nt)) throw Error(a(301));
              (Nt += 1),
                (ts = es = null),
                (tt.updateQueue = null),
                (Al.current = pu),
                (Le = _t(Et, Rt));
            } while (mo);
          }
          if (
            ((Al.current = ol),
            (tt = es !== null && es.next !== null),
            (va = 0),
            (ts = es = Vi = null),
            (yc = !1),
            tt)
          )
            throw Error(a(300));
          return Le;
        }
        function ea() {
          var Le = ya !== 0;
          return (ya = 0), Le;
        }
        function so() {
          var Le = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            ts === null ? (Vi.memoizedState = ts = Le) : (ts = ts.next = Le), ts
          );
        }
        function oo() {
          if (es === null) {
            var Le = Vi.alternate;
            Le = Le !== null ? Le.memoizedState : null;
          } else Le = es.next;
          var tt = ts === null ? Vi.memoizedState : ts.next;
          if (tt !== null) (ts = tt), (es = Le);
          else {
            if (Le === null) throw Error(a(310));
            (es = Le),
              (Le = {
                memoizedState: es.memoizedState,
                baseState: es.baseState,
                baseQueue: es.baseQueue,
                queue: es.queue,
                next: null,
              }),
              ts === null ? (Vi.memoizedState = ts = Le) : (ts = ts.next = Le);
          }
          return ts;
        }
        function go(Le, tt) {
          return typeof tt == "function" ? tt(Le) : tt;
        }
        function Rl(Le) {
          var tt = oo(),
            _t = tt.queue;
          if (_t === null) throw Error(a(311));
          _t.lastRenderedReducer = Le;
          var Et = es,
            Rt = Et.baseQueue,
            Nt = _t.pending;
          if (Nt !== null) {
            if (Rt !== null) {
              var Jt = Rt.next;
              (Rt.next = Nt.next), (Nt.next = Jt);
            }
            (Et.baseQueue = Rt = Nt), (_t.pending = null);
          }
          if (Rt !== null) {
            (Nt = Rt.next), (Et = Et.baseState);
            var vn = (Jt = null),
              Wn = null,
              dr = Nt;
            do {
              var kr = dr.lane;
              if ((va & kr) === kr)
                Wn !== null &&
                  (Wn = Wn.next =
                    {
                      lane: 0,
                      action: dr.action,
                      hasEagerState: dr.hasEagerState,
                      eagerState: dr.eagerState,
                      next: null,
                    }),
                  (Et = dr.hasEagerState ? dr.eagerState : Le(Et, dr.action));
              else {
                var ii = {
                  lane: kr,
                  action: dr.action,
                  hasEagerState: dr.hasEagerState,
                  eagerState: dr.eagerState,
                  next: null,
                };
                Wn === null ? ((vn = Wn = ii), (Jt = Et)) : (Wn = Wn.next = ii),
                  (Vi.lanes |= kr),
                  (_o |= kr);
              }
              dr = dr.next;
            } while (dr !== null && dr !== Nt);
            Wn === null ? (Jt = Et) : (Wn.next = vn),
              Yr(Et, tt.memoizedState) || (rs = !0),
              (tt.memoizedState = Et),
              (tt.baseState = Jt),
              (tt.baseQueue = Wn),
              (_t.lastRenderedState = Et);
          }
          if (((Le = _t.interleaved), Le !== null)) {
            Rt = Le;
            do (Nt = Rt.lane), (Vi.lanes |= Nt), (_o |= Nt), (Rt = Rt.next);
            while (Rt !== Le);
          } else Rt === null && (_t.lanes = 0);
          return [tt.memoizedState, _t.dispatch];
        }
        function Il(Le) {
          var tt = oo(),
            _t = tt.queue;
          if (_t === null) throw Error(a(311));
          _t.lastRenderedReducer = Le;
          var Et = _t.dispatch,
            Rt = _t.pending,
            Nt = tt.memoizedState;
          if (Rt !== null) {
            _t.pending = null;
            var Jt = (Rt = Rt.next);
            do (Nt = Le(Nt, Jt.action)), (Jt = Jt.next);
            while (Jt !== Rt);
            Yr(Nt, tt.memoizedState) || (rs = !0),
              (tt.memoizedState = Nt),
              tt.baseQueue === null && (tt.baseState = Nt),
              (_t.lastRenderedState = Nt);
          }
          return [Nt, Et];
        }
        function au() {}
        function lu(Le, tt) {
          var _t = Vi,
            Et = oo(),
            Rt = tt(),
            Nt = !Yr(Et.memoizedState, Rt);
          if (
            (Nt && ((Et.memoizedState = Rt), (rs = !0)),
            (Et = Et.queue),
            rl(Io.bind(null, _t, Et, Le), [Le]),
            Et.getSnapshot !== tt ||
              Nt ||
              (ts !== null && ts.memoizedState.tag & 1))
          ) {
            if (
              ((_t.flags |= 2048),
              kl(9, uu.bind(null, _t, Et, Rt, tt), void 0, null),
              qi === null)
            )
              throw Error(a(349));
            (va & 30) !== 0 || cu(_t, tt, Rt);
          }
          return Rt;
        }
        function cu(Le, tt, _t) {
          (Le.flags |= 16384),
            (Le = { getSnapshot: tt, value: _t }),
            (tt = Vi.updateQueue),
            tt === null
              ? ((tt = { lastEffect: null, stores: null }),
                (Vi.updateQueue = tt),
                (tt.stores = [Le]))
              : ((_t = tt.stores),
                _t === null ? (tt.stores = [Le]) : _t.push(Le));
        }
        function uu(Le, tt, _t, Et) {
          (tt.value = _t), (tt.getSnapshot = Et), Sc(tt) && vs(Le, 1, -1);
        }
        function Io(Le, tt, _t) {
          return _t(function () {
            Sc(tt) && vs(Le, 1, -1);
          });
        }
        function Sc(Le) {
          var tt = Le.getSnapshot;
          Le = Le.value;
          try {
            var _t = tt();
            return !Yr(Le, _t);
          } catch {
            return !0;
          }
        }
        function Ll(Le) {
          var tt = so();
          return (
            typeof Le == "function" && (Le = Le()),
            (tt.memoizedState = tt.baseState = Le),
            (Le = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: go,
              lastRenderedState: Le,
            }),
            (tt.queue = Le),
            (Le = Le.dispatch = Ff.bind(null, Vi, Le)),
            [tt.memoizedState, Le]
          );
        }
        function kl(Le, tt, _t, Et) {
          return (
            (Le = { tag: Le, create: tt, destroy: _t, deps: Et, next: null }),
            (tt = Vi.updateQueue),
            tt === null
              ? ((tt = { lastEffect: null, stores: null }),
                (Vi.updateQueue = tt),
                (tt.lastEffect = Le.next = Le))
              : ((_t = tt.lastEffect),
                _t === null
                  ? (tt.lastEffect = Le.next = Le)
                  : ((Et = _t.next),
                    (_t.next = Le),
                    (Le.next = Et),
                    (tt.lastEffect = Le))),
            Le
          );
        }
        function Qu() {
          return oo().memoizedState;
        }
        function ta(Le, tt, _t, Et) {
          var Rt = so();
          (Vi.flags |= Le),
            (Rt.memoizedState = kl(
              1 | tt,
              _t,
              void 0,
              Et === void 0 ? null : Et
            ));
        }
        function wc(Le, tt, _t, Et) {
          var Rt = oo();
          Et = Et === void 0 ? null : Et;
          var Nt = void 0;
          if (es !== null) {
            var Jt = es.memoizedState;
            if (((Nt = Jt.destroy), Et !== null && xc(Et, Jt.deps))) {
              Rt.memoizedState = kl(tt, _t, Nt, Et);
              return;
            }
          }
          (Vi.flags |= Le), (Rt.memoizedState = kl(1 | tt, _t, Nt, Et));
        }
        function Ec(Le, tt) {
          return ta(8390656, 8, Le, tt);
        }
        function rl(Le, tt) {
          return wc(2048, 8, Le, tt);
        }
        function Li(Le, tt) {
          return wc(4, 2, Le, tt);
        }
        function Tc(Le, tt) {
          return wc(4, 4, Le, tt);
        }
        function Fl(Le, tt) {
          if (typeof tt == "function")
            return (
              (Le = Le()),
              tt(Le),
              function () {
                tt(null);
              }
            );
          if (tt != null)
            return (
              (Le = Le()),
              (tt.current = Le),
              function () {
                tt.current = null;
              }
            );
        }
        function il(Le, tt, _t) {
          return (
            (_t = _t != null ? _t.concat([Le]) : null),
            wc(4, 4, Fl.bind(null, tt, Le), _t)
          );
        }
        function bc() {}
        function Mc(Le, tt) {
          var _t = oo();
          tt = tt === void 0 ? null : tt;
          var Et = _t.memoizedState;
          return Et !== null && tt !== null && xc(tt, Et[1])
            ? Et[0]
            : ((_t.memoizedState = [Le, tt]), Le);
        }
        function sl(Le, tt) {
          var _t = oo();
          tt = tt === void 0 ? null : tt;
          var Et = _t.memoizedState;
          return Et !== null && tt !== null && xc(tt, Et[1])
            ? Et[0]
            : ((Le = Le()), (_t.memoizedState = [Le, tt]), Le);
        }
        function Cc(Le, tt) {
          var _t = ci;
          (ci = _t !== 0 && 4 > _t ? _t : 4), Le(!0);
          var Et = Us.transition;
          Us.transition = {};
          try {
            Le(!1), tt();
          } finally {
            (ci = _t), (Us.transition = Et);
          }
        }
        function xa() {
          return oo().memoizedState;
        }
        function Ju(Le, tt, _t) {
          var Et = uo(Le);
          (_t = {
            lane: Et,
            action: _t,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          }),
            ef(Le)
              ? fu(tt, _t)
              : (Dl(Le, tt, _t),
                (_t = Si()),
                (Le = vs(Le, Et, _t)),
                Le !== null && Ol(Le, tt, Et));
        }
        function Ff(Le, tt, _t) {
          var Et = uo(Le),
            Rt = {
              lane: Et,
              action: _t,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (ef(Le)) fu(tt, Rt);
          else {
            Dl(Le, tt, Rt);
            var Nt = Le.alternate;
            if (
              Le.lanes === 0 &&
              (Nt === null || Nt.lanes === 0) &&
              ((Nt = tt.lastRenderedReducer), Nt !== null)
            )
              try {
                var Jt = tt.lastRenderedState,
                  vn = Nt(Jt, _t);
                if (((Rt.hasEagerState = !0), (Rt.eagerState = vn), Yr(vn, Jt)))
                  return;
              } catch {
              } finally {
              }
            (_t = Si()), (Le = vs(Le, Et, _t)), Le !== null && Ol(Le, tt, Et);
          }
        }
        function ef(Le) {
          var tt = Le.alternate;
          return Le === Vi || (tt !== null && tt === Vi);
        }
        function fu(Le, tt) {
          mo = yc = !0;
          var _t = Le.pending;
          _t === null ? (tt.next = tt) : ((tt.next = _t.next), (_t.next = tt)),
            (Le.pending = tt);
        }
        function Dl(Le, tt, _t) {
          qi !== null && (Le.mode & 1) !== 0 && (ui & 2) === 0
            ? ((Le = tt.interleaved),
              Le === null
                ? ((_t.next = _t), Xs === null ? (Xs = [tt]) : Xs.push(tt))
                : ((_t.next = Le.next), (Le.next = _t)),
              (tt.interleaved = _t))
            : ((Le = tt.pending),
              Le === null
                ? (_t.next = _t)
                : ((_t.next = Le.next), (Le.next = _t)),
              (tt.pending = _t));
        }
        function Ol(Le, tt, _t) {
          if ((_t & 4194240) !== 0) {
            var Et = tt.lanes;
            (Et &= Le.pendingLanes), (_t |= Et), (tt.lanes = _t), qs(Le, _t);
          }
        }
        var ol = {
            readContext: Is,
            useCallback: ns,
            useContext: ns,
            useEffect: ns,
            useImperativeHandle: ns,
            useInsertionEffect: ns,
            useLayoutEffect: ns,
            useMemo: ns,
            useReducer: ns,
            useRef: ns,
            useState: ns,
            useDebugValue: ns,
            useDeferredValue: ns,
            useTransition: ns,
            useMutableSource: ns,
            useSyncExternalStore: ns,
            useId: ns,
            unstable_isNewReconciler: !1,
          },
          hu = {
            readContext: Is,
            useCallback: function (Le, tt) {
              return (so().memoizedState = [Le, tt === void 0 ? null : tt]), Le;
            },
            useContext: Is,
            useEffect: Ec,
            useImperativeHandle: function (Le, tt, _t) {
              return (
                (_t = _t != null ? _t.concat([Le]) : null),
                ta(4194308, 4, Fl.bind(null, tt, Le), _t)
              );
            },
            useLayoutEffect: function (Le, tt) {
              return ta(4194308, 4, Le, tt);
            },
            useInsertionEffect: function (Le, tt) {
              return ta(4, 2, Le, tt);
            },
            useMemo: function (Le, tt) {
              var _t = so();
              return (
                (tt = tt === void 0 ? null : tt),
                (Le = Le()),
                (_t.memoizedState = [Le, tt]),
                Le
              );
            },
            useReducer: function (Le, tt, _t) {
              var Et = so();
              return (
                (tt = _t !== void 0 ? _t(tt) : tt),
                (Et.memoizedState = Et.baseState = tt),
                (Le = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: Le,
                  lastRenderedState: tt,
                }),
                (Et.queue = Le),
                (Le = Le.dispatch = Ju.bind(null, Vi, Le)),
                [Et.memoizedState, Le]
              );
            },
            useRef: function (Le) {
              var tt = so();
              return (Le = { current: Le }), (tt.memoizedState = Le);
            },
            useState: Ll,
            useDebugValue: bc,
            useDeferredValue: function (Le) {
              var tt = Ll(Le),
                _t = tt[0],
                Et = tt[1];
              return (
                Ec(
                  function () {
                    var Rt = Us.transition;
                    Us.transition = {};
                    try {
                      Et(Le);
                    } finally {
                      Us.transition = Rt;
                    }
                  },
                  [Le]
                ),
                _t
              );
            },
            useTransition: function () {
              var Le = Ll(!1),
                tt = Le[0];
              return (
                (Le = Cc.bind(null, Le[1])), (so().memoizedState = Le), [tt, Le]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (Le, tt, _t) {
              var Et = Vi,
                Rt = so();
              if (Ni) {
                if (_t === void 0) throw Error(a(407));
                _t = _t();
              } else {
                if (((_t = tt()), qi === null)) throw Error(a(349));
                (va & 30) !== 0 || cu(Et, tt, _t);
              }
              Rt.memoizedState = _t;
              var Nt = { value: _t, getSnapshot: tt };
              return (
                (Rt.queue = Nt),
                Ec(Io.bind(null, Et, Nt, Le), [Le]),
                (Et.flags |= 2048),
                kl(9, uu.bind(null, Et, Nt, _t, tt), void 0, null),
                _t
              );
            },
            useId: function () {
              var Le = so(),
                tt = qi.identifierPrefix;
              if (Ni) {
                var _t = Po,
                  Et = Ao;
                (_t = (Et & ~(1 << (32 - Kr(Et) - 1))).toString(32) + _t),
                  (tt = ":" + tt + "R" + _t),
                  (_t = ya++),
                  0 < _t && (tt += "H" + _t.toString(32)),
                  (tt += ":");
              } else (_t = Pl++), (tt = ":" + tt + "r" + _t.toString(32) + ":");
              return (Le.memoizedState = tt);
            },
            unstable_isNewReconciler: !1,
          },
          du = {
            readContext: Is,
            useCallback: Mc,
            useContext: Is,
            useEffect: rl,
            useImperativeHandle: il,
            useInsertionEffect: Li,
            useLayoutEffect: Tc,
            useMemo: sl,
            useReducer: Rl,
            useRef: Qu,
            useState: function () {
              return Rl(go);
            },
            useDebugValue: bc,
            useDeferredValue: function (Le) {
              var tt = Rl(go),
                _t = tt[0],
                Et = tt[1];
              return (
                rl(
                  function () {
                    var Rt = Us.transition;
                    Us.transition = {};
                    try {
                      Et(Le);
                    } finally {
                      Us.transition = Rt;
                    }
                  },
                  [Le]
                ),
                _t
              );
            },
            useTransition: function () {
              var Le = Rl(go)[0],
                tt = oo().memoizedState;
              return [Le, tt];
            },
            useMutableSource: au,
            useSyncExternalStore: lu,
            useId: xa,
            unstable_isNewReconciler: !1,
          },
          pu = {
            readContext: Is,
            useCallback: Mc,
            useContext: Is,
            useEffect: rl,
            useImperativeHandle: il,
            useInsertionEffect: Li,
            useLayoutEffect: Tc,
            useMemo: sl,
            useReducer: Il,
            useRef: Qu,
            useState: function () {
              return Il(go);
            },
            useDebugValue: bc,
            useDeferredValue: function (Le) {
              var tt = Il(go),
                _t = tt[0],
                Et = tt[1];
              return (
                rl(
                  function () {
                    var Rt = Us.transition;
                    Us.transition = {};
                    try {
                      Et(Le);
                    } finally {
                      Us.transition = Rt;
                    }
                  },
                  [Le]
                ),
                _t
              );
            },
            useTransition: function () {
              var Le = Il(go)[0],
                tt = oo().memoizedState;
              return [Le, tt];
            },
            useMutableSource: au,
            useSyncExternalStore: lu,
            useId: xa,
            unstable_isNewReconciler: !1,
          };
        function mu(Le, tt) {
          try {
            var _t = "",
              Et = tt;
            do (_t += $a(Et)), (Et = Et.return);
            while (Et);
            var Rt = _t;
          } catch (Nt) {
            Rt =
              `
Error generating stack: ` +
              Nt.message +
              `
` +
              Nt.stack;
          }
          return { value: Le, source: tt, stack: Rt };
        }
        function Ac(Le, tt) {
          try {
            console.error(tt.value);
          } catch (_t) {
            setTimeout(function () {
              throw _t;
            });
          }
        }
        var Df = typeof WeakMap == "function" ? WeakMap : Map;
        function tf(Le, tt, _t) {
          (_t = Co(-1, _t)), (_t.tag = 3), (_t.payload = { element: null });
          var Et = tt.value;
          return (
            (_t.callback = function () {
              dl || ((dl = !0), (Oi = Et)), Ac(Le, tt);
            }),
            _t
          );
        }
        function Pc(Le, tt, _t) {
          (_t = Co(-1, _t)), (_t.tag = 3);
          var Et = Le.type.getDerivedStateFromError;
          if (typeof Et == "function") {
            var Rt = tt.value;
            (_t.payload = function () {
              return Et(Rt);
            }),
              (_t.callback = function () {
                Ac(Le, tt);
              });
          }
          var Nt = Le.stateNode;
          return (
            Nt !== null &&
              typeof Nt.componentDidCatch == "function" &&
              (_t.callback = function () {
                Ac(Le, tt),
                  typeof Et != "function" &&
                    (co === null ? (co = new Set([this])) : co.add(this));
                var Jt = tt.stack;
                this.componentDidCatch(tt.value, {
                  componentStack: Jt !== null ? Jt : "",
                });
              }),
            _t
          );
        }
        function Lo(Le, tt, _t) {
          var Et = Le.pingCache;
          if (Et === null) {
            Et = Le.pingCache = new Df();
            var Rt = new Set();
            Et.set(tt, Rt);
          } else
            (Rt = Et.get(tt)),
              Rt === void 0 && ((Rt = new Set()), Et.set(tt, Rt));
          Rt.has(_t) ||
            (Rt.add(_t), (Le = ku.bind(null, Le, tt, _t)), tt.then(Le, Le));
        }
        function gu(Le) {
          do {
            var tt;
            if (
              ((tt = Le.tag === 13) &&
                ((tt = Le.memoizedState),
                (tt = tt !== null ? tt.dehydrated !== null : !0)),
              tt)
            )
              return Le;
            Le = Le.return;
          } while (Le !== null);
          return null;
        }
        function Sa(Le, tt, _t, Et, Rt) {
          return (Le.mode & 1) === 0
            ? (Le === tt
                ? (Le.flags |= 65536)
                : ((Le.flags |= 128),
                  (_t.flags |= 131072),
                  (_t.flags &= -52805),
                  _t.tag === 1 &&
                    (_t.alternate === null
                      ? (_t.tag = 17)
                      : ((tt = Co(-1, 1)), (tt.tag = 2), Ko(_t, tt))),
                  (_t.lanes |= 1)),
              Le)
            : ((Le.flags |= 65536), (Le.lanes = Rt), Le);
        }
        function Qi(Le) {
          Le.flags |= 4;
        }
        function al(Le, tt) {
          if (Le !== null && Le.child === tt.child) return !0;
          if ((tt.flags & 16) !== 0) return !1;
          for (Le = tt.child; Le !== null; ) {
            if ((Le.flags & 12854) !== 0 || (Le.subtreeFlags & 12854) !== 0)
              return !1;
            Le = Le.sibling;
          }
          return !0;
        }
        var zs, wa, Rc, Ic;
        if (ur)
          (zs = function (Le, tt) {
            for (var _t = tt.child; _t !== null; ) {
              if (_t.tag === 5 || _t.tag === 6) Xt(Le, _t.stateNode);
              else if (_t.tag !== 4 && _t.child !== null) {
                (_t.child.return = _t), (_t = _t.child);
                continue;
              }
              if (_t === tt) break;
              for (; _t.sibling === null; ) {
                if (_t.return === null || _t.return === tt) return;
                _t = _t.return;
              }
              (_t.sibling.return = _t.return), (_t = _t.sibling);
            }
          }),
            (wa = function () {}),
            (Rc = function (Le, tt, _t, Et, Rt) {
              if (((Le = Le.memoizedProps), Le !== Et)) {
                var Nt = tt.stateNode,
                  Jt = io(Ls.current);
                (_t = Kt(Nt, _t, Le, Et, Rt, Jt)),
                  (tt.updateQueue = _t) && Qi(tt);
              }
            }),
            (Ic = function (Le, tt, _t, Et) {
              _t !== Et && Qi(tt);
            });
        else if (_r) {
          zs = function (Le, tt, _t, Et) {
            for (var Rt = tt.child; Rt !== null; ) {
              if (Rt.tag === 5) {
                var Nt = Rt.stateNode;
                _t && Et && (Nt = wr(Nt, Rt.type, Rt.memoizedProps, Rt)),
                  Xt(Le, Nt);
              } else if (Rt.tag === 6)
                (Nt = Rt.stateNode),
                  _t && Et && (Nt = Rr(Nt, Rt.memoizedProps, Rt)),
                  Xt(Le, Nt);
              else if (Rt.tag !== 4) {
                if (Rt.tag === 22 && Rt.memoizedState !== null)
                  (Nt = Rt.child),
                    Nt !== null && (Nt.return = Rt),
                    zs(Le, Rt, !0, !0);
                else if (Rt.child !== null) {
                  (Rt.child.return = Rt), (Rt = Rt.child);
                  continue;
                }
              }
              if (Rt === tt) break;
              for (; Rt.sibling === null; ) {
                if (Rt.return === null || Rt.return === tt) return;
                Rt = Rt.return;
              }
              (Rt.sibling.return = Rt.return), (Rt = Rt.sibling);
            }
          };
          var na = function (Le, tt, _t, Et) {
            for (var Rt = tt.child; Rt !== null; ) {
              if (Rt.tag === 5) {
                var Nt = Rt.stateNode;
                _t && Et && (Nt = wr(Nt, Rt.type, Rt.memoizedProps, Rt)),
                  jr(Le, Nt);
              } else if (Rt.tag === 6)
                (Nt = Rt.stateNode),
                  _t && Et && (Nt = Rr(Nt, Rt.memoizedProps, Rt)),
                  jr(Le, Nt);
              else if (Rt.tag !== 4) {
                if (Rt.tag === 22 && Rt.memoizedState !== null)
                  (Nt = Rt.child),
                    Nt !== null && (Nt.return = Rt),
                    na(Le, Rt, !0, !0);
                else if (Rt.child !== null) {
                  (Rt.child.return = Rt), (Rt = Rt.child);
                  continue;
                }
              }
              if (Rt === tt) break;
              for (; Rt.sibling === null; ) {
                if (Rt.return === null || Rt.return === tt) return;
                Rt = Rt.return;
              }
              (Rt.sibling.return = Rt.return), (Rt = Rt.sibling);
            }
          };
          (wa = function (Le, tt) {
            var _t = tt.stateNode;
            if (!al(Le, tt)) {
              Le = _t.containerInfo;
              var Et = pr(Le);
              na(Et, tt, !1, !1), (_t.pendingChildren = Et), Qi(tt), fi(Le, Et);
            }
          }),
            (Rc = function (Le, tt, _t, Et, Rt) {
              var Nt = Le.stateNode,
                Jt = Le.memoizedProps;
              if ((Le = al(Le, tt)) && Jt === Et) tt.stateNode = Nt;
              else {
                var vn = tt.stateNode,
                  Wn = io(Ls.current),
                  dr = null;
                Jt !== Et && (dr = Kt(vn, _t, Jt, Et, Rt, Wn)),
                  Le && dr === null
                    ? (tt.stateNode = Nt)
                    : ((Nt = hr(Nt, dr, _t, Jt, Et, tt, Le, vn)),
                      sn(Nt, _t, Et, Rt, Wn) && Qi(tt),
                      (tt.stateNode = Nt),
                      Le ? Qi(tt) : zs(Nt, tt, !1, !1));
              }
            }),
            (Ic = function (Le, tt, _t, Et) {
              _t !== Et
                ? ((Le = io(ma.current)),
                  (_t = io(Ls.current)),
                  (tt.stateNode = pn(Et, Le, _t, tt)),
                  Qi(tt))
                : (tt.stateNode = Le.stateNode);
            });
        } else
          (wa = function () {}), (Rc = function () {}), (Ic = function () {});
        function ko(Le, tt) {
          if (!Ni)
            switch (Le.tailMode) {
              case "hidden":
                tt = Le.tail;
                for (var _t = null; tt !== null; )
                  tt.alternate !== null && (_t = tt), (tt = tt.sibling);
                _t === null ? (Le.tail = null) : (_t.sibling = null);
                break;
              case "collapsed":
                _t = Le.tail;
                for (var Et = null; _t !== null; )
                  _t.alternate !== null && (Et = _t), (_t = _t.sibling);
                Et === null
                  ? tt || Le.tail === null
                    ? (Le.tail = null)
                    : (Le.tail.sibling = null)
                  : (Et.sibling = null);
            }
        }
        function $i(Le) {
          var tt = Le.alternate !== null && Le.alternate.child === Le.child,
            _t = 0,
            Et = 0;
          if (tt)
            for (var Rt = Le.child; Rt !== null; )
              (_t |= Rt.lanes | Rt.childLanes),
                (Et |= Rt.subtreeFlags & 14680064),
                (Et |= Rt.flags & 14680064),
                (Rt.return = Le),
                (Rt = Rt.sibling);
          else
            for (Rt = Le.child; Rt !== null; )
              (_t |= Rt.lanes | Rt.childLanes),
                (Et |= Rt.subtreeFlags),
                (Et |= Rt.flags),
                (Rt.return = Le),
                (Rt = Rt.sibling);
          return (Le.subtreeFlags |= Et), (Le.childLanes = _t), tt;
        }
        function Lc(Le, tt, _t) {
          var Et = tt.pendingProps;
          switch ((ru(tt), tt.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return $i(tt), null;
            case 1:
              return oi(tt.type) && Xr(), $i(tt), null;
            case 3:
              return (
                (Et = tt.stateNode),
                tl(),
                Qn(Dr),
                Qn(Qr),
                ga(),
                Et.pendingContext &&
                  ((Et.context = Et.pendingContext),
                  (Et.pendingContext = null)),
                (Le === null || Le.child === null) &&
                  (Cl(tt)
                    ? Qi(tt)
                    : Le === null ||
                      (Le.memoizedState.isDehydrated &&
                        (tt.flags & 256) === 0) ||
                      ((tt.flags |= 1024),
                      Zs !== null && (Yl(Zs), (Zs = null)))),
                wa(Le, tt),
                $i(tt),
                null
              );
            case 5:
              ou(tt), (_t = io(ma.current));
              var Rt = tt.type;
              if (Le !== null && tt.stateNode != null)
                Rc(Le, tt, Rt, Et, _t),
                  Le.ref !== tt.ref &&
                    ((tt.flags |= 512), (tt.flags |= 2097152));
              else {
                if (!Et) {
                  if (tt.stateNode === null) throw Error(a(166));
                  return $i(tt), null;
                }
                if (((Le = io(Ls.current)), Cl(tt))) {
                  if (!Bn) throw Error(a(175));
                  (Le = Ut(
                    tt.stateNode,
                    tt.type,
                    tt.memoizedProps,
                    _t,
                    Le,
                    tt,
                    !Ka
                  )),
                    (tt.updateQueue = Le),
                    Le !== null && Qi(tt);
                } else {
                  var Nt = Ot(Rt, Et, _t, Le, tt);
                  zs(Nt, tt, !1, !1),
                    (tt.stateNode = Nt),
                    sn(Nt, Rt, Et, _t, Le) && Qi(tt);
                }
                tt.ref !== null && ((tt.flags |= 512), (tt.flags |= 2097152));
              }
              return $i(tt), null;
            case 6:
              if (Le && tt.stateNode != null) Ic(Le, tt, Le.memoizedProps, Et);
              else {
                if (typeof Et != "string" && tt.stateNode === null)
                  throw Error(a(166));
                if (((Le = io(ma.current)), (_t = io(Ls.current)), Cl(tt))) {
                  if (!Bn) throw Error(a(176));
                  if (
                    ((Le = tt.stateNode),
                    (Et = tt.memoizedProps),
                    (_t = $t(Le, Et, tt, !Ka)) && ((Rt = ws), Rt !== null))
                  )
                    switch (((Nt = (Rt.mode & 1) !== 0), Rt.tag)) {
                      case 3:
                        Zt(Rt.stateNode.containerInfo, Le, Et, Nt);
                        break;
                      case 5:
                        an(Rt.type, Rt.memoizedProps, Rt.stateNode, Le, Et, Nt);
                    }
                  _t && Qi(tt);
                } else tt.stateNode = pn(Et, Le, _t, tt);
              }
              return $i(tt), null;
            case 13:
              if (
                (Qn(zi),
                (Et = tt.memoizedState),
                Ni &&
                  as !== null &&
                  (tt.mode & 1) !== 0 &&
                  (tt.flags & 128) === 0)
              ) {
                for (Le = as; Le; ) Le = qr(Le);
                return Za(), (tt.flags |= 98560), tt;
              }
              if (Et !== null && Et.dehydrated !== null) {
                if (((Et = Cl(tt)), Le === null)) {
                  if (!Et) throw Error(a(318));
                  if (!Bn) throw Error(a(344));
                  if (
                    ((Le = tt.memoizedState),
                    (Le = Le !== null ? Le.dehydrated : null),
                    !Le)
                  )
                    throw Error(a(317));
                  un(Le, tt);
                } else
                  Za(),
                    (tt.flags & 128) === 0 && (tt.memoizedState = null),
                    (tt.flags |= 4);
                return $i(tt), null;
              }
              return (
                Zs !== null && (Yl(Zs), (Zs = null)),
                (tt.flags & 128) !== 0
                  ? ((tt.lanes = _t), tt)
                  : ((Et = Et !== null),
                    (_t = !1),
                    Le === null ? Cl(tt) : (_t = Le.memoizedState !== null),
                    Et &&
                      !_t &&
                      ((tt.child.flags |= 8192),
                      (tt.mode & 1) !== 0 &&
                        (Le === null || (zi.current & 1) !== 0
                          ? Hi === 0 && (Hi = 3)
                          : Uc())),
                    tt.updateQueue !== null && (tt.flags |= 4),
                    $i(tt),
                    null)
              );
            case 4:
              return (
                tl(),
                wa(Le, tt),
                Le === null && Yn(tt.stateNode.containerInfo),
                $i(tt),
                null
              );
            case 10:
              return Ml(tt.type._context), $i(tt), null;
            case 17:
              return oi(tt.type) && Xr(), $i(tt), null;
            case 19:
              if ((Qn(zi), (Rt = tt.memoizedState), Rt === null))
                return $i(tt), null;
              if (
                ((Et = (tt.flags & 128) !== 0),
                (Nt = Rt.rendering),
                Nt === null)
              )
                if (Et) ko(Rt, !1);
                else {
                  if (Hi !== 0 || (Le !== null && (Le.flags & 128) !== 0))
                    for (Le = tt.child; Le !== null; ) {
                      if (((Nt = _c(Le)), Nt !== null)) {
                        for (
                          tt.flags |= 128,
                            ko(Rt, !1),
                            Le = Nt.updateQueue,
                            Le !== null &&
                              ((tt.updateQueue = Le), (tt.flags |= 4)),
                            tt.subtreeFlags = 0,
                            Le = _t,
                            Et = tt.child;
                          Et !== null;

                        )
                          (_t = Et),
                            (Rt = Le),
                            (_t.flags &= 14680066),
                            (Nt = _t.alternate),
                            Nt === null
                              ? ((_t.childLanes = 0),
                                (_t.lanes = Rt),
                                (_t.child = null),
                                (_t.subtreeFlags = 0),
                                (_t.memoizedProps = null),
                                (_t.memoizedState = null),
                                (_t.updateQueue = null),
                                (_t.dependencies = null),
                                (_t.stateNode = null))
                              : ((_t.childLanes = Nt.childLanes),
                                (_t.lanes = Nt.lanes),
                                (_t.child = Nt.child),
                                (_t.subtreeFlags = 0),
                                (_t.deletions = null),
                                (_t.memoizedProps = Nt.memoizedProps),
                                (_t.memoizedState = Nt.memoizedState),
                                (_t.updateQueue = Nt.updateQueue),
                                (_t.type = Nt.type),
                                (Rt = Nt.dependencies),
                                (_t.dependencies =
                                  Rt === null
                                    ? null
                                    : {
                                        lanes: Rt.lanes,
                                        firstContext: Rt.firstContext,
                                      })),
                            (Et = Et.sibling);
                        return gr(zi, (zi.current & 1) | 2), tt.child;
                      }
                      Le = Le.sibling;
                    }
                  Rt.tail !== null &&
                    ji() > sa &&
                    ((tt.flags |= 128),
                    (Et = !0),
                    ko(Rt, !1),
                    (tt.lanes = 4194304));
                }
              else {
                if (!Et)
                  if (((Le = _c(Nt)), Le !== null)) {
                    if (
                      ((tt.flags |= 128),
                      (Et = !0),
                      (Le = Le.updateQueue),
                      Le !== null && ((tt.updateQueue = Le), (tt.flags |= 4)),
                      ko(Rt, !0),
                      Rt.tail === null &&
                        Rt.tailMode === "hidden" &&
                        !Nt.alternate &&
                        !Ni)
                    )
                      return $i(tt), null;
                  } else
                    2 * ji() - Rt.renderingStartTime > sa &&
                      _t !== 1073741824 &&
                      ((tt.flags |= 128),
                      (Et = !0),
                      ko(Rt, !1),
                      (tt.lanes = 4194304));
                Rt.isBackwards
                  ? ((Nt.sibling = tt.child), (tt.child = Nt))
                  : ((Le = Rt.last),
                    Le !== null ? (Le.sibling = Nt) : (tt.child = Nt),
                    (Rt.last = Nt));
              }
              return Rt.tail !== null
                ? ((tt = Rt.tail),
                  (Rt.rendering = tt),
                  (Rt.tail = tt.sibling),
                  (Rt.renderingStartTime = ji()),
                  (tt.sibling = null),
                  (Le = zi.current),
                  gr(zi, Et ? (Le & 1) | 2 : Le & 1),
                  tt)
                : ($i(tt), null);
            case 22:
            case 23:
              return (
                Kl(),
                (Et = tt.memoizedState !== null),
                Le !== null &&
                  (Le.memoizedState !== null) !== Et &&
                  (tt.flags |= 8192),
                Et && (tt.mode & 1) !== 0
                  ? (gs & 1073741824) !== 0 &&
                    ($i(tt), ur && tt.subtreeFlags & 6 && (tt.flags |= 8192))
                  : $i(tt),
                null
              );
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(a(156, tt.tag));
        }
        var vu = l.ReactCurrentOwner,
          rs = !1;
        function Gi(Le, tt, _t, Et) {
          tt.child =
            Le === null ? Ku(tt, null, _t, Et) : Ro(tt, Le.child, _t, Et);
        }
        function ki(Le, tt, _t, Et, Rt) {
          _t = _t.render;
          var Nt = tt.ref;
          return (
            qa(tt, Rt),
            (Et = nl(Le, tt, _t, Et, Nt, Rt)),
            (_t = ea()),
            Le !== null && !rs
              ? ((tt.updateQueue = Le.updateQueue),
                (tt.flags &= -2053),
                (Le.lanes &= ~Rt),
                ks(Le, tt, Rt))
              : (Ni && _t && nu(tt),
                (tt.flags |= 1),
                Gi(Le, tt, Et, Rt),
                tt.child)
          );
        }
        function Ri(Le, tt, _t, Et, Rt) {
          if (Le === null) {
            var Nt = _t.type;
            return typeof Nt == "function" &&
              !Vc(Nt) &&
              Nt.defaultProps === void 0 &&
              _t.compare === null &&
              _t.defaultProps === void 0
              ? ((tt.tag = 15), (tt.type = Nt), Fo(Le, tt, Nt, Et, Rt))
              : ((Le = Gc(_t.type, null, Et, tt, tt.mode, Rt)),
                (Le.ref = tt.ref),
                (Le.return = tt),
                (tt.child = Le));
          }
          if (((Nt = Le.child), (Le.lanes & Rt) === 0)) {
            var Jt = Nt.memoizedProps;
            if (
              ((_t = _t.compare),
              (_t = _t !== null ? _t : Ps),
              _t(Jt, Et) && Le.ref === tt.ref)
            )
              return ks(Le, tt, Rt);
          }
          return (
            (tt.flags |= 1),
            (Le = Ho(Nt, Et)),
            (Le.ref = tt.ref),
            (Le.return = tt),
            (tt.child = Le)
          );
        }
        function Fo(Le, tt, _t, Et, Rt) {
          if (Le !== null && Ps(Le.memoizedProps, Et) && Le.ref === tt.ref)
            if (((rs = !1), (Le.lanes & Rt) !== 0))
              (Le.flags & 131072) !== 0 && (rs = !0);
            else return (tt.lanes = Le.lanes), ks(Le, tt, Rt);
          return Do(Le, tt, _t, Et, Rt);
        }
        function ls(Le, tt, _t) {
          var Et = tt.pendingProps,
            Rt = Et.children,
            Nt = Le !== null ? Le.memoizedState : null;
          if (Et.mode === "hidden")
            if ((tt.mode & 1) === 0)
              (tt.memoizedState = { baseLanes: 0, cachePool: null }),
                gr(Ia, gs),
                (gs |= _t);
            else if ((_t & 1073741824) !== 0)
              (tt.memoizedState = { baseLanes: 0, cachePool: null }),
                (Et = Nt !== null ? Nt.baseLanes : _t),
                gr(Ia, gs),
                (gs |= Et);
            else
              return (
                (Le = Nt !== null ? Nt.baseLanes | _t : _t),
                (tt.lanes = tt.childLanes = 1073741824),
                (tt.memoizedState = { baseLanes: Le, cachePool: null }),
                (tt.updateQueue = null),
                gr(Ia, gs),
                (gs |= Le),
                null
              );
          else
            Nt !== null
              ? ((Et = Nt.baseLanes | _t), (tt.memoizedState = null))
              : (Et = _t),
              gr(Ia, gs),
              (gs |= Et);
          return Gi(Le, tt, Rt, _t), tt.child;
        }
        function Es(Le, tt) {
          var _t = tt.ref;
          ((Le === null && _t !== null) || (Le !== null && Le.ref !== _t)) &&
            ((tt.flags |= 512), (tt.flags |= 2097152));
        }
        function Do(Le, tt, _t, Et, Rt) {
          var Nt = oi(_t) ? Br : Qr.current;
          return (
            (Nt = Mr(tt, Nt)),
            qa(tt, Rt),
            (_t = nl(Le, tt, _t, Et, Nt, Rt)),
            (Et = ea()),
            Le !== null && !rs
              ? ((tt.updateQueue = Le.updateQueue),
                (tt.flags &= -2053),
                (Le.lanes &= ~Rt),
                ks(Le, tt, Rt))
              : (Ni && Et && nu(tt),
                (tt.flags |= 1),
                Gi(Le, tt, _t, Rt),
                tt.child)
          );
        }
        function Ea(Le, tt, _t, Et, Rt) {
          if (oi(_t)) {
            var Nt = !0;
            ni(tt);
          } else Nt = !1;
          if ((qa(tt, Rt), tt.stateNode === null))
            Le !== null &&
              ((Le.alternate = null), (tt.alternate = null), (tt.flags |= 2)),
              ju(tt, _t, Et),
              tu(tt, _t, Et, Rt),
              (Et = !0);
          else if (Le === null) {
            var Jt = tt.stateNode,
              vn = tt.memoizedProps;
            Jt.props = vn;
            var Wn = Jt.context,
              dr = _t.contextType;
            typeof dr == "object" && dr !== null
              ? (dr = Is(dr))
              : ((dr = oi(_t) ? Br : Qr.current), (dr = Mr(tt, dr)));
            var kr = _t.getDerivedStateFromProps,
              ii =
                typeof kr == "function" ||
                typeof Jt.getSnapshotBeforeUpdate == "function";
            ii ||
              (typeof Jt.UNSAFE_componentWillReceiveProps != "function" &&
                typeof Jt.componentWillReceiveProps != "function") ||
              ((vn !== Et || Wn !== dr) && $u(tt, Jt, Et, dr)),
              (Ys = !1);
            var Zr = tt.memoizedState;
            (Jt.state = Zr),
              fc(tt, Et, Jt, Rt),
              (Wn = tt.memoizedState),
              vn !== Et || Zr !== Wn || Dr.current || Ys
                ? (typeof kr == "function" &&
                    (Jc(tt, _t, kr, Et), (Wn = tt.memoizedState)),
                  (vn = Ys || eu(tt, _t, vn, Et, Zr, Wn, dr))
                    ? (ii ||
                        (typeof Jt.UNSAFE_componentWillMount != "function" &&
                          typeof Jt.componentWillMount != "function") ||
                        (typeof Jt.componentWillMount == "function" &&
                          Jt.componentWillMount(),
                        typeof Jt.UNSAFE_componentWillMount == "function" &&
                          Jt.UNSAFE_componentWillMount()),
                      typeof Jt.componentDidMount == "function" &&
                        (tt.flags |= 4194308))
                    : (typeof Jt.componentDidMount == "function" &&
                        (tt.flags |= 4194308),
                      (tt.memoizedProps = Et),
                      (tt.memoizedState = Wn)),
                  (Jt.props = Et),
                  (Jt.state = Wn),
                  (Jt.context = dr),
                  (Et = vn))
                : (typeof Jt.componentDidMount == "function" &&
                    (tt.flags |= 4194308),
                  (Et = !1));
          } else {
            (Jt = tt.stateNode),
              Qc(Le, tt),
              (vn = tt.memoizedProps),
              (dr = tt.type === tt.elementType ? vn : Rs(tt.type, vn)),
              (Jt.props = dr),
              (ii = tt.pendingProps),
              (Zr = Jt.context),
              (Wn = _t.contextType),
              typeof Wn == "object" && Wn !== null
                ? (Wn = Is(Wn))
                : ((Wn = oi(_t) ? Br : Qr.current), (Wn = Mr(tt, Wn)));
            var hi = _t.getDerivedStateFromProps;
            (kr =
              typeof hi == "function" ||
              typeof Jt.getSnapshotBeforeUpdate == "function") ||
              (typeof Jt.UNSAFE_componentWillReceiveProps != "function" &&
                typeof Jt.componentWillReceiveProps != "function") ||
              ((vn !== ii || Zr !== Wn) && $u(tt, Jt, Et, Wn)),
              (Ys = !1),
              (Zr = tt.memoizedState),
              (Jt.state = Zr),
              fc(tt, Et, Jt, Rt);
            var Ar = tt.memoizedState;
            vn !== ii || Zr !== Ar || Dr.current || Ys
              ? (typeof hi == "function" &&
                  (Jc(tt, _t, hi, Et), (Ar = tt.memoizedState)),
                (dr = Ys || eu(tt, _t, dr, Et, Zr, Ar, Wn) || !1)
                  ? (kr ||
                      (typeof Jt.UNSAFE_componentWillUpdate != "function" &&
                        typeof Jt.componentWillUpdate != "function") ||
                      (typeof Jt.componentWillUpdate == "function" &&
                        Jt.componentWillUpdate(Et, Ar, Wn),
                      typeof Jt.UNSAFE_componentWillUpdate == "function" &&
                        Jt.UNSAFE_componentWillUpdate(Et, Ar, Wn)),
                    typeof Jt.componentDidUpdate == "function" &&
                      (tt.flags |= 4),
                    typeof Jt.getSnapshotBeforeUpdate == "function" &&
                      (tt.flags |= 1024))
                  : (typeof Jt.componentDidUpdate != "function" ||
                      (vn === Le.memoizedProps && Zr === Le.memoizedState) ||
                      (tt.flags |= 4),
                    typeof Jt.getSnapshotBeforeUpdate != "function" ||
                      (vn === Le.memoizedProps && Zr === Le.memoizedState) ||
                      (tt.flags |= 1024),
                    (tt.memoizedProps = Et),
                    (tt.memoizedState = Ar)),
                (Jt.props = Et),
                (Jt.state = Ar),
                (Jt.context = Wn),
                (Et = dr))
              : (typeof Jt.componentDidUpdate != "function" ||
                  (vn === Le.memoizedProps && Zr === Le.memoizedState) ||
                  (tt.flags |= 4),
                typeof Jt.getSnapshotBeforeUpdate != "function" ||
                  (vn === Le.memoizedProps && Zr === Le.memoizedState) ||
                  (tt.flags |= 1024),
                (Et = !1));
          }
          return ms(Le, tt, _t, Et, Nt, Rt);
        }
        function ms(Le, tt, _t, Et, Rt, Nt) {
          Es(Le, tt);
          var Jt = (tt.flags & 128) !== 0;
          if (!Et && !Jt) return Rt && ai(tt, _t, !1), ks(Le, tt, Nt);
          (Et = tt.stateNode), (vu.current = tt);
          var vn =
            Jt && typeof _t.getDerivedStateFromError != "function"
              ? null
              : Et.render();
          return (
            (tt.flags |= 1),
            Le !== null && Jt
              ? ((tt.child = Ro(tt, Le.child, null, Nt)),
                (tt.child = Ro(tt, null, vn, Nt)))
              : Gi(Le, tt, vn, Nt),
            (tt.memoizedState = Et.state),
            Rt && ai(tt, _t, !0),
            tt.child
          );
        }
        function Nl(Le) {
          var tt = Le.stateNode;
          tt.pendingContext
            ? ti(Le, tt.pendingContext, tt.pendingContext !== tt.context)
            : tt.context && ti(Le, tt.context, !1),
            vc(Le, tt.containerInfo);
        }
        function _u(Le, tt, _t, Et, Rt) {
          return Za(), gc(Rt), (tt.flags |= 256), Gi(Le, tt, _t, Et), tt.child;
        }
        var Bl = { dehydrated: null, treeContext: null, retryLane: 0 };
        function Ta(Le) {
          return { baseLanes: Le, cachePool: null };
        }
        function yu(Le, tt, _t) {
          var Et = tt.pendingProps,
            Rt = zi.current,
            Nt = !1,
            Jt = (tt.flags & 128) !== 0,
            vn;
          if (
            ((vn = Jt) ||
              (vn =
                Le !== null && Le.memoizedState === null ? !1 : (Rt & 2) !== 0),
            vn
              ? ((Nt = !0), (tt.flags &= -129))
              : (Le === null || Le.memoizedState !== null) && (Rt |= 1),
            gr(zi, Rt & 1),
            Le === null)
          )
            return (
              Qo(tt),
              (Le = tt.memoizedState),
              Le !== null && ((Le = Le.dehydrated), Le !== null)
                ? ((tt.mode & 1) === 0
                    ? (tt.lanes = 1)
                    : zr(Le)
                    ? (tt.lanes = 8)
                    : (tt.lanes = 1073741824),
                  null)
                : ((Rt = Et.children),
                  (Le = Et.fallback),
                  Nt
                    ? ((Et = tt.mode),
                      (Nt = tt.child),
                      (Rt = { mode: "hidden", children: Rt }),
                      (Et & 1) === 0 && Nt !== null
                        ? ((Nt.childLanes = 0), (Nt.pendingProps = Rt))
                        : (Nt = Jl(Rt, Et, 0, null)),
                      (Le = Oa(Le, Et, _t, null)),
                      (Nt.return = tt),
                      (Le.return = tt),
                      (Nt.sibling = Le),
                      (tt.child = Nt),
                      (tt.child.memoizedState = Ta(_t)),
                      (tt.memoizedState = Bl),
                      Le)
                    : ao(tt, Rt))
            );
          if (((Rt = Le.memoizedState), Rt !== null)) {
            if (((vn = Rt.dehydrated), vn !== null)) {
              if (Jt)
                return tt.flags & 256
                  ? ((tt.flags &= -257), zl(Le, tt, _t, Error(a(422))))
                  : tt.memoizedState !== null
                  ? ((tt.child = Le.child), (tt.flags |= 128), null)
                  : ((Nt = Et.fallback),
                    (Rt = tt.mode),
                    (Et = Jl(
                      { mode: "visible", children: Et.children },
                      Rt,
                      0,
                      null
                    )),
                    (Nt = Oa(Nt, Rt, _t, null)),
                    (Nt.flags |= 2),
                    (Et.return = tt),
                    (Nt.return = tt),
                    (Et.sibling = Nt),
                    (tt.child = Et),
                    (tt.mode & 1) !== 0 && Ro(tt, Le.child, null, _t),
                    (tt.child.memoizedState = Ta(_t)),
                    (tt.memoizedState = Bl),
                    Nt);
              if ((tt.mode & 1) === 0) tt = zl(Le, tt, _t, null);
              else if (zr(vn)) tt = zl(Le, tt, _t, Error(a(419)));
              else if (((Et = (_t & Le.childLanes) !== 0), rs || Et)) {
                if (((Et = qi), Et !== null)) {
                  switch (_t & -_t) {
                    case 4:
                      Nt = 2;
                      break;
                    case 16:
                      Nt = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      Nt = 32;
                      break;
                    case 536870912:
                      Nt = 268435456;
                      break;
                    default:
                      Nt = 0;
                  }
                  (Et = (Nt & (Et.suspendedLanes | _t)) !== 0 ? 0 : Nt),
                    Et !== 0 &&
                      Et !== Rt.retryLane &&
                      ((Rt.retryLane = Et), vs(Le, Et, -1));
                }
                Uc(), (tt = zl(Le, tt, _t, Error(a(421))));
              } else
                Cr(vn)
                  ? ((tt.flags |= 128),
                    (tt.child = Le.child),
                    (tt = af.bind(null, Le)),
                    pi(vn, tt),
                    (tt = null))
                  : ((_t = Rt.treeContext),
                    Bn &&
                      ((as = mi(vn)),
                      (ws = tt),
                      (Ni = !0),
                      (Zs = null),
                      (Ka = !1),
                      _t !== null &&
                        ((Ks[Ns++] = Ao),
                        (Ks[Ns++] = Po),
                        (Ks[Ns++] = ha),
                        (Ao = _t.id),
                        (Po = _t.overflow),
                        (ha = tt))),
                    (tt = ao(tt, tt.pendingProps.children)),
                    (tt.flags |= 4096));
              return tt;
            }
            return Nt
              ? ((Et = kc(Le, tt, Et.children, Et.fallback, _t)),
                (Nt = tt.child),
                (Rt = Le.child.memoizedState),
                (Nt.memoizedState =
                  Rt === null
                    ? Ta(_t)
                    : { baseLanes: Rt.baseLanes | _t, cachePool: null }),
                (Nt.childLanes = Le.childLanes & ~_t),
                (tt.memoizedState = Bl),
                Et)
              : ((_t = Ul(Le, tt, Et.children, _t)),
                (tt.memoizedState = null),
                _t);
          }
          return Nt
            ? ((Et = kc(Le, tt, Et.children, Et.fallback, _t)),
              (Nt = tt.child),
              (Rt = Le.child.memoizedState),
              (Nt.memoizedState =
                Rt === null
                  ? Ta(_t)
                  : { baseLanes: Rt.baseLanes | _t, cachePool: null }),
              (Nt.childLanes = Le.childLanes & ~_t),
              (tt.memoizedState = Bl),
              Et)
            : ((_t = Ul(Le, tt, Et.children, _t)),
              (tt.memoizedState = null),
              _t);
        }
        function ao(Le, tt) {
          return (
            (tt = Jl({ mode: "visible", children: tt }, Le.mode, 0, null)),
            (tt.return = Le),
            (Le.child = tt)
          );
        }
        function Ul(Le, tt, _t, Et) {
          var Rt = Le.child;
          return (
            (Le = Rt.sibling),
            (_t = Ho(Rt, { mode: "visible", children: _t })),
            (tt.mode & 1) === 0 && (_t.lanes = Et),
            (_t.return = tt),
            (_t.sibling = null),
            Le !== null &&
              ((Et = tt.deletions),
              Et === null
                ? ((tt.deletions = [Le]), (tt.flags |= 16))
                : Et.push(Le)),
            (tt.child = _t)
          );
        }
        function kc(Le, tt, _t, Et, Rt) {
          var Nt = tt.mode;
          Le = Le.child;
          var Jt = Le.sibling,
            vn = { mode: "hidden", children: _t };
          return (
            (Nt & 1) === 0 && tt.child !== Le
              ? ((_t = tt.child),
                (_t.childLanes = 0),
                (_t.pendingProps = vn),
                (tt.deletions = null))
              : ((_t = Ho(Le, vn)),
                (_t.subtreeFlags = Le.subtreeFlags & 14680064)),
            Jt !== null
              ? (Et = Ho(Jt, Et))
              : ((Et = Oa(Et, Nt, Rt, null)), (Et.flags |= 2)),
            (Et.return = tt),
            (_t.return = tt),
            (_t.sibling = Et),
            (tt.child = _t),
            Et
          );
        }
        function zl(Le, tt, _t, Et) {
          return (
            Et !== null && gc(Et),
            Ro(tt, Le.child, null, _t),
            (Le = ao(tt, tt.pendingProps.children)),
            (Le.flags |= 2),
            (tt.memoizedState = null),
            Le
          );
        }
        function nf(Le, tt, _t) {
          Le.lanes |= tt;
          var Et = Le.alternate;
          Et !== null && (Et.lanes |= tt), fa(Le.return, tt, _t);
        }
        function vo(Le, tt, _t, Et, Rt) {
          var Nt = Le.memoizedState;
          Nt === null
            ? (Le.memoizedState = {
                isBackwards: tt,
                rendering: null,
                renderingStartTime: 0,
                last: Et,
                tail: _t,
                tailMode: Rt,
              })
            : ((Nt.isBackwards = tt),
              (Nt.rendering = null),
              (Nt.renderingStartTime = 0),
              (Nt.last = Et),
              (Nt.tail = _t),
              (Nt.tailMode = Rt));
        }
        function ba(Le, tt, _t) {
          var Et = tt.pendingProps,
            Rt = Et.revealOrder,
            Nt = Et.tail;
          if ((Gi(Le, tt, Et.children, _t), (Et = zi.current), (Et & 2) !== 0))
            (Et = (Et & 1) | 2), (tt.flags |= 128);
          else {
            if (Le !== null && (Le.flags & 128) !== 0)
              e: for (Le = tt.child; Le !== null; ) {
                if (Le.tag === 13) Le.memoizedState !== null && nf(Le, _t, tt);
                else if (Le.tag === 19) nf(Le, _t, tt);
                else if (Le.child !== null) {
                  (Le.child.return = Le), (Le = Le.child);
                  continue;
                }
                if (Le === tt) break e;
                for (; Le.sibling === null; ) {
                  if (Le.return === null || Le.return === tt) break e;
                  Le = Le.return;
                }
                (Le.sibling.return = Le.return), (Le = Le.sibling);
              }
            Et &= 1;
          }
          if ((gr(zi, Et), (tt.mode & 1) === 0)) tt.memoizedState = null;
          else
            switch (Rt) {
              case "forwards":
                for (_t = tt.child, Rt = null; _t !== null; )
                  (Le = _t.alternate),
                    Le !== null && _c(Le) === null && (Rt = _t),
                    (_t = _t.sibling);
                (_t = Rt),
                  _t === null
                    ? ((Rt = tt.child), (tt.child = null))
                    : ((Rt = _t.sibling), (_t.sibling = null)),
                  vo(tt, !1, Rt, _t, Nt);
                break;
              case "backwards":
                for (_t = null, Rt = tt.child, tt.child = null; Rt !== null; ) {
                  if (((Le = Rt.alternate), Le !== null && _c(Le) === null)) {
                    tt.child = Rt;
                    break;
                  }
                  (Le = Rt.sibling), (Rt.sibling = _t), (_t = Rt), (Rt = Le);
                }
                vo(tt, !0, _t, null, Nt);
                break;
              case "together":
                vo(tt, !1, null, null, void 0);
                break;
              default:
                tt.memoizedState = null;
            }
          return tt.child;
        }
        function ks(Le, tt, _t) {
          if (
            (Le !== null && (tt.dependencies = Le.dependencies),
            (_o |= tt.lanes),
            (_t & tt.childLanes) === 0)
          )
            return null;
          if (Le !== null && tt.child !== Le.child) throw Error(a(153));
          if (tt.child !== null) {
            for (
              Le = tt.child,
                _t = Ho(Le, Le.pendingProps),
                tt.child = _t,
                _t.return = tt;
              Le.sibling !== null;

            )
              (Le = Le.sibling),
                (_t = _t.sibling = Ho(Le, Le.pendingProps)),
                (_t.return = tt);
            _t.sibling = null;
          }
          return tt.child;
        }
        function Fc(Le, tt, _t) {
          switch (tt.tag) {
            case 3:
              Nl(tt), Za();
              break;
            case 5:
              Zu(tt);
              break;
            case 1:
              oi(tt.type) && ni(tt);
              break;
            case 4:
              vc(tt, tt.stateNode.containerInfo);
              break;
            case 10:
              ua(tt, tt.type._context, tt.memoizedProps.value);
              break;
            case 13:
              var Et = tt.memoizedState;
              if (Et !== null)
                return Et.dehydrated !== null
                  ? (gr(zi, zi.current & 1), (tt.flags |= 128), null)
                  : (_t & tt.child.childLanes) !== 0
                  ? yu(Le, tt, _t)
                  : (gr(zi, zi.current & 1),
                    (Le = ks(Le, tt, _t)),
                    Le !== null ? Le.sibling : null);
              gr(zi, zi.current & 1);
              break;
            case 19:
              if (((Et = (_t & tt.childLanes) !== 0), (Le.flags & 128) !== 0)) {
                if (Et) return ba(Le, tt, _t);
                tt.flags |= 128;
              }
              var Rt = tt.memoizedState;
              if (
                (Rt !== null &&
                  ((Rt.rendering = null),
                  (Rt.tail = null),
                  (Rt.lastEffect = null)),
                gr(zi, zi.current),
                Et)
              )
                break;
              return null;
            case 22:
            case 23:
              return (tt.lanes = 0), ls(Le, tt, _t);
          }
          return ks(Le, tt, _t);
        }
        function Dc(Le, tt) {
          switch ((ru(tt), tt.tag)) {
            case 1:
              return (
                oi(tt.type) && Xr(),
                (Le = tt.flags),
                Le & 65536 ? ((tt.flags = (Le & -65537) | 128), tt) : null
              );
            case 3:
              return (
                tl(),
                Qn(Dr),
                Qn(Qr),
                ga(),
                (Le = tt.flags),
                (Le & 65536) !== 0 && (Le & 128) === 0
                  ? ((tt.flags = (Le & -65537) | 128), tt)
                  : null
              );
            case 5:
              return ou(tt), null;
            case 13:
              if (
                (Qn(zi),
                (Le = tt.memoizedState),
                Le !== null && Le.dehydrated !== null)
              ) {
                if (tt.alternate === null) throw Error(a(340));
                Za();
              }
              return (
                (Le = tt.flags),
                Le & 65536 ? ((tt.flags = (Le & -65537) | 128), tt) : null
              );
            case 19:
              return Qn(zi), null;
            case 4:
              return tl(), null;
            case 10:
              return Ml(tt.type._context), null;
            case 22:
            case 23:
              return Kl(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Ts = !1,
          ss = !1,
          Ma = typeof WeakSet == "function" ? WeakSet : Set,
          Er = null;
        function Qs(Le, tt) {
          var _t = Le.ref;
          if (_t !== null)
            if (typeof _t == "function")
              try {
                _t(null);
              } catch (Et) {
                Ms(Le, tt, Et);
              }
            else _t.current = null;
        }
        function Oo(Le, tt, _t) {
          try {
            _t();
          } catch (Et) {
            Ms(Le, tt, Et);
          }
        }
        var xu = !1;
        function Su(Le, tt) {
          for (Pt(Le.containerInfo), Er = tt; Er !== null; )
            if (
              ((Le = Er),
              (tt = Le.child),
              (Le.subtreeFlags & 1028) !== 0 && tt !== null)
            )
              (tt.return = Le), (Er = tt);
            else
              for (; Er !== null; ) {
                Le = Er;
                try {
                  var _t = Le.alternate;
                  if ((Le.flags & 1024) !== 0)
                    switch (Le.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (_t !== null) {
                          var Et = _t.memoizedProps,
                            Rt = _t.memoizedState,
                            Nt = Le.stateNode,
                            Jt = Nt.getSnapshotBeforeUpdate(
                              Le.elementType === Le.type ? Et : Rs(Le.type, Et),
                              Rt
                            );
                          Nt.__reactInternalSnapshotBeforeUpdate = Jt;
                        }
                        break;
                      case 3:
                        ur && Hn(Le.stateNode.containerInfo);
                        break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        throw Error(a(163));
                    }
                } catch (vn) {
                  Ms(Le, Le.return, vn);
                }
                if (((tt = Le.sibling), tt !== null)) {
                  (tt.return = Le.return), (Er = tt);
                  break;
                }
                Er = Le.return;
              }
          return (_t = xu), (xu = !1), _t;
        }
        function No(Le, tt, _t) {
          var Et = tt.updateQueue;
          if (((Et = Et !== null ? Et.lastEffect : null), Et !== null)) {
            var Rt = (Et = Et.next);
            do {
              if ((Rt.tag & Le) === Le) {
                var Nt = Rt.destroy;
                (Rt.destroy = void 0), Nt !== void 0 && Oo(tt, _t, Nt);
              }
              Rt = Rt.next;
            } while (Rt !== Et);
          }
        }
        function cs(Le, tt) {
          if (
            ((tt = tt.updateQueue),
            (tt = tt !== null ? tt.lastEffect : null),
            tt !== null)
          ) {
            var _t = (tt = tt.next);
            do {
              if ((_t.tag & Le) === Le) {
                var Et = _t.create;
                _t.destroy = Et();
              }
              _t = _t.next;
            } while (_t !== tt);
          }
        }
        function bs(Le) {
          var tt = Le.ref;
          if (tt !== null) {
            var _t = Le.stateNode;
            switch (Le.tag) {
              case 5:
                Le = Ft(_t);
                break;
              default:
                Le = _t;
            }
            typeof tt == "function" ? tt(Le) : (tt.current = Le);
          }
        }
        function Di(Le, tt, _t) {
          if (ln && typeof ln.onCommitFiberUnmount == "function")
            try {
              ln.onCommitFiberUnmount(en, tt);
            } catch {}
          switch (tt.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                ((Le = tt.updateQueue),
                Le !== null && ((Le = Le.lastEffect), Le !== null))
              ) {
                var Et = (Le = Le.next);
                do {
                  var Rt = Et,
                    Nt = Rt.destroy;
                  (Rt = Rt.tag),
                    Nt !== void 0 &&
                      ((Rt & 2) !== 0 || (Rt & 4) !== 0) &&
                      Oo(tt, _t, Nt),
                    (Et = Et.next);
                } while (Et !== Le);
              }
              break;
            case 1:
              if (
                (Qs(tt, _t),
                (Le = tt.stateNode),
                typeof Le.componentWillUnmount == "function")
              )
                try {
                  (Le.props = tt.memoizedProps),
                    (Le.state = tt.memoizedState),
                    Le.componentWillUnmount();
                } catch (Jt) {
                  Ms(tt, _t, Jt);
                }
              break;
            case 5:
              Qs(tt, _t);
              break;
            case 4:
              ur
                ? Tu(Le, tt, _t)
                : _r &&
                  _r &&
                  ((tt = tt.stateNode.containerInfo),
                  (_t = pr(tt)),
                  wi(tt, _t));
          }
        }
        function Js(Le, tt, _t) {
          for (var Et = tt; ; )
            if ((Di(Le, Et, _t), Et.child === null || (ur && Et.tag === 4))) {
              if (Et === tt) break;
              for (; Et.sibling === null; ) {
                if (Et.return === null || Et.return === tt) return;
                Et = Et.return;
              }
              (Et.sibling.return = Et.return), (Et = Et.sibling);
            } else (Et.child.return = Et), (Et = Et.child);
        }
        function wu(Le) {
          var tt = Le.alternate;
          tt !== null && ((Le.alternate = null), wu(tt)),
            (Le.child = null),
            (Le.deletions = null),
            (Le.sibling = null),
            Le.tag === 5 && ((tt = Le.stateNode), tt !== null && rn(tt)),
            (Le.stateNode = null),
            (Le.return = null),
            (Le.dependencies = null),
            (Le.memoizedProps = null),
            (Le.memoizedState = null),
            (Le.pendingProps = null),
            (Le.stateNode = null),
            (Le.updateQueue = null);
        }
        function Eu(Le) {
          return Le.tag === 5 || Le.tag === 3 || Le.tag === 4;
        }
        function Oc(Le) {
          e: for (;;) {
            for (; Le.sibling === null; ) {
              if (Le.return === null || Eu(Le.return)) return null;
              Le = Le.return;
            }
            for (
              Le.sibling.return = Le.return, Le = Le.sibling;
              Le.tag !== 5 && Le.tag !== 6 && Le.tag !== 18;

            ) {
              if (Le.flags & 2 || Le.child === null || Le.tag === 4) continue e;
              (Le.child.return = Le), (Le = Le.child);
            }
            if (!(Le.flags & 2)) return Le.stateNode;
          }
        }
        function Nc(Le) {
          if (ur) {
            e: {
              for (var tt = Le.return; tt !== null; ) {
                if (Eu(tt)) break e;
                tt = tt.return;
              }
              throw Error(a(160));
            }
            var _t = tt;
            switch (_t.tag) {
              case 5:
                (tt = _t.stateNode),
                  _t.flags & 32 && (Pr(tt), (_t.flags &= -33)),
                  (_t = Oc(Le)),
                  ll(Le, _t, tt);
                break;
              case 3:
              case 4:
                (tt = _t.stateNode.containerInfo),
                  (_t = Oc(Le)),
                  Bc(Le, _t, tt);
                break;
              default:
                throw Error(a(161));
            }
          }
        }
        function Bc(Le, tt, _t) {
          var Et = Le.tag;
          if (Et === 5 || Et === 6)
            (Le = Le.stateNode), tt ? mr(_t, Le, tt) : nr(_t, Le);
          else if (Et !== 4 && ((Le = Le.child), Le !== null))
            for (Bc(Le, tt, _t), Le = Le.sibling; Le !== null; )
              Bc(Le, tt, _t), (Le = Le.sibling);
        }
        function ll(Le, tt, _t) {
          var Et = Le.tag;
          if (Et === 5 || Et === 6)
            (Le = Le.stateNode), tt ? Jn(_t, Le, tt) : Fn(_t, Le);
          else if (Et !== 4 && ((Le = Le.child), Le !== null))
            for (ll(Le, tt, _t), Le = Le.sibling; Le !== null; )
              ll(Le, tt, _t), (Le = Le.sibling);
        }
        function Tu(Le, tt, _t) {
          for (var Et = tt, Rt = !1, Nt, Jt; ; ) {
            if (!Rt) {
              Rt = Et.return;
              e: for (;;) {
                if (Rt === null) throw Error(a(160));
                switch (((Nt = Rt.stateNode), Rt.tag)) {
                  case 5:
                    Jt = !1;
                    break e;
                  case 3:
                    (Nt = Nt.containerInfo), (Jt = !0);
                    break e;
                  case 4:
                    (Nt = Nt.containerInfo), (Jt = !0);
                    break e;
                }
                Rt = Rt.return;
              }
              Rt = !0;
            }
            if (Et.tag === 5 || Et.tag === 6)
              Js(Le, Et, _t), Jt ? Ur(Nt, Et.stateNode) : Sr(Nt, Et.stateNode);
            else if (Et.tag === 18)
              Jt ? Xn(Nt, Et.stateNode) : er(Nt, Et.stateNode);
            else if (Et.tag === 4) {
              if (Et.child !== null) {
                (Nt = Et.stateNode.containerInfo),
                  (Jt = !0),
                  (Et.child.return = Et),
                  (Et = Et.child);
                continue;
              }
            } else if ((Di(Le, Et, _t), Et.child !== null)) {
              (Et.child.return = Et), (Et = Et.child);
              continue;
            }
            if (Et === tt) break;
            for (; Et.sibling === null; ) {
              if (Et.return === null || Et.return === tt) return;
              (Et = Et.return), Et.tag === 4 && (Rt = !1);
            }
            (Et.sibling.return = Et.return), (Et = Et.sibling);
          }
        }
        function ra(Le, tt) {
          if (ur) {
            switch (tt.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                No(3, tt, tt.return), cs(3, tt), No(5, tt, tt.return);
                return;
              case 1:
                return;
              case 5:
                var _t = tt.stateNode;
                if (_t != null) {
                  var Et = tt.memoizedProps;
                  Le = Le !== null ? Le.memoizedProps : Et;
                  var Rt = tt.type,
                    Nt = tt.updateQueue;
                  (tt.updateQueue = null),
                    Nt !== null && jn(_t, Nt, Rt, Le, Et, tt);
                }
                return;
              case 6:
                if (tt.stateNode === null) throw Error(a(162));
                (_t = tt.memoizedProps),
                  yr(tt.stateNode, Le !== null ? Le.memoizedProps : _t, _t);
                return;
              case 3:
                Bn &&
                  Le !== null &&
                  Le.memoizedState.isDehydrated &&
                  Rn(tt.stateNode.containerInfo);
                return;
              case 12:
                return;
              case 13:
                cl(tt);
                return;
              case 19:
                cl(tt);
                return;
              case 17:
                return;
            }
            throw Error(a(163));
          }
          switch (tt.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              No(3, tt, tt.return), cs(3, tt), No(5, tt, tt.return);
              return;
            case 12:
              return;
            case 13:
              cl(tt);
              return;
            case 19:
              cl(tt);
              return;
            case 3:
              Bn &&
                Le !== null &&
                Le.memoizedState.isDehydrated &&
                Rn(tt.stateNode.containerInfo);
              break;
            case 22:
            case 23:
              return;
          }
          e: if (_r) {
            switch (tt.tag) {
              case 1:
              case 5:
              case 6:
                break e;
              case 3:
              case 4:
                (tt = tt.stateNode), wi(tt.containerInfo, tt.pendingChildren);
                break e;
            }
            throw Error(a(163));
          }
        }
        function cl(Le) {
          var tt = Le.updateQueue;
          if (tt !== null) {
            Le.updateQueue = null;
            var _t = Le.stateNode;
            _t === null && (_t = Le.stateNode = new Ma()),
              tt.forEach(function (Et) {
                var Rt = lf.bind(null, Le, Et);
                _t.has(Et) || (_t.add(Et), Et.then(Rt, Rt));
              });
          }
        }
        function Of(Le, tt) {
          for (Er = tt; Er !== null; ) {
            tt = Er;
            var _t = tt.deletions;
            if (_t !== null)
              for (var Et = 0; Et < _t.length; Et++) {
                var Rt = _t[Et];
                try {
                  var Nt = Le;
                  ur ? Tu(Nt, Rt, tt) : Js(Nt, Rt, tt);
                  var Jt = Rt.alternate;
                  Jt !== null && (Jt.return = null), (Rt.return = null);
                } catch (Gr) {
                  Ms(Rt, tt, Gr);
                }
              }
            if (
              ((_t = tt.child), (tt.subtreeFlags & 12854) !== 0 && _t !== null)
            )
              (_t.return = tt), (Er = _t);
            else
              for (; Er !== null; ) {
                tt = Er;
                try {
                  var vn = tt.flags;
                  if ((vn & 32 && ur && Pr(tt.stateNode), vn & 512)) {
                    var Wn = tt.alternate;
                    if (Wn !== null) {
                      var dr = Wn.ref;
                      dr !== null &&
                        (typeof dr == "function"
                          ? dr(null)
                          : (dr.current = null));
                    }
                  }
                  if (vn & 8192)
                    switch (tt.tag) {
                      case 13:
                        if (tt.memoizedState !== null) {
                          var kr = tt.alternate;
                          (kr === null || kr.memoizedState === null) &&
                            (ql = ji());
                        }
                        break;
                      case 22:
                        var ii = tt.memoizedState !== null,
                          Zr = tt.alternate,
                          hi = Zr !== null && Zr.memoizedState !== null;
                        if (((_t = tt), ur)) {
                          e: if (((Et = _t), (Rt = ii), (Nt = null), ur))
                            for (var Ar = Et; ; ) {
                              if (Ar.tag === 5) {
                                if (Nt === null) {
                                  Nt = Ar;
                                  var hs = Ar.stateNode;
                                  Rt
                                    ? Hr(hs)
                                    : An(Ar.stateNode, Ar.memoizedProps);
                                }
                              } else if (Ar.tag === 6) {
                                if (Nt === null) {
                                  var js = Ar.stateNode;
                                  Rt ? cn(js) : Mn(js, Ar.memoizedProps);
                                }
                              } else if (
                                ((Ar.tag !== 22 && Ar.tag !== 23) ||
                                  Ar.memoizedState === null ||
                                  Ar === Et) &&
                                Ar.child !== null
                              ) {
                                (Ar.child.return = Ar), (Ar = Ar.child);
                                continue;
                              }
                              if (Ar === Et) break;
                              for (; Ar.sibling === null; ) {
                                if (Ar.return === null || Ar.return === Et)
                                  break e;
                                Nt === Ar && (Nt = null), (Ar = Ar.return);
                              }
                              Nt === Ar && (Nt = null),
                                (Ar.sibling.return = Ar.return),
                                (Ar = Ar.sibling);
                            }
                        }
                        if (ii && !hi && (_t.mode & 1) !== 0) {
                          Er = _t;
                          for (var Pn = _t.child; Pn !== null; ) {
                            for (_t = Er = Pn; Er !== null; ) {
                              Et = Er;
                              var xn = Et.child;
                              switch (Et.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  No(4, Et, Et.return);
                                  break;
                                case 1:
                                  Qs(Et, Et.return);
                                  var Nn = Et.stateNode;
                                  if (
                                    typeof Nn.componentWillUnmount == "function"
                                  ) {
                                    var br = Et.return;
                                    try {
                                      (Nn.props = Et.memoizedProps),
                                        (Nn.state = Et.memoizedState),
                                        Nn.componentWillUnmount();
                                    } catch (Gr) {
                                      Ms(Et, br, Gr);
                                    }
                                  }
                                  break;
                                case 5:
                                  Qs(Et, Et.return);
                                  break;
                                case 22:
                                  if (Et.memoizedState !== null) {
                                    Mu(_t);
                                    continue;
                                  }
                              }
                              xn !== null
                                ? ((xn.return = Et), (Er = xn))
                                : Mu(_t);
                            }
                            Pn = Pn.sibling;
                          }
                        }
                    }
                  switch (vn & 4102) {
                    case 2:
                      Nc(tt), (tt.flags &= -3);
                      break;
                    case 6:
                      Nc(tt), (tt.flags &= -3), ra(tt.alternate, tt);
                      break;
                    case 4096:
                      tt.flags &= -4097;
                      break;
                    case 4100:
                      (tt.flags &= -4097), ra(tt.alternate, tt);
                      break;
                    case 4:
                      ra(tt.alternate, tt);
                  }
                } catch (Gr) {
                  Ms(tt, tt.return, Gr);
                }
                if (((_t = tt.sibling), _t !== null)) {
                  (_t.return = tt.return), (Er = _t);
                  break;
                }
                Er = tt.return;
              }
          }
        }
        function Vl(Le, tt, _t) {
          (Er = Le), Gl(Le);
        }
        function Gl(Le, tt, _t) {
          for (var Et = (Le.mode & 1) !== 0; Er !== null; ) {
            var Rt = Er,
              Nt = Rt.child;
            if (Rt.tag === 22 && Et) {
              var Jt = Rt.memoizedState !== null || Ts;
              if (!Jt) {
                var vn = Rt.alternate,
                  Wn = (vn !== null && vn.memoizedState !== null) || ss;
                vn = Ts;
                var dr = ss;
                if (((Ts = Jt), (ss = Wn) && !dr))
                  for (Er = Rt; Er !== null; )
                    (Jt = Er),
                      (Wn = Jt.child),
                      Jt.tag === 22 && Jt.memoizedState !== null
                        ? Ca(Rt)
                        : Wn !== null
                        ? ((Wn.return = Jt), (Er = Wn))
                        : Ca(Rt);
                for (; Nt !== null; ) (Er = Nt), Gl(Nt), (Nt = Nt.sibling);
                (Er = Rt), (Ts = vn), (ss = dr);
              }
              bu(Le);
            } else
              (Rt.subtreeFlags & 8772) !== 0 && Nt !== null
                ? ((Nt.return = Rt), (Er = Nt))
                : bu(Le);
          }
        }
        function bu(Le) {
          for (; Er !== null; ) {
            var tt = Er;
            if ((tt.flags & 8772) !== 0) {
              var _t = tt.alternate;
              try {
                if ((tt.flags & 8772) !== 0)
                  switch (tt.tag) {
                    case 0:
                    case 11:
                    case 15:
                      ss || cs(5, tt);
                      break;
                    case 1:
                      var Et = tt.stateNode;
                      if (tt.flags & 4 && !ss)
                        if (_t === null) Et.componentDidMount();
                        else {
                          var Rt =
                            tt.elementType === tt.type
                              ? _t.memoizedProps
                              : Rs(tt.type, _t.memoizedProps);
                          Et.componentDidUpdate(
                            Rt,
                            _t.memoizedState,
                            Et.__reactInternalSnapshotBeforeUpdate
                          );
                        }
                      var Nt = tt.updateQueue;
                      Nt !== null && Hu(tt, Nt, Et);
                      break;
                    case 3:
                      var Jt = tt.updateQueue;
                      if (Jt !== null) {
                        if (((_t = null), tt.child !== null))
                          switch (tt.child.tag) {
                            case 5:
                              _t = Ft(tt.child.stateNode);
                              break;
                            case 1:
                              _t = tt.child.stateNode;
                          }
                        Hu(tt, Jt, _t);
                      }
                      break;
                    case 5:
                      var vn = tt.stateNode;
                      _t === null &&
                        tt.flags & 4 &&
                        qn(vn, tt.type, tt.memoizedProps, tt);
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (Bn && tt.memoizedState === null) {
                        var Wn = tt.alternate;
                        if (Wn !== null) {
                          var dr = Wn.memoizedState;
                          if (dr !== null) {
                            var kr = dr.dehydrated;
                            kr !== null && kn(kr);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break;
                    default:
                      throw Error(a(163));
                  }
                ss || (tt.flags & 512 && bs(tt));
              } catch (ii) {
                Ms(tt, tt.return, ii);
              }
            }
            if (tt === Le) {
              Er = null;
              break;
            }
            if (((_t = tt.sibling), _t !== null)) {
              (_t.return = tt.return), (Er = _t);
              break;
            }
            Er = tt.return;
          }
        }
        function Mu(Le) {
          for (; Er !== null; ) {
            var tt = Er;
            if (tt === Le) {
              Er = null;
              break;
            }
            var _t = tt.sibling;
            if (_t !== null) {
              (_t.return = tt.return), (Er = _t);
              break;
            }
            Er = tt.return;
          }
        }
        function Ca(Le) {
          for (; Er !== null; ) {
            var tt = Er;
            try {
              switch (tt.tag) {
                case 0:
                case 11:
                case 15:
                  var _t = tt.return;
                  try {
                    cs(4, tt);
                  } catch (Wn) {
                    Ms(tt, _t, Wn);
                  }
                  break;
                case 1:
                  var Et = tt.stateNode;
                  if (typeof Et.componentDidMount == "function") {
                    var Rt = tt.return;
                    try {
                      Et.componentDidMount();
                    } catch (Wn) {
                      Ms(tt, Rt, Wn);
                    }
                  }
                  var Nt = tt.return;
                  try {
                    bs(tt);
                  } catch (Wn) {
                    Ms(tt, Nt, Wn);
                  }
                  break;
                case 5:
                  var Jt = tt.return;
                  try {
                    bs(tt);
                  } catch (Wn) {
                    Ms(tt, Jt, Wn);
                  }
              }
            } catch (Wn) {
              Ms(tt, tt.return, Wn);
            }
            if (tt === Le) {
              Er = null;
              break;
            }
            var vn = tt.sibling;
            if (vn !== null) {
              (vn.return = tt.return), (Er = vn);
              break;
            }
            Er = tt.return;
          }
        }
        var Hl = 0,
          Aa = 1,
          Pa = 2,
          Bo = 3,
          ul = 4;
        if (typeof Symbol == "function" && Symbol.for) {
          var Ra = Symbol.for;
          (Hl = Ra("selector.component")),
            (Aa = Ra("selector.has_pseudo_class")),
            (Pa = Ra("selector.role")),
            (Bo = Ra("selector.test_id")),
            (ul = Ra("selector.text"));
        }
        function Wl(Le) {
          var tt = jt(Le);
          if (tt != null) {
            if (typeof tt.memoizedProps["data-testname"] != "string")
              throw Error(a(364));
            return tt;
          }
          if (((Le = Yt(Le)), Le === null)) throw Error(a(362));
          return Le.stateNode.current;
        }
        function jl(Le, tt) {
          switch (tt.$$typeof) {
            case Hl:
              if (Le.type === tt.value) return !0;
              break;
            case Aa:
              e: {
                (tt = tt.value), (Le = [Le, 0]);
                for (var _t = 0; _t < Le.length; ) {
                  var Et = Le[_t++],
                    Rt = Le[_t++],
                    Nt = tt[Rt];
                  if (Et.tag !== 5 || !En(Et)) {
                    for (; Nt != null && jl(Et, Nt); ) Rt++, (Nt = tt[Rt]);
                    if (Rt === tt.length) {
                      tt = !0;
                      break e;
                    } else
                      for (Et = Et.child; Et !== null; )
                        Le.push(Et, Rt), (Et = Et.sibling);
                  }
                }
                tt = !1;
              }
              return tt;
            case Pa:
              if (Le.tag === 5 && Ln(Le.stateNode, tt.value)) return !0;
              break;
            case ul:
              if (
                (Le.tag === 5 || Le.tag === 6) &&
                ((Le = hn(Le)), Le !== null && 0 <= Le.indexOf(tt.value))
              )
                return !0;
              break;
            case Bo:
              if (
                Le.tag === 5 &&
                ((Le = Le.memoizedProps["data-testname"]),
                typeof Le == "string" &&
                  Le.toLowerCase() === tt.value.toLowerCase())
              )
                return !0;
              break;
            default:
              throw Error(a(365));
          }
          return !1;
        }
        function ia(Le) {
          switch (Le.$$typeof) {
            case Hl:
              return "<" + (wt(Le.value) || "Unknown") + ">";
            case Aa:
              return ":has(" + (ia(Le) || "") + ")";
            case Pa:
              return '[role="' + Le.value + '"]';
            case ul:
              return '"' + Le.value + '"';
            case Bo:
              return '[data-testname="' + Le.value + '"]';
            default:
              throw Error(a(365));
          }
        }
        function Vs(Le, tt) {
          var _t = [];
          Le = [Le, 0];
          for (var Et = 0; Et < Le.length; ) {
            var Rt = Le[Et++],
              Nt = Le[Et++],
              Jt = tt[Nt];
            if (Rt.tag !== 5 || !En(Rt)) {
              for (; Jt != null && jl(Rt, Jt); ) Nt++, (Jt = tt[Nt]);
              if (Nt === tt.length) _t.push(Rt);
              else
                for (Rt = Rt.child; Rt !== null; )
                  Le.push(Rt, Nt), (Rt = Rt.sibling);
            }
          }
          return _t;
        }
        function Uo(Le, tt) {
          if (!Gn) throw Error(a(363));
          (Le = Wl(Le)), (Le = Vs(Le, tt)), (tt = []), (Le = Array.from(Le));
          for (var _t = 0; _t < Le.length; ) {
            var Et = Le[_t++];
            if (Et.tag === 5) En(Et) || tt.push(Et.stateNode);
            else
              for (Et = Et.child; Et !== null; ) Le.push(Et), (Et = Et.sibling);
          }
          return tt;
        }
        var Cu = Math.ceil,
          $l = l.ReactCurrentDispatcher,
          lo = l.ReactCurrentOwner,
          Ci = l.ReactCurrentBatchConfig,
          ui = 0,
          qi = null,
          Ai = null,
          Bi = 0,
          gs = 0,
          Ia = cr(0),
          Hi = 0,
          hl = null,
          _o = 0,
          Gs = 0,
          La = 0,
          zo = null,
          Xi = null,
          ql = 0,
          sa = 1 / 0;
        function ka() {
          sa = ji() + 500;
        }
        var dl = !1,
          Oi = null,
          co = null,
          pl = !1,
          yo = null,
          Fa = 0,
          Da = 0,
          Vo = null,
          Fi = -1,
          Wi = 0;
        function Si() {
          return (ui & 6) !== 0 ? ji() : Fi !== -1 ? Fi : (Fi = ji());
        }
        function uo(Le) {
          return (Le.mode & 1) === 0
            ? 1
            : (ui & 2) !== 0 && Bi !== 0
            ? Bi & -Bi
            : Tl.transition !== null
            ? (Wi === 0 &&
                ((Le = Ui),
                (Ui <<= 1),
                (Ui & 4194240) === 0 && (Ui = 64),
                (Wi = Le)),
              Wi)
            : ((Le = ci), Le !== 0 ? Le : zn());
        }
        function vs(Le, tt, _t) {
          if (50 < Da) throw ((Da = 0), (Vo = null), Error(a(185)));
          var Et = oa(Le, tt);
          return Et === null
            ? null
            : (Eo(Et, tt, _t),
              ((ui & 2) === 0 || Et !== qi) &&
                (Et === qi &&
                  ((ui & 2) === 0 && (Gs |= tt), Hi === 4 && fs(Et, Bi)),
                Fs(Et, _t),
                tt === 1 &&
                  ui === 0 &&
                  (Le.mode & 1) === 0 &&
                  (ka(), Zi && xs())),
              Et);
        }
        function oa(Le, tt) {
          Le.lanes |= tt;
          var _t = Le.alternate;
          for (
            _t !== null && (_t.lanes |= tt), _t = Le, Le = Le.return;
            Le !== null;

          )
            (Le.childLanes |= tt),
              (_t = Le.alternate),
              _t !== null && (_t.childLanes |= tt),
              (_t = Le),
              (Le = Le.return);
          return _t.tag === 3 ? _t.stateNode : null;
        }
        function Fs(Le, tt) {
          var _t = Le.callbackNode;
          oc(Le, tt);
          var Et = la(Le, Le === qi ? Bi : 0);
          if (Et === 0)
            _t !== null && Xo(_t),
              (Le.callbackNode = null),
              (Le.callbackPriority = 0);
          else if (((tt = Et & -Et), Le.callbackPriority !== tt)) {
            if ((_t != null && Xo(_t), tt === 1))
              Le.tag === 0 ? ja(Hs.bind(null, Le)) : Wa(Hs.bind(null, Le)),
                In
                  ? or(function () {
                      ui === 0 && xs();
                    })
                  : To(bo, xs),
                (_t = null);
            else {
              switch (ro(Et)) {
                case 1:
                  _t = bo;
                  break;
                case 4:
                  _t = ac;
                  break;
                case 16:
                  _t = Ha;
                  break;
                case 536870912:
                  _t = Sn;
                  break;
                default:
                  _t = Ha;
              }
              _t = zc(_t, us.bind(null, Le));
            }
            (Le.callbackPriority = tt), (Le.callbackNode = _t);
          }
        }
        function us(Le, tt) {
          if (((Fi = -1), (Wi = 0), (ui & 6) !== 0)) throw Error(a(327));
          var _t = Le.callbackNode;
          if (xo() && Le.callbackNode !== _t) return null;
          var Et = la(Le, Le === qi ? Bi : 0);
          if (Et === 0) return null;
          if ((Et & 30) !== 0 || (Et & Le.expiredLanes) !== 0 || tt)
            tt = Zl(Le, Et);
          else {
            tt = Et;
            var Rt = ui;
            ui |= 2;
            var Nt = Ru();
            (qi !== Le || Bi !== tt) && (ka(), Go(Le, tt));
            do
              try {
                sf();
                break;
              } catch (vn) {
                Pu(Le, vn);
              }
            while (!0);
            Ss(),
              ($l.current = Nt),
              (ui = Rt),
              Ai !== null ? (tt = 0) : ((qi = null), (Bi = 0), (tt = Hi));
          }
          if (tt !== 0) {
            if (
              (tt === 2 &&
                ((Rt = za(Le)), Rt !== 0 && ((Et = Rt), (tt = Xl(Le, Rt)))),
              tt === 1)
            )
              throw ((_t = hl), Go(Le, 0), fs(Le, Et), Fs(Le, ji()), _t);
            if (tt === 6) fs(Le, Et);
            else {
              if (
                ((Rt = Le.current.alternate),
                (Et & 30) === 0 &&
                  !Au(Rt) &&
                  ((tt = Zl(Le, Et)),
                  tt === 2 &&
                    ((Nt = za(Le)), Nt !== 0 && ((Et = Nt), (tt = Xl(Le, Nt)))),
                  tt === 1))
              )
                throw ((_t = hl), Go(Le, 0), fs(Le, Et), Fs(Le, ji()), _t);
              switch (((Le.finishedWork = Rt), (Le.finishedLanes = Et), tt)) {
                case 0:
                case 1:
                  throw Error(a(345));
                case 2:
                  fo(Le, Xi);
                  break;
                case 3:
                  if (
                    (fs(Le, Et),
                    (Et & 130023424) === Et &&
                      ((tt = ql + 500 - ji()), 10 < tt))
                  ) {
                    if (la(Le, 0) !== 0) break;
                    if (((Rt = Le.suspendedLanes), (Rt & Et) !== Et)) {
                      Si(), (Le.pingedLanes |= Le.suspendedLanes & Rt);
                      break;
                    }
                    Le.timeoutHandle = _n(fo.bind(null, Le, Xi), tt);
                    break;
                  }
                  fo(Le, Xi);
                  break;
                case 4:
                  if ((fs(Le, Et), (Et & 4194240) === Et)) break;
                  for (tt = Le.eventTimes, Rt = -1; 0 < Et; ) {
                    var Jt = 31 - Kr(Et);
                    (Nt = 1 << Jt),
                      (Jt = tt[Jt]),
                      Jt > Rt && (Rt = Jt),
                      (Et &= ~Nt);
                  }
                  if (
                    ((Et = Rt),
                    (Et = ji() - Et),
                    (Et =
                      (120 > Et
                        ? 120
                        : 480 > Et
                        ? 480
                        : 1080 > Et
                        ? 1080
                        : 1920 > Et
                        ? 1920
                        : 3e3 > Et
                        ? 3e3
                        : 4320 > Et
                        ? 4320
                        : 1960 * Cu(Et / 1960)) - Et),
                    10 < Et)
                  ) {
                    Le.timeoutHandle = _n(fo.bind(null, Le, Xi), Et);
                    break;
                  }
                  fo(Le, Xi);
                  break;
                case 5:
                  fo(Le, Xi);
                  break;
                default:
                  throw Error(a(329));
              }
            }
          }
          return (
            Fs(Le, ji()), Le.callbackNode === _t ? us.bind(null, Le) : null
          );
        }
        function Xl(Le, tt) {
          var _t = zo;
          return (
            Le.current.memoizedState.isDehydrated && (Go(Le, tt).flags |= 256),
            (Le = Zl(Le, tt)),
            Le !== 2 && ((tt = Xi), (Xi = _t), tt !== null && Yl(tt)),
            Le
          );
        }
        function Yl(Le) {
          Xi === null ? (Xi = Le) : Xi.push.apply(Xi, Le);
        }
        function Au(Le) {
          for (var tt = Le; ; ) {
            if (tt.flags & 16384) {
              var _t = tt.updateQueue;
              if (_t !== null && ((_t = _t.stores), _t !== null))
                for (var Et = 0; Et < _t.length; Et++) {
                  var Rt = _t[Et],
                    Nt = Rt.getSnapshot;
                  Rt = Rt.value;
                  try {
                    if (!Yr(Nt(), Rt)) return !1;
                  } catch {
                    return !1;
                  }
                }
            }
            if (((_t = tt.child), tt.subtreeFlags & 16384 && _t !== null))
              (_t.return = tt), (tt = _t);
            else {
              if (tt === Le) break;
              for (; tt.sibling === null; ) {
                if (tt.return === null || tt.return === Le) return !0;
                tt = tt.return;
              }
              (tt.sibling.return = tt.return), (tt = tt.sibling);
            }
          }
          return !0;
        }
        function fs(Le, tt) {
          for (
            tt &= ~La,
              tt &= ~Gs,
              Le.suspendedLanes |= tt,
              Le.pingedLanes &= ~tt,
              Le = Le.expirationTimes;
            0 < tt;

          ) {
            var _t = 31 - Kr(tt),
              Et = 1 << _t;
            (Le[_t] = -1), (tt &= ~Et);
          }
        }
        function Hs(Le) {
          if ((ui & 6) !== 0) throw Error(a(327));
          xo();
          var tt = la(Le, 0);
          if ((tt & 1) === 0) return Fs(Le, ji()), null;
          var _t = Zl(Le, tt);
          if (Le.tag !== 0 && _t === 2) {
            var Et = za(Le);
            Et !== 0 && ((tt = Et), (_t = Xl(Le, Et)));
          }
          if (_t === 1)
            throw ((_t = hl), Go(Le, 0), fs(Le, tt), Fs(Le, ji()), _t);
          if (_t === 6) throw Error(a(345));
          return (
            (Le.finishedWork = Le.current.alternate),
            (Le.finishedLanes = tt),
            fo(Le, Xi),
            Fs(Le, ji()),
            null
          );
        }
        function ml(Le) {
          yo !== null && yo.tag === 0 && (ui & 6) === 0 && xo();
          var tt = ui;
          ui |= 1;
          var _t = Ci.transition,
            Et = ci;
          try {
            if (((Ci.transition = null), (ci = 1), Le)) return Le();
          } finally {
            (ci = Et), (Ci.transition = _t), (ui = tt), (ui & 6) === 0 && xs();
          }
        }
        function Kl() {
          (gs = Ia.current), Qn(Ia);
        }
        function Go(Le, tt) {
          (Le.finishedWork = null), (Le.finishedLanes = 0);
          var _t = Le.timeoutHandle;
          if ((_t !== $n && ((Le.timeoutHandle = $n), bn(_t)), Ai !== null))
            for (_t = Ai.return; _t !== null; ) {
              var Et = _t;
              switch ((ru(Et), Et.tag)) {
                case 1:
                  (Et = Et.type.childContextTypes), Et != null && Xr();
                  break;
                case 3:
                  tl(), Qn(Dr), Qn(Qr), ga();
                  break;
                case 5:
                  ou(Et);
                  break;
                case 4:
                  tl();
                  break;
                case 13:
                  Qn(zi);
                  break;
                case 19:
                  Qn(zi);
                  break;
                case 10:
                  Ml(Et.type._context);
                  break;
                case 22:
                case 23:
                  Kl();
              }
              _t = _t.return;
            }
          if (
            ((qi = Le),
            (Ai = Le = Ho(Le.current, null)),
            (Bi = gs = tt),
            (Hi = 0),
            (hl = null),
            (La = Gs = _o = 0),
            (Xi = zo = null),
            Xs !== null)
          ) {
            for (tt = 0; tt < Xs.length; tt++)
              if (((_t = Xs[tt]), (Et = _t.interleaved), Et !== null)) {
                _t.interleaved = null;
                var Rt = Et.next,
                  Nt = _t.pending;
                if (Nt !== null) {
                  var Jt = Nt.next;
                  (Nt.next = Rt), (Et.next = Jt);
                }
                _t.pending = Et;
              }
            Xs = null;
          }
          return Le;
        }
        function Pu(Le, tt) {
          do {
            var _t = Ai;
            try {
              if ((Ss(), (Al.current = ol), yc)) {
                for (var Et = Vi.memoizedState; Et !== null; ) {
                  var Rt = Et.queue;
                  Rt !== null && (Rt.pending = null), (Et = Et.next);
                }
                yc = !1;
              }
              if (
                ((va = 0),
                (ts = es = Vi = null),
                (mo = !1),
                (ya = 0),
                (lo.current = null),
                _t === null || _t.return === null)
              ) {
                (Hi = 1), (hl = tt), (Ai = null);
                break;
              }
              e: {
                var Nt = Le,
                  Jt = _t.return,
                  vn = _t,
                  Wn = tt;
                if (
                  ((tt = Bi),
                  (vn.flags |= 32768),
                  Wn !== null &&
                    typeof Wn == "object" &&
                    typeof Wn.then == "function")
                ) {
                  var dr = Wn,
                    kr = vn,
                    ii = kr.tag;
                  if (
                    (kr.mode & 1) === 0 &&
                    (ii === 0 || ii === 11 || ii === 15)
                  ) {
                    var Zr = kr.alternate;
                    Zr
                      ? ((kr.updateQueue = Zr.updateQueue),
                        (kr.memoizedState = Zr.memoizedState),
                        (kr.lanes = Zr.lanes))
                      : ((kr.updateQueue = null), (kr.memoizedState = null));
                  }
                  var hi = gu(Jt);
                  if (hi !== null) {
                    (hi.flags &= -257),
                      Sa(hi, Jt, vn, Nt, tt),
                      hi.mode & 1 && Lo(Nt, dr, tt),
                      (tt = hi),
                      (Wn = dr);
                    var Ar = tt.updateQueue;
                    if (Ar === null) {
                      var hs = new Set();
                      hs.add(Wn), (tt.updateQueue = hs);
                    } else Ar.add(Wn);
                    break e;
                  } else {
                    if ((tt & 1) === 0) {
                      Lo(Nt, dr, tt), Uc();
                      break e;
                    }
                    Wn = Error(a(426));
                  }
                } else if (Ni && vn.mode & 1) {
                  var js = gu(Jt);
                  if (js !== null) {
                    (js.flags & 65536) === 0 && (js.flags |= 256),
                      Sa(js, Jt, vn, Nt, tt),
                      gc(Wn);
                    break e;
                  }
                }
                (Nt = Wn),
                  Hi !== 4 && (Hi = 2),
                  zo === null ? (zo = [Nt]) : zo.push(Nt),
                  (Wn = mu(Wn, vn)),
                  (vn = Jt);
                do {
                  switch (vn.tag) {
                    case 3:
                      (vn.flags |= 65536), (tt &= -tt), (vn.lanes |= tt);
                      var Pn = tf(vn, Wn, tt);
                      uc(vn, Pn);
                      break e;
                    case 1:
                      Nt = Wn;
                      var xn = vn.type,
                        Nn = vn.stateNode;
                      if (
                        (vn.flags & 128) === 0 &&
                        (typeof xn.getDerivedStateFromError == "function" ||
                          (Nn !== null &&
                            typeof Nn.componentDidCatch == "function" &&
                            (co === null || !co.has(Nn))))
                      ) {
                        (vn.flags |= 65536), (tt &= -tt), (vn.lanes |= tt);
                        var br = Pc(vn, Nt, tt);
                        uc(vn, br);
                        break e;
                      }
                  }
                  vn = vn.return;
                } while (vn !== null);
              }
              Lu(_t);
            } catch (Gr) {
              (tt = Gr), Ai === _t && _t !== null && (Ai = _t = _t.return);
              continue;
            }
            break;
          } while (!0);
        }
        function Ru() {
          var Le = $l.current;
          return ($l.current = ol), Le === null ? ol : Le;
        }
        function Uc() {
          (Hi === 0 || Hi === 3 || Hi === 2) && (Hi = 4),
            qi === null ||
              ((_o & 268435455) === 0 && (Gs & 268435455) === 0) ||
              fs(qi, Bi);
        }
        function Zl(Le, tt) {
          var _t = ui;
          ui |= 2;
          var Et = Ru();
          (qi === Le && Bi === tt) || Go(Le, tt);
          do
            try {
              rf();
              break;
            } catch (Rt) {
              Pu(Le, Rt);
            }
          while (!0);
          if ((Ss(), (ui = _t), ($l.current = Et), Ai !== null))
            throw Error(a(261));
          return (qi = null), (Bi = 0), Hi;
        }
        function rf() {
          for (; Ai !== null; ) Iu(Ai);
        }
        function sf() {
          for (; Ai !== null && !po(); ) Iu(Ai);
        }
        function Iu(Le) {
          var tt = Du(Le.alternate, Le, gs);
          (Le.memoizedProps = Le.pendingProps),
            tt === null ? Lu(Le) : (Ai = tt),
            (lo.current = null);
        }
        function Lu(Le) {
          var tt = Le;
          do {
            var _t = tt.alternate;
            if (((Le = tt.return), (tt.flags & 32768) === 0)) {
              if (((_t = Lc(_t, tt, gs)), _t !== null)) {
                Ai = _t;
                return;
              }
            } else {
              if (((_t = Dc(_t, tt)), _t !== null)) {
                (_t.flags &= 32767), (Ai = _t);
                return;
              }
              if (Le !== null)
                (Le.flags |= 32768),
                  (Le.subtreeFlags = 0),
                  (Le.deletions = null);
              else {
                (Hi = 6), (Ai = null);
                return;
              }
            }
            if (((tt = tt.sibling), tt !== null)) {
              Ai = tt;
              return;
            }
            Ai = tt = Le;
          } while (tt !== null);
          Hi === 0 && (Hi = 5);
        }
        function fo(Le, tt) {
          var _t = ci,
            Et = Ci.transition;
          try {
            (Ci.transition = null), (ci = 1), of(Le, tt, _t);
          } finally {
            (Ci.transition = Et), (ci = _t);
          }
          return null;
        }
        function of(Le, tt, _t) {
          do xo();
          while (yo !== null);
          if ((ui & 6) !== 0) throw Error(a(327));
          var Et = Le.finishedWork,
            Rt = Le.finishedLanes;
          if (Et === null) return null;
          if (
            ((Le.finishedWork = null),
            (Le.finishedLanes = 0),
            Et === Le.current)
          )
            throw Error(a(177));
          (Le.callbackNode = null), (Le.callbackPriority = 0);
          var Nt = Et.lanes | Et.childLanes;
          if (
            (Ga(Le, Nt),
            Le === qi && ((Ai = qi = null), (Bi = 0)),
            ((Et.subtreeFlags & 2064) === 0 && (Et.flags & 2064) === 0) ||
              pl ||
              ((pl = !0),
              zc(Ha, function () {
                return xo(), null;
              })),
            (Nt = (Et.flags & 15990) !== 0),
            (Et.subtreeFlags & 15990) !== 0 || Nt)
          ) {
            (Nt = Ci.transition), (Ci.transition = null);
            var Jt = ci;
            ci = 1;
            var vn = ui;
            (ui |= 4),
              (lo.current = null),
              Su(Le, Et),
              Of(Le, Et),
              It(Le.containerInfo),
              (Le.current = Et),
              Vl(Et),
              Zc(),
              (ui = vn),
              (ci = Jt),
              (Ci.transition = Nt);
          } else Le.current = Et;
          if (
            (pl && ((pl = !1), (yo = Le), (Fa = Rt)),
            (Nt = Le.pendingLanes),
            Nt === 0 && (co = null),
            Un(Et.stateNode),
            Fs(Le, ji()),
            tt !== null)
          )
            for (_t = Le.onRecoverableError, Et = 0; Et < tt.length; Et++)
              _t(tt[Et]);
          if (dl) throw ((dl = !1), (Le = Oi), (Oi = null), Le);
          return (
            (Fa & 1) !== 0 && Le.tag !== 0 && xo(),
            (Nt = Le.pendingLanes),
            (Nt & 1) !== 0
              ? Le === Vo
                ? Da++
                : ((Da = 0), (Vo = Le))
              : (Da = 0),
            xs(),
            null
          );
        }
        function xo() {
          if (yo !== null) {
            var Le = ro(Fa),
              tt = Ci.transition,
              _t = ci;
            try {
              if (
                ((Ci.transition = null), (ci = 16 > Le ? 16 : Le), yo === null)
              )
                var Et = !1;
              else {
                if (((Le = yo), (yo = null), (Fa = 0), (ui & 6) !== 0))
                  throw Error(a(331));
                var Rt = ui;
                for (ui |= 4, Er = Le.current; Er !== null; ) {
                  var Nt = Er,
                    Jt = Nt.child;
                  if ((Er.flags & 16) !== 0) {
                    var vn = Nt.deletions;
                    if (vn !== null) {
                      for (var Wn = 0; Wn < vn.length; Wn++) {
                        var dr = vn[Wn];
                        for (Er = dr; Er !== null; ) {
                          var kr = Er;
                          switch (kr.tag) {
                            case 0:
                            case 11:
                            case 15:
                              No(8, kr, Nt);
                          }
                          var ii = kr.child;
                          if (ii !== null) (ii.return = kr), (Er = ii);
                          else
                            for (; Er !== null; ) {
                              kr = Er;
                              var Zr = kr.sibling,
                                hi = kr.return;
                              if ((wu(kr), kr === dr)) {
                                Er = null;
                                break;
                              }
                              if (Zr !== null) {
                                (Zr.return = hi), (Er = Zr);
                                break;
                              }
                              Er = hi;
                            }
                        }
                      }
                      var Ar = Nt.alternate;
                      if (Ar !== null) {
                        var hs = Ar.child;
                        if (hs !== null) {
                          Ar.child = null;
                          do {
                            var js = hs.sibling;
                            (hs.sibling = null), (hs = js);
                          } while (hs !== null);
                        }
                      }
                      Er = Nt;
                    }
                  }
                  if ((Nt.subtreeFlags & 2064) !== 0 && Jt !== null)
                    (Jt.return = Nt), (Er = Jt);
                  else
                    e: for (; Er !== null; ) {
                      if (((Nt = Er), (Nt.flags & 2048) !== 0))
                        switch (Nt.tag) {
                          case 0:
                          case 11:
                          case 15:
                            No(9, Nt, Nt.return);
                        }
                      var Pn = Nt.sibling;
                      if (Pn !== null) {
                        (Pn.return = Nt.return), (Er = Pn);
                        break e;
                      }
                      Er = Nt.return;
                    }
                }
                var xn = Le.current;
                for (Er = xn; Er !== null; ) {
                  Jt = Er;
                  var Nn = Jt.child;
                  if ((Jt.subtreeFlags & 2064) !== 0 && Nn !== null)
                    (Nn.return = Jt), (Er = Nn);
                  else
                    e: for (Jt = xn; Er !== null; ) {
                      if (((vn = Er), (vn.flags & 2048) !== 0))
                        try {
                          switch (vn.tag) {
                            case 0:
                            case 11:
                            case 15:
                              cs(9, vn);
                          }
                        } catch (Gr) {
                          Ms(vn, vn.return, Gr);
                        }
                      if (vn === Jt) {
                        Er = null;
                        break e;
                      }
                      var br = vn.sibling;
                      if (br !== null) {
                        (br.return = vn.return), (Er = br);
                        break e;
                      }
                      Er = vn.return;
                    }
                }
                if (
                  ((ui = Rt),
                  xs(),
                  ln && typeof ln.onPostCommitFiberRoot == "function")
                )
                  try {
                    ln.onPostCommitFiberRoot(en, Le);
                  } catch {}
                Et = !0;
              }
              return Et;
            } finally {
              (ci = _t), (Ci.transition = tt);
            }
          }
          return !1;
        }
        function Ql(Le, tt, _t) {
          (tt = mu(_t, tt)),
            (tt = tf(Le, tt, 1)),
            Ko(Le, tt),
            (tt = Si()),
            (Le = oa(Le, 1)),
            Le !== null && (Eo(Le, 1, tt), Fs(Le, tt));
        }
        function Ms(Le, tt, _t) {
          if (Le.tag === 3) Ql(Le, Le, _t);
          else
            for (; tt !== null; ) {
              if (tt.tag === 3) {
                Ql(tt, Le, _t);
                break;
              } else if (tt.tag === 1) {
                var Et = tt.stateNode;
                if (
                  typeof tt.type.getDerivedStateFromError == "function" ||
                  (typeof Et.componentDidCatch == "function" &&
                    (co === null || !co.has(Et)))
                ) {
                  (Le = mu(_t, Le)),
                    (Le = Pc(tt, Le, 1)),
                    Ko(tt, Le),
                    (Le = Si()),
                    (tt = oa(tt, 1)),
                    tt !== null && (Eo(tt, 1, Le), Fs(tt, Le));
                  break;
                }
              }
              tt = tt.return;
            }
        }
        function ku(Le, tt, _t) {
          var Et = Le.pingCache;
          Et !== null && Et.delete(tt),
            (tt = Si()),
            (Le.pingedLanes |= Le.suspendedLanes & _t),
            qi === Le &&
              (Bi & _t) === _t &&
              (Hi === 4 ||
              (Hi === 3 && (Bi & 130023424) === Bi && 500 > ji() - ql)
                ? Go(Le, 0)
                : (La |= _t)),
            Fs(Le, tt);
        }
        function Fu(Le, tt) {
          tt === 0 &&
            ((Le.mode & 1) === 0
              ? (tt = 1)
              : ((tt = di),
                (di <<= 1),
                (di & 130023424) === 0 && (di = 4194304)));
          var _t = Si();
          (Le = oa(Le, tt)), Le !== null && (Eo(Le, tt, _t), Fs(Le, _t));
        }
        function af(Le) {
          var tt = Le.memoizedState,
            _t = 0;
          tt !== null && (_t = tt.retryLane), Fu(Le, _t);
        }
        function lf(Le, tt) {
          var _t = 0;
          switch (Le.tag) {
            case 13:
              var Et = Le.stateNode,
                Rt = Le.memoizedState;
              Rt !== null && (_t = Rt.retryLane);
              break;
            case 19:
              Et = Le.stateNode;
              break;
            default:
              throw Error(a(314));
          }
          Et !== null && Et.delete(tt), Fu(Le, _t);
        }
        var Du;
        Du = function (Le, tt, _t) {
          if (Le !== null)
            if (Le.memoizedProps !== tt.pendingProps || Dr.current) rs = !0;
            else {
              if ((Le.lanes & _t) === 0 && (tt.flags & 128) === 0)
                return (rs = !1), Fc(Le, tt, _t);
              rs = (Le.flags & 131072) !== 0;
            }
          else
            (rs = !1), Ni && (tt.flags & 1048576) !== 0 && qu(tt, pc, tt.index);
          switch (((tt.lanes = 0), tt.tag)) {
            case 2:
              var Et = tt.type;
              Le !== null &&
                ((Le.alternate = null), (tt.alternate = null), (tt.flags |= 2)),
                (Le = tt.pendingProps);
              var Rt = Mr(tt, Qr.current);
              qa(tt, _t), (Rt = nl(null, tt, Et, Le, Rt, _t));
              var Nt = ea();
              return (
                (tt.flags |= 1),
                typeof Rt == "object" &&
                Rt !== null &&
                typeof Rt.render == "function" &&
                Rt.$$typeof === void 0
                  ? ((tt.tag = 1),
                    (tt.memoizedState = null),
                    (tt.updateQueue = null),
                    oi(Et) ? ((Nt = !0), ni(tt)) : (Nt = !1),
                    (tt.memoizedState =
                      Rt.state !== null && Rt.state !== void 0
                        ? Rt.state
                        : null),
                    Xa(tt),
                    (Rt.updater = hc),
                    (tt.stateNode = Rt),
                    (Rt._reactInternals = tt),
                    tu(tt, Et, Le, _t),
                    (tt = ms(null, tt, Et, !0, Nt, _t)))
                  : ((tt.tag = 0),
                    Ni && Nt && nu(tt),
                    Gi(null, tt, Rt, _t),
                    (tt = tt.child)),
                tt
              );
            case 16:
              Et = tt.elementType;
              e: {
                switch (
                  (Le !== null &&
                    ((Le.alternate = null),
                    (tt.alternate = null),
                    (tt.flags |= 2)),
                  (Le = tt.pendingProps),
                  (Rt = Et._init),
                  (Et = Rt(Et._payload)),
                  (tt.type = Et),
                  (Rt = tt.tag = Nf(Et)),
                  (Le = Rs(Et, Le)),
                  Rt)
                ) {
                  case 0:
                    tt = Do(null, tt, Et, Le, _t);
                    break e;
                  case 1:
                    tt = Ea(null, tt, Et, Le, _t);
                    break e;
                  case 11:
                    tt = ki(null, tt, Et, Le, _t);
                    break e;
                  case 14:
                    tt = Ri(null, tt, Et, Rs(Et.type, Le), _t);
                    break e;
                }
                throw Error(a(306, Et, ""));
              }
              return tt;
            case 0:
              return (
                (Et = tt.type),
                (Rt = tt.pendingProps),
                (Rt = tt.elementType === Et ? Rt : Rs(Et, Rt)),
                Do(Le, tt, Et, Rt, _t)
              );
            case 1:
              return (
                (Et = tt.type),
                (Rt = tt.pendingProps),
                (Rt = tt.elementType === Et ? Rt : Rs(Et, Rt)),
                Ea(Le, tt, Et, Rt, _t)
              );
            case 3:
              e: {
                if ((Nl(tt), Le === null)) throw Error(a(387));
                (Et = tt.pendingProps),
                  (Nt = tt.memoizedState),
                  (Rt = Nt.element),
                  Qc(Le, tt),
                  fc(tt, Et, null, _t);
                var Jt = tt.memoizedState;
                if (((Et = Jt.element), Bn && Nt.isDehydrated))
                  if (
                    ((Nt = {
                      element: Et,
                      isDehydrated: !1,
                      cache: Jt.cache,
                      transitions: Jt.transitions,
                    }),
                    (tt.updateQueue.baseState = Nt),
                    (tt.memoizedState = Nt),
                    tt.flags & 256)
                  ) {
                    (Rt = Error(a(423))), (tt = _u(Le, tt, Et, _t, Rt));
                    break e;
                  } else if (Et !== Rt) {
                    (Rt = Error(a(424))), (tt = _u(Le, tt, Et, _t, Rt));
                    break e;
                  } else
                    for (
                      Bn &&
                        ((as = Pi(tt.stateNode.containerInfo)),
                        (ws = tt),
                        (Ni = !0),
                        (Zs = null),
                        (Ka = !1)),
                        _t = Ku(tt, null, Et, _t),
                        tt.child = _t;
                      _t;

                    )
                      (_t.flags = (_t.flags & -3) | 4096), (_t = _t.sibling);
                else {
                  if ((Za(), Et === Rt)) {
                    tt = ks(Le, tt, _t);
                    break e;
                  }
                  Gi(Le, tt, Et, _t);
                }
                tt = tt.child;
              }
              return tt;
            case 5:
              return (
                Zu(tt),
                Le === null && Qo(tt),
                (Et = tt.type),
                (Rt = tt.pendingProps),
                (Nt = Le !== null ? Le.memoizedProps : null),
                (Jt = Rt.children),
                tn(Et, Rt)
                  ? (Jt = null)
                  : Nt !== null && tn(Et, Nt) && (tt.flags |= 32),
                Es(Le, tt),
                Gi(Le, tt, Jt, _t),
                tt.child
              );
            case 6:
              return Le === null && Qo(tt), null;
            case 13:
              return yu(Le, tt, _t);
            case 4:
              return (
                vc(tt, tt.stateNode.containerInfo),
                (Et = tt.pendingProps),
                Le === null
                  ? (tt.child = Ro(tt, null, Et, _t))
                  : Gi(Le, tt, Et, _t),
                tt.child
              );
            case 11:
              return (
                (Et = tt.type),
                (Rt = tt.pendingProps),
                (Rt = tt.elementType === Et ? Rt : Rs(Et, Rt)),
                ki(Le, tt, Et, Rt, _t)
              );
            case 7:
              return Gi(Le, tt, tt.pendingProps, _t), tt.child;
            case 8:
              return Gi(Le, tt, tt.pendingProps.children, _t), tt.child;
            case 12:
              return Gi(Le, tt, tt.pendingProps.children, _t), tt.child;
            case 10:
              e: {
                if (
                  ((Et = tt.type._context),
                  (Rt = tt.pendingProps),
                  (Nt = tt.memoizedProps),
                  (Jt = Rt.value),
                  ua(tt, Et, Jt),
                  Nt !== null)
                )
                  if (Yr(Nt.value, Jt)) {
                    if (Nt.children === Rt.children && !Dr.current) {
                      tt = ks(Le, tt, _t);
                      break e;
                    }
                  } else
                    for (
                      Nt = tt.child, Nt !== null && (Nt.return = tt);
                      Nt !== null;

                    ) {
                      var vn = Nt.dependencies;
                      if (vn !== null) {
                        Jt = Nt.child;
                        for (var Wn = vn.firstContext; Wn !== null; ) {
                          if (Wn.context === Et) {
                            if (Nt.tag === 1) {
                              (Wn = Co(-1, _t & -_t)), (Wn.tag = 2);
                              var dr = Nt.updateQueue;
                              if (dr !== null) {
                                dr = dr.shared;
                                var kr = dr.pending;
                                kr === null
                                  ? (Wn.next = Wn)
                                  : ((Wn.next = kr.next), (kr.next = Wn)),
                                  (dr.pending = Wn);
                              }
                            }
                            (Nt.lanes |= _t),
                              (Wn = Nt.alternate),
                              Wn !== null && (Wn.lanes |= _t),
                              fa(Nt.return, _t, tt),
                              (vn.lanes |= _t);
                            break;
                          }
                          Wn = Wn.next;
                        }
                      } else if (Nt.tag === 10)
                        Jt = Nt.type === tt.type ? null : Nt.child;
                      else if (Nt.tag === 18) {
                        if (((Jt = Nt.return), Jt === null))
                          throw Error(a(341));
                        (Jt.lanes |= _t),
                          (vn = Jt.alternate),
                          vn !== null && (vn.lanes |= _t),
                          fa(Jt, _t, tt),
                          (Jt = Nt.sibling);
                      } else Jt = Nt.child;
                      if (Jt !== null) Jt.return = Nt;
                      else
                        for (Jt = Nt; Jt !== null; ) {
                          if (Jt === tt) {
                            Jt = null;
                            break;
                          }
                          if (((Nt = Jt.sibling), Nt !== null)) {
                            (Nt.return = Jt.return), (Jt = Nt);
                            break;
                          }
                          Jt = Jt.return;
                        }
                      Nt = Jt;
                    }
                Gi(Le, tt, Rt.children, _t), (tt = tt.child);
              }
              return tt;
            case 9:
              return (
                (Rt = tt.type),
                (Et = tt.pendingProps.children),
                qa(tt, _t),
                (Rt = Is(Rt)),
                (Et = Et(Rt)),
                (tt.flags |= 1),
                Gi(Le, tt, Et, _t),
                tt.child
              );
            case 14:
              return (
                (Et = tt.type),
                (Rt = Rs(Et, tt.pendingProps)),
                (Rt = Rs(Et.type, Rt)),
                Ri(Le, tt, Et, Rt, _t)
              );
            case 15:
              return Fo(Le, tt, tt.type, tt.pendingProps, _t);
            case 17:
              return (
                (Et = tt.type),
                (Rt = tt.pendingProps),
                (Rt = tt.elementType === Et ? Rt : Rs(Et, Rt)),
                Le !== null &&
                  ((Le.alternate = null),
                  (tt.alternate = null),
                  (tt.flags |= 2)),
                (tt.tag = 1),
                oi(Et) ? ((Le = !0), ni(tt)) : (Le = !1),
                qa(tt, _t),
                ju(tt, Et, Rt),
                tu(tt, Et, Rt, _t),
                ms(null, tt, Et, !0, Le, _t)
              );
            case 19:
              return ba(Le, tt, _t);
            case 22:
              return ls(Le, tt, _t);
          }
          throw Error(a(156, tt.tag));
        };
        function zc(Le, tt) {
          return To(Le, tt);
        }
        function cf(Le, tt, _t, Et) {
          (this.tag = Le),
            (this.key = _t),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = tt),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = Et),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function Ws(Le, tt, _t, Et) {
          return new cf(Le, tt, _t, Et);
        }
        function Vc(Le) {
          return (Le = Le.prototype), !(!Le || !Le.isReactComponent);
        }
        function Nf(Le) {
          if (typeof Le == "function") return Vc(Le) ? 1 : 0;
          if (Le != null) {
            if (((Le = Le.$$typeof), Le === Ye)) return 11;
            if (Le === ot) return 14;
          }
          return 2;
        }
        function Ho(Le, tt) {
          var _t = Le.alternate;
          return (
            _t === null
              ? ((_t = Ws(Le.tag, tt, Le.key, Le.mode)),
                (_t.elementType = Le.elementType),
                (_t.type = Le.type),
                (_t.stateNode = Le.stateNode),
                (_t.alternate = Le),
                (Le.alternate = _t))
              : ((_t.pendingProps = tt),
                (_t.type = Le.type),
                (_t.flags = 0),
                (_t.subtreeFlags = 0),
                (_t.deletions = null)),
            (_t.flags = Le.flags & 14680064),
            (_t.childLanes = Le.childLanes),
            (_t.lanes = Le.lanes),
            (_t.child = Le.child),
            (_t.memoizedProps = Le.memoizedProps),
            (_t.memoizedState = Le.memoizedState),
            (_t.updateQueue = Le.updateQueue),
            (tt = Le.dependencies),
            (_t.dependencies =
              tt === null
                ? null
                : { lanes: tt.lanes, firstContext: tt.firstContext }),
            (_t.sibling = Le.sibling),
            (_t.index = Le.index),
            (_t.ref = Le.ref),
            _t
          );
        }
        function Gc(Le, tt, _t, Et, Rt, Nt) {
          var Jt = 2;
          if (((Et = Le), typeof Le == "function")) Vc(Le) && (Jt = 1);
          else if (typeof Le == "string") Jt = 5;
          else
            e: switch (Le) {
              case p:
                return Oa(_t.children, Rt, Nt, tt);
              case N:
                (Jt = 8), (Rt |= 8);
                break;
              case P:
                return (
                  (Le = Ws(12, _t, tt, Rt | 2)),
                  (Le.elementType = P),
                  (Le.lanes = Nt),
                  Le
                );
              case nt:
                return (
                  (Le = Ws(13, _t, tt, Rt)),
                  (Le.elementType = nt),
                  (Le.lanes = Nt),
                  Le
                );
              case Be:
                return (
                  (Le = Ws(19, _t, tt, Rt)),
                  (Le.elementType = Be),
                  (Le.lanes = Nt),
                  Le
                );
              case vt:
                return Jl(_t, Rt, Nt, tt);
              default:
                if (typeof Le == "object" && Le !== null)
                  switch (Le.$$typeof) {
                    case de:
                      Jt = 10;
                      break e;
                    case me:
                      Jt = 9;
                      break e;
                    case Ye:
                      Jt = 11;
                      break e;
                    case ot:
                      Jt = 14;
                      break e;
                    case st:
                      (Jt = 16), (Et = null);
                      break e;
                  }
                throw Error(a(130, Le == null ? Le : typeof Le, ""));
            }
          return (
            (tt = Ws(Jt, _t, tt, Rt)),
            (tt.elementType = Le),
            (tt.type = Et),
            (tt.lanes = Nt),
            tt
          );
        }
        function Oa(Le, tt, _t, Et) {
          return (Le = Ws(7, Le, Et, tt)), (Le.lanes = _t), Le;
        }
        function Jl(Le, tt, _t, Et) {
          return (
            (Le = Ws(22, Le, Et, tt)),
            (Le.elementType = vt),
            (Le.lanes = _t),
            (Le.stateNode = {}),
            Le
          );
        }
        function Hc(Le, tt, _t) {
          return (Le = Ws(6, Le, null, tt)), (Le.lanes = _t), Le;
        }
        function Wc(Le, tt, _t) {
          return (
            (tt = Ws(4, Le.children !== null ? Le.children : [], Le.key, tt)),
            (tt.lanes = _t),
            (tt.stateNode = {
              containerInfo: Le.containerInfo,
              pendingChildren: null,
              implementation: Le.implementation,
            }),
            tt
          );
        }
        function jc(Le, tt, _t, Et, Rt) {
          (this.tag = tt),
            (this.containerInfo = Le),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = $n),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = Va(0)),
            (this.expirationTimes = Va(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = Va(0)),
            (this.identifierPrefix = Et),
            (this.onRecoverableError = Rt),
            Bn && (this.mutableSourceEagerHydrationData = null);
        }
        function uf(Le, tt, _t, Et, Rt, Nt, Jt, vn, Wn) {
          return (
            (Le = new jc(Le, tt, _t, vn, Wn)),
            tt === 1 ? ((tt = 1), Nt === !0 && (tt |= 8)) : (tt = 0),
            (Nt = Ws(3, null, null, tt)),
            (Le.current = Nt),
            (Nt.stateNode = Le),
            (Nt.memoizedState = {
              element: Et,
              isDehydrated: _t,
              cache: null,
              transitions: null,
            }),
            Xa(Nt),
            Le
          );
        }
        function ff(Le) {
          if (!Le) return Tr;
          Le = Le._reactInternals;
          e: {
            if (Tt(Le) !== Le || Le.tag !== 1) throw Error(a(170));
            var tt = Le;
            do {
              switch (tt.tag) {
                case 3:
                  tt = tt.stateNode.context;
                  break e;
                case 1:
                  if (oi(tt.type)) {
                    tt = tt.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              tt = tt.return;
            } while (tt !== null);
            throw Error(a(171));
          }
          if (Le.tag === 1) {
            var _t = Le.type;
            if (oi(_t)) return bi(Le, _t, tt);
          }
          return tt;
        }
        function hf(Le) {
          var tt = Le._reactInternals;
          if (tt === void 0)
            throw typeof Le.render == "function"
              ? Error(a(188))
              : ((Le = Object.keys(Le).join(",")), Error(a(268, Le)));
          return (Le = Dt(tt)), Le === null ? null : Le.stateNode;
        }
        function eo(Le, tt) {
          if (
            ((Le = Le.memoizedState), Le !== null && Le.dehydrated !== null)
          ) {
            var _t = Le.retryLane;
            Le.retryLane = _t !== 0 && _t < tt ? _t : tt;
          }
        }
        function ec(Le, tt) {
          eo(Le, tt), (Le = Le.alternate) && eo(Le, tt);
        }
        function $c(Le) {
          return (Le = Dt(Le)), Le === null ? null : Le.stateNode;
        }
        function df() {
          return null;
        }
        return (
          (t.attemptContinuousHydration = function (Le) {
            if (Le.tag === 13) {
              var tt = Si();
              vs(Le, 134217728, tt), ec(Le, 134217728);
            }
          }),
          (t.attemptHydrationAtCurrentPriority = function (Le) {
            if (Le.tag === 13) {
              var tt = Si(),
                _t = uo(Le);
              vs(Le, _t, tt), ec(Le, _t);
            }
          }),
          (t.attemptSynchronousHydration = function (Le) {
            switch (Le.tag) {
              case 3:
                var tt = Le.stateNode;
                if (tt.current.memoizedState.isDehydrated) {
                  var _t = ps(tt.pendingLanes);
                  _t !== 0 &&
                    (qs(tt, _t | 1),
                    Fs(tt, ji()),
                    (ui & 6) === 0 && (ka(), xs()));
                }
                break;
              case 13:
                var Et = Si();
                ml(function () {
                  return vs(Le, 1, Et);
                }),
                  ec(Le, 1);
            }
          }),
          (t.batchedUpdates = function (Le, tt) {
            var _t = ui;
            ui |= 1;
            try {
              return Le(tt);
            } finally {
              (ui = _t), ui === 0 && (ka(), Zi && xs());
            }
          }),
          (t.createComponentSelector = function (Le) {
            return { $$typeof: Hl, value: Le };
          }),
          (t.createContainer = function (Le, tt, _t, Et, Rt, Nt, Jt) {
            return uf(Le, tt, !1, null, _t, Et, Rt, Nt, Jt);
          }),
          (t.createHasPseudoClassSelector = function (Le) {
            return { $$typeof: Aa, value: Le };
          }),
          (t.createHydrationContainer = function (
            Le,
            tt,
            _t,
            Et,
            Rt,
            Nt,
            Jt,
            vn,
            Wn
          ) {
            return (
              (Le = uf(_t, Et, !0, Le, Rt, Nt, Jt, vn, Wn)),
              (Le.context = ff(null)),
              (_t = Le.current),
              (Et = Si()),
              (Rt = uo(_t)),
              (Nt = Co(Et, Rt)),
              (Nt.callback = tt ?? null),
              Ko(_t, Nt),
              (Le.current.lanes = Rt),
              Eo(Le, Rt, Et),
              Fs(Le, Et),
              Le
            );
          }),
          (t.createPortal = function (Le, tt, _t) {
            var Et =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null;
            return {
              $$typeof: u,
              key: Et == null ? null : "" + Et,
              children: Le,
              containerInfo: tt,
              implementation: _t,
            };
          }),
          (t.createRoleSelector = function (Le) {
            return { $$typeof: Pa, value: Le };
          }),
          (t.createTestNameSelector = function (Le) {
            return { $$typeof: Bo, value: Le };
          }),
          (t.createTextSelector = function (Le) {
            return { $$typeof: ul, value: Le };
          }),
          (t.deferredUpdates = function (Le) {
            var tt = ci,
              _t = Ci.transition;
            try {
              return (Ci.transition = null), (ci = 16), Le();
            } finally {
              (ci = tt), (Ci.transition = _t);
            }
          }),
          (t.discreteUpdates = function (Le, tt, _t, Et, Rt) {
            var Nt = ci,
              Jt = Ci.transition;
            try {
              return (Ci.transition = null), (ci = 1), Le(tt, _t, Et, Rt);
            } finally {
              (ci = Nt), (Ci.transition = Jt), ui === 0 && ka();
            }
          }),
          (t.findAllNodes = Uo),
          (t.findBoundingRects = function (Le, tt) {
            if (!Gn) throw Error(a(363));
            (tt = Uo(Le, tt)), (Le = []);
            for (var _t = 0; _t < tt.length; _t++) Le.push(Gt(tt[_t]));
            for (tt = Le.length - 1; 0 < tt; tt--) {
              _t = Le[tt];
              for (
                var Et = _t.x,
                  Rt = Et + _t.width,
                  Nt = _t.y,
                  Jt = Nt + _t.height,
                  vn = tt - 1;
                0 <= vn;
                vn--
              )
                if (tt !== vn) {
                  var Wn = Le[vn],
                    dr = Wn.x,
                    kr = dr + Wn.width,
                    ii = Wn.y,
                    Zr = ii + Wn.height;
                  if (Et >= dr && Nt >= ii && Rt <= kr && Jt <= Zr) {
                    Le.splice(tt, 1);
                    break;
                  } else if (
                    Et !== dr ||
                    _t.width !== Wn.width ||
                    Zr < Nt ||
                    ii > Jt
                  ) {
                    if (
                      !(
                        Nt !== ii ||
                        _t.height !== Wn.height ||
                        kr < Et ||
                        dr > Rt
                      )
                    ) {
                      dr > Et && ((Wn.width += dr - Et), (Wn.x = Et)),
                        kr < Rt && (Wn.width = Rt - dr),
                        Le.splice(tt, 1);
                      break;
                    }
                  } else {
                    ii > Nt && ((Wn.height += ii - Nt), (Wn.y = Nt)),
                      Zr < Jt && (Wn.height = Jt - ii),
                      Le.splice(tt, 1);
                    break;
                  }
                }
            }
            return Le;
          }),
          (t.findHostInstance = hf),
          (t.findHostInstanceWithNoPortals = function (Le) {
            return (
              (Le = kt(Le)),
              (Le = Le !== null ? Ht(Le) : null),
              Le === null ? null : Le.stateNode
            );
          }),
          (t.findHostInstanceWithWarning = function (Le) {
            return hf(Le);
          }),
          (t.flushControlled = function (Le) {
            var tt = ui;
            ui |= 1;
            var _t = Ci.transition,
              Et = ci;
            try {
              (Ci.transition = null), (ci = 1), Le();
            } finally {
              (ci = Et),
                (Ci.transition = _t),
                (ui = tt),
                ui === 0 && (ka(), xs());
            }
          }),
          (t.flushPassiveEffects = xo),
          (t.flushSync = ml),
          (t.focusWithin = function (Le, tt) {
            if (!Gn) throw Error(a(363));
            for (
              Le = Wl(Le), tt = Vs(Le, tt), tt = Array.from(tt), Le = 0;
              Le < tt.length;

            ) {
              var _t = tt[Le++];
              if (!En(_t)) {
                if (_t.tag === 5 && mn(_t.stateNode)) return !0;
                for (_t = _t.child; _t !== null; )
                  tt.push(_t), (_t = _t.sibling);
              }
            }
            return !1;
          }),
          (t.getCurrentUpdatePriority = function () {
            return ci;
          }),
          (t.getFindAllNodesFailureDescription = function (Le, tt) {
            if (!Gn) throw Error(a(363));
            var _t = 0,
              Et = [];
            Le = [Wl(Le), 0];
            for (var Rt = 0; Rt < Le.length; ) {
              var Nt = Le[Rt++],
                Jt = Le[Rt++],
                vn = tt[Jt];
              if (
                (Nt.tag !== 5 || !En(Nt)) &&
                (jl(Nt, vn) && (Et.push(ia(vn)), Jt++, Jt > _t && (_t = Jt)),
                Jt < tt.length)
              )
                for (Nt = Nt.child; Nt !== null; )
                  Le.push(Nt, Jt), (Nt = Nt.sibling);
            }
            if (_t < tt.length) {
              for (Le = []; _t < tt.length; _t++) Le.push(ia(tt[_t]));
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (Et.join(" > ") +
                  `

No matching component was found for:
  `) +
                Le.join(" > ")
              );
            }
            return null;
          }),
          (t.getPublicRootInstance = function (Le) {
            if (((Le = Le.current), !Le.child)) return null;
            switch (Le.child.tag) {
              case 5:
                return Ft(Le.child.stateNode);
              default:
                return Le.child.stateNode;
            }
          }),
          (t.injectIntoDevTools = function (Le) {
            if (
              ((Le = {
                bundleType: Le.bundleType,
                version: Le.version,
                rendererPackageName: Le.rendererPackageName,
                rendererConfig: Le.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: l.ReactCurrentDispatcher,
                findHostInstanceByFiber: $c,
                findFiberByHostInstance: Le.findFiberByHostInstance || df,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329",
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            )
              Le = !1;
            else {
              var tt = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (tt.isDisabled || !tt.supportsFiber) Le = !0;
              else {
                try {
                  (en = tt.inject(Le)), (ln = tt);
                } catch {}
                Le = !!tt.checkDCE;
              }
            }
            return Le;
          }),
          (t.isAlreadyRendering = function () {
            return !1;
          }),
          (t.observeVisibleRects = function (Le, tt, _t, Et) {
            if (!Gn) throw Error(a(363));
            Le = Uo(Le, tt);
            var Rt = Vn(Le, _t, Et).disconnect;
            return {
              disconnect: function () {
                Rt();
              },
            };
          }),
          (t.registerMutableSourceForHydration = function (Le, tt) {
            var _t = tt._getVersion;
            (_t = _t(tt._source)),
              Le.mutableSourceEagerHydrationData == null
                ? (Le.mutableSourceEagerHydrationData = [tt, _t])
                : Le.mutableSourceEagerHydrationData.push(tt, _t);
          }),
          (t.runWithPriority = function (Le, tt) {
            var _t = ci;
            try {
              return (ci = Le), tt();
            } finally {
              ci = _t;
            }
          }),
          (t.shouldError = function () {
            return null;
          }),
          (t.shouldSuspend = function () {
            return !1;
          }),
          (t.updateContainer = function (Le, tt, _t, Et) {
            var Rt = tt.current,
              Nt = Si(),
              Jt = uo(Rt);
            return (
              (_t = ff(_t)),
              tt.context === null
                ? (tt.context = _t)
                : (tt.pendingContext = _t),
              (tt = Co(Nt, Jt)),
              (tt.payload = { element: Le }),
              (Et = Et === void 0 ? null : Et),
              Et !== null && (tt.callback = Et),
              Ko(Rt, tt),
              (Le = vs(Rt, Jt, Nt)),
              Le !== null && cc(Le, Rt, Jt),
              Jt
            );
          }),
          t
        );
      })),
    reactReconciler_production_min
  );
}
var hasRequiredReactReconciler;
function requireReactReconciler() {
  return (
    hasRequiredReactReconciler ||
      ((hasRequiredReactReconciler = 1),
      (reactReconciler.exports = requireReactReconciler_production_min())),
    reactReconciler.exports
  );
}
var reactReconcilerExports = requireReactReconciler();
const Reconciler = getDefaultExportFromCjs(reactReconcilerExports);
var schedulerExports = requireScheduler();
const catalogue = {},
  extend = (n) => void Object.assign(catalogue, n);
function createRenderer(n, e) {
  function t(p, { args: N = [], attach: P, ...de }, me) {
    let Ye = `${p[0].toUpperCase()}${p.slice(1)}`,
      nt;
    if (p === "primitive") {
      if (de.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const Be = de.object;
      nt = prepare(Be, { type: p, root: me, attach: P, primitive: !0 });
    } else {
      const Be = catalogue[Ye];
      if (!Be)
        throw new Error(
          `R3F: ${Ye} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(N))
        throw new Error("R3F: The args prop must be an array!");
      nt = prepare(new Be(...N), {
        type: p,
        root: me,
        attach: P,
        memoizedProps: { args: N },
      });
    }
    return (
      nt.__r3f.attach === void 0 &&
        (nt.isBufferGeometry
          ? (nt.__r3f.attach = "geometry")
          : nt.isMaterial && (nt.__r3f.attach = "material")),
      Ye !== "inject" && applyProps$1(nt, de),
      nt
    );
  }
  function r(p, N) {
    let P = !1;
    if (N) {
      var de, me;
      (de = N.__r3f) != null && de.attach
        ? attach(p, N, N.__r3f.attach)
        : N.isObject3D && p.isObject3D && (p.add(N), (P = !0)),
        P || (me = p.__r3f) == null || me.objects.push(N),
        N.__r3f || prepare(N, {}),
        (N.__r3f.parent = p),
        updateInstance(N),
        invalidateInstance(N);
    }
  }
  function s(p, N, P) {
    let de = !1;
    if (N) {
      var me, Ye;
      if ((me = N.__r3f) != null && me.attach) attach(p, N, N.__r3f.attach);
      else if (N.isObject3D && p.isObject3D) {
        (N.parent = p),
          N.dispatchEvent({ type: "added" }),
          p.dispatchEvent({ type: "childadded", child: N });
        const nt = p.children.filter((ot) => ot !== N),
          Be = nt.indexOf(P);
        (p.children = [...nt.slice(0, Be), N, ...nt.slice(Be)]), (de = !0);
      }
      de || (Ye = p.__r3f) == null || Ye.objects.push(N),
        N.__r3f || prepare(N, {}),
        (N.__r3f.parent = p),
        updateInstance(N),
        invalidateInstance(N);
    }
  }
  function o(p, N, P = !1) {
    p && [...p].forEach((de) => a(N, de, P));
  }
  function a(p, N, P) {
    if (N) {
      var de, me, Ye;
      if (
        (N.__r3f && (N.__r3f.parent = null),
        (de = p.__r3f) != null &&
          de.objects &&
          (p.__r3f.objects = p.__r3f.objects.filter((vt) => vt !== N)),
        (me = N.__r3f) != null && me.attach)
      )
        detach(p, N, N.__r3f.attach);
      else if (N.isObject3D && p.isObject3D) {
        var nt;
        p.remove(N),
          (nt = N.__r3f) != null &&
            nt.root &&
            removeInteractivity(findInitialRoot(N), N);
      }
      const ot = (Ye = N.__r3f) == null ? void 0 : Ye.primitive,
        st = !ot && (P === void 0 ? N.dispose !== null : P);
      if (!ot) {
        var Be;
        o((Be = N.__r3f) == null ? void 0 : Be.objects, N, st),
          o(N.children, N, st);
      }
      if ((delete N.__r3f, st && N.dispose && N.type !== "Scene")) {
        const vt = () => {
          try {
            N.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? schedulerExports.unstable_scheduleCallback(
              schedulerExports.unstable_IdlePriority,
              vt
            )
          : vt();
      }
      invalidateInstance(p);
    }
  }
  function l(p, N, P, de) {
    var me;
    const Ye = (me = p.__r3f) == null ? void 0 : me.parent;
    if (!Ye) return;
    const nt = t(N, P, p.__r3f.root);
    if (p.children) {
      for (const Be of p.children) Be.__r3f && r(nt, Be);
      p.children = p.children.filter((Be) => !Be.__r3f);
    }
    p.__r3f.objects.forEach((Be) => r(nt, Be)),
      (p.__r3f.objects = []),
      p.__r3f.autoRemovedBeforeAppend || a(Ye, p),
      nt.parent && (nt.__r3f.autoRemovedBeforeAppend = !0),
      r(Ye, nt),
      nt.raycast &&
        nt.__r3f.eventCount &&
        findInitialRoot(nt).getState().internal.interaction.push(nt),
      [de, de.alternate].forEach((Be) => {
        Be !== null &&
          ((Be.stateNode = nt),
          Be.ref &&
            (typeof Be.ref == "function" ? Be.ref(nt) : (Be.ref.current = nt)));
      });
  }
  const c = () => {};
  return {
    reconciler: Reconciler({
      createInstance: t,
      removeChild: a,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: s,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (p, N) => {
        if (!N) return;
        const P = p.getState().scene;
        P.__r3f && ((P.__r3f.root = p), r(P, N));
      },
      removeChildFromContainer: (p, N) => {
        N && a(p.getState().scene, N);
      },
      insertInContainerBefore: (p, N, P) => {
        if (!N || !P) return;
        const de = p.getState().scene;
        de.__r3f && s(de, N, P);
      },
      getRootHostContext: () => null,
      getChildHostContext: (p) => p,
      finalizeInitialChildren(p) {
        var N;
        return !!((N = p == null ? void 0 : p.__r3f) != null ? N : {}).handlers;
      },
      prepareUpdate(p, N, P, de) {
        var me;
        if (
          ((me = p == null ? void 0 : p.__r3f) != null ? me : {}).primitive &&
          de.object &&
          de.object !== p
        )
          return [!0];
        {
          const { args: nt = [], children: Be, ...ot } = de,
            { args: st = [], children: vt, ...xt } = P;
          if (!Array.isArray(nt))
            throw new Error("R3F: the args prop must be an array!");
          if (nt.some((wt, bt) => wt !== st[bt])) return [!0];
          const St = diffProps(p, ot, xt, !0);
          return St.changes.length ? [!1, St] : null;
        }
      },
      commitUpdate(p, [N, P], de, me, Ye, nt) {
        N ? l(p, de, Ye, nt) : applyProps$1(p, P);
      },
      commitMount(p, N, P, de) {
        var me;
        const Ye = (me = p.__r3f) != null ? me : {};
        p.raycast &&
          Ye.handlers &&
          Ye.eventCount &&
          findInitialRoot(p).getState().internal.interaction.push(p);
      },
      getPublicInstance: (p) => p,
      prepareForCommit: () => null,
      preparePortalMount: (p) => prepare(p.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(p) {
        var N;
        const { attach: P, parent: de } = (N = p.__r3f) != null ? N : {};
        P && de && detach(de, p, P),
          p.isObject3D && (p.visible = !1),
          invalidateInstance(p);
      },
      unhideInstance(p, N) {
        var P;
        const { attach: de, parent: me } = (P = p.__r3f) != null ? P : {};
        de && me && attach(me, p, de),
          ((p.isObject3D && N.visible == null) || N.visible) &&
            (p.visible = !0),
          invalidateInstance(p);
      },
      createTextInstance: c,
      hideTextInstance: c,
      unhideTextInstance: c,
      getCurrentEventPriority: () =>
        e ? e() : constantsExports.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && is.fun(performance.now)
          ? performance.now
          : is.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: applyProps$1,
  };
}
var _window$document, _window$navigator;
const hasColorSpace$1 = (n) => "colorSpace" in n || "outputColorSpace" in n,
  getColorManagement = () => {
    var n;
    return (n = catalogue.ColorManagement) != null ? n : null;
  },
  isOrthographicCamera = (n) => n && n.isOrthographicCamera,
  isRef$1 = (n) => n && n.hasOwnProperty("current"),
  useIsomorphicLayoutEffect =
    typeof window < "u" &&
    (((_window$document = window.document) != null &&
      _window$document.createElement) ||
      ((_window$navigator = window.navigator) == null
        ? void 0
        : _window$navigator.product) === "ReactNative")
      ? reactExports.useLayoutEffect
      : reactExports.useEffect;
function useMutableCallback(n) {
  const e = reactExports.useRef(n);
  return useIsomorphicLayoutEffect(() => void (e.current = n), [n]), e;
}
function Block({ set: n }) {
  return (
    useIsomorphicLayoutEffect(
      () => (n(new Promise(() => null)), () => n(!1)),
      [n]
    ),
    null
  );
}
class ErrorBoundary extends reactExports.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
ErrorBoundary.getDerivedStateFromError = () => ({ error: !0 });
const DEFAULT = "__default",
  DEFAULTS = new Map(),
  isDiffSet = (n) => n && !!n.memoized && !!n.changes;
function calculateDpr(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const getRootState = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function findInitialRoot(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const is = {
  obj: (n) => n === Object(n) && !is.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: r = "reference", strict: s = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (is.str(n) || is.num(n) || is.boo(n)) return n === e;
    const o = is.obj(n);
    if (o && r === "reference") return n === e;
    const a = is.arr(n);
    if (a && t === "reference") return n === e;
    if ((a || o) && n === e) return !0;
    let l;
    for (l in n) if (!(l in e)) return !1;
    if (o && t === "shallow" && r === "shallow") {
      for (l in s ? e : n)
        if (!is.equ(n[l], e[l], { strict: s, objects: "reference" })) return !1;
    } else for (l in s ? e : n) if (n[l] !== e[l]) return !1;
    if (is.und(l)) {
      if (
        (a && n.length === 0 && e.length === 0) ||
        (o && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function buildGraph(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function dispose(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function prepare(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function resolve(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      s = r.pop();
    return (t = r.reduce((o, a) => o[a], n)), { target: t, key: s };
  } else return { target: t, key: e };
}
const INDEX_REGEX = /-\d+$/;
function attach(n, e, t) {
  if (is.str(t)) {
    if (INDEX_REGEX.test(t)) {
      const o = t.replace(INDEX_REGEX, ""),
        { target: a, key: l } = resolve(n, o);
      Array.isArray(a[l]) || (a[l] = []);
    }
    const { target: r, key: s } = resolve(n, t);
    (e.__r3f.previousAttach = r[s]), (r[s] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function detach(n, e, t) {
  var r, s;
  if (is.str(t)) {
    const { target: o, key: a } = resolve(n, t),
      l = e.__r3f.previousAttach;
    l === void 0 ? delete o[a] : (o[a] = l);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (s = e.__r3f) == null || delete s.previousAttach;
}
function diffProps(
  n,
  { children: e, key: t, ref: r, ...s },
  { children: o, key: a, ref: l, ...c } = {},
  u = !1
) {
  const p = n.__r3f,
    N = Object.entries(s),
    P = [];
  if (u) {
    const me = Object.keys(c);
    for (let Ye = 0; Ye < me.length; Ye++)
      s.hasOwnProperty(me[Ye]) || N.unshift([me[Ye], DEFAULT + "remove"]);
  }
  N.forEach(([me, Ye]) => {
    var nt;
    if (
      ((nt = n.__r3f) != null && nt.primitive && me === "object") ||
      is.equ(Ye, c[me])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(me))
      return P.push([me, Ye, !0, []]);
    let Be = [];
    me.includes("-") && (Be = me.split("-")), P.push([me, Ye, !1, Be]);
    for (const ot in s) {
      const st = s[ot];
      ot.startsWith(`${me}-`) && P.push([ot, st, !1, ot.split("-")]);
    }
  });
  const de = { ...s };
  return (
    p != null &&
      p.memoizedProps &&
      p != null &&
      p.memoizedProps.args &&
      (de.args = p.memoizedProps.args),
    p != null &&
      p.memoizedProps &&
      p != null &&
      p.memoizedProps.attach &&
      (de.attach = p.memoizedProps.attach),
    { memoized: de, changes: P }
  );
}
function applyProps$1(n, e) {
  var t;
  const r = n.__r3f,
    s = r == null ? void 0 : r.root,
    o = s == null || s.getState == null ? void 0 : s.getState(),
    { memoized: a, changes: l } = isDiffSet(e) ? e : diffProps(n, e),
    c = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = a);
  for (let P = 0; P < l.length; P++) {
    let [de, me, Ye, nt] = l[P];
    if (hasColorSpace$1(n)) {
      const vt = "srgb",
        xt = "srgb-linear";
      de === "encoding"
        ? ((de = "colorSpace"), (me = me === 3001 ? vt : xt))
        : de === "outputEncoding" &&
          ((de = "outputColorSpace"), (me = me === 3001 ? vt : xt));
    }
    let Be = n,
      ot = Be[de];
    if (
      nt.length &&
      ((ot = nt.reduce((st, vt) => st[vt], n)), !(ot && ot.set))
    ) {
      const [st, ...vt] = nt.reverse();
      (Be = vt.reverse().reduce((xt, St) => xt[St], n)), (de = st);
    }
    if (me === DEFAULT + "remove")
      if (Be.constructor) {
        let st = DEFAULTS.get(Be.constructor);
        st || ((st = new Be.constructor()), DEFAULTS.set(Be.constructor, st)),
          (me = st[de]);
      } else me = 0;
    if (Ye && r)
      me ? (r.handlers[de] = me) : delete r.handlers[de],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (ot && ot.set && (ot.copy || ot instanceof Layers)) {
      if (Array.isArray(me)) ot.fromArray ? ot.fromArray(me) : ot.set(...me);
      else if (
        ot.copy &&
        me &&
        me.constructor &&
        ot.constructor === me.constructor
      )
        ot.copy(me);
      else if (me !== void 0) {
        var u;
        const st = (u = ot) == null ? void 0 : u.isColor;
        !st && ot.setScalar
          ? ot.setScalar(me)
          : ot instanceof Layers && me instanceof Layers
          ? (ot.mask = me.mask)
          : ot.set(me),
          !getColorManagement() &&
            o &&
            !o.linear &&
            st &&
            ot.convertSRGBToLinear();
      }
    } else {
      var p;
      if (
        ((Be[de] = me),
        (p = Be[de]) != null &&
          p.isTexture &&
          Be[de].format === RGBAFormat &&
          Be[de].type === UnsignedByteType &&
          o)
      ) {
        const st = Be[de];
        hasColorSpace$1(st) && hasColorSpace$1(o.gl)
          ? (st.colorSpace = o.gl.outputColorSpace)
          : (st.encoding = o.gl.outputEncoding);
      }
    }
    invalidateInstance(n);
  }
  if (r && r.parent && n.raycast && c !== r.eventCount) {
    const P = findInitialRoot(n).getState().internal,
      de = P.interaction.indexOf(n);
    de > -1 && P.interaction.splice(de, 1),
      r.eventCount && P.interaction.push(n);
  }
  return (
    !(l.length === 1 && l[0][0] === "onUpdate") &&
      l.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      updateInstance(n),
    n
  );
}
function invalidateInstance(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function updateInstance(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function updateCamera(n, e) {
  n.manual ||
    (isOrthographicCamera(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function makeId(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function getEventPriority() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return constantsExports.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return constantsExports.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return constantsExports.ContinuousEventPriority;
    default:
      return constantsExports.DefaultEventPriority;
  }
}
function releaseInternalPointerCapture(n, e, t, r) {
  const s = t.get(e);
  s &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), s.target.releasePointerCapture(r)));
}
function removeInteractivity(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, s) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(s);
    }),
    t.capturedMap.forEach((r, s) => {
      releaseInternalPointerCapture(t.capturedMap, e, r, s);
    });
}
function createEvents(n) {
  function e(c) {
    const { internal: u } = n.getState(),
      p = c.offsetX - u.initialClick[0],
      N = c.offsetY - u.initialClick[1];
    return Math.round(Math.sqrt(p * p + N * N));
  }
  function t(c) {
    return c.filter((u) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((p) => {
        var N;
        return (N = u.__r3f) == null ? void 0 : N.handlers["onPointer" + p];
      })
    );
  }
  function r(c, u) {
    const p = n.getState(),
      N = new Set(),
      P = [],
      de = u ? u(p.internal.interaction) : p.internal.interaction;
    for (let Be = 0; Be < de.length; Be++) {
      const ot = getRootState(de[Be]);
      ot && (ot.raycaster.camera = void 0);
    }
    p.previousRoot || p.events.compute == null || p.events.compute(c, p);
    function me(Be) {
      const ot = getRootState(Be);
      if (!ot || !ot.events.enabled || ot.raycaster.camera === null) return [];
      if (ot.raycaster.camera === void 0) {
        var st;
        ot.events.compute == null ||
          ot.events.compute(
            c,
            ot,
            (st = ot.previousRoot) == null ? void 0 : st.getState()
          ),
          ot.raycaster.camera === void 0 && (ot.raycaster.camera = null);
      }
      return ot.raycaster.camera ? ot.raycaster.intersectObject(Be, !0) : [];
    }
    let Ye = de
      .flatMap(me)
      .sort((Be, ot) => {
        const st = getRootState(Be.object),
          vt = getRootState(ot.object);
        return !st || !vt
          ? Be.distance - ot.distance
          : vt.events.priority - st.events.priority ||
              Be.distance - ot.distance;
      })
      .filter((Be) => {
        const ot = makeId(Be);
        return N.has(ot) ? !1 : (N.add(ot), !0);
      });
    p.events.filter && (Ye = p.events.filter(Ye, p));
    for (const Be of Ye) {
      let ot = Be.object;
      for (; ot; ) {
        var nt;
        (nt = ot.__r3f) != null &&
          nt.eventCount &&
          P.push({ ...Be, eventObject: ot }),
          (ot = ot.parent);
      }
    }
    if ("pointerId" in c && p.internal.capturedMap.has(c.pointerId))
      for (let Be of p.internal.capturedMap.get(c.pointerId).values())
        N.has(makeId(Be.intersection)) || P.push(Be.intersection);
    return P;
  }
  function s(c, u, p, N) {
    const P = n.getState();
    if (c.length) {
      const de = { stopped: !1 };
      for (const me of c) {
        const Ye = getRootState(me.object) || P,
          { raycaster: nt, pointer: Be, camera: ot, internal: st } = Ye,
          vt = new Vector3(Be.x, Be.y, 0).unproject(ot),
          xt = (Ct) => {
            var kt, Dt;
            return (kt =
              (Dt = st.capturedMap.get(Ct)) == null
                ? void 0
                : Dt.has(me.eventObject)) != null
              ? kt
              : !1;
          },
          St = (Ct) => {
            const kt = { intersection: me, target: u.target };
            st.capturedMap.has(Ct)
              ? st.capturedMap.get(Ct).set(me.eventObject, kt)
              : st.capturedMap.set(Ct, new Map([[me.eventObject, kt]])),
              u.target.setPointerCapture(Ct);
          },
          wt = (Ct) => {
            const kt = st.capturedMap.get(Ct);
            kt &&
              releaseInternalPointerCapture(
                st.capturedMap,
                me.eventObject,
                kt,
                Ct
              );
          };
        let bt = {};
        for (let Ct in u) {
          let kt = u[Ct];
          typeof kt != "function" && (bt[Ct] = kt);
        }
        let Tt = {
          ...me,
          ...bt,
          pointer: Be,
          intersections: c,
          stopped: de.stopped,
          delta: p,
          unprojectedPoint: vt,
          ray: nt.ray,
          camera: ot,
          stopPropagation() {
            const Ct = "pointerId" in u && st.capturedMap.get(u.pointerId);
            if (
              (!Ct || Ct.has(me.eventObject)) &&
              ((Tt.stopped = de.stopped = !0),
              st.hovered.size &&
                Array.from(st.hovered.values()).find(
                  (kt) => kt.eventObject === me.eventObject
                ))
            ) {
              const kt = c.slice(0, c.indexOf(me));
              o([...kt, me]);
            }
          },
          target: {
            hasPointerCapture: xt,
            setPointerCapture: St,
            releasePointerCapture: wt,
          },
          currentTarget: {
            hasPointerCapture: xt,
            setPointerCapture: St,
            releasePointerCapture: wt,
          },
          nativeEvent: u,
        };
        if ((N(Tt), de.stopped === !0)) break;
      }
    }
    return c;
  }
  function o(c) {
    const { internal: u } = n.getState();
    for (const p of u.hovered.values())
      if (
        !c.length ||
        !c.find(
          (N) =>
            N.object === p.object &&
            N.index === p.index &&
            N.instanceId === p.instanceId
        )
      ) {
        const P = p.eventObject.__r3f,
          de = P == null ? void 0 : P.handlers;
        if ((u.hovered.delete(makeId(p)), P != null && P.eventCount)) {
          const me = { ...p, intersections: c };
          de.onPointerOut == null || de.onPointerOut(me),
            de.onPointerLeave == null || de.onPointerLeave(me);
        }
      }
  }
  function a(c, u) {
    for (let p = 0; p < u.length; p++) {
      const N = u[p].__r3f;
      N == null ||
        N.handlers.onPointerMissed == null ||
        N.handlers.onPointerMissed(c);
    }
  }
  function l(c) {
    switch (c) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (u) => {
          const { internal: p } = n.getState();
          "pointerId" in u &&
            p.capturedMap.has(u.pointerId) &&
            requestAnimationFrame(() => {
              p.capturedMap.has(u.pointerId) &&
                (p.capturedMap.delete(u.pointerId), o([]));
            });
        };
    }
    return function (p) {
      const { onPointerMissed: N, internal: P } = n.getState();
      P.lastEvent.current = p;
      const de = c === "onPointerMove",
        me = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick",
        nt = r(p, de ? t : void 0),
        Be = me ? e(p) : 0;
      c === "onPointerDown" &&
        ((P.initialClick = [p.offsetX, p.offsetY]),
        (P.initialHits = nt.map((st) => st.eventObject))),
        me && !nt.length && Be <= 2 && (a(p, P.interaction), N && N(p)),
        de && o(nt);
      function ot(st) {
        const vt = st.eventObject,
          xt = vt.__r3f,
          St = xt == null ? void 0 : xt.handlers;
        if (xt != null && xt.eventCount)
          if (de) {
            if (
              St.onPointerOver ||
              St.onPointerEnter ||
              St.onPointerOut ||
              St.onPointerLeave
            ) {
              const wt = makeId(st),
                bt = P.hovered.get(wt);
              bt
                ? bt.stopped && st.stopPropagation()
                : (P.hovered.set(wt, st),
                  St.onPointerOver == null || St.onPointerOver(st),
                  St.onPointerEnter == null || St.onPointerEnter(st));
            }
            St.onPointerMove == null || St.onPointerMove(st);
          } else {
            const wt = St[c];
            wt
              ? (!me || P.initialHits.includes(vt)) &&
                (a(
                  p,
                  P.interaction.filter((bt) => !P.initialHits.includes(bt))
                ),
                wt(st))
              : me &&
                P.initialHits.includes(vt) &&
                a(
                  p,
                  P.interaction.filter((bt) => !P.initialHits.includes(bt))
                );
          }
      }
      s(nt, p, Be, ot);
    };
  }
  return { handlePointer: l };
}
const privateKeys = [
    "set",
    "get",
    "setSize",
    "setFrameloop",
    "setDpr",
    "events",
    "invalidate",
    "advance",
    "size",
    "viewport",
  ],
  isRenderer = (n) => !!(n != null && n.render),
  context = reactExports.createContext(null),
  createStore = (n, e) => {
    const t = create((l, c) => {
        const u = new Vector3(),
          p = new Vector3(),
          N = new Vector3();
        function P(Be = c().camera, ot = p, st = c().size) {
          const { width: vt, height: xt, top: St, left: wt } = st,
            bt = vt / xt;
          ot.isVector3 ? N.copy(ot) : N.set(...ot);
          const Tt = Be.getWorldPosition(u).distanceTo(N);
          if (isOrthographicCamera(Be))
            return {
              width: vt / Be.zoom,
              height: xt / Be.zoom,
              top: St,
              left: wt,
              factor: 1,
              distance: Tt,
              aspect: bt,
            };
          {
            const Ct = (Be.fov * Math.PI) / 180,
              kt = 2 * Math.tan(Ct / 2) * Tt,
              Dt = kt * (vt / xt);
            return {
              width: Dt,
              height: kt,
              top: St,
              left: wt,
              factor: vt / Dt,
              distance: Tt,
              aspect: bt,
            };
          }
        }
        let de;
        const me = (Be) =>
            l((ot) => ({ performance: { ...ot.performance, current: Be } })),
          Ye = new Vector2();
        return {
          set: l,
          get: c,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (Be = 1) => n(c(), Be),
          advance: (Be, ot) => e(Be, ot, c()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new Clock(),
          pointer: Ye,
          mouse: Ye,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const Be = c();
              de && clearTimeout(de),
                Be.performance.current !== Be.performance.min &&
                  me(Be.performance.min),
                (de = setTimeout(
                  () => me(c().performance.max),
                  Be.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: P,
          },
          setEvents: (Be) =>
            l((ot) => ({ ...ot, events: { ...ot.events, ...Be } })),
          setSize: (Be, ot, st, vt, xt) => {
            const St = c().camera,
              wt = {
                width: Be,
                height: ot,
                top: vt || 0,
                left: xt || 0,
                updateStyle: st,
              };
            l((bt) => ({
              size: wt,
              viewport: { ...bt.viewport, ...P(St, p, wt) },
            }));
          },
          setDpr: (Be) =>
            l((ot) => {
              const st = calculateDpr(Be);
              return {
                viewport: {
                  ...ot.viewport,
                  dpr: st,
                  initialDpr: ot.viewport.initialDpr || st,
                },
              };
            }),
          setFrameloop: (Be = "always") => {
            const ot = c().clock;
            ot.stop(),
              (ot.elapsedTime = 0),
              Be !== "never" && (ot.start(), (ot.elapsedTime = 0)),
              l(() => ({ frameloop: Be }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: reactExports.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (Be, ot, st) => {
              const vt = c().internal;
              return (
                (vt.priority = vt.priority + (ot > 0 ? 1 : 0)),
                vt.subscribers.push({ ref: Be, priority: ot, store: st }),
                (vt.subscribers = vt.subscribers.sort(
                  (xt, St) => xt.priority - St.priority
                )),
                () => {
                  const xt = c().internal;
                  xt != null &&
                    xt.subscribers &&
                    ((xt.priority = xt.priority - (ot > 0 ? 1 : 0)),
                    (xt.subscribers = xt.subscribers.filter(
                      (St) => St.ref !== Be
                    )));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let s = r.size,
      o = r.viewport.dpr,
      a = r.camera;
    return (
      t.subscribe(() => {
        const { camera: l, size: c, viewport: u, gl: p, set: N } = t.getState();
        if (c.width !== s.width || c.height !== s.height || u.dpr !== o) {
          var P;
          (s = c), (o = u.dpr), updateCamera(l, c), p.setPixelRatio(u.dpr);
          const de =
            (P = c.updateStyle) != null
              ? P
              : typeof HTMLCanvasElement < "u" &&
                p.domElement instanceof HTMLCanvasElement;
          p.setSize(c.width, c.height, de);
        }
        l !== a &&
          ((a = l),
          N((de) => ({
            viewport: { ...de.viewport, ...de.viewport.getCurrentViewport(l) },
          })));
      }),
      t.subscribe((l) => n(l)),
      t
    );
  };
let i$1,
  globalEffects = new Set(),
  globalAfterEffects = new Set(),
  globalTailEffects = new Set();
function run(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function flushGlobalEffects(n, e) {
  switch (n) {
    case "before":
      return run(globalEffects, e);
    case "after":
      return run(globalAfterEffects, e);
    case "tail":
      return run(globalTailEffects, e);
  }
}
let subscribers, subscription;
function render$1(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      subscribers = e.internal.subscribers,
      i$1 = 0;
    i$1 < subscribers.length;
    i$1++
  )
    (subscription = subscribers[i$1]),
      subscription.ref.current(subscription.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function createLoop(n) {
  let e = !1,
    t = !1,
    r,
    s,
    o;
  function a(u) {
    (s = requestAnimationFrame(a)),
      (e = !0),
      (r = 0),
      flushGlobalEffects("before", u),
      (t = !0);
    for (const N of n.values()) {
      var p;
      (o = N.store.getState()),
        o.internal.active &&
          (o.frameloop === "always" || o.internal.frames > 0) &&
          !((p = o.gl.xr) != null && p.isPresenting) &&
          (r += render$1(u, o));
    }
    if (((t = !1), flushGlobalEffects("after", u), r === 0))
      return flushGlobalEffects("tail", u), (e = !1), cancelAnimationFrame(s);
  }
  function l(u, p = 1) {
    var N;
    if (!u) return n.forEach((P) => l(P.store.getState(), p));
    ((N = u.gl.xr) != null && N.isPresenting) ||
      !u.internal.active ||
      u.frameloop === "never" ||
      (p > 1
        ? (u.internal.frames = Math.min(60, u.internal.frames + p))
        : t
        ? (u.internal.frames = 2)
        : (u.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(a)));
  }
  function c(u, p = !0, N, P) {
    if ((p && flushGlobalEffects("before", u), N)) render$1(u, N, P);
    else for (const de of n.values()) render$1(u, de.store.getState());
    p && flushGlobalEffects("after", u);
  }
  return { loop: a, invalidate: l, advance: c };
}
function useStore() {
  const n = reactExports.useContext(context);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function useThree(n = (t) => t, e) {
  return useStore()(n, e);
}
function useFrame(n, e = 0) {
  const t = useStore(),
    r = t.getState().internal.subscribe,
    s = useMutableCallback(n);
  return useIsomorphicLayoutEffect(() => r(s, e, t), [e, r, t]), null;
}
const memoizedLoaders = new WeakMap();
function loadingFn(n, e) {
  return function (t, ...r) {
    let s = memoizedLoaders.get(t);
    return (
      s || ((s = new t()), memoizedLoaders.set(t, s)),
      n && n(s),
      Promise.all(
        r.map(
          (o) =>
            new Promise((a, l) =>
              s.load(
                o,
                (c) => {
                  c.scene && Object.assign(c, buildGraph(c.scene)), a(c);
                },
                e,
                (c) =>
                  l(
                    new Error(
                      `Could not load ${o}: ${c == null ? void 0 : c.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function useLoader(n, e, t, r) {
  const s = Array.isArray(e) ? e : [e],
    o = suspend(loadingFn(t, r), [n, ...s], { equal: is.equ });
  return Array.isArray(e) ? o : o[0];
}
useLoader.preload = function (n, e, t) {
  const r = Array.isArray(e) ? e : [e];
  return preload(loadingFn(t), [n, ...r]);
};
useLoader.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return clear([n, ...t]);
};
const roots = new Map(),
  { invalidate, advance } = createLoop(roots),
  { reconciler, applyProps } = createRenderer(roots, getEventPriority),
  shallowLoose = { objects: "shallow", strict: !1 },
  createRendererInstance = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return isRenderer(t)
      ? t
      : new WebGLRenderer({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function computeInitialSize(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: s, top: o, left: a, updateStyle: l = t } = e;
    return { width: r, height: s, top: o, left: a, updateStyle: l };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: r,
      height: s,
      top: o,
      left: a,
    } = n.parentElement.getBoundingClientRect();
    return { width: r, height: s, top: o, left: a, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function createRoot(n) {
  const e = roots.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const s = typeof reportError == "function" ? reportError : console.error,
    o = r || createStore(invalidate, advance),
    a =
      t ||
      reconciler.createContainer(
        o,
        constantsExports.ConcurrentRoot,
        null,
        !1,
        null,
        "",
        s,
        null
      );
  e || roots.set(n, { fiber: a, store: o });
  let l,
    c = !1,
    u;
  return {
    configure(p = {}) {
      let {
          gl: N,
          size: P,
          scene: de,
          events: me,
          onCreated: Ye,
          shadows: nt = !1,
          linear: Be = !1,
          flat: ot = !1,
          legacy: st = !1,
          orthographic: vt = !1,
          frameloop: xt = "always",
          dpr: St = [1, 2],
          performance: wt,
          raycaster: bt,
          camera: Tt,
          onPointerMissed: Ct,
        } = p,
        kt = o.getState(),
        Dt = kt.gl;
      kt.gl || kt.set({ gl: (Dt = createRendererInstance(N, n)) });
      let Vt = kt.raycaster;
      Vt || kt.set({ raycaster: (Vt = new Raycaster()) });
      const { params: Ht, ...qt } = bt || {};
      if (
        (is.equ(qt, Vt, shallowLoose) || applyProps(Vt, { ...qt }),
        is.equ(Ht, Vt.params, shallowLoose) ||
          applyProps(Vt, { params: { ...Vt.params, ...Ht } }),
        !kt.camera || (kt.camera === u && !is.equ(u, Tt, shallowLoose)))
      ) {
        u = Tt;
        const It = Tt instanceof Camera,
          Ot = It
            ? Tt
            : vt
            ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3)
            : new PerspectiveCamera(75, 0, 0.1, 1e3);
        It ||
          ((Ot.position.z = 5),
          Tt &&
            (applyProps(Ot, Tt),
            ("aspect" in Tt ||
              "left" in Tt ||
              "right" in Tt ||
              "bottom" in Tt ||
              "top" in Tt) &&
              ((Ot.manual = !0), Ot.updateProjectionMatrix())),
          !kt.camera && !(Tt != null && Tt.rotation) && Ot.lookAt(0, 0, 0)),
          kt.set({ camera: Ot }),
          (Vt.camera = Ot);
      }
      if (!kt.scene) {
        let It;
        de != null && de.isScene
          ? (It = de)
          : ((It = new Scene()), de && applyProps(It, de)),
          kt.set({ scene: prepare(It) });
      }
      if (!kt.xr) {
        var Ft;
        const It = (sn, Kt) => {
            const tn = o.getState();
            tn.frameloop !== "never" && advance(sn, !0, tn, Kt);
          },
          Ot = () => {
            const sn = o.getState();
            (sn.gl.xr.enabled = sn.gl.xr.isPresenting),
              sn.gl.xr.setAnimationLoop(sn.gl.xr.isPresenting ? It : null),
              sn.gl.xr.isPresenting || invalidate(sn);
          },
          Xt = {
            connect() {
              const sn = o.getState().gl;
              sn.xr.addEventListener("sessionstart", Ot),
                sn.xr.addEventListener("sessionend", Ot);
            },
            disconnect() {
              const sn = o.getState().gl;
              sn.xr.removeEventListener("sessionstart", Ot),
                sn.xr.removeEventListener("sessionend", Ot);
            },
          };
        typeof ((Ft = Dt.xr) == null ? void 0 : Ft.addEventListener) ==
          "function" && Xt.connect(),
          kt.set({ xr: Xt });
      }
      if (Dt.shadowMap) {
        const It = Dt.shadowMap.enabled,
          Ot = Dt.shadowMap.type;
        if (((Dt.shadowMap.enabled = !!nt), is.boo(nt)))
          Dt.shadowMap.type = PCFSoftShadowMap;
        else if (is.str(nt)) {
          var Bt;
          const Xt = {
            basic: BasicShadowMap,
            percentage: PCFShadowMap,
            soft: PCFSoftShadowMap,
            variance: VSMShadowMap,
          };
          Dt.shadowMap.type = (Bt = Xt[nt]) != null ? Bt : PCFSoftShadowMap;
        } else is.obj(nt) && Object.assign(Dt.shadowMap, nt);
        (It !== Dt.shadowMap.enabled || Ot !== Dt.shadowMap.type) &&
          (Dt.shadowMap.needsUpdate = !0);
      }
      const Mt = getColorManagement();
      Mt &&
        ("enabled" in Mt
          ? (Mt.enabled = !st)
          : "legacyMode" in Mt && (Mt.legacyMode = st)),
        c ||
          applyProps(Dt, {
            outputEncoding: Be ? 3e3 : 3001,
            toneMapping: ot ? NoToneMapping : ACESFilmicToneMapping,
          }),
        kt.legacy !== st && kt.set(() => ({ legacy: st })),
        kt.linear !== Be && kt.set(() => ({ linear: Be })),
        kt.flat !== ot && kt.set(() => ({ flat: ot })),
        N &&
          !is.fun(N) &&
          !isRenderer(N) &&
          !is.equ(N, Dt, shallowLoose) &&
          applyProps(Dt, N),
        me && !kt.events.handlers && kt.set({ events: me(o) });
      const Pt = computeInitialSize(n, P);
      return (
        is.equ(Pt, kt.size, shallowLoose) ||
          kt.setSize(Pt.width, Pt.height, Pt.updateStyle, Pt.top, Pt.left),
        St && kt.viewport.dpr !== calculateDpr(St) && kt.setDpr(St),
        kt.frameloop !== xt && kt.setFrameloop(xt),
        kt.onPointerMissed || kt.set({ onPointerMissed: Ct }),
        wt &&
          !is.equ(wt, kt.performance, shallowLoose) &&
          kt.set((It) => ({ performance: { ...It.performance, ...wt } })),
        (l = Ye),
        (c = !0),
        this
      );
    },
    render(p) {
      return (
        c || this.configure(),
        reconciler.updateContainer(
          jsxRuntimeExports.jsx(Provider, {
            store: o,
            children: p,
            onCreated: l,
            rootElement: n,
          }),
          a,
          null,
          () => {}
        ),
        o
      );
    },
    unmount() {
      unmountComponentAtNode(n);
    },
  };
}
function Provider({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    useIsomorphicLayoutEffect(() => {
      const s = n.getState();
      s.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        t && t(s),
        n.getState().events.connected ||
          s.events.connect == null ||
          s.events.connect(r);
    }, []),
    jsxRuntimeExports.jsx(context.Provider, { value: n, children: e })
  );
}
function unmountComponentAtNode(n, e) {
  const t = roots.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const s = t == null ? void 0 : t.store.getState();
    s && (s.internal.active = !1),
      reconciler.updateContainer(null, r, null, () => {
        s &&
          setTimeout(() => {
            try {
              var o, a, l, c;
              s.events.disconnect == null || s.events.disconnect(),
                (o = s.gl) == null ||
                  (a = o.renderLists) == null ||
                  a.dispose == null ||
                  a.dispose(),
                (l = s.gl) == null ||
                  l.forceContextLoss == null ||
                  l.forceContextLoss(),
                (c = s.gl) != null && c.xr && s.xr.disconnect(),
                dispose(s),
                roots.delete(n);
            } catch {}
          }, 500);
      });
  }
}
function createPortal(n, e, t) {
  return jsxRuntimeExports.jsx(
    Portal,
    { children: n, container: e, state: t },
    e.uuid
  );
}
function Portal({ state: n = {}, children: e, container: t }) {
  const { events: r, size: s, ...o } = n,
    a = useStore(),
    [l] = reactExports.useState(() => new Raycaster()),
    [c] = reactExports.useState(() => new Vector2()),
    u = reactExports.useCallback(
      (N, P) => {
        const de = { ...N };
        Object.keys(N).forEach((Ye) => {
          (privateKeys.includes(Ye) || (N[Ye] !== P[Ye] && P[Ye])) &&
            delete de[Ye];
        });
        let me;
        if (P && s) {
          const Ye = P.camera;
          (me = N.viewport.getCurrentViewport(Ye, new Vector3(), s)),
            Ye !== N.camera && updateCamera(Ye, s);
        }
        return {
          ...de,
          scene: t,
          raycaster: l,
          pointer: c,
          mouse: c,
          previousRoot: a,
          events: { ...N.events, ...(P == null ? void 0 : P.events), ...r },
          size: { ...N.size, ...s },
          viewport: { ...N.viewport, ...me },
          ...o,
        };
      },
      [n]
    ),
    [p] = reactExports.useState(() => {
      const N = a.getState();
      return create((de, me) => ({
        ...N,
        scene: t,
        raycaster: l,
        pointer: c,
        mouse: c,
        previousRoot: a,
        events: { ...N.events, ...r },
        size: { ...N.size, ...s },
        ...o,
        set: de,
        get: me,
        setEvents: (Ye) =>
          de((nt) => ({ ...nt, events: { ...nt.events, ...Ye } })),
      }));
    });
  return (
    reactExports.useEffect(() => {
      const N = a.subscribe((P) => p.setState((de) => u(P, de)));
      return () => {
        N();
      };
    }, [u]),
    reactExports.useEffect(() => {
      p.setState((N) => u(a.getState(), N));
    }, [u]),
    reactExports.useEffect(
      () => () => {
        p.destroy();
      },
      []
    ),
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: reconciler.createPortal(
        jsxRuntimeExports.jsx(context.Provider, { value: p, children: e }),
        p,
        null
      ),
    })
  );
}
reconciler.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: reactExports.version,
});
const DOM_EVENTS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function createPointerEvents(n) {
  const { handlePointer: e } = createEvents(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, s) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(DOM_EVENTS).reduce(
      (t, r) => ({ ...t, [r]: e(r) }),
      {}
    ),
    update: () => {
      var t;
      const { events: r, internal: s } = n.getState();
      (t = s.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(s.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: s, events: o } = n.getState();
      o.disconnect == null || o.disconnect(),
        s((a) => ({ events: { ...a.events, connected: t } })),
        Object.entries((r = o.handlers) != null ? r : []).forEach(([a, l]) => {
          const [c, u] = DOM_EVENTS[a];
          t.addEventListener(c, l, { passive: u });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var s;
        Object.entries((s = r.handlers) != null ? s : []).forEach(([o, a]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [l] = DOM_EVENTS[o];
            r.connected.removeEventListener(l, a);
          }
        }),
          t((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
function g(n, e) {
  let t;
  return (...r) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...r), e));
  };
}
function j(
  { debounce: n, scroll: e, polyfill: t, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const s = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = reactExports.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = reactExports.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    c = n ? (typeof n == "number" ? n : n.scroll) : null,
    u = n ? (typeof n == "number" ? n : n.resize) : null,
    p = reactExports.useRef(!1);
  reactExports.useEffect(() => ((p.current = !0), () => void (p.current = !1)));
  const [N, P, de] = reactExports.useMemo(() => {
    const Be = () => {
      if (!l.current.element) return;
      const {
          left: ot,
          top: st,
          width: vt,
          height: xt,
          bottom: St,
          right: wt,
          x: bt,
          y: Tt,
        } = l.current.element.getBoundingClientRect(),
        Ct = {
          left: ot,
          top: st,
          width: vt,
          height: xt,
          bottom: St,
          right: wt,
          x: bt,
          y: Tt,
        };
      l.current.element instanceof HTMLElement &&
        r &&
        ((Ct.height = l.current.element.offsetHeight),
        (Ct.width = l.current.element.offsetWidth)),
        Object.freeze(Ct),
        p.current &&
          !D(l.current.lastBounds, Ct) &&
          a((l.current.lastBounds = Ct));
    };
    return [Be, u ? g(Be, u) : Be, c ? g(Be, c) : Be];
  }, [a, r, c, u]);
  function me() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((Be) =>
        Be.removeEventListener("scroll", de, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null)),
      l.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              l.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              l.current.orientationHandler
            ));
  }
  function Ye() {
    l.current.element &&
      ((l.current.resizeObserver = new s(de)),
      l.current.resizeObserver.observe(l.current.element),
      e &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((Be) =>
          Be.addEventListener("scroll", de, { capture: !0, passive: !0 })
        ),
      (l.current.orientationHandler = () => {
        de();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            l.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            l.current.orientationHandler
          ));
  }
  const nt = (Be) => {
    !Be ||
      Be === l.current.element ||
      (me(),
      (l.current.element = Be),
      (l.current.scrollContainers = E(Be)),
      Ye());
  };
  return (
    X(de, !!e),
    W(P),
    reactExports.useEffect(() => {
      me(), Ye();
    }, [e, de, P]),
    reactExports.useEffect(() => me, []),
    [nt, o, N]
  );
}
function W(n) {
  reactExports.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function X(n, e) {
  reactExports.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function E(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: s,
  } = window.getComputedStyle(n);
  return (
    [t, r, s].some((o) => o === "auto" || o === "scroll") && e.push(n),
    [...e, ...E(n.parentElement)]
  );
}
const k = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  D = (n, e) => k.every((t) => n[t] === e[t]);
var __defProp = Object.defineProperty,
  __defProps = Object.defineProperties,
  __getOwnPropDescs = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols = Object.getOwnPropertySymbols,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __propIsEnum = Object.prototype.propertyIsEnumerable,
  __defNormalProp = (n, e, t) =>
    e in n
      ? __defProp(n, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: t,
        })
      : (n[e] = t),
  __spreadValues = (n, e) => {
    for (var t in e || (e = {}))
      __hasOwnProp.call(e, t) && __defNormalProp(n, t, e[t]);
    if (__getOwnPropSymbols)
      for (var t of __getOwnPropSymbols(e))
        __propIsEnum.call(e, t) && __defNormalProp(n, t, e[t]);
    return n;
  },
  __spreadProps = (n, e) => __defProps(n, __getOwnPropDescs(e)),
  _a$1,
  _b$1;
typeof window < "u" &&
(((_a$1 = window.document) != null && _a$1.createElement) ||
  ((_b$1 = window.navigator) == null ? void 0 : _b$1.product) === "ReactNative")
  ? reactExports.useLayoutEffect
  : reactExports.useEffect;
function traverseFiber(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = n.child;
  for (; r; ) {
    const s = traverseFiber(r, e, t);
    if (s) return s;
    r = r.sibling;
  }
}
function wrapContext(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const error = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = error;
    return;
  }
  return error.apply(this, arguments);
};
const FiberContext = wrapContext(reactExports.createContext(null));
class FiberProvider extends reactExports.Component {
  render() {
    return reactExports.createElement(
      FiberContext.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function useFiber() {
  const n = reactExports.useContext(FiberContext);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = reactExports.useId();
  return reactExports.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r) continue;
      const s = traverseFiber(r, !1, (o) => {
        let a = o.memoizedState;
        for (; a; ) {
          if (a.memoizedState === e) return !0;
          a = a.next;
        }
      });
      if (s) return s;
    }
  }, [n, e]);
}
function useContextMap() {
  const n = useFiber(),
    [e] = reactExports.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const s =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      s &&
        s !== FiberContext &&
        !e.has(s) &&
        e.set(s, reactExports.useContext(wrapContext(s)));
    }
    t = t.return;
  }
  return e;
}
function useContextBridge() {
  const n = useContextMap();
  return reactExports.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          reactExports.createElement(
            e,
            null,
            reactExports.createElement(
              t.Provider,
              __spreadProps(__spreadValues({}, r), { value: n.get(t) })
            )
          ),
        (e) => reactExports.createElement(FiberProvider, __spreadValues({}, e))
      ),
    [n]
  );
}
const CanvasImpl = reactExports.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: s,
      gl: o,
      events: a = createPointerEvents,
      eventSource: l,
      eventPrefix: c,
      shadows: u,
      linear: p,
      flat: N,
      legacy: P,
      orthographic: de,
      frameloop: me,
      dpr: Ye,
      performance: nt,
      raycaster: Be,
      camera: ot,
      scene: st,
      onPointerMissed: vt,
      onCreated: xt,
      ...St
    },
    wt
  ) {
    reactExports.useMemo(() => extend(THREE), []);
    const bt = useContextBridge(),
      [Tt, Ct] = j({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      kt = reactExports.useRef(null),
      Dt = reactExports.useRef(null);
    reactExports.useImperativeHandle(wt, () => kt.current);
    const Vt = useMutableCallback(vt),
      [Ht, qt] = reactExports.useState(!1),
      [Ft, Bt] = reactExports.useState(!1);
    if (Ht) throw Ht;
    if (Ft) throw Ft;
    const Mt = reactExports.useRef(null);
    useIsomorphicLayoutEffect(() => {
      const It = kt.current;
      Ct.width > 0 &&
        Ct.height > 0 &&
        It &&
        (Mt.current || (Mt.current = createRoot(It)),
        Mt.current.configure({
          gl: o,
          events: a,
          shadows: u,
          linear: p,
          flat: N,
          legacy: P,
          orthographic: de,
          frameloop: me,
          dpr: Ye,
          performance: nt,
          raycaster: Be,
          camera: ot,
          scene: st,
          size: Ct,
          onPointerMissed: (...Ot) =>
            Vt.current == null ? void 0 : Vt.current(...Ot),
          onCreated: (Ot) => {
            Ot.events.connect == null ||
              Ot.events.connect(l ? (isRef$1(l) ? l.current : l) : Dt.current),
              c &&
                Ot.setEvents({
                  compute: (Xt, sn) => {
                    const Kt = Xt[c + "X"],
                      tn = Xt[c + "Y"];
                    sn.pointer.set(
                      (Kt / sn.size.width) * 2 - 1,
                      -(tn / sn.size.height) * 2 + 1
                    ),
                      sn.raycaster.setFromCamera(sn.pointer, sn.camera);
                  },
                }),
              xt == null || xt(Ot);
          },
        }),
        Mt.current.render(
          jsxRuntimeExports.jsx(bt, {
            children: jsxRuntimeExports.jsx(ErrorBoundary, {
              set: Bt,
              children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: jsxRuntimeExports.jsx(Block, { set: qt }),
                children: e ?? null,
              }),
            }),
          })
        ));
    }),
      reactExports.useEffect(() => {
        const It = kt.current;
        if (It) return () => unmountComponentAtNode(It);
      }, []);
    const Pt = l ? "none" : "auto";
    return jsxRuntimeExports.jsx("div", {
      ref: Dt,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: Pt,
        ...s,
      },
      ...St,
      children: jsxRuntimeExports.jsx("div", {
        ref: Tt,
        style: { width: "100%", height: "100%" },
        children: jsxRuntimeExports.jsx("canvas", {
          ref: kt,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  Canvas = reactExports.forwardRef(function (e, t) {
    return jsxRuntimeExports.jsx(FiberProvider, {
      children: jsxRuntimeExports.jsx(CanvasImpl, { ...e, ref: t }),
    });
  });
function CameraControl() {
  const { camera: n, gl: e } = useThree(),
    { isTouchDevices: t } = useDeviceType(),
    { snakeCameraFactor: r, snakeCameraSmoothness: s } = useLandingContext(),
    o = reactExports.useRef({ x: 0, y: 0 }),
    a = reactExports.useRef(new Vector3(0, 0, 0)),
    l = reactExports.useRef(!1),
    c = reactExports.useRef(void 0),
    [u, p] = reactExports.useState(!1),
    N = ["legend", "howItWorks"],
    P = reactExports.useRef(new Vector3(0, 0, 5)),
    de = reactExports.useRef(new Vector3(0, 0, 0)),
    me = () => {
      n instanceof PerspectiveCamera &&
        (n.position.copy(P.current),
        n.lookAt(de.current),
        n.updateProjectionMatrix());
    };
  return (
    reactExports.useEffect(() => {
      n instanceof PerspectiveCamera
        ? (n.position.copy(P.current),
          (n.fov = 30),
          n.updateProjectionMatrix(),
          console.log("PerspectiveCamera initialized".toUpperCase()))
        : console.warn("Camera is not a PerspectiveCamera".toUpperCase());
      const Ye = () => {
        n instanceof PerspectiveCamera &&
          ((n.aspect = window.innerWidth / window.innerHeight),
          n.updateProjectionMatrix()),
          e.setSize(window.innerWidth, window.innerHeight);
      };
      return (
        window.addEventListener("resize", Ye),
        () => {
          window.removeEventListener("resize", Ye);
        }
      );
    }, [n, e]),
    reactExports.useEffect(() => {
      if (!t) {
        const Ye = (Be) => {
            clearTimeout(c.current),
              (o.current.x = (Be.clientX / window.innerWidth) * 2 - 1),
              (o.current.y = -(Be.clientY / window.innerHeight) * 2 + 1),
              (l.current = !0),
              (c.current = setTimeout(nt, 250));
          },
          nt = () => {
            l.current = !1;
          };
        return (
          window.addEventListener("mouseout", nt),
          window.addEventListener("mousemove", Ye),
          () => {
            window.removeEventListener("mouseout", nt),
              window.removeEventListener("mousemove", Ye);
          }
        );
      }
    }, [t, n, e]),
    reactExports.useEffect(() => {
      if (!t) {
        const Ye = [],
          nt = N.map((vt) => document.getElementById(vt)),
          Be = document.getElementById("blocksContainer"),
          ot = new Set(),
          st = (vt) => {
            vt.forEach((St) => {
              const wt = St.target.id;
              St.isIntersecting ? ot.add(wt) : ot.delete(wt);
            });
            const xt = ot.size > 0;
            p(xt), xt && me();
          };
        return (
          nt.forEach((vt) => {
            if (vt) {
              const xt = new IntersectionObserver(st, {
                root: Be,
                threshold: 0.5,
              });
              xt.observe(vt), Ye.push(xt);
            }
          }),
          () => {
            Ye.forEach((vt) => vt.disconnect());
          }
        );
      }
    }, []),
    useFrame(() => {
      if (!(!l.current || u) && n instanceof PerspectiveCamera) {
        const Ye = o.current.x * r,
          nt = o.current.y * r;
        (n.position.x += (Ye - n.position.x) * s),
          (n.position.y += (nt - n.position.y) * s),
          n.lookAt(a.current);
      }
    }),
    null
  );
}
function _assertThisInitialized(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function _inheritsLoose(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    (n.__proto__ = e);
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  _defaults$1 = { duration: 0.5, overwrite: !1, delay: 0 },
  _suppressOverwrites$1,
  _reverting$1,
  _context$2,
  _bigNum$1 = 1e8,
  _tinyNum = 1 / _bigNum$1,
  _2PI = Math.PI * 2,
  _HALF_PI = _2PI / 4,
  _gsID = 0,
  _sqrt = Math.sqrt,
  _cos = Math.cos,
  _sin = Math.sin,
  _isString$1 = function (e) {
    return typeof e == "string";
  },
  _isFunction$1 = function (e) {
    return typeof e == "function";
  },
  _isNumber$1 = function (e) {
    return typeof e == "number";
  },
  _isUndefined = function (e) {
    return typeof e > "u";
  },
  _isObject$1 = function (e) {
    return typeof e == "object";
  },
  _isNotFalse = function (e) {
    return e !== !1;
  },
  _windowExists$2 = function () {
    return typeof window < "u";
  },
  _isFuncOrString = function (e) {
    return _isFunction$1(e) || _isString$1(e);
  },
  _isTypedArray =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  _isArray = Array.isArray,
  _strictNumExp = /(?:-?\.?\d|\.)+/gi,
  _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  _relExp = /[+-]=-?[.\d]+/,
  _delimitedValueExp = /[^,'"\[\]\s]+/gi,
  _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  _globalTimeline,
  _win$3,
  _coreInitted$2,
  _doc$3,
  _globals = {},
  _installScope = {},
  _coreReady,
  _install = function (e) {
    return (_installScope = _merge(e, _globals)) && gsap$2;
  },
  _missingPlugin = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  _warn = function (e, t) {
    return !t && console.warn(e);
  },
  _addGlobal = function (e, t) {
    return (
      (e && (_globals[e] = t) && _installScope && (_installScope[e] = t)) ||
      _globals
    );
  },
  _emptyFunc = function () {
    return 0;
  },
  _startAtRevertConfig = { suppressEvents: !0, isStart: !0, kill: !1 },
  _revertConfigNoKill = { suppressEvents: !0, kill: !1 },
  _revertConfig = { suppressEvents: !0 },
  _reservedProps = {},
  _lazyTweens = [],
  _lazyLookup = {},
  _lastRenderedFrame,
  _plugins = {},
  _effects = {},
  _nextGCFrame = 30,
  _harnessPlugins = [],
  _callbackNames = "",
  _harness = function (e) {
    var t = e[0],
      r,
      s;
    if (
      (_isObject$1(t) || _isFunction$1(t) || (e = [e]),
      !(r = (t._gsap || {}).harness))
    ) {
      for (
        s = _harnessPlugins.length;
        s-- && !_harnessPlugins[s].targetTest(t);

      );
      r = _harnessPlugins[s];
    }
    for (s = e.length; s--; )
      (e[s] && (e[s]._gsap || (e[s]._gsap = new GSCache(e[s], r)))) ||
        e.splice(s, 1);
    return e;
  },
  _getCache = function (e) {
    return e._gsap || _harness(toArray(e))[0]._gsap;
  },
  _getProperty = function (e, t, r) {
    return (r = e[t]) && _isFunction$1(r)
      ? e[t]()
      : (_isUndefined(r) && e.getAttribute && e.getAttribute(t)) || r;
  },
  _forEachName = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  _round$1 = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  _roundPrecise = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  _parseRelative = function (e, t) {
    var r = t.charAt(0),
      s = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      r === "+" ? e + s : r === "-" ? e - s : r === "*" ? e * s : e / s
    );
  },
  _arrayContainsAny = function (e, t) {
    for (var r = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < r; );
    return s < r;
  },
  _lazyRender = function () {
    var e = _lazyTweens.length,
      t = _lazyTweens.slice(0),
      r,
      s;
    for (_lazyLookup = {}, _lazyTweens.length = 0, r = 0; r < e; r++)
      (s = t[r]),
        s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0);
  },
  _isRevertWorthy = function (e) {
    return !!(e._initted || e._startAt || e.add);
  },
  _lazySafeRender = function (e, t, r, s) {
    _lazyTweens.length && !_reverting$1 && _lazyRender(),
      e.render(t, r, !!(_reverting$1 && t < 0 && _isRevertWorthy(e))),
      _lazyTweens.length && !_reverting$1 && _lazyRender();
  },
  _numericIfPossible = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(_delimitedValueExp).length < 2
      ? t
      : _isString$1(e)
      ? e.trim()
      : e;
  },
  _passThrough$1 = function (e) {
    return e;
  },
  _setDefaults$1 = function (e, t) {
    for (var r in t) r in e || (e[r] = t[r]);
    return e;
  },
  _setKeyframeDefaults = function (e) {
    return function (t, r) {
      for (var s in r)
        s in t || (s === "duration" && e) || s === "ease" || (t[s] = r[s]);
    };
  },
  _merge = function (e, t) {
    for (var r in t) e[r] = t[r];
    return e;
  },
  _mergeDeep = function n(e, t) {
    for (var r in t)
      r !== "__proto__" &&
        r !== "constructor" &&
        r !== "prototype" &&
        (e[r] = _isObject$1(t[r]) ? n(e[r] || (e[r] = {}), t[r]) : t[r]);
    return e;
  },
  _copyExcluding = function (e, t) {
    var r = {},
      s;
    for (s in e) s in t || (r[s] = e[s]);
    return r;
  },
  _inheritDefaults = function (e) {
    var t = e.parent || _globalTimeline,
      r = e.keyframes
        ? _setKeyframeDefaults(_isArray(e.keyframes))
        : _setDefaults$1;
    if (_isNotFalse(e.inherit))
      for (; t; ) r(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  _arraysMatch = function (e, t) {
    for (var r = e.length, s = r === t.length; s && r-- && e[r] === t[r]; );
    return r < 0;
  },
  _addLinkedListItem = function (e, t, r, s, o) {
    var a = e[s],
      l;
    if (o) for (l = t[o]; a && a[o] > l; ) a = a._prev;
    return (
      a ? ((t._next = a._next), (a._next = t)) : ((t._next = e[r]), (e[r] = t)),
      t._next ? (t._next._prev = t) : (e[s] = t),
      (t._prev = a),
      (t.parent = t._dp = e),
      t
    );
  },
  _removeLinkedListItem = function (e, t, r, s) {
    r === void 0 && (r = "_first"), s === void 0 && (s = "_last");
    var o = t._prev,
      a = t._next;
    o ? (o._next = a) : e[r] === t && (e[r] = a),
      a ? (a._prev = o) : e[s] === t && (e[s] = o),
      (t._next = t._prev = t.parent = null);
  },
  _removeFromParent = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  _uncache = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var r = e; r; ) (r._dirty = 1), (r = r.parent);
    return e;
  },
  _recacheAncestors = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  _rewindStartAt = function (e, t, r, s) {
    return (
      e._startAt &&
      (_reverting$1
        ? e._startAt.revert(_revertConfigNoKill)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, s))
    );
  },
  _hasNoPausedAncestors = function n(e) {
    return !e || (e._ts && n(e.parent));
  },
  _elapsedCycleDuration = function (e) {
    return e._repeat
      ? _animationCycle(e._tTime, (e = e.duration() + e._rDelay)) * e
      : 0;
  },
  _animationCycle = function (e, t) {
    var r = Math.floor((e = _roundPrecise(e / t)));
    return e && r === e ? r - 1 : r;
  },
  _parentToChildTotalTime = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  _setEnd = function (e) {
    return (e._end = _roundPrecise(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || _tinyNum) || 0)
    ));
  },
  _alignPlayhead = function (e, t) {
    var r = e._dp;
    return (
      r &&
        r.smoothChildTiming &&
        e._ts &&
        ((e._start = _roundPrecise(
          r._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        _setEnd(e),
        r._dirty || _uncache(r, e)),
      e
    );
  },
  _postAddChecks = function (e, t) {
    var r;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((r = _parentToChildTotalTime(e.rawTime(), t)),
        (!t._dur || _clamp$1(0, t.totalDuration(), r) - t._tTime > _tinyNum) &&
          t.render(r, !0)),
      _uncache(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (r = e; r._dp; )
          r.rawTime() >= 0 && r.totalTime(r._tTime), (r = r._dp);
      e._zTime = -1e-8;
    }
  },
  _addToTimeline = function (e, t, r, s) {
    return (
      t.parent && _removeFromParent(t),
      (t._start = _roundPrecise(
        (_isNumber$1(r)
          ? r
          : r || e !== _globalTimeline
          ? _parsePosition$1(e, r, t)
          : e._time) + t._delay
      )),
      (t._end = _roundPrecise(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      _addLinkedListItem(e, t, "_first", "_last", e._sort ? "_start" : 0),
      _isFromOrFromStart(t) || (e._recent = t),
      s || _postAddChecks(e, t),
      e._ts < 0 && _alignPlayhead(e, e._tTime),
      e
    );
  },
  _scrollTrigger = function (e, t) {
    return (
      (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", t)) &&
      _globals.ScrollTrigger.create(t, e)
    );
  },
  _attemptInitTween = function (e, t, r, s, o) {
    if ((_initTween(e, t, o), !e._initted)) return 1;
    if (
      !r &&
      e._pt &&
      !_reverting$1 &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      _lastRenderedFrame !== _ticker.frame
    )
      return _lazyTweens.push(e), (e._lazy = [o, s]), 1;
  },
  _parentPlayheadIsBeforeStart = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
  },
  _isFromOrFromStart = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  _renderZeroDurationTween = function (e, t, r, s) {
    var o = e.ratio,
      a =
        t < 0 ||
        (!t &&
          ((!e._start &&
            _parentPlayheadIsBeforeStart(e) &&
            !(!e._initted && _isFromOrFromStart(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !_isFromOrFromStart(e))))
          ? 0
          : 1,
      l = e._rDelay,
      c = 0,
      u,
      p,
      N;
    if (
      (l &&
        e._repeat &&
        ((c = _clamp$1(0, e._tDur, t)),
        (p = _animationCycle(c, l)),
        e._yoyo && p & 1 && (a = 1 - a),
        p !== _animationCycle(e._tTime, l) &&
          ((o = 1 - a), e.vars.repeatRefresh && e._initted && e.invalidate())),
      a !== o || _reverting$1 || s || e._zTime === _tinyNum || (!t && e._zTime))
    ) {
      if (!e._initted && _attemptInitTween(e, t, s, r, c)) return;
      for (
        N = e._zTime,
          e._zTime = t || (r ? _tinyNum : 0),
          r || (r = t && !N),
          e.ratio = a,
          e._from && (a = 1 - a),
          e._time = 0,
          e._tTime = c,
          u = e._pt;
        u;

      )
        u.r(a, u.d), (u = u._next);
      t < 0 && _rewindStartAt(e, t, r, !0),
        e._onUpdate && !r && _callback$1(e, "onUpdate"),
        c && e._repeat && !r && e.parent && _callback$1(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === a &&
          (a && _removeFromParent(e, 1),
          !r &&
            !_reverting$1 &&
            (_callback$1(e, a ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  _findNextPauseTween = function (e, t, r) {
    var s;
    if (r > t)
      for (s = e._first; s && s._start <= r; ) {
        if (s.data === "isPause" && s._start > t) return s;
        s = s._next;
      }
    else
      for (s = e._last; s && s._start >= r; ) {
        if (s.data === "isPause" && s._start < t) return s;
        s = s._prev;
      }
  },
  _setDuration = function (e, t, r, s) {
    var o = e._repeat,
      a = _roundPrecise(t) || 0,
      l = e._tTime / e._tDur;
    return (
      l && !s && (e._time *= a / e._dur),
      (e._dur = a),
      (e._tDur = o
        ? o < 0
          ? 1e10
          : _roundPrecise(a * (o + 1) + e._rDelay * o)
        : a),
      l > 0 && !s && _alignPlayhead(e, (e._tTime = e._tDur * l)),
      e.parent && _setEnd(e),
      r || _uncache(e.parent, e),
      e
    );
  },
  _onUpdateTotalDuration = function (e) {
    return e instanceof Timeline ? _uncache(e) : _setDuration(e, e._dur);
  },
  _zeroPosition = { _start: 0, endTime: _emptyFunc, totalDuration: _emptyFunc },
  _parsePosition$1 = function n(e, t, r) {
    var s = e.labels,
      o = e._recent || _zeroPosition,
      a = e.duration() >= _bigNum$1 ? o.endTime(!1) : e._dur,
      l,
      c,
      u;
    return _isString$1(t) && (isNaN(t) || t in s)
      ? ((c = t.charAt(0)),
        (u = t.substr(-1) === "%"),
        (l = t.indexOf("=")),
        c === "<" || c === ">"
          ? (l >= 0 && (t = t.replace(/=/, "")),
            (c === "<" ? o._start : o.endTime(o._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (u ? (l < 0 ? o : r).totalDuration() / 100 : 1))
          : l < 0
          ? (t in s || (s[t] = a), s[t])
          : ((c = parseFloat(t.charAt(l - 1) + t.substr(l + 1))),
            u &&
              r &&
              (c = (c / 100) * (_isArray(r) ? r[0] : r).totalDuration()),
            l > 1 ? n(e, t.substr(0, l - 1), r) + c : a + c))
      : t == null
      ? a
      : +t;
  },
  _createTweenType = function (e, t, r) {
    var s = _isNumber$1(t[1]),
      o = (s ? 2 : 1) + (e < 2 ? 0 : 1),
      a = t[o],
      l,
      c;
    if ((s && (a.duration = t[1]), (a.parent = r), e)) {
      for (l = a, c = r; c && !("immediateRender" in l); )
        (l = c.vars.defaults || {}),
          (c = _isNotFalse(c.vars.inherit) && c.parent);
      (a.immediateRender = _isNotFalse(l.immediateRender)),
        e < 2 ? (a.runBackwards = 1) : (a.startAt = t[o - 1]);
    }
    return new Tween(t[0], a, t[o + 1]);
  },
  _conditionalReturn = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  _clamp$1 = function (e, t, r) {
    return r < e ? e : r > t ? t : r;
  },
  getUnit = function (e, t) {
    return !_isString$1(e) || !(t = _unitExp.exec(e)) ? "" : t[1];
  },
  clamp = function (e, t, r) {
    return _conditionalReturn(r, function (s) {
      return _clamp$1(e, t, s);
    });
  },
  _slice = [].slice,
  _isArrayLike = function (e, t) {
    return (
      e &&
      _isObject$1(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && _isObject$1(e[0]))) &&
      !e.nodeType &&
      e !== _win$3
    );
  },
  _flatten = function (e, t, r) {
    return (
      r === void 0 && (r = []),
      e.forEach(function (s) {
        var o;
        return (_isString$1(s) && !t) || _isArrayLike(s, 1)
          ? (o = r).push.apply(o, toArray(s))
          : r.push(s);
      }) || r
    );
  },
  toArray = function (e, t, r) {
    return _context$2 && !t && _context$2.selector
      ? _context$2.selector(e)
      : _isString$1(e) && !r && (_coreInitted$2 || !_wake())
      ? _slice.call((t || _doc$3).querySelectorAll(e), 0)
      : _isArray(e)
      ? _flatten(e, r)
      : _isArrayLike(e)
      ? _slice.call(e, 0)
      : e
      ? [e]
      : [];
  },
  selector = function (e) {
    return (
      (e = toArray(e)[0] || _warn("Invalid scope") || {}),
      function (t) {
        var r = e.current || e.nativeElement || e;
        return toArray(
          t,
          r.querySelectorAll
            ? r
            : r === e
            ? _warn("Invalid scope") || _doc$3.createElement("div")
            : e
        );
      }
    );
  },
  shuffle = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  distribute = function (e) {
    if (_isFunction$1(e)) return e;
    var t = _isObject$1(e) ? e : { each: e },
      r = _parseEase(t.ease),
      s = t.from || 0,
      o = parseFloat(t.base) || 0,
      a = {},
      l = s > 0 && s < 1,
      c = isNaN(s) || l,
      u = t.axis,
      p = s,
      N = s;
    return (
      _isString$1(s)
        ? (p = N = { center: 0.5, edges: 0.5, end: 1 }[s] || 0)
        : !l && c && ((p = s[0]), (N = s[1])),
      function (P, de, me) {
        var Ye = (me || t).length,
          nt = a[Ye],
          Be,
          ot,
          st,
          vt,
          xt,
          St,
          wt,
          bt,
          Tt;
        if (!nt) {
          if (
            ((Tt = t.grid === "auto" ? 0 : (t.grid || [1, _bigNum$1])[1]), !Tt)
          ) {
            for (
              wt = -1e8;
              wt < (wt = me[Tt++].getBoundingClientRect().left) && Tt < Ye;

            );
            Tt < Ye && Tt--;
          }
          for (
            nt = a[Ye] = [],
              Be = c ? Math.min(Tt, Ye) * p - 0.5 : s % Tt,
              ot =
                Tt === _bigNum$1 ? 0 : c ? (Ye * N) / Tt - 0.5 : (s / Tt) | 0,
              wt = 0,
              bt = _bigNum$1,
              St = 0;
            St < Ye;
            St++
          )
            (st = (St % Tt) - Be),
              (vt = ot - ((St / Tt) | 0)),
              (nt[St] = xt =
                u ? Math.abs(u === "y" ? vt : st) : _sqrt(st * st + vt * vt)),
              xt > wt && (wt = xt),
              xt < bt && (bt = xt);
          s === "random" && shuffle(nt),
            (nt.max = wt - bt),
            (nt.min = bt),
            (nt.v = Ye =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (Tt > Ye
                    ? Ye - 1
                    : u
                    ? u === "y"
                      ? Ye / Tt
                      : Tt
                    : Math.max(Tt, Ye / Tt)) ||
                0) * (s === "edges" ? -1 : 1)),
            (nt.b = Ye < 0 ? o - Ye : o),
            (nt.u = getUnit(t.amount || t.each) || 0),
            (r = r && Ye < 0 ? _invertEase(r) : r);
        }
        return (
          (Ye = (nt[P] - nt.min) / nt.max || 0),
          _roundPrecise(nt.b + (r ? r(Ye) : Ye) * nt.v) + nt.u
        );
      }
    );
  },
  _roundModifier = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (r) {
      var s = _roundPrecise(Math.round(parseFloat(r) / e) * e * t);
      return (s - (s % 1)) / t + (_isNumber$1(r) ? 0 : getUnit(r));
    };
  },
  snap = function (e, t) {
    var r = _isArray(e),
      s,
      o;
    return (
      !r &&
        _isObject$1(e) &&
        ((s = r = e.radius || _bigNum$1),
        e.values
          ? ((e = toArray(e.values)), (o = !_isNumber$1(e[0])) && (s *= s))
          : (e = _roundModifier(e.increment))),
      _conditionalReturn(
        t,
        r
          ? _isFunction$1(e)
            ? function (a) {
                return (o = e(a)), Math.abs(o - a) <= s ? o : a;
              }
            : function (a) {
                for (
                  var l = parseFloat(o ? a.x : a),
                    c = parseFloat(o ? a.y : 0),
                    u = _bigNum$1,
                    p = 0,
                    N = e.length,
                    P,
                    de;
                  N--;

                )
                  o
                    ? ((P = e[N].x - l),
                      (de = e[N].y - c),
                      (P = P * P + de * de))
                    : (P = Math.abs(e[N] - l)),
                    P < u && ((u = P), (p = N));
                return (
                  (p = !s || u <= s ? e[p] : a),
                  o || p === a || _isNumber$1(a) ? p : p + getUnit(a)
                );
              }
          : _roundModifier(e)
      )
    );
  },
  random = function (e, t, r, s) {
    return _conditionalReturn(
      _isArray(e) ? !t : r === !0 ? !!(r = 0) : !s,
      function () {
        return _isArray(e)
          ? e[~~(Math.random() * e.length)]
          : (r = r || 1e-5) &&
              (s = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) &&
              Math.floor(
                Math.round(
                  (e - r / 2 + Math.random() * (t - e + r * 0.99)) / r
                ) *
                  r *
                  s
              ) / s;
      }
    );
  },
  pipe = function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return function (s) {
      return t.reduce(function (o, a) {
        return a(o);
      }, s);
    };
  },
  unitize = function (e, t) {
    return function (r) {
      return e(parseFloat(r)) + (t || getUnit(r));
    };
  },
  normalize = function (e, t, r) {
    return mapRange(e, t, 0, 1, r);
  },
  _wrapArray = function (e, t, r) {
    return _conditionalReturn(r, function (s) {
      return e[~~t(s)];
    });
  },
  wrap = function n(e, t, r) {
    var s = t - e;
    return _isArray(e)
      ? _wrapArray(e, n(0, e.length), t)
      : _conditionalReturn(r, function (o) {
          return ((s + ((o - e) % s)) % s) + e;
        });
  },
  wrapYoyo = function n(e, t, r) {
    var s = t - e,
      o = s * 2;
    return _isArray(e)
      ? _wrapArray(e, n(0, e.length - 1), t)
      : _conditionalReturn(r, function (a) {
          return (a = (o + ((a - e) % o)) % o || 0), e + (a > s ? o - a : a);
        });
  },
  _replaceRandom = function (e) {
    for (var t = 0, r = "", s, o, a, l; ~(s = e.indexOf("random(", t)); )
      (a = e.indexOf(")", s)),
        (l = e.charAt(s + 7) === "["),
        (o = e
          .substr(s + 7, a - s - 7)
          .match(l ? _delimitedValueExp : _strictNumExp)),
        (r +=
          e.substr(t, s - t) +
          random(l ? o : +o[0], l ? 0 : +o[1], +o[2] || 1e-5)),
        (t = a + 1);
    return r + e.substr(t, e.length - t);
  },
  mapRange = function (e, t, r, s, o) {
    var a = t - e,
      l = s - r;
    return _conditionalReturn(o, function (c) {
      return r + (((c - e) / a) * l || 0);
    });
  },
  interpolate = function n(e, t, r, s) {
    var o = isNaN(e + t)
      ? 0
      : function (de) {
          return (1 - de) * e + de * t;
        };
    if (!o) {
      var a = _isString$1(e),
        l = {},
        c,
        u,
        p,
        N,
        P;
      if ((r === !0 && (s = 1) && (r = null), a))
        (e = { p: e }), (t = { p: t });
      else if (_isArray(e) && !_isArray(t)) {
        for (p = [], N = e.length, P = N - 2, u = 1; u < N; u++)
          p.push(n(e[u - 1], e[u]));
        N--,
          (o = function (me) {
            me *= N;
            var Ye = Math.min(P, ~~me);
            return p[Ye](me - Ye);
          }),
          (r = t);
      } else s || (e = _merge(_isArray(e) ? [] : {}, e));
      if (!p) {
        for (c in t) _addPropTween.call(l, e, c, "get", t[c]);
        o = function (me) {
          return _renderPropTweens(me, l) || (a ? e.p : e);
        };
      }
    }
    return _conditionalReturn(r, o);
  },
  _getLabelInDirection = function (e, t, r) {
    var s = e.labels,
      o = _bigNum$1,
      a,
      l,
      c;
    for (a in s)
      (l = s[a] - t),
        l < 0 == !!r && l && o > (l = Math.abs(l)) && ((c = a), (o = l));
    return c;
  },
  _callback$1 = function (e, t, r) {
    var s = e.vars,
      o = s[t],
      a = _context$2,
      l = e._ctx,
      c,
      u,
      p;
    if (o)
      return (
        (c = s[t + "Params"]),
        (u = s.callbackScope || e),
        r && _lazyTweens.length && _lazyRender(),
        l && (_context$2 = l),
        (p = c ? o.apply(u, c) : o.call(u)),
        (_context$2 = a),
        p
      );
  },
  _interrupt = function (e) {
    return (
      _removeFromParent(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!_reverting$1),
      e.progress() < 1 && _callback$1(e, "onInterrupt"),
      e
    );
  },
  _quickTween,
  _registerPluginQueue = [],
  _createPlugin = function (e) {
    if (e)
      if (
        ((e = (!e.name && e.default) || e), _windowExists$2() || e.headless)
      ) {
        var t = e.name,
          r = _isFunction$1(e),
          s =
            t && !r && e.init
              ? function () {
                  this._props = [];
                }
              : e,
          o = {
            init: _emptyFunc,
            render: _renderPropTweens,
            add: _addPropTween,
            kill: _killPropTweensOf,
            modifier: _addPluginModifier,
            rawVars: 0,
          },
          a = {
            targetTest: 0,
            get: 0,
            getSetter: _getSetter,
            aliases: {},
            register: 0,
          };
        if ((_wake(), e !== s)) {
          if (_plugins[t]) return;
          _setDefaults$1(s, _setDefaults$1(_copyExcluding(e, o), a)),
            _merge(s.prototype, _merge(o, _copyExcluding(e, a))),
            (_plugins[(s.prop = t)] = s),
            e.targetTest && (_harnessPlugins.push(s), (_reservedProps[t] = 1)),
            (t =
              (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
              "Plugin");
        }
        _addGlobal(t, s), e.register && e.register(gsap$2, s, PropTween);
      } else _registerPluginQueue.push(e);
  },
  _255 = 255,
  _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0],
  },
  _hue = function (e, t, r) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (r - t) * e * 6
        : e < 0.5
        ? r
        : e * 3 < 2
        ? t + (r - t) * (2 / 3 - e) * 6
        : t) *
        _255 +
        0.5) |
        0
    );
  },
  splitColor = function (e, t, r) {
    var s = e
        ? _isNumber$1(e)
          ? [e >> 16, (e >> 8) & _255, e & _255]
          : 0
        : _colorLookup.black,
      o,
      a,
      l,
      c,
      u,
      p,
      N,
      P,
      de,
      me;
    if (!s) {
      if (
        (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        _colorLookup[e])
      )
        s = _colorLookup[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((o = e.charAt(1)),
            (a = e.charAt(2)),
            (l = e.charAt(3)),
            (e =
              "#" +
              o +
              o +
              a +
              a +
              l +
              l +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (s = parseInt(e.substr(1, 6), 16)),
            [
              s >> 16,
              (s >> 8) & _255,
              s & _255,
              parseInt(e.substr(7), 16) / 255,
            ]
          );
        (e = parseInt(e.substr(1), 16)),
          (s = [e >> 16, (e >> 8) & _255, e & _255]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((s = me = e.match(_strictNumExp)), !t))
          (c = (+s[0] % 360) / 360),
            (u = +s[1] / 100),
            (p = +s[2] / 100),
            (a = p <= 0.5 ? p * (u + 1) : p + u - p * u),
            (o = p * 2 - a),
            s.length > 3 && (s[3] *= 1),
            (s[0] = _hue(c + 1 / 3, o, a)),
            (s[1] = _hue(c, o, a)),
            (s[2] = _hue(c - 1 / 3, o, a));
        else if (~e.indexOf("="))
          return (s = e.match(_numExp)), r && s.length < 4 && (s[3] = 1), s;
      } else s = e.match(_strictNumExp) || _colorLookup.transparent;
      s = s.map(Number);
    }
    return (
      t &&
        !me &&
        ((o = s[0] / _255),
        (a = s[1] / _255),
        (l = s[2] / _255),
        (N = Math.max(o, a, l)),
        (P = Math.min(o, a, l)),
        (p = (N + P) / 2),
        N === P
          ? (c = u = 0)
          : ((de = N - P),
            (u = p > 0.5 ? de / (2 - N - P) : de / (N + P)),
            (c =
              N === o
                ? (a - l) / de + (a < l ? 6 : 0)
                : N === a
                ? (l - o) / de + 2
                : (o - a) / de + 4),
            (c *= 60)),
        (s[0] = ~~(c + 0.5)),
        (s[1] = ~~(u * 100 + 0.5)),
        (s[2] = ~~(p * 100 + 0.5))),
      r && s.length < 4 && (s[3] = 1),
      s
    );
  },
  _colorOrderData = function (e) {
    var t = [],
      r = [],
      s = -1;
    return (
      e.split(_colorExp).forEach(function (o) {
        var a = o.match(_numWithUnitExp) || [];
        t.push.apply(t, a), r.push((s += a.length + 1));
      }),
      (t.c = r),
      t
    );
  },
  _formatColors = function (e, t, r) {
    var s = "",
      o = (e + s).match(_colorExp),
      a = t ? "hsla(" : "rgba(",
      l = 0,
      c,
      u,
      p,
      N;
    if (!o) return e;
    if (
      ((o = o.map(function (P) {
        return (
          (P = splitColor(P, t, 1)) &&
          a +
            (t ? P[0] + "," + P[1] + "%," + P[2] + "%," + P[3] : P.join(",")) +
            ")"
        );
      })),
      r && ((p = _colorOrderData(e)), (c = r.c), c.join(s) !== p.c.join(s)))
    )
      for (
        u = e.replace(_colorExp, "1").split(_numWithUnitExp), N = u.length - 1;
        l < N;
        l++
      )
        s +=
          u[l] +
          (~c.indexOf(l)
            ? o.shift() || a + "0,0,0,0)"
            : (p.length ? p : o.length ? o : r).shift());
    if (!u)
      for (u = e.split(_colorExp), N = u.length - 1; l < N; l++)
        s += u[l] + o[l];
    return s + u[N];
  },
  _colorExp = (function () {
    var n =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in _colorLookup) n += "|" + e + "\\b";
    return new RegExp(n + ")", "gi");
  })(),
  _hslExp = /hsl[a]?\(/,
  _colorStringFilter = function (e) {
    var t = e.join(" "),
      r;
    if (((_colorExp.lastIndex = 0), _colorExp.test(t)))
      return (
        (r = _hslExp.test(t)),
        (e[1] = _formatColors(e[1], r)),
        (e[0] = _formatColors(e[0], r, _colorOrderData(e[1]))),
        !0
      );
  },
  _tickerActive,
  _ticker = (function () {
    var n = Date.now,
      e = 500,
      t = 33,
      r = n(),
      s = r,
      o = 1e3 / 240,
      a = o,
      l = [],
      c,
      u,
      p,
      N,
      P,
      de,
      me = function Ye(nt) {
        var Be = n() - s,
          ot = nt === !0,
          st,
          vt,
          xt,
          St;
        if (
          ((Be > e || Be < 0) && (r += Be - t),
          (s += Be),
          (xt = s - r),
          (st = xt - a),
          (st > 0 || ot) &&
            ((St = ++N.frame),
            (P = xt - N.time * 1e3),
            (N.time = xt = xt / 1e3),
            (a += st + (st >= o ? 4 : o - st)),
            (vt = 1)),
          ot || (c = u(Ye)),
          vt)
        )
          for (de = 0; de < l.length; de++) l[de](xt, P, St, nt);
      };
    return (
      (N = {
        time: 0,
        frame: 0,
        tick: function () {
          me(!0);
        },
        deltaRatio: function (nt) {
          return P / (1e3 / (nt || 60));
        },
        wake: function () {
          _coreReady &&
            (!_coreInitted$2 &&
              _windowExists$2() &&
              ((_win$3 = _coreInitted$2 = window),
              (_doc$3 = _win$3.document || {}),
              (_globals.gsap = gsap$2),
              (_win$3.gsapVersions || (_win$3.gsapVersions = [])).push(
                gsap$2.version
              ),
              _install(
                _installScope ||
                  _win$3.GreenSockGlobals ||
                  (!_win$3.gsap && _win$3) ||
                  {}
              ),
              _registerPluginQueue.forEach(_createPlugin)),
            (p = typeof requestAnimationFrame < "u" && requestAnimationFrame),
            c && N.sleep(),
            (u =
              p ||
              function (nt) {
                return setTimeout(nt, (a - N.time * 1e3 + 1) | 0);
              }),
            (_tickerActive = 1),
            me(2));
        },
        sleep: function () {
          (p ? cancelAnimationFrame : clearTimeout)(c),
            (_tickerActive = 0),
            (u = _emptyFunc);
        },
        lagSmoothing: function (nt, Be) {
          (e = nt || 1 / 0), (t = Math.min(Be || 33, e));
        },
        fps: function (nt) {
          (o = 1e3 / (nt || 240)), (a = N.time * 1e3 + o);
        },
        add: function (nt, Be, ot) {
          var st = Be
            ? function (vt, xt, St, wt) {
                nt(vt, xt, St, wt), N.remove(st);
              }
            : nt;
          return N.remove(nt), l[ot ? "unshift" : "push"](st), _wake(), st;
        },
        remove: function (nt, Be) {
          ~(Be = l.indexOf(nt)) && l.splice(Be, 1) && de >= Be && de--;
        },
        _listeners: l,
      }),
      N
    );
  })(),
  _wake = function () {
    return !_tickerActive && _ticker.wake();
  },
  _easeMap = {},
  _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
  _quotesExp = /["']/g,
  _parseObjectInString = function (e) {
    for (
      var t = {},
        r = e.substr(1, e.length - 3).split(":"),
        s = r[0],
        o = 1,
        a = r.length,
        l,
        c,
        u;
      o < a;
      o++
    )
      (c = r[o]),
        (l = o !== a - 1 ? c.lastIndexOf(",") : c.length),
        (u = c.substr(0, l)),
        (t[s] = isNaN(u) ? u.replace(_quotesExp, "").trim() : +u),
        (s = c.substr(l + 1).trim());
    return t;
  },
  _valueInParentheses = function (e) {
    var t = e.indexOf("(") + 1,
      r = e.indexOf(")"),
      s = e.indexOf("(", t);
    return e.substring(t, ~s && s < r ? e.indexOf(")", r + 1) : r);
  },
  _configEaseFromString = function (e) {
    var t = (e + "").split("("),
      r = _easeMap[t[0]];
    return r && t.length > 1 && r.config
      ? r.config.apply(
          null,
          ~e.indexOf("{")
            ? [_parseObjectInString(t[1])]
            : _valueInParentheses(e).split(",").map(_numericIfPossible)
        )
      : _easeMap._CE && _customEaseExp.test(e)
      ? _easeMap._CE("", e)
      : r;
  },
  _invertEase = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  _propagateYoyoEase = function n(e, t) {
    for (var r = e._first, s; r; )
      r instanceof Timeline
        ? n(r, t)
        : r.vars.yoyoEase &&
          (!r._yoyo || !r._repeat) &&
          r._yoyo !== t &&
          (r.timeline
            ? n(r.timeline, t)
            : ((s = r._ease),
              (r._ease = r._yEase),
              (r._yEase = s),
              (r._yoyo = t))),
        (r = r._next);
  },
  _parseEase = function (e, t) {
    return (
      (e && (_isFunction$1(e) ? e : _easeMap[e] || _configEaseFromString(e))) ||
      t
    );
  },
  _insertEase = function (e, t, r, s) {
    r === void 0 &&
      (r = function (c) {
        return 1 - t(1 - c);
      }),
      s === void 0 &&
        (s = function (c) {
          return c < 0.5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2;
        });
    var o = { easeIn: t, easeOut: r, easeInOut: s },
      a;
    return (
      _forEachName(e, function (l) {
        (_easeMap[l] = _globals[l] = o), (_easeMap[(a = l.toLowerCase())] = r);
        for (var c in o)
          _easeMap[
            a + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")
          ] = _easeMap[l + "." + c] = o[c];
      }),
      o
    );
  },
  _easeInOutFromOut = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  _configElastic = function n(e, t, r) {
    var s = t >= 1 ? t : 1,
      o = (r || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      a = (o / _2PI) * (Math.asin(1 / s) || 0),
      l = function (p) {
        return p === 1 ? 1 : s * Math.pow(2, -10 * p) * _sin((p - a) * o) + 1;
      },
      c =
        e === "out"
          ? l
          : e === "in"
          ? function (u) {
              return 1 - l(1 - u);
            }
          : _easeInOutFromOut(l);
    return (
      (o = _2PI / o),
      (c.config = function (u, p) {
        return n(e, u, p);
      }),
      c
    );
  },
  _configBack = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var r = function (a) {
        return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
      },
      s =
        e === "out"
          ? r
          : e === "in"
          ? function (o) {
              return 1 - r(1 - o);
            }
          : _easeInOutFromOut(r);
    return (
      (s.config = function (o) {
        return n(e, o);
      }),
      s
    );
  };
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
  var t = e < 5 ? e + 1 : e;
  _insertEase(
    n + ",Power" + (t - 1),
    e
      ? function (r) {
          return Math.pow(r, t);
        }
      : function (r) {
          return r;
        },
    function (r) {
      return 1 - Math.pow(1 - r, t);
    },
    function (r) {
      return r < 0.5
        ? Math.pow(r * 2, t) / 2
        : 1 - Math.pow((1 - r) * 2, t) / 2;
    }
  );
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase(
  "Elastic",
  _configElastic("in"),
  _configElastic("out"),
  _configElastic()
);
(function (n, e) {
  var t = 1 / e,
    r = 2 * t,
    s = 2.5 * t,
    o = function (l) {
      return l < t
        ? n * l * l
        : l < r
        ? n * Math.pow(l - 1.5 / e, 2) + 0.75
        : l < s
        ? n * (l -= 2.25 / e) * l + 0.9375
        : n * Math.pow(l - 2.625 / e, 2) + 0.984375;
    };
  _insertEase(
    "Bounce",
    function (a) {
      return 1 - o(1 - a);
    },
    o
  );
})(7.5625, 2.75);
_insertEase("Expo", function (n) {
  return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n);
});
_insertEase("Circ", function (n) {
  return -(_sqrt(1 - n * n) - 1);
});
_insertEase("Sine", function (n) {
  return n === 1 ? 1 : -_cos(n * _HALF_PI) + 1;
});
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase =
  _easeMap.steps =
  _globals.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var r = 1 / e,
          s = e + (t ? 0 : 1),
          o = t ? 1 : 0,
          a = 1 - _tinyNum;
        return function (l) {
          return (((s * _clamp$1(0, a, l)) | 0) + o) * r;
        };
      },
    };
_defaults$1.ease = _easeMap["quad.out"];
_forEachName(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (n) {
    return (_callbackNames += n + "," + n + "Params,");
  }
);
var GSCache = function (e, t) {
    (this.id = _gsID++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : _getProperty),
      (this.set = t ? t.getSetter : _getSetter);
  },
  Animation = (function () {
    function n(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        _setDuration(this, +t.duration, 1, 1),
        (this.data = t.data),
        _context$2 && ((this._ctx = _context$2), _context$2.data.push(this)),
        _tickerActive || _ticker.wake();
    }
    var e = n.prototype;
    return (
      (e.delay = function (r) {
        return r || r === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + r - this._delay),
            (this._delay = r),
            this)
          : this._delay;
      }),
      (e.duration = function (r) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (r) {
        return arguments.length
          ? ((this._dirty = 0),
            _setDuration(
              this,
              this._repeat < 0
                ? r
                : (r - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (r, s) {
        if ((_wake(), !arguments.length)) return this._tTime;
        var o = this._dp;
        if (o && o.smoothChildTiming && this._ts) {
          for (
            _alignPlayhead(this, r),
              !o._dp || o.parent || _postAddChecks(o, this);
            o && o.parent;

          )
            o.parent._time !==
              o._start +
                (o._ts >= 0
                  ? o._tTime / o._ts
                  : (o.totalDuration() - o._tTime) / -o._ts) &&
              o.totalTime(o._tTime, !0),
              (o = o.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && r < this._tDur) ||
              (this._ts < 0 && r > 0) ||
              (!this._tDur && !r)) &&
            _addToTimeline(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== r ||
            (!this._dur && !s) ||
            (this._initted && Math.abs(this._zTime) === _tinyNum) ||
            (!r && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = r), _lazySafeRender(this, r, s)),
          this
        );
      }),
      (e.time = function (r, s) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), r + _elapsedCycleDuration(this)) %
                (this._dur + this._rDelay) || (r ? this._dur : 0),
              s
            )
          : this._time;
      }),
      (e.totalProgress = function (r, s) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * r, s)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.rawTime() >= 0 && this._initted
          ? 1
          : 0;
      }),
      (e.progress = function (r, s) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) +
                _elapsedCycleDuration(this),
              s
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.rawTime() > 0
          ? 1
          : 0;
      }),
      (e.iteration = function (r, s) {
        var o = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (r - 1) * o, s)
          : this._repeat
          ? _animationCycle(this._tTime, o) + 1
          : 1;
      }),
      (e.timeScale = function (r, s) {
        if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
        if (this._rts === r) return this;
        var o =
          this.parent && this._ts
            ? _parentToChildTotalTime(this.parent._time, this)
            : this._tTime;
        return (
          (this._rts = +r || 0),
          (this._ts = this._ps || r === -1e-8 ? 0 : this._rts),
          this.totalTime(
            _clamp$1(-Math.abs(this._delay), this.totalDuration(), o),
            s !== !1
          ),
          _setEnd(this),
          _recacheAncestors(this)
        );
      }),
      (e.paused = function (r) {
        return arguments.length
          ? (this._ps !== r &&
              ((this._ps = r),
              r
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (_wake(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== _tinyNum &&
                      (this._tTime -= _tinyNum)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (r) {
        if (arguments.length) {
          this._start = r;
          var s = this.parent || this._dp;
          return (
            s &&
              (s._sort || !this.parent) &&
              _addToTimeline(s, this, r - this._delay),
            this
          );
        }
        return this._start;
      }),
      (e.endTime = function (r) {
        return (
          this._start +
          (_isNotFalse(r) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (r) {
        var s = this.parent || this._dp;
        return s
          ? r &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? _parentToChildTotalTime(s.rawTime(r), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (r) {
        r === void 0 && (r = _revertConfig);
        var s = _reverting$1;
        return (
          (_reverting$1 = r),
          _isRevertWorthy(this) &&
            (this.timeline && this.timeline.revert(r),
            this.totalTime(-0.01, r.suppressEvents)),
          this.data !== "nested" && r.kill !== !1 && this.kill(),
          (_reverting$1 = s),
          this
        );
      }),
      (e.globalTime = function (r) {
        for (var s = this, o = arguments.length ? r : s.rawTime(); s; )
          (o = s._start + o / (Math.abs(s._ts) || 1)), (s = s._dp);
        return !this.parent && this._sat ? this._sat.globalTime(r) : o;
      }),
      (e.repeat = function (r) {
        return arguments.length
          ? ((this._repeat = r === 1 / 0 ? -2 : r),
            _onUpdateTotalDuration(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (r) {
        if (arguments.length) {
          var s = this._time;
          return (
            (this._rDelay = r),
            _onUpdateTotalDuration(this),
            s ? this.time(s) : this
          );
        }
        return this._rDelay;
      }),
      (e.yoyo = function (r) {
        return arguments.length ? ((this._yoyo = r), this) : this._yoyo;
      }),
      (e.seek = function (r, s) {
        return this.totalTime(_parsePosition$1(this, r), _isNotFalse(s));
      }),
      (e.restart = function (r, s) {
        return (
          this.play().totalTime(r ? -this._delay : 0, _isNotFalse(s)),
          this._dur || (this._zTime = -1e-8),
          this
        );
      }),
      (e.play = function (r, s) {
        return r != null && this.seek(r, s), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (r, s) {
        return (
          r != null && this.seek(r || this.totalDuration(), s),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (r, s) {
        return r != null && this.seek(r, s), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (r) {
        return arguments.length
          ? (!!r !== this.reversed() &&
              this.timeScale(-this._rts || (r ? -1e-8 : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
      }),
      (e.isActive = function () {
        var r = this.parent || this._dp,
          s = this._start,
          o;
        return !!(
          !r ||
          (this._ts &&
            this._initted &&
            r.isActive() &&
            (o = r.rawTime(!0)) >= s &&
            o < this.endTime(!0) - _tinyNum)
        );
      }),
      (e.eventCallback = function (r, s, o) {
        var a = this.vars;
        return arguments.length > 1
          ? (s
              ? ((a[r] = s),
                o && (a[r + "Params"] = o),
                r === "onUpdate" && (this._onUpdate = s))
              : delete a[r],
            this)
          : a[r];
      }),
      (e.then = function (r) {
        var s = this;
        return new Promise(function (o) {
          var a = _isFunction$1(r) ? r : _passThrough$1,
            l = function () {
              var u = s.then;
              (s.then = null),
                _isFunction$1(a) &&
                  (a = a(s)) &&
                  (a.then || a === s) &&
                  (s.then = u),
                o(a),
                (s.then = u);
            };
          (s._initted && s.totalProgress() === 1 && s._ts >= 0) ||
          (!s._tTime && s._ts < 0)
            ? l()
            : (s._prom = l);
        });
      }),
      (e.kill = function () {
        _interrupt(this);
      }),
      n
    );
  })();
_setDefaults$1(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -1e-8,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var Timeline = (function (n) {
  _inheritsLoose(e, n);
  function e(r, s) {
    var o;
    return (
      r === void 0 && (r = {}),
      (o = n.call(this, r) || this),
      (o.labels = {}),
      (o.smoothChildTiming = !!r.smoothChildTiming),
      (o.autoRemoveChildren = !!r.autoRemoveChildren),
      (o._sort = _isNotFalse(r.sortChildren)),
      _globalTimeline &&
        _addToTimeline(
          r.parent || _globalTimeline,
          _assertThisInitialized(o),
          s
        ),
      r.reversed && o.reverse(),
      r.paused && o.paused(!0),
      r.scrollTrigger &&
        _scrollTrigger(_assertThisInitialized(o), r.scrollTrigger),
      o
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (s, o, a) {
      return _createTweenType(0, arguments, this), this;
    }),
    (t.from = function (s, o, a) {
      return _createTweenType(1, arguments, this), this;
    }),
    (t.fromTo = function (s, o, a, l) {
      return _createTweenType(2, arguments, this), this;
    }),
    (t.set = function (s, o, a) {
      return (
        (o.duration = 0),
        (o.parent = this),
        _inheritDefaults(o).repeatDelay || (o.repeat = 0),
        (o.immediateRender = !!o.immediateRender),
        new Tween(s, o, _parsePosition$1(this, a), 1),
        this
      );
    }),
    (t.call = function (s, o, a) {
      return _addToTimeline(this, Tween.delayedCall(0, s, o), a);
    }),
    (t.staggerTo = function (s, o, a, l, c, u, p) {
      return (
        (a.duration = o),
        (a.stagger = a.stagger || l),
        (a.onComplete = u),
        (a.onCompleteParams = p),
        (a.parent = this),
        new Tween(s, a, _parsePosition$1(this, c)),
        this
      );
    }),
    (t.staggerFrom = function (s, o, a, l, c, u, p) {
      return (
        (a.runBackwards = 1),
        (_inheritDefaults(a).immediateRender = _isNotFalse(a.immediateRender)),
        this.staggerTo(s, o, a, l, c, u, p)
      );
    }),
    (t.staggerFromTo = function (s, o, a, l, c, u, p, N) {
      return (
        (l.startAt = a),
        (_inheritDefaults(l).immediateRender = _isNotFalse(l.immediateRender)),
        this.staggerTo(s, o, l, c, u, p, N)
      );
    }),
    (t.render = function (s, o, a) {
      var l = this._time,
        c = this._dirty ? this.totalDuration() : this._tDur,
        u = this._dur,
        p = s <= 0 ? 0 : _roundPrecise(s),
        N = this._zTime < 0 != s < 0 && (this._initted || !u),
        P,
        de,
        me,
        Ye,
        nt,
        Be,
        ot,
        st,
        vt,
        xt,
        St,
        wt;
      if (
        (this !== _globalTimeline && p > c && s >= 0 && (p = c),
        p !== this._tTime || a || N)
      ) {
        if (
          (l !== this._time &&
            u &&
            ((p += this._time - l), (s += this._time - l)),
          (P = p),
          (vt = this._start),
          (st = this._ts),
          (Be = !st),
          N && (u || (l = this._zTime), (s || !o) && (this._zTime = s)),
          this._repeat)
        ) {
          if (
            ((St = this._yoyo),
            (nt = u + this._rDelay),
            this._repeat < -1 && s < 0)
          )
            return this.totalTime(nt * 100 + s, o, a);
          if (
            ((P = _roundPrecise(p % nt)),
            p === c
              ? ((Ye = this._repeat), (P = u))
              : ((xt = _roundPrecise(p / nt)),
                (Ye = ~~xt),
                Ye && Ye === xt && ((P = u), Ye--),
                P > u && (P = u)),
            (xt = _animationCycle(this._tTime, nt)),
            !l &&
              this._tTime &&
              xt !== Ye &&
              this._tTime - xt * nt - this._dur <= 0 &&
              (xt = Ye),
            St && Ye & 1 && ((P = u - P), (wt = 1)),
            Ye !== xt && !this._lock)
          ) {
            var bt = St && xt & 1,
              Tt = bt === (St && Ye & 1);
            if (
              (Ye < xt && (bt = !bt),
              (l = bt ? 0 : p % u ? u : p),
              (this._lock = 1),
              (this.render(
                l || (wt ? 0 : _roundPrecise(Ye * nt)),
                o,
                !u
              )._lock = 0),
              (this._tTime = p),
              !o && this.parent && _callback$1(this, "onRepeat"),
              this.vars.repeatRefresh && !wt && (this.invalidate()._lock = 1),
              (l && l !== this._time) ||
                Be !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((u = this._dur),
              (c = this._tDur),
              Tt &&
                ((this._lock = 2),
                (l = bt ? u : -1e-4),
                this.render(l, !0),
                this.vars.repeatRefresh && !wt && this.invalidate()),
              (this._lock = 0),
              !this._ts && !Be)
            )
              return this;
            _propagateYoyoEase(this, wt);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((ot = _findNextPauseTween(
              this,
              _roundPrecise(l),
              _roundPrecise(P)
            )),
            ot && (p -= P - (P = ot._start))),
          (this._tTime = p),
          (this._time = P),
          (this._act = !st),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = s),
            (l = 0)),
          !l &&
            p &&
            !o &&
            !xt &&
            (_callback$1(this, "onStart"), this._tTime !== p))
        )
          return this;
        if (P >= l && s >= 0)
          for (de = this._first; de; ) {
            if (
              ((me = de._next),
              (de._act || P >= de._start) && de._ts && ot !== de)
            ) {
              if (de.parent !== this) return this.render(s, o, a);
              if (
                (de.render(
                  de._ts > 0
                    ? (P - de._start) * de._ts
                    : (de._dirty ? de.totalDuration() : de._tDur) +
                        (P - de._start) * de._ts,
                  o,
                  a
                ),
                P !== this._time || (!this._ts && !Be))
              ) {
                (ot = 0), me && (p += this._zTime = -1e-8);
                break;
              }
            }
            de = me;
          }
        else {
          de = this._last;
          for (var Ct = s < 0 ? s : P; de; ) {
            if (
              ((me = de._prev),
              (de._act || Ct <= de._end) && de._ts && ot !== de)
            ) {
              if (de.parent !== this) return this.render(s, o, a);
              if (
                (de.render(
                  de._ts > 0
                    ? (Ct - de._start) * de._ts
                    : (de._dirty ? de.totalDuration() : de._tDur) +
                        (Ct - de._start) * de._ts,
                  o,
                  a || (_reverting$1 && _isRevertWorthy(de))
                ),
                P !== this._time || (!this._ts && !Be))
              ) {
                (ot = 0), me && (p += this._zTime = Ct ? -1e-8 : _tinyNum);
                break;
              }
            }
            de = me;
          }
        }
        if (
          ot &&
          !o &&
          (this.pause(),
          (ot.render(P >= l ? 0 : -1e-8)._zTime = P >= l ? 1 : -1),
          this._ts)
        )
          return (this._start = vt), _setEnd(this), this.render(s, o, a);
        this._onUpdate && !o && _callback$1(this, "onUpdate", !0),
          ((p === c && this._tTime >= this.totalDuration()) || (!p && l)) &&
            (vt === this._start || Math.abs(st) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((s || !u) &&
                ((p === c && this._ts > 0) || (!p && this._ts < 0)) &&
                _removeFromParent(this, 1),
              !o &&
                !(s < 0 && !l) &&
                (p || l || !c) &&
                (_callback$1(
                  this,
                  p === c && s >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(p < c && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (s, o) {
      var a = this;
      if (
        (_isNumber$1(o) || (o = _parsePosition$1(this, o, s)),
        !(s instanceof Animation))
      ) {
        if (_isArray(s))
          return (
            s.forEach(function (l) {
              return a.add(l, o);
            }),
            this
          );
        if (_isString$1(s)) return this.addLabel(s, o);
        if (_isFunction$1(s)) s = Tween.delayedCall(0, s);
        else return this;
      }
      return this !== s ? _addToTimeline(this, s, o) : this;
    }),
    (t.getChildren = function (s, o, a, l) {
      s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = !0),
        l === void 0 && (l = -1e8);
      for (var c = [], u = this._first; u; )
        u._start >= l &&
          (u instanceof Tween
            ? o && c.push(u)
            : (a && c.push(u), s && c.push.apply(c, u.getChildren(!0, o, a)))),
          (u = u._next);
      return c;
    }),
    (t.getById = function (s) {
      for (var o = this.getChildren(1, 1, 1), a = o.length; a--; )
        if (o[a].vars.id === s) return o[a];
    }),
    (t.remove = function (s) {
      return _isString$1(s)
        ? this.removeLabel(s)
        : _isFunction$1(s)
        ? this.killTweensOf(s)
        : (s.parent === this && _removeLinkedListItem(this, s),
          s === this._recent && (this._recent = this._last),
          _uncache(this));
    }),
    (t.totalTime = function (s, o) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = _roundPrecise(
              _ticker.time -
                (this._ts > 0
                  ? s / this._ts
                  : (this.totalDuration() - s) / -this._ts)
            )),
          n.prototype.totalTime.call(this, s, o),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (s, o) {
      return (this.labels[s] = _parsePosition$1(this, o)), this;
    }),
    (t.removeLabel = function (s) {
      return delete this.labels[s], this;
    }),
    (t.addPause = function (s, o, a) {
      var l = Tween.delayedCall(0, o || _emptyFunc, a);
      return (
        (l.data = "isPause"),
        (this._hasPause = 1),
        _addToTimeline(this, l, _parsePosition$1(this, s))
      );
    }),
    (t.removePause = function (s) {
      var o = this._first;
      for (s = _parsePosition$1(this, s); o; )
        o._start === s && o.data === "isPause" && _removeFromParent(o),
          (o = o._next);
    }),
    (t.killTweensOf = function (s, o, a) {
      for (var l = this.getTweensOf(s, a), c = l.length; c--; )
        _overwritingTween !== l[c] && l[c].kill(s, o);
      return this;
    }),
    (t.getTweensOf = function (s, o) {
      for (
        var a = [], l = toArray(s), c = this._first, u = _isNumber$1(o), p;
        c;

      )
        c instanceof Tween
          ? _arrayContainsAny(c._targets, l) &&
            (u
              ? (!_overwritingTween || (c._initted && c._ts)) &&
                c.globalTime(0) <= o &&
                c.globalTime(c.totalDuration()) > o
              : !o || c.isActive()) &&
            a.push(c)
          : (p = c.getTweensOf(l, o)).length && a.push.apply(a, p),
          (c = c._next);
      return a;
    }),
    (t.tweenTo = function (s, o) {
      o = o || {};
      var a = this,
        l = _parsePosition$1(a, s),
        c = o,
        u = c.startAt,
        p = c.onStart,
        N = c.onStartParams,
        P = c.immediateRender,
        de,
        me = Tween.to(
          a,
          _setDefaults$1(
            {
              ease: o.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: l,
              overwrite: "auto",
              duration:
                o.duration ||
                Math.abs(
                  (l - (u && "time" in u ? u.time : a._time)) / a.timeScale()
                ) ||
                _tinyNum,
              onStart: function () {
                if ((a.pause(), !de)) {
                  var nt =
                    o.duration ||
                    Math.abs(
                      (l - (u && "time" in u ? u.time : a._time)) /
                        a.timeScale()
                    );
                  me._dur !== nt &&
                    _setDuration(me, nt, 0, 1).render(me._time, !0, !0),
                    (de = 1);
                }
                p && p.apply(me, N || []);
              },
            },
            o
          )
        );
      return P ? me.render(0) : me;
    }),
    (t.tweenFromTo = function (s, o, a) {
      return this.tweenTo(
        o,
        _setDefaults$1({ startAt: { time: _parsePosition$1(this, s) } }, a)
      );
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (s) {
      return (
        s === void 0 && (s = this._time),
        _getLabelInDirection(this, _parsePosition$1(this, s))
      );
    }),
    (t.previousLabel = function (s) {
      return (
        s === void 0 && (s = this._time),
        _getLabelInDirection(this, _parsePosition$1(this, s), 1)
      );
    }),
    (t.currentLabel = function (s) {
      return arguments.length
        ? this.seek(s, !0)
        : this.previousLabel(this._time + _tinyNum);
    }),
    (t.shiftChildren = function (s, o, a) {
      a === void 0 && (a = 0);
      for (var l = this._first, c = this.labels, u; l; )
        l._start >= a && ((l._start += s), (l._end += s)), (l = l._next);
      if (o) for (u in c) c[u] >= a && (c[u] += s);
      return _uncache(this);
    }),
    (t.invalidate = function (s) {
      var o = this._first;
      for (this._lock = 0; o; ) o.invalidate(s), (o = o._next);
      return n.prototype.invalidate.call(this, s);
    }),
    (t.clear = function (s) {
      s === void 0 && (s = !0);
      for (var o = this._first, a; o; ) (a = o._next), this.remove(o), (o = a);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        s && (this.labels = {}),
        _uncache(this)
      );
    }),
    (t.totalDuration = function (s) {
      var o = 0,
        a = this,
        l = a._last,
        c = _bigNum$1,
        u,
        p,
        N;
      if (arguments.length)
        return a.timeScale(
          (a._repeat < 0 ? a.duration() : a.totalDuration()) /
            (a.reversed() ? -s : s)
        );
      if (a._dirty) {
        for (N = a.parent; l; )
          (u = l._prev),
            l._dirty && l.totalDuration(),
            (p = l._start),
            p > c && a._sort && l._ts && !a._lock
              ? ((a._lock = 1),
                (_addToTimeline(a, l, p - l._delay, 1)._lock = 0))
              : (c = p),
            p < 0 &&
              l._ts &&
              ((o -= p),
              ((!N && !a._dp) || (N && N.smoothChildTiming)) &&
                ((a._start += p / a._ts), (a._time -= p), (a._tTime -= p)),
              a.shiftChildren(-p, !1, -1 / 0),
              (c = 0)),
            l._end > o && l._ts && (o = l._end),
            (l = u);
        _setDuration(
          a,
          a === _globalTimeline && a._time > o ? a._time : o,
          1,
          1
        ),
          (a._dirty = 0);
      }
      return a._tDur;
    }),
    (e.updateRoot = function (s) {
      if (
        (_globalTimeline._ts &&
          (_lazySafeRender(
            _globalTimeline,
            _parentToChildTotalTime(s, _globalTimeline)
          ),
          (_lastRenderedFrame = _ticker.frame)),
        _ticker.frame >= _nextGCFrame)
      ) {
        _nextGCFrame += _config.autoSleep || 120;
        var o = _globalTimeline._first;
        if (
          (!o || !o._ts) &&
          _config.autoSleep &&
          _ticker._listeners.length < 2
        ) {
          for (; o && !o._ts; ) o = o._next;
          o || _ticker.sleep();
        }
      }
    }),
    e
  );
})(Animation);
_setDefaults$1(Timeline.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var _addComplexStringPropTween = function (e, t, r, s, o, a, l) {
    var c = new PropTween(this._pt, e, t, 0, 1, _renderComplexString, null, o),
      u = 0,
      p = 0,
      N,
      P,
      de,
      me,
      Ye,
      nt,
      Be,
      ot;
    for (
      c.b = r,
        c.e = s,
        r += "",
        s += "",
        (Be = ~s.indexOf("random(")) && (s = _replaceRandom(s)),
        a && ((ot = [r, s]), a(ot, e, t), (r = ot[0]), (s = ot[1])),
        P = r.match(_complexStringNumExp) || [];
      (N = _complexStringNumExp.exec(s));

    )
      (me = N[0]),
        (Ye = s.substring(u, N.index)),
        de ? (de = (de + 1) % 5) : Ye.substr(-5) === "rgba(" && (de = 1),
        me !== P[p++] &&
          ((nt = parseFloat(P[p - 1]) || 0),
          (c._pt = {
            _next: c._pt,
            p: Ye || p === 1 ? Ye : ",",
            s: nt,
            c:
              me.charAt(1) === "="
                ? _parseRelative(nt, me) - nt
                : parseFloat(me) - nt,
            m: de && de < 4 ? Math.round : 0,
          }),
          (u = _complexStringNumExp.lastIndex));
    return (
      (c.c = u < s.length ? s.substring(u, s.length) : ""),
      (c.fp = l),
      (_relExp.test(s) || Be) && (c.e = 0),
      (this._pt = c),
      c
    );
  },
  _addPropTween = function (e, t, r, s, o, a, l, c, u, p) {
    _isFunction$1(s) && (s = s(o || 0, e, a));
    var N = e[t],
      P =
        r !== "get"
          ? r
          : _isFunction$1(N)
          ? u
            ? e[
                t.indexOf("set") || !_isFunction$1(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](u)
            : e[t]()
          : N,
      de = _isFunction$1(N)
        ? u
          ? _setterFuncWithParam
          : _setterFunc
        : _setterPlain,
      me;
    if (
      (_isString$1(s) &&
        (~s.indexOf("random(") && (s = _replaceRandom(s)),
        s.charAt(1) === "=" &&
          ((me = _parseRelative(P, s) + (getUnit(P) || 0)),
          (me || me === 0) && (s = me))),
      !p || P !== s || _forceAllPropTweens)
    )
      return !isNaN(P * s) && s !== ""
        ? ((me = new PropTween(
            this._pt,
            e,
            t,
            +P || 0,
            s - (P || 0),
            typeof N == "boolean" ? _renderBoolean : _renderPlain,
            0,
            de
          )),
          u && (me.fp = u),
          l && me.modifier(l, this, e),
          (this._pt = me))
        : (!N && !(t in e) && _missingPlugin(t, s),
          _addComplexStringPropTween.call(
            this,
            e,
            t,
            P,
            s,
            de,
            c || _config.stringFilter,
            u
          ));
  },
  _processVars = function (e, t, r, s, o) {
    if (
      (_isFunction$1(e) && (e = _parseFuncOrString(e, o, t, r, s)),
      !_isObject$1(e) ||
        (e.style && e.nodeType) ||
        _isArray(e) ||
        _isTypedArray(e))
    )
      return _isString$1(e) ? _parseFuncOrString(e, o, t, r, s) : e;
    var a = {},
      l;
    for (l in e) a[l] = _parseFuncOrString(e[l], o, t, r, s);
    return a;
  },
  _checkPlugin = function (e, t, r, s, o, a) {
    var l, c, u, p;
    if (
      _plugins[e] &&
      (l = new _plugins[e]()).init(
        o,
        l.rawVars ? t[e] : _processVars(t[e], s, o, a, r),
        r,
        s,
        a
      ) !== !1 &&
      ((r._pt = c =
        new PropTween(r._pt, o, e, 0, 1, l.render, l, 0, l.priority)),
      r !== _quickTween)
    )
      for (u = r._ptLookup[r._targets.indexOf(o)], p = l._props.length; p--; )
        u[l._props[p]] = c;
    return l;
  },
  _overwritingTween,
  _forceAllPropTweens,
  _initTween = function n(e, t, r) {
    var s = e.vars,
      o = s.ease,
      a = s.startAt,
      l = s.immediateRender,
      c = s.lazy,
      u = s.onUpdate,
      p = s.runBackwards,
      N = s.yoyoEase,
      P = s.keyframes,
      de = s.autoRevert,
      me = e._dur,
      Ye = e._startAt,
      nt = e._targets,
      Be = e.parent,
      ot = Be && Be.data === "nested" ? Be.vars.targets : nt,
      st = e._overwrite === "auto" && !_suppressOverwrites$1,
      vt = e.timeline,
      xt,
      St,
      wt,
      bt,
      Tt,
      Ct,
      kt,
      Dt,
      Vt,
      Ht,
      qt,
      Ft,
      Bt;
    if (
      (vt && (!P || !o) && (o = "none"),
      (e._ease = _parseEase(o, _defaults$1.ease)),
      (e._yEase = N
        ? _invertEase(_parseEase(N === !0 ? o : N, _defaults$1.ease))
        : 0),
      N &&
        e._yoyo &&
        !e._repeat &&
        ((N = e._yEase), (e._yEase = e._ease), (e._ease = N)),
      (e._from = !vt && !!s.runBackwards),
      !vt || (P && !s.stagger))
    ) {
      if (
        ((Dt = nt[0] ? _getCache(nt[0]).harness : 0),
        (Ft = Dt && s[Dt.prop]),
        (xt = _copyExcluding(s, _reservedProps)),
        Ye &&
          (Ye._zTime < 0 && Ye.progress(1),
          t < 0 && p && l && !de
            ? Ye.render(-1, !0)
            : Ye.revert(p && me ? _revertConfigNoKill : _startAtRevertConfig),
          (Ye._lazy = 0)),
        a)
      ) {
        if (
          (_removeFromParent(
            (e._startAt = Tween.set(
              nt,
              _setDefaults$1(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: Be,
                  immediateRender: !0,
                  lazy: !Ye && _isNotFalse(c),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    u &&
                    function () {
                      return _callback$1(e, "onUpdate");
                    },
                  stagger: 0,
                },
                a
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 &&
            (_reverting$1 || (!l && !de)) &&
            e._startAt.revert(_revertConfigNoKill),
          l && me && t <= 0 && r <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (p && me && !Ye) {
        if (
          (t && (l = !1),
          (wt = _setDefaults$1(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: l && !Ye && _isNotFalse(c),
              immediateRender: l,
              stagger: 0,
              parent: Be,
            },
            xt
          )),
          Ft && (wt[Dt.prop] = Ft),
          _removeFromParent((e._startAt = Tween.set(nt, wt))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 &&
            (_reverting$1
              ? e._startAt.revert(_revertConfigNoKill)
              : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !l)
        )
          n(e._startAt, _tinyNum, _tinyNum);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0,
          c = (me && _isNotFalse(c)) || (c && !me),
          St = 0;
        St < nt.length;
        St++
      ) {
        if (
          ((Tt = nt[St]),
          (kt = Tt._gsap || _harness(nt)[St]._gsap),
          (e._ptLookup[St] = Ht = {}),
          _lazyLookup[kt.id] && _lazyTweens.length && _lazyRender(),
          (qt = ot === nt ? St : ot.indexOf(Tt)),
          Dt &&
            (Vt = new Dt()).init(Tt, Ft || xt, e, qt, ot) !== !1 &&
            ((e._pt = bt =
              new PropTween(
                e._pt,
                Tt,
                Vt.name,
                0,
                1,
                Vt.render,
                Vt,
                0,
                Vt.priority
              )),
            Vt._props.forEach(function (Mt) {
              Ht[Mt] = bt;
            }),
            Vt.priority && (Ct = 1)),
          !Dt || Ft)
        )
          for (wt in xt)
            _plugins[wt] && (Vt = _checkPlugin(wt, xt, e, qt, Tt, ot))
              ? Vt.priority && (Ct = 1)
              : (Ht[wt] = bt =
                  _addPropTween.call(
                    e,
                    Tt,
                    wt,
                    "get",
                    xt[wt],
                    qt,
                    ot,
                    0,
                    s.stringFilter
                  ));
        e._op && e._op[St] && e.kill(Tt, e._op[St]),
          st &&
            e._pt &&
            ((_overwritingTween = e),
            _globalTimeline.killTweensOf(Tt, Ht, e.globalTime(t)),
            (Bt = !e.parent),
            (_overwritingTween = 0)),
          e._pt && c && (_lazyLookup[kt.id] = 1);
      }
      Ct && _sortPropTweensByPriority(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = u),
      (e._initted = (!e._op || e._pt) && !Bt),
      P && t <= 0 && vt.render(_bigNum$1, !0, !0);
  },
  _updatePropTweens = function (e, t, r, s, o, a, l, c) {
    var u = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      p,
      N,
      P,
      de;
    if (!u)
      for (
        u = e._ptCache[t] = [], P = e._ptLookup, de = e._targets.length;
        de--;

      ) {
        if (((p = P[de][t]), p && p.d && p.d._pt))
          for (p = p.d._pt; p && p.p !== t && p.fp !== t; ) p = p._next;
        if (!p)
          return (
            (_forceAllPropTweens = 1),
            (e.vars[t] = "+=0"),
            _initTween(e, l),
            (_forceAllPropTweens = 0),
            c ? _warn(t + " not eligible for reset") : 1
          );
        u.push(p);
      }
    for (de = u.length; de--; )
      (N = u[de]),
        (p = N._pt || N),
        (p.s = (s || s === 0) && !o ? s : p.s + (s || 0) + a * p.c),
        (p.c = r - p.s),
        N.e && (N.e = _round$1(r) + getUnit(N.e)),
        N.b && (N.b = p.s + getUnit(N.b));
  },
  _addAliasesToVars = function (e, t) {
    var r = e[0] ? _getCache(e[0]).harness : 0,
      s = r && r.aliases,
      o,
      a,
      l,
      c;
    if (!s) return t;
    o = _merge({}, t);
    for (a in s)
      if (a in o) for (c = s[a].split(","), l = c.length; l--; ) o[c[l]] = o[a];
    return o;
  },
  _parseKeyframe = function (e, t, r, s) {
    var o = t.ease || s || "power1.inOut",
      a,
      l;
    if (_isArray(t))
      (l = r[e] || (r[e] = [])),
        t.forEach(function (c, u) {
          return l.push({ t: (u / (t.length - 1)) * 100, v: c, e: o });
        });
    else
      for (a in t)
        (l = r[a] || (r[a] = [])),
          a === "ease" || l.push({ t: parseFloat(e), v: t[a], e: o });
  },
  _parseFuncOrString = function (e, t, r, s, o) {
    return _isFunction$1(e)
      ? e.call(t, r, s, o)
      : _isString$1(e) && ~e.indexOf("random(")
      ? _replaceRandom(e)
      : e;
  },
  _staggerTweenProps =
    _callbackNames +
    "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  _staggerPropsToSkip = {};
_forEachName(
  _staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger",
  function (n) {
    return (_staggerPropsToSkip[n] = 1);
  }
);
var Tween = (function (n) {
  _inheritsLoose(e, n);
  function e(r, s, o, a) {
    var l;
    typeof s == "number" && ((o.duration = s), (s = o), (o = null)),
      (l = n.call(this, a ? s : _inheritDefaults(s)) || this);
    var c = l.vars,
      u = c.duration,
      p = c.delay,
      N = c.immediateRender,
      P = c.stagger,
      de = c.overwrite,
      me = c.keyframes,
      Ye = c.defaults,
      nt = c.scrollTrigger,
      Be = c.yoyoEase,
      ot = s.parent || _globalTimeline,
      st = (_isArray(r) || _isTypedArray(r) ? _isNumber$1(r[0]) : "length" in s)
        ? [r]
        : toArray(r),
      vt,
      xt,
      St,
      wt,
      bt,
      Tt,
      Ct,
      kt;
    if (
      ((l._targets = st.length
        ? _harness(st)
        : _warn(
            "GSAP target " + r + " not found. https://gsap.com",
            !_config.nullTargetWarn
          ) || []),
      (l._ptLookup = []),
      (l._overwrite = de),
      me || P || _isFuncOrString(u) || _isFuncOrString(p))
    ) {
      if (
        ((s = l.vars),
        (vt = l.timeline =
          new Timeline({
            data: "nested",
            defaults: Ye || {},
            targets: ot && ot.data === "nested" ? ot.vars.targets : st,
          })),
        vt.kill(),
        (vt.parent = vt._dp = _assertThisInitialized(l)),
        (vt._start = 0),
        P || _isFuncOrString(u) || _isFuncOrString(p))
      ) {
        if (((wt = st.length), (Ct = P && distribute(P)), _isObject$1(P)))
          for (bt in P)
            ~_staggerTweenProps.indexOf(bt) &&
              (kt || (kt = {}), (kt[bt] = P[bt]));
        for (xt = 0; xt < wt; xt++)
          (St = _copyExcluding(s, _staggerPropsToSkip)),
            (St.stagger = 0),
            Be && (St.yoyoEase = Be),
            kt && _merge(St, kt),
            (Tt = st[xt]),
            (St.duration = +_parseFuncOrString(
              u,
              _assertThisInitialized(l),
              xt,
              Tt,
              st
            )),
            (St.delay =
              (+_parseFuncOrString(p, _assertThisInitialized(l), xt, Tt, st) ||
                0) - l._delay),
            !P &&
              wt === 1 &&
              St.delay &&
              ((l._delay = p = St.delay), (l._start += p), (St.delay = 0)),
            vt.to(Tt, St, Ct ? Ct(xt, Tt, st) : 0),
            (vt._ease = _easeMap.none);
        vt.duration() ? (u = p = 0) : (l.timeline = 0);
      } else if (me) {
        _inheritDefaults(_setDefaults$1(vt.vars.defaults, { ease: "none" })),
          (vt._ease = _parseEase(me.ease || s.ease || "none"));
        var Dt = 0,
          Vt,
          Ht,
          qt;
        if (_isArray(me))
          me.forEach(function (Ft) {
            return vt.to(st, Ft, ">");
          }),
            vt.duration();
        else {
          St = {};
          for (bt in me)
            bt === "ease" ||
              bt === "easeEach" ||
              _parseKeyframe(bt, me[bt], St, me.easeEach);
          for (bt in St)
            for (
              Vt = St[bt].sort(function (Ft, Bt) {
                return Ft.t - Bt.t;
              }),
                Dt = 0,
                xt = 0;
              xt < Vt.length;
              xt++
            )
              (Ht = Vt[xt]),
                (qt = {
                  ease: Ht.e,
                  duration: ((Ht.t - (xt ? Vt[xt - 1].t : 0)) / 100) * u,
                }),
                (qt[bt] = Ht.v),
                vt.to(st, qt, Dt),
                (Dt += qt.duration);
          vt.duration() < u && vt.to({}, { duration: u - vt.duration() });
        }
      }
      u || l.duration((u = vt.duration()));
    } else l.timeline = 0;
    return (
      de === !0 &&
        !_suppressOverwrites$1 &&
        ((_overwritingTween = _assertThisInitialized(l)),
        _globalTimeline.killTweensOf(st),
        (_overwritingTween = 0)),
      _addToTimeline(ot, _assertThisInitialized(l), o),
      s.reversed && l.reverse(),
      s.paused && l.paused(!0),
      (N ||
        (!u &&
          !me &&
          l._start === _roundPrecise(ot._time) &&
          _isNotFalse(N) &&
          _hasNoPausedAncestors(_assertThisInitialized(l)) &&
          ot.data !== "nested")) &&
        ((l._tTime = -1e-8), l.render(Math.max(0, -p) || 0)),
      nt && _scrollTrigger(_assertThisInitialized(l), nt),
      l
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (s, o, a) {
      var l = this._time,
        c = this._tDur,
        u = this._dur,
        p = s < 0,
        N = s > c - _tinyNum && !p ? c : s < _tinyNum ? 0 : s,
        P,
        de,
        me,
        Ye,
        nt,
        Be,
        ot,
        st,
        vt;
      if (!u) _renderZeroDurationTween(this, s, o, a);
      else if (
        N !== this._tTime ||
        !s ||
        a ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== p) ||
        this._lazy
      ) {
        if (((P = N), (st = this.timeline), this._repeat)) {
          if (((Ye = u + this._rDelay), this._repeat < -1 && p))
            return this.totalTime(Ye * 100 + s, o, a);
          if (
            ((P = _roundPrecise(N % Ye)),
            N === c
              ? ((me = this._repeat), (P = u))
              : ((nt = _roundPrecise(N / Ye)),
                (me = ~~nt),
                me && me === nt ? ((P = u), me--) : P > u && (P = u)),
            (Be = this._yoyo && me & 1),
            Be && ((vt = this._yEase), (P = u - P)),
            (nt = _animationCycle(this._tTime, Ye)),
            P === l && !a && this._initted && me === nt)
          )
            return (this._tTime = N), this;
          me !== nt &&
            (st && this._yEase && _propagateYoyoEase(st, Be),
            this.vars.repeatRefresh &&
              !Be &&
              !this._lock &&
              P !== Ye &&
              this._initted &&
              ((this._lock = a = 1),
              (this.render(
                _roundPrecise(Ye * me),
                !0
              ).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (_attemptInitTween(this, p ? s : P, a, o, N))
            return (this._tTime = 0), this;
          if (l !== this._time && !(a && this.vars.repeatRefresh && me !== nt))
            return this;
          if (u !== this._dur) return this.render(s, o, a);
        }
        if (
          ((this._tTime = N),
          (this._time = P),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = ot = (vt || this._ease)(P / u)),
          this._from && (this.ratio = ot = 1 - ot),
          !l &&
            N &&
            !o &&
            !nt &&
            (_callback$1(this, "onStart"), this._tTime !== N))
        )
          return this;
        for (de = this._pt; de; ) de.r(ot, de.d), (de = de._next);
        (st &&
          st.render(s < 0 ? s : st._dur * st._ease(P / this._dur), o, a)) ||
          (this._startAt && (this._zTime = s)),
          this._onUpdate &&
            !o &&
            (p && _rewindStartAt(this, s, o, a), _callback$1(this, "onUpdate")),
          this._repeat &&
            me !== nt &&
            this.vars.onRepeat &&
            !o &&
            this.parent &&
            _callback$1(this, "onRepeat"),
          (N === this._tDur || !N) &&
            this._tTime === N &&
            (p && !this._onUpdate && _rewindStartAt(this, s, !0, !0),
            (s || !u) &&
              ((N === this._tDur && this._ts > 0) || (!N && this._ts < 0)) &&
              _removeFromParent(this, 1),
            !o &&
              !(p && !l) &&
              (N || l || Be) &&
              (_callback$1(
                this,
                N === c ? "onComplete" : "onReverseComplete",
                !0
              ),
              this._prom && !(N < c && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (s) {
      return (
        (!s || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(s),
        n.prototype.invalidate.call(this, s)
      );
    }),
    (t.resetTo = function (s, o, a, l, c) {
      _tickerActive || _ticker.wake(), this._ts || this.play();
      var u = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        p;
      return (
        this._initted || _initTween(this, u),
        (p = this._ease(u / this._dur)),
        _updatePropTweens(this, s, o, a, l, p, u, c)
          ? this.resetTo(s, o, a, l, 1)
          : (_alignPlayhead(this, 0),
            this.parent ||
              _addLinkedListItem(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (s, o) {
      if ((o === void 0 && (o = "all"), !s && (!o || o === "all")))
        return (
          (this._lazy = this._pt = 0),
          this.parent
            ? _interrupt(this)
            : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting$1),
          this
        );
      if (this.timeline) {
        var a = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(
            s,
            o,
            _overwritingTween && _overwritingTween.vars.overwrite !== !0
          )._first || _interrupt(this),
          this.parent &&
            a !== this.timeline.totalDuration() &&
            _setDuration(this, (this._dur * this.timeline._tDur) / a, 0, 1),
          this
        );
      }
      var l = this._targets,
        c = s ? toArray(s) : l,
        u = this._ptLookup,
        p = this._pt,
        N,
        P,
        de,
        me,
        Ye,
        nt,
        Be;
      if ((!o || o === "all") && _arraysMatch(l, c))
        return o === "all" && (this._pt = 0), _interrupt(this);
      for (
        N = this._op = this._op || [],
          o !== "all" &&
            (_isString$1(o) &&
              ((Ye = {}),
              _forEachName(o, function (ot) {
                return (Ye[ot] = 1);
              }),
              (o = Ye)),
            (o = _addAliasesToVars(l, o))),
          Be = l.length;
        Be--;

      )
        if (~c.indexOf(l[Be])) {
          (P = u[Be]),
            o === "all"
              ? ((N[Be] = o), (me = P), (de = {}))
              : ((de = N[Be] = N[Be] || {}), (me = o));
          for (Ye in me)
            (nt = P && P[Ye]),
              nt &&
                ((!("kill" in nt.d) || nt.d.kill(Ye) === !0) &&
                  _removeLinkedListItem(this, nt, "_pt"),
                delete P[Ye]),
              de !== "all" && (de[Ye] = 1);
        }
      return this._initted && !this._pt && p && _interrupt(this), this;
    }),
    (e.to = function (s, o) {
      return new e(s, o, arguments[2]);
    }),
    (e.from = function (s, o) {
      return _createTweenType(1, arguments);
    }),
    (e.delayedCall = function (s, o, a, l) {
      return new e(o, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: s,
        onComplete: o,
        onReverseComplete: o,
        onCompleteParams: a,
        onReverseCompleteParams: a,
        callbackScope: l,
      });
    }),
    (e.fromTo = function (s, o, a) {
      return _createTweenType(2, arguments);
    }),
    (e.set = function (s, o) {
      return (o.duration = 0), o.repeatDelay || (o.repeat = 0), new e(s, o);
    }),
    (e.killTweensOf = function (s, o, a) {
      return _globalTimeline.killTweensOf(s, o, a);
    }),
    e
  );
})(Animation);
_setDefaults$1(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0,
});
_forEachName("staggerTo,staggerFrom,staggerFromTo", function (n) {
  Tween[n] = function () {
    var e = new Timeline(),
      t = _slice.call(arguments, 0);
    return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
  };
});
var _setterPlain = function (e, t, r) {
    return (e[t] = r);
  },
  _setterFunc = function (e, t, r) {
    return e[t](r);
  },
  _setterFuncWithParam = function (e, t, r, s) {
    return e[t](s.fp, r);
  },
  _setterAttribute = function (e, t, r) {
    return e.setAttribute(t, r);
  },
  _getSetter = function (e, t) {
    return _isFunction$1(e[t])
      ? _setterFunc
      : _isUndefined(e[t]) && e.setAttribute
      ? _setterAttribute
      : _setterPlain;
  },
  _renderPlain = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  _renderBoolean = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  _renderComplexString = function (e, t) {
    var r = t._pt,
      s = "";
    if (!e && t.b) s = t.b;
    else if (e === 1 && t.e) s = t.e;
    else {
      for (; r; )
        (s =
          r.p +
          (r.m ? r.m(r.s + r.c * e) : Math.round((r.s + r.c * e) * 1e4) / 1e4) +
          s),
          (r = r._next);
      s += t.c;
    }
    t.set(t.t, t.p, s, t);
  },
  _renderPropTweens = function (e, t) {
    for (var r = t._pt; r; ) r.r(e, r.d), (r = r._next);
  },
  _addPluginModifier = function (e, t, r, s) {
    for (var o = this._pt, a; o; )
      (a = o._next), o.p === s && o.modifier(e, t, r), (o = a);
  },
  _killPropTweensOf = function (e) {
    for (var t = this._pt, r, s; t; )
      (s = t._next),
        (t.p === e && !t.op) || t.op === e
          ? _removeLinkedListItem(this, t, "_pt")
          : t.dep || (r = 1),
        (t = s);
    return !r;
  },
  _setterWithModifier = function (e, t, r, s) {
    s.mSet(e, t, s.m.call(s.tween, r, s.mt), s);
  },
  _sortPropTweensByPriority = function (e) {
    for (var t = e._pt, r, s, o, a; t; ) {
      for (r = t._next, s = o; s && s.pr > t.pr; ) s = s._next;
      (t._prev = s ? s._prev : a) ? (t._prev._next = t) : (o = t),
        (t._next = s) ? (s._prev = t) : (a = t),
        (t = r);
    }
    e._pt = o;
  },
  PropTween = (function () {
    function n(t, r, s, o, a, l, c, u, p) {
      (this.t = r),
        (this.s = o),
        (this.c = a),
        (this.p = s),
        (this.r = l || _renderPlain),
        (this.d = c || this),
        (this.set = u || _setterPlain),
        (this.pr = p || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = n.prototype;
    return (
      (e.modifier = function (r, s, o) {
        (this.mSet = this.mSet || this.set),
          (this.set = _setterWithModifier),
          (this.m = r),
          (this.mt = o),
          (this.tween = s);
      }),
      n
    );
  })();
_forEachName(
  _callbackNames +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (n) {
    return (_reservedProps[n] = 1);
  }
);
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: !1,
  defaults: _defaults$1,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
_config.stringFilter = _colorStringFilter;
var _media = [],
  _listeners$1 = {},
  _emptyArray$1 = [],
  _lastMediaTime = 0,
  _contextID = 0,
  _dispatch$1 = function (e) {
    return (_listeners$1[e] || _emptyArray$1).map(function (t) {
      return t();
    });
  },
  _onMediaChange = function () {
    var e = Date.now(),
      t = [];
    e - _lastMediaTime > 2 &&
      (_dispatch$1("matchMediaInit"),
      _media.forEach(function (r) {
        var s = r.queries,
          o = r.conditions,
          a,
          l,
          c,
          u;
        for (l in s)
          (a = _win$3.matchMedia(s[l]).matches),
            a && (c = 1),
            a !== o[l] && ((o[l] = a), (u = 1));
        u && (r.revert(), c && t.push(r));
      }),
      _dispatch$1("matchMediaRevert"),
      t.forEach(function (r) {
        return r.onMatch(r, function (s) {
          return r.add(null, s);
        });
      }),
      (_lastMediaTime = e),
      _dispatch$1("matchMedia"));
  },
  Context = (function () {
    function n(t, r) {
      (this.selector = r && selector(r)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = _contextID++),
        t && this.add(t);
    }
    var e = n.prototype;
    return (
      (e.add = function (r, s, o) {
        _isFunction$1(r) && ((o = s), (s = r), (r = _isFunction$1));
        var a = this,
          l = function () {
            var u = _context$2,
              p = a.selector,
              N;
            return (
              u && u !== a && u.data.push(a),
              o && (a.selector = selector(o)),
              (_context$2 = a),
              (N = s.apply(a, arguments)),
              _isFunction$1(N) && a._r.push(N),
              (_context$2 = u),
              (a.selector = p),
              (a.isReverted = !1),
              N
            );
          };
        return (
          (a.last = l),
          r === _isFunction$1
            ? l(a, function (c) {
                return a.add(null, c);
              })
            : r
            ? (a[r] = l)
            : l
        );
      }),
      (e.ignore = function (r) {
        var s = _context$2;
        (_context$2 = null), r(this), (_context$2 = s);
      }),
      (e.getTweens = function () {
        var r = [];
        return (
          this.data.forEach(function (s) {
            return s instanceof n
              ? r.push.apply(r, s.getTweens())
              : s instanceof Tween &&
                  !(s.parent && s.parent.data === "nested") &&
                  r.push(s);
          }),
          r
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (r, s) {
        var o = this;
        if (
          (r
            ? (function () {
                for (var l = o.getTweens(), c = o.data.length, u; c--; )
                  (u = o.data[c]),
                    u.data === "isFlip" &&
                      (u.revert(),
                      u.getChildren(!0, !0, !1).forEach(function (p) {
                        return l.splice(l.indexOf(p), 1);
                      }));
                for (
                  l
                    .map(function (p) {
                      return {
                        g:
                          p._dur ||
                          p._delay ||
                          (p._sat && !p._sat.vars.immediateRender)
                            ? p.globalTime(0)
                            : -1 / 0,
                        t: p,
                      };
                    })
                    .sort(function (p, N) {
                      return N.g - p.g || -1 / 0;
                    })
                    .forEach(function (p) {
                      return p.t.revert(r);
                    }),
                    c = o.data.length;
                  c--;

                )
                  (u = o.data[c]),
                    u instanceof Timeline
                      ? u.data !== "nested" &&
                        (u.scrollTrigger && u.scrollTrigger.revert(), u.kill())
                      : !(u instanceof Tween) && u.revert && u.revert(r);
                o._r.forEach(function (p) {
                  return p(r, o);
                }),
                  (o.isReverted = !0);
              })()
            : this.data.forEach(function (l) {
                return l.kill && l.kill();
              }),
          this.clear(),
          s)
        )
          for (var a = _media.length; a--; )
            _media[a].id === this.id && _media.splice(a, 1);
      }),
      (e.revert = function (r) {
        this.kill(r || {});
      }),
      n
    );
  })(),
  MatchMedia = (function () {
    function n(t) {
      (this.contexts = []),
        (this.scope = t),
        _context$2 && _context$2.data.push(this);
    }
    var e = n.prototype;
    return (
      (e.add = function (r, s, o) {
        _isObject$1(r) || (r = { matches: r });
        var a = new Context(0, o || this.scope),
          l = (a.conditions = {}),
          c,
          u,
          p;
        _context$2 && !a.selector && (a.selector = _context$2.selector),
          this.contexts.push(a),
          (s = a.add("onMatch", s)),
          (a.queries = r);
        for (u in r)
          u === "all"
            ? (p = 1)
            : ((c = _win$3.matchMedia(r[u])),
              c &&
                (_media.indexOf(a) < 0 && _media.push(a),
                (l[u] = c.matches) && (p = 1),
                c.addListener
                  ? c.addListener(_onMediaChange)
                  : c.addEventListener("change", _onMediaChange)));
        return (
          p &&
            s(a, function (N) {
              return a.add(null, N);
            }),
          this
        );
      }),
      (e.revert = function (r) {
        this.kill(r || {});
      }),
      (e.kill = function (r) {
        this.contexts.forEach(function (s) {
          return s.kill(r, !0);
        });
      }),
      n
    );
  })(),
  _gsap = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
      t.forEach(function (s) {
        return _createPlugin(s);
      });
    },
    timeline: function (e) {
      return new Timeline(e);
    },
    getTweensOf: function (e, t) {
      return _globalTimeline.getTweensOf(e, t);
    },
    getProperty: function (e, t, r, s) {
      _isString$1(e) && (e = toArray(e)[0]);
      var o = _getCache(e || {}).get,
        a = r ? _passThrough$1 : _numericIfPossible;
      return (
        r === "native" && (r = ""),
        e &&
          (t
            ? a(((_plugins[t] && _plugins[t].get) || o)(e, t, r, s))
            : function (l, c, u) {
                return a(((_plugins[l] && _plugins[l].get) || o)(e, l, c, u));
              })
      );
    },
    quickSetter: function (e, t, r) {
      if (((e = toArray(e)), e.length > 1)) {
        var s = e.map(function (p) {
            return gsap$2.quickSetter(p, t, r);
          }),
          o = s.length;
        return function (p) {
          for (var N = o; N--; ) s[N](p);
        };
      }
      e = e[0] || {};
      var a = _plugins[t],
        l = _getCache(e),
        c = (l.harness && (l.harness.aliases || {})[t]) || t,
        u = a
          ? function (p) {
              var N = new a();
              (_quickTween._pt = 0),
                N.init(e, r ? p + r : p, _quickTween, 0, [e]),
                N.render(1, N),
                _quickTween._pt && _renderPropTweens(1, _quickTween);
            }
          : l.set(e, c);
      return a
        ? u
        : function (p) {
            return u(e, c, r ? p + r : p, l, 1);
          };
    },
    quickTo: function (e, t, r) {
      var s,
        o = gsap$2.to(
          e,
          _setDefaults$1(
            ((s = {}), (s[t] = "+=0.1"), (s.paused = !0), (s.stagger = 0), s),
            r || {}
          )
        ),
        a = function (c, u, p) {
          return o.resetTo(t, c, u, p);
        };
      return (a.tween = o), a;
    },
    isTweening: function (e) {
      return _globalTimeline.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return (
        e && e.ease && (e.ease = _parseEase(e.ease, _defaults$1.ease)),
        _mergeDeep(_defaults$1, e || {})
      );
    },
    config: function (e) {
      return _mergeDeep(_config, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        r = e.effect,
        s = e.plugins,
        o = e.defaults,
        a = e.extendTimeline;
      (s || "").split(",").forEach(function (l) {
        return (
          l &&
          !_plugins[l] &&
          !_globals[l] &&
          _warn(t + " effect requires " + l + " plugin.")
        );
      }),
        (_effects[t] = function (l, c, u) {
          return r(toArray(l), _setDefaults$1(c || {}, o), u);
        }),
        a &&
          (Timeline.prototype[t] = function (l, c, u) {
            return this.add(
              _effects[t](l, _isObject$1(c) ? c : (u = c) && {}, this),
              u
            );
          });
    },
    registerEase: function (e, t) {
      _easeMap[e] = _parseEase(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? _parseEase(e, t) : _easeMap;
    },
    getById: function (e) {
      return _globalTimeline.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var r = new Timeline(e),
        s,
        o;
      for (
        r.smoothChildTiming = _isNotFalse(e.smoothChildTiming),
          _globalTimeline.remove(r),
          r._dp = 0,
          r._time = r._tTime = _globalTimeline._time,
          s = _globalTimeline._first;
        s;

      )
        (o = s._next),
          (t ||
            !(
              !s._dur &&
              s instanceof Tween &&
              s.vars.onComplete === s._targets[0]
            )) &&
            _addToTimeline(r, s, s._start - s._delay),
          (s = o);
      return _addToTimeline(_globalTimeline, r, 0), r;
    },
    context: function (e, t) {
      return e ? new Context(e, t) : _context$2;
    },
    matchMedia: function (e) {
      return new MatchMedia(e);
    },
    matchMediaRefresh: function () {
      return (
        _media.forEach(function (e) {
          var t = e.conditions,
            r,
            s;
          for (s in t) t[s] && ((t[s] = !1), (r = 1));
          r && e.revert();
        }) || _onMediaChange()
      );
    },
    addEventListener: function (e, t) {
      var r = _listeners$1[e] || (_listeners$1[e] = []);
      ~r.indexOf(t) || r.push(t);
    },
    removeEventListener: function (e, t) {
      var r = _listeners$1[e],
        s = r && r.indexOf(t);
      s >= 0 && r.splice(s, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle,
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function () {
        return _reverting$1;
      },
      context: function (e) {
        return (
          e && _context$2 && (_context$2.data.push(e), (e._ctx = _context$2)),
          _context$2
        );
      },
      suppressOverwrites: function (e) {
        return (_suppressOverwrites$1 = e);
      },
    },
  };
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
  return (_gsap[n] = Tween[n]);
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, { duration: 0 });
var _getPluginPropTween = function (e, t) {
    for (var r = e._pt; r && r.p !== t && r.op !== t && r.fp !== t; )
      r = r._next;
    return r;
  },
  _addModifiers = function (e, t) {
    var r = e._targets,
      s,
      o,
      a;
    for (s in t)
      for (o = r.length; o--; )
        (a = e._ptLookup[o][s]),
          a &&
            (a = a.d) &&
            (a._pt && (a = _getPluginPropTween(a, s)),
            a && a.modifier && a.modifier(t[s], e, r[o], s));
  },
  _buildModifierPlugin = function (e, t) {
    return {
      name: e,
      headless: 1,
      rawVars: 1,
      init: function (s, o, a) {
        a._onInit = function (l) {
          var c, u;
          if (
            (_isString$1(o) &&
              ((c = {}),
              _forEachName(o, function (p) {
                return (c[p] = 1);
              }),
              (o = c)),
            t)
          ) {
            c = {};
            for (u in o) c[u] = t(o[u]);
            o = c;
          }
          _addModifiers(l, o);
        };
      },
    };
  },
  gsap$2 =
    _gsap.registerPlugin(
      {
        name: "attr",
        init: function (e, t, r, s, o) {
          var a, l, c;
          this.tween = r;
          for (a in t)
            (c = e.getAttribute(a) || ""),
              (l = this.add(
                e,
                "setAttribute",
                (c || 0) + "",
                t[a],
                s,
                o,
                0,
                0,
                a
              )),
              (l.op = a),
              (l.b = c),
              this._props.push(a);
        },
        render: function (e, t) {
          for (var r = t._pt; r; )
            _reverting$1 ? r.set(r.t, r.p, r.b, r) : r.r(e, r.d), (r = r._next);
        },
      },
      {
        name: "endArray",
        headless: 1,
        init: function (e, t) {
          for (var r = t.length; r--; )
            this.add(e, r, e[r] || 0, t[r], 0, 0, 0, 0, 0, 1);
        },
      },
      _buildModifierPlugin("roundProps", _roundModifier),
      _buildModifierPlugin("modifiers"),
      _buildModifierPlugin("snap", snap)
    ) || _gsap;
Tween.version = Timeline.version = gsap$2.version = "3.13.0";
_coreReady = 1;
_windowExists$2() && _wake();
_easeMap.Power0;
_easeMap.Power1;
_easeMap.Power2;
_easeMap.Power3;
_easeMap.Power4;
_easeMap.Linear;
_easeMap.Quad;
_easeMap.Cubic;
_easeMap.Quart;
_easeMap.Quint;
_easeMap.Strong;
_easeMap.Elastic;
_easeMap.Back;
_easeMap.SteppedEase;
_easeMap.Bounce;
_easeMap.Sine;
_easeMap.Expo;
_easeMap.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var _win$2,
  _doc$2,
  _docElement,
  _pluginInitted,
  _tempDiv,
  _recentSetterPlugin,
  _reverting,
  _windowExists$1 = function () {
    return typeof window < "u";
  },
  _transformProps = {},
  _RAD2DEG = 180 / Math.PI,
  _DEG2RAD = Math.PI / 180,
  _atan2 = Math.atan2,
  _bigNum = 1e8,
  _capsExp$1 = /([A-Z])/g,
  _horizontalExp = /(left|right|width|margin|padding|x)/i,
  _complexExp = /[\s,\(]\S/,
  _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  _renderCSSProp = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  _renderPropWithEnd = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  _renderCSSPropWithBeginning = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  _renderRoundedCSSProp = function (e, t) {
    var r = t.s + t.c * e;
    t.set(t.t, t.p, ~~(r + (r < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  _renderNonTweeningValue = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  _renderNonTweeningValueOnlyAtEnd = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  _setterCSSStyle = function (e, t, r) {
    return (e.style[t] = r);
  },
  _setterCSSProp = function (e, t, r) {
    return e.style.setProperty(t, r);
  },
  _setterTransform = function (e, t, r) {
    return (e._gsap[t] = r);
  },
  _setterScale = function (e, t, r) {
    return (e._gsap.scaleX = e._gsap.scaleY = r);
  },
  _setterScaleWithRender = function (e, t, r, s, o) {
    var a = e._gsap;
    (a.scaleX = a.scaleY = r), a.renderTransform(o, a);
  },
  _setterTransformWithRender = function (e, t, r, s, o) {
    var a = e._gsap;
    (a[t] = r), a.renderTransform(o, a);
  },
  _transformProp$1 = "transform",
  _transformOriginProp = _transformProp$1 + "Origin",
  _saveStyle = function n(e, t) {
    var r = this,
      s = this.target,
      o = s.style,
      a = s._gsap;
    if (e in _transformProps && o) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = _propertyAliases[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (l) {
                return (r.tfm[l] = _get(s, l));
              })
            : (this.tfm[e] = a.x ? a[e] : _get(s, e)),
          e === _transformOriginProp && (this.tfm.zOrigin = a.zOrigin);
      else
        return _propertyAliases.transform.split(",").forEach(function (l) {
          return n.call(r, l, t);
        });
      if (this.props.indexOf(_transformProp$1) >= 0) return;
      a.svg &&
        ((this.svgo = s.getAttribute("data-svg-origin")),
        this.props.push(_transformOriginProp, t, "")),
        (e = _transformProp$1);
    }
    (o || t) && this.props.push(e, t, o[e]);
  },
  _removeIndependentTransforms = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  _revertStyle = function () {
    var e = this.props,
      t = this.target,
      r = t.style,
      s = t._gsap,
      o,
      a;
    for (o = 0; o < e.length; o += 3)
      e[o + 1]
        ? e[o + 1] === 2
          ? t[e[o]](e[o + 2])
          : (t[e[o]] = e[o + 2])
        : e[o + 2]
        ? (r[e[o]] = e[o + 2])
        : r.removeProperty(
            e[o].substr(0, 2) === "--"
              ? e[o]
              : e[o].replace(_capsExp$1, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (a in this.tfm) s[a] = this.tfm[a];
      s.svg &&
        (s.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (o = _reverting()),
        (!o || !o.isStart) &&
          !r[_transformProp$1] &&
          (_removeIndependentTransforms(r),
          s.zOrigin &&
            r[_transformOriginProp] &&
            ((r[_transformOriginProp] += " " + s.zOrigin + "px"),
            (s.zOrigin = 0),
            s.renderTransform()),
          (s.uncache = 1));
    }
  },
  _getStyleSaver = function (e, t) {
    var r = { target: e, props: [], revert: _revertStyle, save: _saveStyle };
    return (
      e._gsap || gsap$2.core.getCache(e),
      t &&
        e.style &&
        e.nodeType &&
        t.split(",").forEach(function (s) {
          return r.save(s);
        }),
      r
    );
  },
  _supports3D,
  _createElement = function (e, t) {
    var r = _doc$2.createElementNS
      ? _doc$2.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : _doc$2.createElement(e);
    return r && r.style ? r : _doc$2.createElement(e);
  },
  _getComputedProperty = function n(e, t, r) {
    var s = getComputedStyle(e);
    return (
      s[t] ||
      s.getPropertyValue(t.replace(_capsExp$1, "-$1").toLowerCase()) ||
      s.getPropertyValue(t) ||
      (!r && n(e, _checkPropPrefix(t) || t, 1)) ||
      ""
    );
  },
  _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
  _checkPropPrefix = function (e, t, r) {
    var s = t || _tempDiv,
      o = s.style,
      a = 5;
    if (e in o && !r) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      a-- && !(_prefixes[a] + e in o);

    );
    return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? _prefixes[a] : "") + e;
  },
  _initCore$1 = function () {
    _windowExists$1() &&
      window.document &&
      ((_win$2 = window),
      (_doc$2 = _win$2.document),
      (_docElement = _doc$2.documentElement),
      (_tempDiv = _createElement("div") || { style: {} }),
      _createElement("div"),
      (_transformProp$1 = _checkPropPrefix(_transformProp$1)),
      (_transformOriginProp = _transformProp$1 + "Origin"),
      (_tempDiv.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (_supports3D = !!_checkPropPrefix("perspective")),
      (_reverting = gsap$2.core.reverting),
      (_pluginInitted = 1));
  },
  _getReparentedCloneBBox = function (e) {
    var t = e.ownerSVGElement,
      r = _createElement(
        "svg",
        (t && t.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"
      ),
      s = e.cloneNode(!0),
      o;
    (s.style.display = "block"), r.appendChild(s), _docElement.appendChild(r);
    try {
      o = s.getBBox();
    } catch {}
    return r.removeChild(s), _docElement.removeChild(r), o;
  },
  _getAttributeFallbacks = function (e, t) {
    for (var r = t.length; r--; )
      if (e.hasAttribute(t[r])) return e.getAttribute(t[r]);
  },
  _getBBox = function (e) {
    var t, r;
    try {
      t = e.getBBox();
    } catch {
      (t = _getReparentedCloneBBox(e)), (r = 1);
    }
    return (
      (t && (t.width || t.height)) || r || (t = _getReparentedCloneBBox(e)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +_getAttributeFallbacks(e, ["x", "cx", "x1"]) || 0,
            y: +_getAttributeFallbacks(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  _isSVG = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
  _removeProperty = function (e, t) {
    if (t) {
      var r = e.style,
        s;
      t in _transformProps &&
        t !== _transformOriginProp &&
        (t = _transformProp$1),
        r.removeProperty
          ? ((s = t.substr(0, 2)),
            (s === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
            r.removeProperty(
              s === "--" ? t : t.replace(_capsExp$1, "-$1").toLowerCase()
            ))
          : r.removeAttribute(t);
    }
  },
  _addNonTweeningPT = function (e, t, r, s, o, a) {
    var l = new PropTween(
      e._pt,
      t,
      r,
      0,
      1,
      a ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue
    );
    return (e._pt = l), (l.b = s), (l.e = o), e._props.push(r), l;
  },
  _nonConvertibleUnits = { deg: 1, rad: 1, turn: 1 },
  _nonStandardLayouts = { grid: 1, flex: 1 },
  _convertToUnit = function n(e, t, r, s) {
    var o = parseFloat(r) || 0,
      a = (r + "").trim().substr((o + "").length) || "px",
      l = _tempDiv.style,
      c = _horizontalExp.test(t),
      u = e.tagName.toLowerCase() === "svg",
      p = (u ? "client" : "offset") + (c ? "Width" : "Height"),
      N = 100,
      P = s === "px",
      de = s === "%",
      me,
      Ye,
      nt,
      Be;
    if (s === a || !o || _nonConvertibleUnits[s] || _nonConvertibleUnits[a])
      return o;
    if (
      (a !== "px" && !P && (o = n(e, t, r, "px")),
      (Be = e.getCTM && _isSVG(e)),
      (de || a === "%") && (_transformProps[t] || ~t.indexOf("adius")))
    )
      return (
        (me = Be ? e.getBBox()[c ? "width" : "height"] : e[p]),
        _round$1(de ? (o / me) * N : (o / 100) * me)
      );
    if (
      ((l[c ? "width" : "height"] = N + (P ? a : s)),
      (Ye =
        (s !== "rem" && ~t.indexOf("adius")) ||
        (s === "em" && e.appendChild && !u)
          ? e
          : e.parentNode),
      Be && (Ye = (e.ownerSVGElement || {}).parentNode),
      (!Ye || Ye === _doc$2 || !Ye.appendChild) && (Ye = _doc$2.body),
      (nt = Ye._gsap),
      nt && de && nt.width && c && nt.time === _ticker.time && !nt.uncache)
    )
      return _round$1((o / nt.width) * N);
    if (de && (t === "height" || t === "width")) {
      var ot = e.style[t];
      (e.style[t] = N + s),
        (me = e[p]),
        ot ? (e.style[t] = ot) : _removeProperty(e, t);
    } else
      (de || a === "%") &&
        !_nonStandardLayouts[_getComputedProperty(Ye, "display")] &&
        (l.position = _getComputedProperty(e, "position")),
        Ye === e && (l.position = "static"),
        Ye.appendChild(_tempDiv),
        (me = _tempDiv[p]),
        Ye.removeChild(_tempDiv),
        (l.position = "absolute");
    return (
      c &&
        de &&
        ((nt = _getCache(Ye)), (nt.time = _ticker.time), (nt.width = Ye[p])),
      _round$1(P ? (me * o) / N : me && o ? (N / me) * o : 0)
    );
  },
  _get = function (e, t, r, s) {
    var o;
    return (
      _pluginInitted || _initCore$1(),
      t in _propertyAliases &&
        t !== "transform" &&
        ((t = _propertyAliases[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      _transformProps[t] && t !== "transform"
        ? ((o = _parseTransform(e, s)),
          (o =
            t !== "transformOrigin"
              ? o[t]
              : o.svg
              ? o.origin
              : _firstTwoOnly(_getComputedProperty(e, _transformOriginProp)) +
                " " +
                o.zOrigin +
                "px"))
        : ((o = e.style[t]),
          (!o || o === "auto" || s || ~(o + "").indexOf("calc(")) &&
            (o =
              (_specialProps[t] && _specialProps[t](e, t, r)) ||
              _getComputedProperty(e, t) ||
              _getProperty(e, t) ||
              (t === "opacity" ? 1 : 0))),
      r && !~(o + "").trim().indexOf(" ") ? _convertToUnit(e, t, o, r) + r : o
    );
  },
  _tweenComplexCSSString = function (e, t, r, s) {
    if (!r || r === "none") {
      var o = _checkPropPrefix(t, e, 1),
        a = o && _getComputedProperty(e, o, 1);
      a && a !== r
        ? ((t = o), (r = a))
        : t === "borderColor" &&
          (r = _getComputedProperty(e, "borderTopColor"));
    }
    var l = new PropTween(this._pt, e.style, t, 0, 1, _renderComplexString),
      c = 0,
      u = 0,
      p,
      N,
      P,
      de,
      me,
      Ye,
      nt,
      Be,
      ot,
      st,
      vt,
      xt;
    if (
      ((l.b = r),
      (l.e = s),
      (r += ""),
      (s += ""),
      s.substring(0, 6) === "var(--" &&
        (s = _getComputedProperty(e, s.substring(4, s.indexOf(")")))),
      s === "auto" &&
        ((Ye = e.style[t]),
        (e.style[t] = s),
        (s = _getComputedProperty(e, t) || s),
        Ye ? (e.style[t] = Ye) : _removeProperty(e, t)),
      (p = [r, s]),
      _colorStringFilter(p),
      (r = p[0]),
      (s = p[1]),
      (P = r.match(_numWithUnitExp) || []),
      (xt = s.match(_numWithUnitExp) || []),
      xt.length)
    ) {
      for (; (N = _numWithUnitExp.exec(s)); )
        (nt = N[0]),
          (ot = s.substring(c, N.index)),
          me
            ? (me = (me + 1) % 5)
            : (ot.substr(-5) === "rgba(" || ot.substr(-5) === "hsla(") &&
              (me = 1),
          nt !== (Ye = P[u++] || "") &&
            ((de = parseFloat(Ye) || 0),
            (vt = Ye.substr((de + "").length)),
            nt.charAt(1) === "=" && (nt = _parseRelative(de, nt) + vt),
            (Be = parseFloat(nt)),
            (st = nt.substr((Be + "").length)),
            (c = _numWithUnitExp.lastIndex - st.length),
            st ||
              ((st = st || _config.units[t] || vt),
              c === s.length && ((s += st), (l.e += st))),
            vt !== st && (de = _convertToUnit(e, t, Ye, st) || 0),
            (l._pt = {
              _next: l._pt,
              p: ot || u === 1 ? ot : ",",
              s: de,
              c: Be - de,
              m: (me && me < 4) || t === "zIndex" ? Math.round : 0,
            }));
      l.c = c < s.length ? s.substring(c, s.length) : "";
    } else
      l.r =
        t === "display" && s === "none"
          ? _renderNonTweeningValueOnlyAtEnd
          : _renderNonTweeningValue;
    return _relExp.test(s) && (l.e = 0), (this._pt = l), l;
  },
  _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%",
  },
  _convertKeywordsToPercentages = function (e) {
    var t = e.split(" "),
      r = t[0],
      s = t[1] || "50%";
    return (
      (r === "top" || r === "bottom" || s === "left" || s === "right") &&
        ((e = r), (r = s), (s = e)),
      (t[0] = _keywordToPercent[r] || r),
      (t[1] = _keywordToPercent[s] || s),
      t.join(" ")
    );
  },
  _renderClearProps = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var r = t.t,
        s = r.style,
        o = t.u,
        a = r._gsap,
        l,
        c,
        u;
      if (o === "all" || o === !0) (s.cssText = ""), (c = 1);
      else
        for (o = o.split(","), u = o.length; --u > -1; )
          (l = o[u]),
            _transformProps[l] &&
              ((c = 1),
              (l =
                l === "transformOrigin"
                  ? _transformOriginProp
                  : _transformProp$1)),
            _removeProperty(r, l);
      c &&
        (_removeProperty(r, _transformProp$1),
        a &&
          (a.svg && r.removeAttribute("transform"),
          (s.scale = s.rotate = s.translate = "none"),
          _parseTransform(r, 1),
          (a.uncache = 1),
          _removeIndependentTransforms(s)));
    }
  },
  _specialProps = {
    clearProps: function (e, t, r, s, o) {
      if (o.data !== "isFromStart") {
        var a = (e._pt = new PropTween(e._pt, t, r, 0, 0, _renderClearProps));
        return (a.u = s), (a.pr = -10), (a.tween = o), e._props.push(r), 1;
      }
    },
  },
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
  _rotationalProperties = {},
  _isNullTransform = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  _getComputedTransformMatrixAsArray = function (e) {
    var t = _getComputedProperty(e, _transformProp$1);
    return _isNullTransform(t)
      ? _identity2DMatrix
      : t.substr(7).match(_numExp).map(_round$1);
  },
  _getMatrix = function (e, t) {
    var r = e._gsap || _getCache(e),
      s = e.style,
      o = _getComputedTransformMatrixAsArray(e),
      a,
      l,
      c,
      u;
    return r.svg && e.getAttribute("transform")
      ? ((c = e.transform.baseVal.consolidate().matrix),
        (o = [c.a, c.b, c.c, c.d, c.e, c.f]),
        o.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : o)
      : (o === _identity2DMatrix &&
          !e.offsetParent &&
          e !== _docElement &&
          !r.svg &&
          ((c = s.display),
          (s.display = "block"),
          (a = e.parentNode),
          (!a || (!e.offsetParent && !e.getBoundingClientRect().width)) &&
            ((u = 1), (l = e.nextElementSibling), _docElement.appendChild(e)),
          (o = _getComputedTransformMatrixAsArray(e)),
          c ? (s.display = c) : _removeProperty(e, "display"),
          u &&
            (l
              ? a.insertBefore(e, l)
              : a
              ? a.appendChild(e)
              : _docElement.removeChild(e))),
        t && o.length > 6 ? [o[0], o[1], o[4], o[5], o[12], o[13]] : o);
  },
  _applySVGOrigin = function (e, t, r, s, o, a) {
    var l = e._gsap,
      c = o || _getMatrix(e, !0),
      u = l.xOrigin || 0,
      p = l.yOrigin || 0,
      N = l.xOffset || 0,
      P = l.yOffset || 0,
      de = c[0],
      me = c[1],
      Ye = c[2],
      nt = c[3],
      Be = c[4],
      ot = c[5],
      st = t.split(" "),
      vt = parseFloat(st[0]) || 0,
      xt = parseFloat(st[1]) || 0,
      St,
      wt,
      bt,
      Tt;
    r
      ? c !== _identity2DMatrix &&
        (wt = de * nt - me * Ye) &&
        ((bt = vt * (nt / wt) + xt * (-Ye / wt) + (Ye * ot - nt * Be) / wt),
        (Tt = vt * (-me / wt) + xt * (de / wt) - (de * ot - me * Be) / wt),
        (vt = bt),
        (xt = Tt))
      : ((St = _getBBox(e)),
        (vt = St.x + (~st[0].indexOf("%") ? (vt / 100) * St.width : vt)),
        (xt =
          St.y +
          (~(st[1] || st[0]).indexOf("%") ? (xt / 100) * St.height : xt))),
      s || (s !== !1 && l.smooth)
        ? ((Be = vt - u),
          (ot = xt - p),
          (l.xOffset = N + (Be * de + ot * Ye) - Be),
          (l.yOffset = P + (Be * me + ot * nt) - ot))
        : (l.xOffset = l.yOffset = 0),
      (l.xOrigin = vt),
      (l.yOrigin = xt),
      (l.smooth = !!s),
      (l.origin = t),
      (l.originIsAbsolute = !!r),
      (e.style[_transformOriginProp] = "0px 0px"),
      a &&
        (_addNonTweeningPT(a, l, "xOrigin", u, vt),
        _addNonTweeningPT(a, l, "yOrigin", p, xt),
        _addNonTweeningPT(a, l, "xOffset", N, l.xOffset),
        _addNonTweeningPT(a, l, "yOffset", P, l.yOffset)),
      e.setAttribute("data-svg-origin", vt + " " + xt);
  },
  _parseTransform = function (e, t) {
    var r = e._gsap || new GSCache(e);
    if ("x" in r && !t && !r.uncache) return r;
    var s = e.style,
      o = r.scaleX < 0,
      a = "px",
      l = "deg",
      c = getComputedStyle(e),
      u = _getComputedProperty(e, _transformOriginProp) || "0",
      p,
      N,
      P,
      de,
      me,
      Ye,
      nt,
      Be,
      ot,
      st,
      vt,
      xt,
      St,
      wt,
      bt,
      Tt,
      Ct,
      kt,
      Dt,
      Vt,
      Ht,
      qt,
      Ft,
      Bt,
      Mt,
      Pt,
      It,
      Ot,
      Xt,
      sn,
      Kt,
      tn;
    return (
      (p = N = P = Ye = nt = Be = ot = st = vt = 0),
      (de = me = 1),
      (r.svg = !!(e.getCTM && _isSVG(e))),
      c.translate &&
        ((c.translate !== "none" ||
          c.scale !== "none" ||
          c.rotate !== "none") &&
          (s[_transformProp$1] =
            (c.translate !== "none"
              ? "translate3d(" +
                (c.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (c.rotate !== "none" ? "rotate(" + c.rotate + ") " : "") +
            (c.scale !== "none"
              ? "scale(" + c.scale.split(" ").join(",") + ") "
              : "") +
            (c[_transformProp$1] !== "none" ? c[_transformProp$1] : "")),
        (s.scale = s.rotate = s.translate = "none")),
      (wt = _getMatrix(e, r.svg)),
      r.svg &&
        (r.uncache
          ? ((Mt = e.getBBox()),
            (u = r.xOrigin - Mt.x + "px " + (r.yOrigin - Mt.y) + "px"),
            (Bt = ""))
          : (Bt = !t && e.getAttribute("data-svg-origin")),
        _applySVGOrigin(
          e,
          Bt || u,
          !!Bt || r.originIsAbsolute,
          r.smooth !== !1,
          wt
        )),
      (xt = r.xOrigin || 0),
      (St = r.yOrigin || 0),
      wt !== _identity2DMatrix &&
        ((kt = wt[0]),
        (Dt = wt[1]),
        (Vt = wt[2]),
        (Ht = wt[3]),
        (p = qt = wt[4]),
        (N = Ft = wt[5]),
        wt.length === 6
          ? ((de = Math.sqrt(kt * kt + Dt * Dt)),
            (me = Math.sqrt(Ht * Ht + Vt * Vt)),
            (Ye = kt || Dt ? _atan2(Dt, kt) * _RAD2DEG : 0),
            (ot = Vt || Ht ? _atan2(Vt, Ht) * _RAD2DEG + Ye : 0),
            ot && (me *= Math.abs(Math.cos(ot * _DEG2RAD))),
            r.svg &&
              ((p -= xt - (xt * kt + St * Vt)),
              (N -= St - (xt * Dt + St * Ht))))
          : ((tn = wt[6]),
            (sn = wt[7]),
            (It = wt[8]),
            (Ot = wt[9]),
            (Xt = wt[10]),
            (Kt = wt[11]),
            (p = wt[12]),
            (N = wt[13]),
            (P = wt[14]),
            (bt = _atan2(tn, Xt)),
            (nt = bt * _RAD2DEG),
            bt &&
              ((Tt = Math.cos(-bt)),
              (Ct = Math.sin(-bt)),
              (Bt = qt * Tt + It * Ct),
              (Mt = Ft * Tt + Ot * Ct),
              (Pt = tn * Tt + Xt * Ct),
              (It = qt * -Ct + It * Tt),
              (Ot = Ft * -Ct + Ot * Tt),
              (Xt = tn * -Ct + Xt * Tt),
              (Kt = sn * -Ct + Kt * Tt),
              (qt = Bt),
              (Ft = Mt),
              (tn = Pt)),
            (bt = _atan2(-Vt, Xt)),
            (Be = bt * _RAD2DEG),
            bt &&
              ((Tt = Math.cos(-bt)),
              (Ct = Math.sin(-bt)),
              (Bt = kt * Tt - It * Ct),
              (Mt = Dt * Tt - Ot * Ct),
              (Pt = Vt * Tt - Xt * Ct),
              (Kt = Ht * Ct + Kt * Tt),
              (kt = Bt),
              (Dt = Mt),
              (Vt = Pt)),
            (bt = _atan2(Dt, kt)),
            (Ye = bt * _RAD2DEG),
            bt &&
              ((Tt = Math.cos(bt)),
              (Ct = Math.sin(bt)),
              (Bt = kt * Tt + Dt * Ct),
              (Mt = qt * Tt + Ft * Ct),
              (Dt = Dt * Tt - kt * Ct),
              (Ft = Ft * Tt - qt * Ct),
              (kt = Bt),
              (qt = Mt)),
            nt &&
              Math.abs(nt) + Math.abs(Ye) > 359.9 &&
              ((nt = Ye = 0), (Be = 180 - Be)),
            (de = _round$1(Math.sqrt(kt * kt + Dt * Dt + Vt * Vt))),
            (me = _round$1(Math.sqrt(Ft * Ft + tn * tn))),
            (bt = _atan2(qt, Ft)),
            (ot = Math.abs(bt) > 2e-4 ? bt * _RAD2DEG : 0),
            (vt = Kt ? 1 / (Kt < 0 ? -Kt : Kt) : 0)),
        r.svg &&
          ((Bt = e.getAttribute("transform")),
          (r.forceCSS =
            e.setAttribute("transform", "") ||
            !_isNullTransform(_getComputedProperty(e, _transformProp$1))),
          Bt && e.setAttribute("transform", Bt))),
      Math.abs(ot) > 90 &&
        Math.abs(ot) < 270 &&
        (o
          ? ((de *= -1),
            (ot += Ye <= 0 ? 180 : -180),
            (Ye += Ye <= 0 ? 180 : -180))
          : ((me *= -1), (ot += ot <= 0 ? 180 : -180))),
      (t = t || r.uncache),
      (r.x =
        p -
        ((r.xPercent =
          p &&
          ((!t && r.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-p) ? -50 : 0)))
          ? (e.offsetWidth * r.xPercent) / 100
          : 0) +
        a),
      (r.y =
        N -
        ((r.yPercent =
          N &&
          ((!t && r.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-N) ? -50 : 0)))
          ? (e.offsetHeight * r.yPercent) / 100
          : 0) +
        a),
      (r.z = P + a),
      (r.scaleX = _round$1(de)),
      (r.scaleY = _round$1(me)),
      (r.rotation = _round$1(Ye) + l),
      (r.rotationX = _round$1(nt) + l),
      (r.rotationY = _round$1(Be) + l),
      (r.skewX = ot + l),
      (r.skewY = st + l),
      (r.transformPerspective = vt + a),
      (r.zOrigin = parseFloat(u.split(" ")[2]) || (!t && r.zOrigin) || 0) &&
        (s[_transformOriginProp] = _firstTwoOnly(u)),
      (r.xOffset = r.yOffset = 0),
      (r.force3D = _config.force3D),
      (r.renderTransform = r.svg
        ? _renderSVGTransforms
        : _supports3D
        ? _renderCSSTransforms
        : _renderNon3DTransforms),
      (r.uncache = 0),
      r
    );
  },
  _firstTwoOnly = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  _addPxTranslate = function (e, t, r) {
    var s = getUnit(t);
    return (
      _round$1(
        parseFloat(t) + parseFloat(_convertToUnit(e, "x", r + "px", s))
      ) + s
    );
  },
  _renderNon3DTransforms = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      _renderCSSTransforms(e, t);
  },
  _zeroDeg = "0deg",
  _zeroPx = "0px",
  _endParenthesis = ") ",
  _renderCSSTransforms = function (e, t) {
    var r = t || this,
      s = r.xPercent,
      o = r.yPercent,
      a = r.x,
      l = r.y,
      c = r.z,
      u = r.rotation,
      p = r.rotationY,
      N = r.rotationX,
      P = r.skewX,
      de = r.skewY,
      me = r.scaleX,
      Ye = r.scaleY,
      nt = r.transformPerspective,
      Be = r.force3D,
      ot = r.target,
      st = r.zOrigin,
      vt = "",
      xt = (Be === "auto" && e && e !== 1) || Be === !0;
    if (st && (N !== _zeroDeg || p !== _zeroDeg)) {
      var St = parseFloat(p) * _DEG2RAD,
        wt = Math.sin(St),
        bt = Math.cos(St),
        Tt;
      (St = parseFloat(N) * _DEG2RAD),
        (Tt = Math.cos(St)),
        (a = _addPxTranslate(ot, a, wt * Tt * -st)),
        (l = _addPxTranslate(ot, l, -Math.sin(St) * -st)),
        (c = _addPxTranslate(ot, c, bt * Tt * -st + st));
    }
    nt !== _zeroPx && (vt += "perspective(" + nt + _endParenthesis),
      (s || o) && (vt += "translate(" + s + "%, " + o + "%) "),
      (xt || a !== _zeroPx || l !== _zeroPx || c !== _zeroPx) &&
        (vt +=
          c !== _zeroPx || xt
            ? "translate3d(" + a + ", " + l + ", " + c + ") "
            : "translate(" + a + ", " + l + _endParenthesis),
      u !== _zeroDeg && (vt += "rotate(" + u + _endParenthesis),
      p !== _zeroDeg && (vt += "rotateY(" + p + _endParenthesis),
      N !== _zeroDeg && (vt += "rotateX(" + N + _endParenthesis),
      (P !== _zeroDeg || de !== _zeroDeg) &&
        (vt += "skew(" + P + ", " + de + _endParenthesis),
      (me !== 1 || Ye !== 1) &&
        (vt += "scale(" + me + ", " + Ye + _endParenthesis),
      (ot.style[_transformProp$1] = vt || "translate(0, 0)");
  },
  _renderSVGTransforms = function (e, t) {
    var r = t || this,
      s = r.xPercent,
      o = r.yPercent,
      a = r.x,
      l = r.y,
      c = r.rotation,
      u = r.skewX,
      p = r.skewY,
      N = r.scaleX,
      P = r.scaleY,
      de = r.target,
      me = r.xOrigin,
      Ye = r.yOrigin,
      nt = r.xOffset,
      Be = r.yOffset,
      ot = r.forceCSS,
      st = parseFloat(a),
      vt = parseFloat(l),
      xt,
      St,
      wt,
      bt,
      Tt;
    (c = parseFloat(c)),
      (u = parseFloat(u)),
      (p = parseFloat(p)),
      p && ((p = parseFloat(p)), (u += p), (c += p)),
      c || u
        ? ((c *= _DEG2RAD),
          (u *= _DEG2RAD),
          (xt = Math.cos(c) * N),
          (St = Math.sin(c) * N),
          (wt = Math.sin(c - u) * -P),
          (bt = Math.cos(c - u) * P),
          u &&
            ((p *= _DEG2RAD),
            (Tt = Math.tan(u - p)),
            (Tt = Math.sqrt(1 + Tt * Tt)),
            (wt *= Tt),
            (bt *= Tt),
            p &&
              ((Tt = Math.tan(p)),
              (Tt = Math.sqrt(1 + Tt * Tt)),
              (xt *= Tt),
              (St *= Tt))),
          (xt = _round$1(xt)),
          (St = _round$1(St)),
          (wt = _round$1(wt)),
          (bt = _round$1(bt)))
        : ((xt = N), (bt = P), (St = wt = 0)),
      ((st && !~(a + "").indexOf("px")) || (vt && !~(l + "").indexOf("px"))) &&
        ((st = _convertToUnit(de, "x", a, "px")),
        (vt = _convertToUnit(de, "y", l, "px"))),
      (me || Ye || nt || Be) &&
        ((st = _round$1(st + me - (me * xt + Ye * wt) + nt)),
        (vt = _round$1(vt + Ye - (me * St + Ye * bt) + Be))),
      (s || o) &&
        ((Tt = de.getBBox()),
        (st = _round$1(st + (s / 100) * Tt.width)),
        (vt = _round$1(vt + (o / 100) * Tt.height))),
      (Tt =
        "matrix(" +
        xt +
        "," +
        St +
        "," +
        wt +
        "," +
        bt +
        "," +
        st +
        "," +
        vt +
        ")"),
      de.setAttribute("transform", Tt),
      ot && (de.style[_transformProp$1] = Tt);
  },
  _addRotationalPropTween = function (e, t, r, s, o) {
    var a = 360,
      l = _isString$1(o),
      c = parseFloat(o) * (l && ~o.indexOf("rad") ? _RAD2DEG : 1),
      u = c - s,
      p = s + u + "deg",
      N,
      P;
    return (
      l &&
        ((N = o.split("_")[1]),
        N === "short" &&
          ((u %= a), u !== u % (a / 2) && (u += u < 0 ? a : -360)),
        N === "cw" && u < 0
          ? (u = ((u + a * _bigNum) % a) - ~~(u / a) * a)
          : N === "ccw" &&
            u > 0 &&
            (u = ((u - a * _bigNum) % a) - ~~(u / a) * a)),
      (e._pt = P = new PropTween(e._pt, t, r, s, u, _renderPropWithEnd)),
      (P.e = p),
      (P.u = "deg"),
      e._props.push(r),
      P
    );
  },
  _assign = function (e, t) {
    for (var r in t) e[r] = t[r];
    return e;
  },
  _addRawTransformPTs = function (e, t, r) {
    var s = _assign({}, r._gsap),
      o = "perspective,force3D,transformOrigin,svgOrigin",
      a = r.style,
      l,
      c,
      u,
      p,
      N,
      P,
      de,
      me;
    s.svg
      ? ((u = r.getAttribute("transform")),
        r.setAttribute("transform", ""),
        (a[_transformProp$1] = t),
        (l = _parseTransform(r, 1)),
        _removeProperty(r, _transformProp$1),
        r.setAttribute("transform", u))
      : ((u = getComputedStyle(r)[_transformProp$1]),
        (a[_transformProp$1] = t),
        (l = _parseTransform(r, 1)),
        (a[_transformProp$1] = u));
    for (c in _transformProps)
      (u = s[c]),
        (p = l[c]),
        u !== p &&
          o.indexOf(c) < 0 &&
          ((de = getUnit(u)),
          (me = getUnit(p)),
          (N = de !== me ? _convertToUnit(r, c, u, me) : parseFloat(u)),
          (P = parseFloat(p)),
          (e._pt = new PropTween(e._pt, l, c, N, P - N, _renderCSSProp)),
          (e._pt.u = me || 0),
          e._props.push(c));
    _assign(l, s);
  };
_forEachName("padding,margin,Width,Radius", function (n, e) {
  var t = "Top",
    r = "Right",
    s = "Bottom",
    o = "Left",
    a = (e < 3 ? [t, r, s, o] : [t + o, t + r, s + r, s + o]).map(function (l) {
      return e < 2 ? n + l : "border" + l + n;
    });
  _specialProps[e > 1 ? "border" + n : n] = function (l, c, u, p, N) {
    var P, de;
    if (arguments.length < 4)
      return (
        (P = a.map(function (me) {
          return _get(l, me, u);
        })),
        (de = P.join(" ")),
        de.split(P[0]).length === 5 ? P[0] : de
      );
    (P = (p + "").split(" ")),
      (de = {}),
      a.forEach(function (me, Ye) {
        return (de[me] = P[Ye] = P[Ye] || P[((Ye - 1) / 2) | 0]);
      }),
      l.init(c, de, N);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore$1,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, r, s, o) {
    var a = this._props,
      l = e.style,
      c = r.vars.startAt,
      u,
      p,
      N,
      P,
      de,
      me,
      Ye,
      nt,
      Be,
      ot,
      st,
      vt,
      xt,
      St,
      wt,
      bt;
    _pluginInitted || _initCore$1(),
      (this.styles = this.styles || _getStyleSaver(e)),
      (bt = this.styles.props),
      (this.tween = r);
    for (Ye in t)
      if (
        Ye !== "autoRound" &&
        ((p = t[Ye]), !(_plugins[Ye] && _checkPlugin(Ye, t, r, s, e, o)))
      ) {
        if (
          ((de = typeof p),
          (me = _specialProps[Ye]),
          de === "function" && ((p = p.call(r, s, e, o)), (de = typeof p)),
          de === "string" && ~p.indexOf("random(") && (p = _replaceRandom(p)),
          me)
        )
          me(this, e, Ye, p, r) && (wt = 1);
        else if (Ye.substr(0, 2) === "--")
          (u = (getComputedStyle(e).getPropertyValue(Ye) + "").trim()),
            (p += ""),
            (_colorExp.lastIndex = 0),
            _colorExp.test(u) || ((nt = getUnit(u)), (Be = getUnit(p))),
            Be
              ? nt !== Be && (u = _convertToUnit(e, Ye, u, Be) + Be)
              : nt && (p += nt),
            this.add(l, "setProperty", u, p, s, o, 0, 0, Ye),
            a.push(Ye),
            bt.push(Ye, 0, l[Ye]);
        else if (de !== "undefined") {
          if (
            (c && Ye in c
              ? ((u =
                  typeof c[Ye] == "function" ? c[Ye].call(r, s, e, o) : c[Ye]),
                _isString$1(u) &&
                  ~u.indexOf("random(") &&
                  (u = _replaceRandom(u)),
                getUnit(u + "") ||
                  u === "auto" ||
                  (u += _config.units[Ye] || getUnit(_get(e, Ye)) || ""),
                (u + "").charAt(1) === "=" && (u = _get(e, Ye)))
              : (u = _get(e, Ye)),
            (P = parseFloat(u)),
            (ot = de === "string" && p.charAt(1) === "=" && p.substr(0, 2)),
            ot && (p = p.substr(2)),
            (N = parseFloat(p)),
            Ye in _propertyAliases &&
              (Ye === "autoAlpha" &&
                (P === 1 && _get(e, "visibility") === "hidden" && N && (P = 0),
                bt.push("visibility", 0, l.visibility),
                _addNonTweeningPT(
                  this,
                  l,
                  "visibility",
                  P ? "inherit" : "hidden",
                  N ? "inherit" : "hidden",
                  !N
                )),
              Ye !== "scale" &&
                Ye !== "transform" &&
                ((Ye = _propertyAliases[Ye]),
                ~Ye.indexOf(",") && (Ye = Ye.split(",")[0]))),
            (st = Ye in _transformProps),
            st)
          ) {
            if (
              (this.styles.save(Ye),
              de === "string" &&
                p.substring(0, 6) === "var(--" &&
                ((p = _getComputedProperty(e, p.substring(4, p.indexOf(")")))),
                (N = parseFloat(p))),
              vt ||
                ((xt = e._gsap),
                (xt.renderTransform && !t.parseTransform) ||
                  _parseTransform(e, t.parseTransform),
                (St = t.smoothOrigin !== !1 && xt.smooth),
                (vt = this._pt =
                  new PropTween(
                    this._pt,
                    l,
                    _transformProp$1,
                    0,
                    1,
                    xt.renderTransform,
                    xt,
                    0,
                    -1
                  )),
                (vt.dep = 1)),
              Ye === "scale")
            )
              (this._pt = new PropTween(
                this._pt,
                xt,
                "scaleY",
                xt.scaleY,
                (ot ? _parseRelative(xt.scaleY, ot + N) : N) - xt.scaleY || 0,
                _renderCSSProp
              )),
                (this._pt.u = 0),
                a.push("scaleY", Ye),
                (Ye += "X");
            else if (Ye === "transformOrigin") {
              bt.push(_transformOriginProp, 0, l[_transformOriginProp]),
                (p = _convertKeywordsToPercentages(p)),
                xt.svg
                  ? _applySVGOrigin(e, p, 0, St, 0, this)
                  : ((Be = parseFloat(p.split(" ")[2]) || 0),
                    Be !== xt.zOrigin &&
                      _addNonTweeningPT(this, xt, "zOrigin", xt.zOrigin, Be),
                    _addNonTweeningPT(
                      this,
                      l,
                      Ye,
                      _firstTwoOnly(u),
                      _firstTwoOnly(p)
                    ));
              continue;
            } else if (Ye === "svgOrigin") {
              _applySVGOrigin(e, p, 1, St, 0, this);
              continue;
            } else if (Ye in _rotationalProperties) {
              _addRotationalPropTween(
                this,
                xt,
                Ye,
                P,
                ot ? _parseRelative(P, ot + p) : p
              );
              continue;
            } else if (Ye === "smoothOrigin") {
              _addNonTweeningPT(this, xt, "smooth", xt.smooth, p);
              continue;
            } else if (Ye === "force3D") {
              xt[Ye] = p;
              continue;
            } else if (Ye === "transform") {
              _addRawTransformPTs(this, p, e);
              continue;
            }
          } else Ye in l || (Ye = _checkPropPrefix(Ye) || Ye);
          if (
            st ||
            ((N || N === 0) &&
              (P || P === 0) &&
              !_complexExp.test(p) &&
              Ye in l)
          )
            (nt = (u + "").substr((P + "").length)),
              N || (N = 0),
              (Be =
                getUnit(p) || (Ye in _config.units ? _config.units[Ye] : nt)),
              nt !== Be && (P = _convertToUnit(e, Ye, u, Be)),
              (this._pt = new PropTween(
                this._pt,
                st ? xt : l,
                Ye,
                P,
                (ot ? _parseRelative(P, ot + N) : N) - P,
                !st && (Be === "px" || Ye === "zIndex") && t.autoRound !== !1
                  ? _renderRoundedCSSProp
                  : _renderCSSProp
              )),
              (this._pt.u = Be || 0),
              nt !== Be &&
                Be !== "%" &&
                ((this._pt.b = u), (this._pt.r = _renderCSSPropWithBeginning));
          else if (Ye in l)
            _tweenComplexCSSString.call(this, e, Ye, u, ot ? ot + p : p);
          else if (Ye in e) this.add(e, Ye, u || e[Ye], ot ? ot + p : p, s, o);
          else if (Ye !== "parseTransform") {
            _missingPlugin(Ye, p);
            continue;
          }
          st ||
            (Ye in l
              ? bt.push(Ye, 0, l[Ye])
              : typeof e[Ye] == "function"
              ? bt.push(Ye, 2, e[Ye]())
              : bt.push(Ye, 1, u || e[Ye])),
            a.push(Ye);
        }
      }
    wt && _sortPropTweensByPriority(this);
  },
  render: function (e, t) {
    if (t.tween._time || !_reverting())
      for (var r = t._pt; r; ) r.r(e, r.d), (r = r._next);
    else t.styles.revert();
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function (e, t, r) {
    var s = _propertyAliases[t];
    return (
      s && s.indexOf(",") < 0 && (t = s),
      t in _transformProps &&
      t !== _transformOriginProp &&
      (e._gsap.x || _get(e, "x"))
        ? r && _recentSetterPlugin === r
          ? t === "scale"
            ? _setterScale
            : _setterTransform
          : (_recentSetterPlugin = r || {}) &&
            (t === "scale"
              ? _setterScaleWithRender
              : _setterTransformWithRender)
        : e.style && !_isUndefined(e.style[t])
        ? _setterCSSStyle
        : ~t.indexOf("-")
        ? _setterCSSProp
        : _getSetter(e, t)
    );
  },
  core: { _removeProperty, _getMatrix },
};
gsap$2.utils.checkPrefix = _checkPropPrefix;
gsap$2.core.getStyleSaver = _getStyleSaver;
(function (n, e, t, r) {
  var s = _forEachName(n + "," + e + "," + t, function (o) {
    _transformProps[o] = 1;
  });
  _forEachName(e, function (o) {
    (_config.units[o] = "deg"), (_rotationalProperties[o] = 1);
  }),
    (_propertyAliases[s[13]] = n + "," + e),
    _forEachName(r, function (o) {
      var a = o.split(":");
      _propertyAliases[a[1]] = s[a[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
_forEachName(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (n) {
    _config.units[n] = "px";
  }
);
gsap$2.registerPlugin(CSSPlugin);
var gsapWithCSS = gsap$2.registerPlugin(CSSPlugin) || gsap$2;
gsapWithCSS.core.Tween;
function _defineProperties(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r);
  }
}
function _createClass(n, e, t) {
  return e && _defineProperties(n.prototype, e), n;
}
/*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var gsap$1,
  _coreInitted$1,
  _win$1,
  _doc$1,
  _docEl$1,
  _body$1,
  _isTouch,
  _pointerType,
  ScrollTrigger$1,
  _root$1,
  _normalizer$1,
  _eventTypes,
  _context$1,
  _getGSAP$1 = function () {
    return (
      gsap$1 ||
      (typeof window < "u" &&
        (gsap$1 = window.gsap) &&
        gsap$1.registerPlugin &&
        gsap$1)
    );
  },
  _startup$1 = 1,
  _observers = [],
  _scrollers = [],
  _proxies = [],
  _getTime$1 = Date.now,
  _bridge = function (e, t) {
    return t;
  },
  _integrate = function () {
    var e = ScrollTrigger$1.core,
      t = e.bridge || {},
      r = e._scrollers,
      s = e._proxies;
    r.push.apply(r, _scrollers),
      s.push.apply(s, _proxies),
      (_scrollers = r),
      (_proxies = s),
      (_bridge = function (a, l) {
        return t[a](l);
      });
  },
  _getProxyProp = function (e, t) {
    return ~_proxies.indexOf(e) && _proxies[_proxies.indexOf(e) + 1][t];
  },
  _isViewport$1 = function (e) {
    return !!~_root$1.indexOf(e);
  },
  _addListener$1 = function (e, t, r, s, o) {
    return e.addEventListener(t, r, { passive: s !== !1, capture: !!o });
  },
  _removeListener$1 = function (e, t, r, s) {
    return e.removeEventListener(t, r, !!s);
  },
  _scrollLeft = "scrollLeft",
  _scrollTop = "scrollTop",
  _onScroll$1 = function () {
    return (_normalizer$1 && _normalizer$1.isPressed) || _scrollers.cache++;
  },
  _scrollCacheFunc = function (e, t) {
    var r = function s(o) {
      if (o || o === 0) {
        _startup$1 && (_win$1.history.scrollRestoration = "manual");
        var a = _normalizer$1 && _normalizer$1.isPressed;
        (o = s.v =
          Math.round(o) || (_normalizer$1 && _normalizer$1.iOS ? 1 : 0)),
          e(o),
          (s.cacheID = _scrollers.cache),
          a && _bridge("ss", o);
      } else
        (t || _scrollers.cache !== s.cacheID || _bridge("ref")) &&
          ((s.cacheID = _scrollers.cache), (s.v = e()));
      return s.v + s.offset;
    };
    return (r.offset = 0), e && r;
  },
  _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function (n) {
      return arguments.length
        ? _win$1.scrollTo(n, _vertical.sc())
        : _win$1.pageXOffset ||
            _doc$1[_scrollLeft] ||
            _docEl$1[_scrollLeft] ||
            _body$1[_scrollLeft] ||
            0;
    }),
  },
  _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function (n) {
      return arguments.length
        ? _win$1.scrollTo(_horizontal.sc(), n)
        : _win$1.pageYOffset ||
            _doc$1[_scrollTop] ||
            _docEl$1[_scrollTop] ||
            _body$1[_scrollTop] ||
            0;
    }),
  },
  _getTarget = function (e, t) {
    return (
      ((t && t._ctx && t._ctx.selector) || gsap$1.utils.toArray)(e)[0] ||
      (typeof e == "string" && gsap$1.config().nullTargetWarn !== !1
        ? console.warn("Element not found:", e)
        : null)
    );
  },
  _isWithin = function (e, t) {
    for (var r = t.length; r--; ) if (t[r] === e || t[r].contains(e)) return !0;
    return !1;
  },
  _getScrollFunc = function (e, t) {
    var r = t.s,
      s = t.sc;
    _isViewport$1(e) && (e = _doc$1.scrollingElement || _docEl$1);
    var o = _scrollers.indexOf(e),
      a = s === _vertical.sc ? 1 : 2;
    !~o && (o = _scrollers.push(e) - 1),
      _scrollers[o + a] || _addListener$1(e, "scroll", _onScroll$1);
    var l = _scrollers[o + a],
      c =
        l ||
        (_scrollers[o + a] =
          _scrollCacheFunc(_getProxyProp(e, r), !0) ||
          (_isViewport$1(e)
            ? s
            : _scrollCacheFunc(function (u) {
                return arguments.length ? (e[r] = u) : e[r];
              })));
    return (
      (c.target = e),
      l || (c.smooth = gsap$1.getProperty(e, "scrollBehavior") === "smooth"),
      c
    );
  },
  _getVelocityProp = function (e, t, r) {
    var s = e,
      o = e,
      a = _getTime$1(),
      l = a,
      c = t || 50,
      u = Math.max(500, c * 3),
      p = function (me, Ye) {
        var nt = _getTime$1();
        Ye || nt - a > c
          ? ((o = s), (s = me), (l = a), (a = nt))
          : r
          ? (s += me)
          : (s = o + ((me - o) / (nt - l)) * (a - l));
      },
      N = function () {
        (o = s = r ? 0 : s), (l = a = 0);
      },
      P = function (me) {
        var Ye = l,
          nt = o,
          Be = _getTime$1();
        return (
          (me || me === 0) && me !== s && p(me),
          a === l || Be - l > u
            ? 0
            : ((s + (r ? nt : -nt)) / ((r ? Be : a) - Ye)) * 1e3
        );
      };
    return { update: p, reset: N, getVelocity: P };
  },
  _getEvent = function (e, t) {
    return (
      t && !e._gsapAllow && e.preventDefault(),
      e.changedTouches ? e.changedTouches[0] : e
    );
  },
  _getAbsoluteMax = function (e) {
    var t = Math.max.apply(Math, e),
      r = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(r) ? t : r;
  },
  _setScrollTrigger = function () {
    (ScrollTrigger$1 = gsap$1.core.globals().ScrollTrigger),
      ScrollTrigger$1 && ScrollTrigger$1.core && _integrate();
  },
  _initCore = function (e) {
    return (
      (gsap$1 = e || _getGSAP$1()),
      !_coreInitted$1 &&
        gsap$1 &&
        typeof document < "u" &&
        document.body &&
        ((_win$1 = window),
        (_doc$1 = document),
        (_docEl$1 = _doc$1.documentElement),
        (_body$1 = _doc$1.body),
        (_root$1 = [_win$1, _doc$1, _docEl$1, _body$1]),
        gsap$1.utils.clamp,
        (_context$1 = gsap$1.core.context || function () {}),
        (_pointerType = "onpointerenter" in _body$1 ? "pointer" : "mouse"),
        (_isTouch = Observer.isTouch =
          _win$1.matchMedia &&
          _win$1.matchMedia("(hover: none), (pointer: coarse)").matches
            ? 1
            : "ontouchstart" in _win$1 ||
              navigator.maxTouchPoints > 0 ||
              navigator.msMaxTouchPoints > 0
            ? 2
            : 0),
        (_eventTypes = Observer.eventTypes =
          (
            "ontouchstart" in _docEl$1
              ? "touchstart,touchmove,touchcancel,touchend"
              : "onpointerdown" in _docEl$1
              ? "pointerdown,pointermove,pointercancel,pointerup"
              : "mousedown,mousemove,mouseup,mouseup"
          ).split(",")),
        setTimeout(function () {
          return (_startup$1 = 0);
        }, 500),
        _setScrollTrigger(),
        (_coreInitted$1 = 1)),
      _coreInitted$1
    );
  };
_horizontal.op = _vertical;
_scrollers.cache = 0;
var Observer = (function () {
  function n(t) {
    this.init(t);
  }
  var e = n.prototype;
  return (
    (e.init = function (r) {
      _coreInitted$1 ||
        _initCore(gsap$1) ||
        console.warn("Please gsap.registerPlugin(Observer)"),
        ScrollTrigger$1 || _setScrollTrigger();
      var s = r.tolerance,
        o = r.dragMinimum,
        a = r.type,
        l = r.target,
        c = r.lineHeight,
        u = r.debounce,
        p = r.preventDefault,
        N = r.onStop,
        P = r.onStopDelay,
        de = r.ignore,
        me = r.wheelSpeed,
        Ye = r.event,
        nt = r.onDragStart,
        Be = r.onDragEnd,
        ot = r.onDrag,
        st = r.onPress,
        vt = r.onRelease,
        xt = r.onRight,
        St = r.onLeft,
        wt = r.onUp,
        bt = r.onDown,
        Tt = r.onChangeX,
        Ct = r.onChangeY,
        kt = r.onChange,
        Dt = r.onToggleX,
        Vt = r.onToggleY,
        Ht = r.onHover,
        qt = r.onHoverEnd,
        Ft = r.onMove,
        Bt = r.ignoreCheck,
        Mt = r.isNormalizer,
        Pt = r.onGestureStart,
        It = r.onGestureEnd,
        Ot = r.onWheel,
        Xt = r.onEnable,
        sn = r.onDisable,
        Kt = r.onClick,
        tn = r.scrollSpeed,
        pn = r.capture,
        _n = r.allowClicks,
        bn = r.lockAxis,
        $n = r.onLockAxis;
      (this.target = l = _getTarget(l) || _docEl$1),
        (this.vars = r),
        de && (de = gsap$1.utils.toArray(de)),
        (s = s || 1e-9),
        (o = o || 0),
        (me = me || 1),
        (tn = tn || 1),
        (a = a || "wheel,touch,pointer"),
        (u = u !== !1),
        c ||
          (c = parseFloat(_win$1.getComputedStyle(_body$1).lineHeight) || 22);
      var tr,
        ur,
        _r,
        Bn,
        jt,
        Yn,
        zn,
        rn = this,
        In = 0,
        or = 0,
        Gn = r.passive || (!p && r.passive !== !1),
        Yt = _getScrollFunc(l, _horizontal),
        Gt = _getScrollFunc(l, _vertical),
        hn = Yt(),
        En = Gt(),
        Ln =
          ~a.indexOf("touch") &&
          !~a.indexOf("pointer") &&
          _eventTypes[0] === "pointerdown",
        mn = _isViewport$1(l),
        Vn = l.ownerDocument || _doc$1,
        Fn = [0, 0, 0],
        nr = [0, 0, 0],
        yr = 0,
        qn = function () {
          return (yr = _getTime$1());
        },
        jn = function (Rr, $r) {
          return (
            ((rn.event = Rr) && de && _isWithin(Rr.target, de)) ||
            ($r && Ln && Rr.pointerType !== "touch") ||
            (Bt && Bt(Rr, $r))
          );
        },
        Jn = function () {
          rn._vx.reset(), rn._vy.reset(), ur.pause(), N && N(rn);
        },
        mr = function () {
          var Rr = (rn.deltaX = _getAbsoluteMax(Fn)),
            $r = (rn.deltaY = _getAbsoluteMax(nr)),
            xr = Math.abs(Rr) >= s,
            Fr = Math.abs($r) >= s;
          kt && (xr || Fr) && kt(rn, Rr, $r, Fn, nr),
            xr &&
              (xt && rn.deltaX > 0 && xt(rn),
              St && rn.deltaX < 0 && St(rn),
              Tt && Tt(rn),
              Dt && rn.deltaX < 0 != In < 0 && Dt(rn),
              (In = rn.deltaX),
              (Fn[0] = Fn[1] = Fn[2] = 0)),
            Fr &&
              (bt && rn.deltaY > 0 && bt(rn),
              wt && rn.deltaY < 0 && wt(rn),
              Ct && Ct(rn),
              Vt && rn.deltaY < 0 != or < 0 && Vt(rn),
              (or = rn.deltaY),
              (nr[0] = nr[1] = nr[2] = 0)),
            (Bn || _r) &&
              (Ft && Ft(rn),
              _r && (nt && _r === 1 && nt(rn), ot && ot(rn), (_r = 0)),
              (Bn = !1)),
            Yn && !(Yn = !1) && $n && $n(rn),
            jt && (Ot(rn), (jt = !1)),
            (tr = 0);
        },
        Sr = function (Rr, $r, xr) {
          (Fn[xr] += Rr),
            (nr[xr] += $r),
            rn._vx.update(Rr),
            rn._vy.update($r),
            u ? tr || (tr = requestAnimationFrame(mr)) : mr();
        },
        Ur = function (Rr, $r) {
          bn &&
            !zn &&
            ((rn.axis = zn = Math.abs(Rr) > Math.abs($r) ? "x" : "y"),
            (Yn = !0)),
            zn !== "y" && ((Fn[2] += Rr), rn._vx.update(Rr, !0)),
            zn !== "x" && ((nr[2] += $r), rn._vy.update($r, !0)),
            u ? tr || (tr = requestAnimationFrame(mr)) : mr();
        },
        Pr = function (Rr) {
          if (!jn(Rr, 1)) {
            Rr = _getEvent(Rr, p);
            var $r = Rr.clientX,
              xr = Rr.clientY,
              Fr = $r - rn.x,
              Cr = xr - rn.y,
              zr = rn.isDragging;
            (rn.x = $r),
              (rn.y = xr),
              (zr ||
                ((Fr || Cr) &&
                  (Math.abs(rn.startX - $r) >= o ||
                    Math.abs(rn.startY - xr) >= o))) &&
                ((_r = zr ? 2 : 1), zr || (rn.isDragging = !0), Ur(Fr, Cr));
          }
        },
        Hr = (rn.onPress = function (wr) {
          jn(wr, 1) ||
            (wr && wr.button) ||
            ((rn.axis = zn = null),
            ur.pause(),
            (rn.isPressed = !0),
            (wr = _getEvent(wr)),
            (In = or = 0),
            (rn.startX = rn.x = wr.clientX),
            (rn.startY = rn.y = wr.clientY),
            rn._vx.reset(),
            rn._vy.reset(),
            _addListener$1(Mt ? l : Vn, _eventTypes[1], Pr, Gn, !0),
            (rn.deltaX = rn.deltaY = 0),
            st && st(rn));
        }),
        cn = (rn.onRelease = function (wr) {
          if (!jn(wr, 1)) {
            _removeListener$1(Mt ? l : Vn, _eventTypes[1], Pr, !0);
            var Rr = !isNaN(rn.y - rn.startY),
              $r = rn.isDragging,
              xr =
                $r &&
                (Math.abs(rn.x - rn.startX) > 3 ||
                  Math.abs(rn.y - rn.startY) > 3),
              Fr = _getEvent(wr);
            !xr &&
              Rr &&
              (rn._vx.reset(),
              rn._vy.reset(),
              p &&
                _n &&
                gsap$1.delayedCall(0.08, function () {
                  if (_getTime$1() - yr > 300 && !wr.defaultPrevented) {
                    if (wr.target.click) wr.target.click();
                    else if (Vn.createEvent) {
                      var Cr = Vn.createEvent("MouseEvents");
                      Cr.initMouseEvent(
                        "click",
                        !0,
                        !0,
                        _win$1,
                        1,
                        Fr.screenX,
                        Fr.screenY,
                        Fr.clientX,
                        Fr.clientY,
                        !1,
                        !1,
                        !1,
                        !1,
                        0,
                        null
                      ),
                        wr.target.dispatchEvent(Cr);
                    }
                  }
                })),
              (rn.isDragging = rn.isGesturing = rn.isPressed = !1),
              N && $r && !Mt && ur.restart(!0),
              _r && mr(),
              Be && $r && Be(rn),
              vt && vt(rn, xr);
          }
        }),
        An = function (Rr) {
          return (
            Rr.touches &&
            Rr.touches.length > 1 &&
            (rn.isGesturing = !0) &&
            Pt(Rr, rn.isDragging)
          );
        },
        Mn = function () {
          return (rn.isGesturing = !1) || It(rn);
        },
        Hn = function (Rr) {
          if (!jn(Rr)) {
            var $r = Yt(),
              xr = Gt();
            Sr(($r - hn) * tn, (xr - En) * tn, 1),
              (hn = $r),
              (En = xr),
              N && ur.restart(!0);
          }
        },
        hr = function (Rr) {
          if (!jn(Rr)) {
            (Rr = _getEvent(Rr, p)), Ot && (jt = !0);
            var $r =
              (Rr.deltaMode === 1
                ? c
                : Rr.deltaMode === 2
                ? _win$1.innerHeight
                : 1) * me;
            Sr(Rr.deltaX * $r, Rr.deltaY * $r, 0), N && !Mt && ur.restart(!0);
          }
        },
        pr = function (Rr) {
          if (!jn(Rr)) {
            var $r = Rr.clientX,
              xr = Rr.clientY,
              Fr = $r - rn.x,
              Cr = xr - rn.y;
            (rn.x = $r),
              (rn.y = xr),
              (Bn = !0),
              N && ur.restart(!0),
              (Fr || Cr) && Ur(Fr, Cr);
          }
        },
        jr = function (Rr) {
          (rn.event = Rr), Ht(rn);
        },
        fi = function (Rr) {
          (rn.event = Rr), qt(rn);
        },
        wi = function (Rr) {
          return jn(Rr) || (_getEvent(Rr, p) && Kt(rn));
        };
      (ur = rn._dc = gsap$1.delayedCall(P || 0.25, Jn).pause()),
        (rn.deltaX = rn.deltaY = 0),
        (rn._vx = _getVelocityProp(0, 50, !0)),
        (rn._vy = _getVelocityProp(0, 50, !0)),
        (rn.scrollX = Yt),
        (rn.scrollY = Gt),
        (rn.isDragging = rn.isGesturing = rn.isPressed = !1),
        _context$1(this),
        (rn.enable = function (wr) {
          return (
            rn.isEnabled ||
              (_addListener$1(mn ? Vn : l, "scroll", _onScroll$1),
              a.indexOf("scroll") >= 0 &&
                _addListener$1(mn ? Vn : l, "scroll", Hn, Gn, pn),
              a.indexOf("wheel") >= 0 && _addListener$1(l, "wheel", hr, Gn, pn),
              ((a.indexOf("touch") >= 0 && _isTouch) ||
                a.indexOf("pointer") >= 0) &&
                (_addListener$1(l, _eventTypes[0], Hr, Gn, pn),
                _addListener$1(Vn, _eventTypes[2], cn),
                _addListener$1(Vn, _eventTypes[3], cn),
                _n && _addListener$1(l, "click", qn, !0, !0),
                Kt && _addListener$1(l, "click", wi),
                Pt && _addListener$1(Vn, "gesturestart", An),
                It && _addListener$1(Vn, "gestureend", Mn),
                Ht && _addListener$1(l, _pointerType + "enter", jr),
                qt && _addListener$1(l, _pointerType + "leave", fi),
                Ft && _addListener$1(l, _pointerType + "move", pr)),
              (rn.isEnabled = !0),
              (rn.isDragging = rn.isGesturing = rn.isPressed = Bn = _r = !1),
              rn._vx.reset(),
              rn._vy.reset(),
              (hn = Yt()),
              (En = Gt()),
              wr && wr.type && Hr(wr),
              Xt && Xt(rn)),
            rn
          );
        }),
        (rn.disable = function () {
          rn.isEnabled &&
            (_observers.filter(function (wr) {
              return wr !== rn && _isViewport$1(wr.target);
            }).length || _removeListener$1(mn ? Vn : l, "scroll", _onScroll$1),
            rn.isPressed &&
              (rn._vx.reset(),
              rn._vy.reset(),
              _removeListener$1(Mt ? l : Vn, _eventTypes[1], Pr, !0)),
            _removeListener$1(mn ? Vn : l, "scroll", Hn, pn),
            _removeListener$1(l, "wheel", hr, pn),
            _removeListener$1(l, _eventTypes[0], Hr, pn),
            _removeListener$1(Vn, _eventTypes[2], cn),
            _removeListener$1(Vn, _eventTypes[3], cn),
            _removeListener$1(l, "click", qn, !0),
            _removeListener$1(l, "click", wi),
            _removeListener$1(Vn, "gesturestart", An),
            _removeListener$1(Vn, "gestureend", Mn),
            _removeListener$1(l, _pointerType + "enter", jr),
            _removeListener$1(l, _pointerType + "leave", fi),
            _removeListener$1(l, _pointerType + "move", pr),
            (rn.isEnabled = rn.isPressed = rn.isDragging = !1),
            sn && sn(rn));
        }),
        (rn.kill = rn.revert =
          function () {
            rn.disable();
            var wr = _observers.indexOf(rn);
            wr >= 0 && _observers.splice(wr, 1),
              _normalizer$1 === rn && (_normalizer$1 = 0);
          }),
        _observers.push(rn),
        Mt && _isViewport$1(l) && (_normalizer$1 = rn),
        rn.enable(Ye);
    }),
    _createClass(n, [
      {
        key: "velocityX",
        get: function () {
          return this._vx.getVelocity();
        },
      },
      {
        key: "velocityY",
        get: function () {
          return this._vy.getVelocity();
        },
      },
    ]),
    n
  );
})();
Observer.version = "3.13.0";
Observer.create = function (n) {
  return new Observer(n);
};
Observer.register = _initCore;
Observer.getAll = function () {
  return _observers.slice();
};
Observer.getById = function (n) {
  return _observers.filter(function (e) {
    return e.vars.id === n;
  })[0];
};
_getGSAP$1() && gsap$1.registerPlugin(Observer);
/*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var gsap,
  _coreInitted,
  _win,
  _doc,
  _docEl,
  _body,
  _root,
  _resizeDelay,
  _toArray,
  _clamp,
  _time2,
  _syncInterval,
  _refreshing,
  _pointerIsDown,
  _transformProp,
  _i,
  _prevWidth,
  _prevHeight,
  _autoRefresh,
  _sort,
  _suppressOverwrites,
  _ignoreResize,
  _normalizer,
  _ignoreMobileResize,
  _baseScreenHeight,
  _baseScreenWidth,
  _fixIOSBug,
  _context,
  _scrollRestoration,
  _div100vh,
  _100vh,
  _isReverted,
  _clampingMax,
  _limitCallbacks,
  _startup = 1,
  _getTime = Date.now,
  _time1 = _getTime(),
  _lastScrollTime = 0,
  _enabled = 0,
  _parseClamp = function (e, t, r) {
    var s =
      _isString(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return (r["_" + t + "Clamp"] = s), s ? e.substr(6, e.length - 7) : e;
  },
  _keepClamp = function (e, t) {
    return t && (!_isString(e) || e.substr(0, 6) !== "clamp(")
      ? "clamp(" + e + ")"
      : e;
  },
  _rafBugFix = function n() {
    return _enabled && requestAnimationFrame(n);
  },
  _pointerDownHandler = function () {
    return (_pointerIsDown = 1);
  },
  _pointerUpHandler = function () {
    return (_pointerIsDown = 0);
  },
  _passThrough = function (e) {
    return e;
  },
  _round = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  _windowExists = function () {
    return typeof window < "u";
  },
  _getGSAP = function () {
    return (
      gsap ||
      (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap)
    );
  },
  _isViewport = function (e) {
    return !!~_root.indexOf(e);
  },
  _getViewportDimension = function (e) {
    return (
      (e === "Height" ? _100vh : _win["inner" + e]) ||
      _docEl["client" + e] ||
      _body["client" + e]
    );
  },
  _getBoundsFunc = function (e) {
    return (
      _getProxyProp(e, "getBoundingClientRect") ||
      (_isViewport(e)
        ? function () {
            return (
              (_winOffsets.width = _win.innerWidth),
              (_winOffsets.height = _100vh),
              _winOffsets
            );
          }
        : function () {
            return _getBounds(e);
          })
    );
  },
  _getSizeFunc = function (e, t, r) {
    var s = r.d,
      o = r.d2,
      a = r.a;
    return (a = _getProxyProp(e, "getBoundingClientRect"))
      ? function () {
          return a()[s];
        }
      : function () {
          return (t ? _getViewportDimension(o) : e["client" + o]) || 0;
        };
  },
  _getOffsetsFunc = function (e, t) {
    return !t || ~_proxies.indexOf(e)
      ? _getBoundsFunc(e)
      : function () {
          return _winOffsets;
        };
  },
  _maxScroll = function (e, t) {
    var r = t.s,
      s = t.d2,
      o = t.d,
      a = t.a;
    return Math.max(
      0,
      (r = "scroll" + s) && (a = _getProxyProp(e, r))
        ? a() - _getBoundsFunc(e)()[o]
        : _isViewport(e)
        ? (_docEl[r] || _body[r]) - _getViewportDimension(s)
        : e[r] - e["offset" + s]
    );
  },
  _iterateAutoRefresh = function (e, t) {
    for (var r = 0; r < _autoRefresh.length; r += 3)
      (!t || ~t.indexOf(_autoRefresh[r + 1])) &&
        e(_autoRefresh[r], _autoRefresh[r + 1], _autoRefresh[r + 2]);
  },
  _isString = function (e) {
    return typeof e == "string";
  },
  _isFunction = function (e) {
    return typeof e == "function";
  },
  _isNumber = function (e) {
    return typeof e == "number";
  },
  _isObject = function (e) {
    return typeof e == "object";
  },
  _endAnimation = function (e, t, r) {
    return e && e.progress(t ? 0 : 1) && r && e.pause();
  },
  _callback = function (e, t) {
    if (e.enabled) {
      var r = e._ctx
        ? e._ctx.add(function () {
            return t(e);
          })
        : t(e);
      r && r.totalTime && (e.callbackAnimation = r);
    }
  },
  _abs = Math.abs,
  _left = "left",
  _top = "top",
  _right = "right",
  _bottom = "bottom",
  _width = "width",
  _height = "height",
  _Right = "Right",
  _Left = "Left",
  _Top = "Top",
  _Bottom = "Bottom",
  _padding = "padding",
  _margin = "margin",
  _Width = "Width",
  _Height = "Height",
  _px = "px",
  _getComputedStyle = function (e) {
    return _win.getComputedStyle(e);
  },
  _makePositionable = function (e) {
    var t = _getComputedStyle(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
  },
  _setDefaults = function (e, t) {
    for (var r in t) r in e || (e[r] = t[r]);
    return e;
  },
  _getBounds = function (e, t) {
    var r =
        t &&
        _getComputedStyle(e)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        gsap
          .to(e, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0,
          })
          .progress(1),
      s = e.getBoundingClientRect();
    return r && r.progress(0).kill(), s;
  },
  _getSize = function (e, t) {
    var r = t.d2;
    return e["offset" + r] || e["client" + r] || 0;
  },
  _getLabelRatioArray = function (e) {
    var t = [],
      r = e.labels,
      s = e.duration(),
      o;
    for (o in r) t.push(r[o] / s);
    return t;
  },
  _getClosestLabel = function (e) {
    return function (t) {
      return gsap.utils.snap(_getLabelRatioArray(e), t);
    };
  },
  _snapDirectional = function (e) {
    var t = gsap.utils.snap(e),
      r =
        Array.isArray(e) &&
        e.slice(0).sort(function (s, o) {
          return s - o;
        });
    return r
      ? function (s, o, a) {
          a === void 0 && (a = 0.001);
          var l;
          if (!o) return t(s);
          if (o > 0) {
            for (s -= a, l = 0; l < r.length; l++) if (r[l] >= s) return r[l];
            return r[l - 1];
          } else for (l = r.length, s += a; l--; ) if (r[l] <= s) return r[l];
          return r[0];
        }
      : function (s, o, a) {
          a === void 0 && (a = 0.001);
          var l = t(s);
          return !o || Math.abs(l - s) < a || l - s < 0 == o < 0
            ? l
            : t(o < 0 ? s - e : s + e);
        };
  },
  _getLabelAtDirection = function (e) {
    return function (t, r) {
      return _snapDirectional(_getLabelRatioArray(e))(t, r.direction);
    };
  },
  _multiListener = function (e, t, r, s) {
    return r.split(",").forEach(function (o) {
      return e(t, o, s);
    });
  },
  _addListener = function (e, t, r, s, o) {
    return e.addEventListener(t, r, { passive: !s, capture: !!o });
  },
  _removeListener = function (e, t, r, s) {
    return e.removeEventListener(t, r, !!s);
  },
  _wheelListener = function (e, t, r) {
    (r = r && r.wheelHandler), r && (e(t, "wheel", r), e(t, "touchmove", r));
  },
  _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  _defaults = { toggleActions: "play", anticipatePin: 0 },
  _keywords = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  _offsetToPx = function (e, t) {
    if (_isString(e)) {
      var r = e.indexOf("="),
        s = ~r ? +(e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0;
      ~r && (e.indexOf("%") > r && (s *= t / 100), (e = e.substr(0, r - 1))),
        (e =
          s +
          (e in _keywords
            ? _keywords[e] * t
            : ~e.indexOf("%")
            ? (parseFloat(e) * t) / 100
            : parseFloat(e) || 0));
    }
    return e;
  },
  _createMarker = function (e, t, r, s, o, a, l, c) {
    var u = o.startColor,
      p = o.endColor,
      N = o.fontSize,
      P = o.indent,
      de = o.fontWeight,
      me = _doc.createElement("div"),
      Ye = _isViewport(r) || _getProxyProp(r, "pinType") === "fixed",
      nt = e.indexOf("scroller") !== -1,
      Be = Ye ? _body : r,
      ot = e.indexOf("start") !== -1,
      st = ot ? u : p,
      vt =
        "border-color:" +
        st +
        ";font-size:" +
        N +
        ";color:" +
        st +
        ";font-weight:" +
        de +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (vt += "position:" + ((nt || c) && Ye ? "fixed;" : "absolute;")),
      (nt || c || !Ye) &&
        (vt +=
          (s === _vertical ? _right : _bottom) +
          ":" +
          (a + parseFloat(P)) +
          "px;"),
      l &&
        (vt +=
          "box-sizing:border-box;text-align:left;width:" +
          l.offsetWidth +
          "px;"),
      (me._isStart = ot),
      me.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
      (me.style.cssText = vt),
      (me.innerText = t || t === 0 ? e + "-" + t : e),
      Be.children[0] ? Be.insertBefore(me, Be.children[0]) : Be.appendChild(me),
      (me._offset = me["offset" + s.op.d2]),
      _positionMarker(me, 0, s, ot),
      me
    );
  },
  _positionMarker = function (e, t, r, s) {
    var o = { display: "block" },
      a = r[s ? "os2" : "p2"],
      l = r[s ? "p2" : "os2"];
    (e._isFlipped = s),
      (o[r.a + "Percent"] = s ? -100 : 0),
      (o[r.a] = s ? "1px" : 0),
      (o["border" + a + _Width] = 1),
      (o["border" + l + _Width] = 0),
      (o[r.p] = t + "px"),
      gsap.set(e, o);
  },
  _triggers = [],
  _ids = {},
  _rafID,
  _sync = function () {
    return (
      _getTime() - _lastScrollTime > 34 &&
      (_rafID || (_rafID = requestAnimationFrame(_updateAll)))
    );
  },
  _onScroll = function () {
    (!_normalizer ||
      !_normalizer.isPressed ||
      _normalizer.startX > _body.clientWidth) &&
      (_scrollers.cache++,
      _normalizer
        ? _rafID || (_rafID = requestAnimationFrame(_updateAll))
        : _updateAll(),
      _lastScrollTime || _dispatch("scrollStart"),
      (_lastScrollTime = _getTime()));
  },
  _setBaseDimensions = function () {
    (_baseScreenWidth = _win.innerWidth),
      (_baseScreenHeight = _win.innerHeight);
  },
  _onResize = function (e) {
    _scrollers.cache++,
      (e === !0 ||
        (!_refreshing &&
          !_ignoreResize &&
          !_doc.fullscreenElement &&
          !_doc.webkitFullscreenElement &&
          (!_ignoreMobileResize ||
            _baseScreenWidth !== _win.innerWidth ||
            Math.abs(_win.innerHeight - _baseScreenHeight) >
              _win.innerHeight * 0.25))) &&
        _resizeDelay.restart(!0);
  },
  _listeners = {},
  _emptyArray = [],
  _softRefresh = function n() {
    return _removeListener(ScrollTrigger, "scrollEnd", n) || _refreshAll(!0);
  },
  _dispatch = function (e) {
    return (
      (_listeners[e] &&
        _listeners[e].map(function (t) {
          return t();
        })) ||
      _emptyArray
    );
  },
  _savedStyles = [],
  _revertRecorded = function (e) {
    for (var t = 0; t < _savedStyles.length; t += 5)
      (!e || (_savedStyles[t + 4] && _savedStyles[t + 4].query === e)) &&
        ((_savedStyles[t].style.cssText = _savedStyles[t + 1]),
        _savedStyles[t].getBBox &&
          _savedStyles[t].setAttribute("transform", _savedStyles[t + 2] || ""),
        (_savedStyles[t + 3].uncache = 1));
  },
  _revertAll = function (e, t) {
    var r;
    for (_i = 0; _i < _triggers.length; _i++)
      (r = _triggers[_i]),
        r && (!t || r._ctx === t) && (e ? r.kill(1) : r.revert(!0, !0));
    (_isReverted = !0), t && _revertRecorded(t), t || _dispatch("revert");
  },
  _clearScrollMemory = function (e, t) {
    _scrollers.cache++,
      (t || !_refreshingAll) &&
        _scrollers.forEach(function (r) {
          return _isFunction(r) && r.cacheID++ && (r.rec = 0);
        }),
      _isString(e) && (_win.history.scrollRestoration = _scrollRestoration = e);
  },
  _refreshingAll,
  _refreshID = 0,
  _queueRefreshID,
  _queueRefreshAll = function () {
    if (_queueRefreshID !== _refreshID) {
      var e = (_queueRefreshID = _refreshID);
      requestAnimationFrame(function () {
        return e === _refreshID && _refreshAll(!0);
      });
    }
  },
  _refresh100vh = function () {
    _body.appendChild(_div100vh),
      (_100vh = (!_normalizer && _div100vh.offsetHeight) || _win.innerHeight),
      _body.removeChild(_div100vh);
  },
  _hideAllMarkers = function (e) {
    return _toArray(
      ".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end"
    ).forEach(function (t) {
      return (t.style.display = e ? "none" : "block");
    });
  },
  _refreshAll = function (e, t) {
    if (
      ((_docEl = _doc.documentElement),
      (_body = _doc.body),
      (_root = [_win, _doc, _docEl, _body]),
      _lastScrollTime && !e && !_isReverted)
    ) {
      _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
      return;
    }
    _refresh100vh(),
      (_refreshingAll = ScrollTrigger.isRefreshing = !0),
      _scrollers.forEach(function (s) {
        return _isFunction(s) && ++s.cacheID && (s.rec = s());
      });
    var r = _dispatch("refreshInit");
    _sort && ScrollTrigger.sort(),
      t || _revertAll(),
      _scrollers.forEach(function (s) {
        _isFunction(s) &&
          (s.smooth && (s.target.style.scrollBehavior = "auto"), s(0));
      }),
      _triggers.slice(0).forEach(function (s) {
        return s.refresh();
      }),
      (_isReverted = !1),
      _triggers.forEach(function (s) {
        if (s._subPinOffset && s.pin) {
          var o = s.vars.horizontal ? "offsetWidth" : "offsetHeight",
            a = s.pin[o];
          s.revert(!0, 1), s.adjustPinSpacing(s.pin[o] - a), s.refresh();
        }
      }),
      (_clampingMax = 1),
      _hideAllMarkers(!0),
      _triggers.forEach(function (s) {
        var o = _maxScroll(s.scroller, s._dir),
          a = s.vars.end === "max" || (s._endClamp && s.end > o),
          l = s._startClamp && s.start >= o;
        (a || l) &&
          s.setPositions(
            l ? o - 1 : s.start,
            a ? Math.max(l ? o : s.start + 1, o) : s.end,
            !0
          );
      }),
      _hideAllMarkers(!1),
      (_clampingMax = 0),
      r.forEach(function (s) {
        return s && s.render && s.render(-1);
      }),
      _scrollers.forEach(function (s) {
        _isFunction(s) &&
          (s.smooth &&
            requestAnimationFrame(function () {
              return (s.target.style.scrollBehavior = "smooth");
            }),
          s.rec && s(s.rec));
      }),
      _clearScrollMemory(_scrollRestoration, 1),
      _resizeDelay.pause(),
      _refreshID++,
      (_refreshingAll = 2),
      _updateAll(2),
      _triggers.forEach(function (s) {
        return _isFunction(s.vars.onRefresh) && s.vars.onRefresh(s);
      }),
      (_refreshingAll = ScrollTrigger.isRefreshing = !1),
      _dispatch("refresh");
  },
  _lastScroll = 0,
  _direction = 1,
  _primary,
  _updateAll = function (e) {
    if (e === 2 || (!_refreshingAll && !_isReverted)) {
      (ScrollTrigger.isUpdating = !0), _primary && _primary.update(0);
      var t = _triggers.length,
        r = _getTime(),
        s = r - _time1 >= 50,
        o = t && _triggers[0].scroll();
      if (
        ((_direction = _lastScroll > o ? -1 : 1),
        _refreshingAll || (_lastScroll = o),
        s &&
          (_lastScrollTime &&
            !_pointerIsDown &&
            r - _lastScrollTime > 200 &&
            ((_lastScrollTime = 0), _dispatch("scrollEnd")),
          (_time2 = _time1),
          (_time1 = r)),
        _direction < 0)
      ) {
        for (_i = t; _i-- > 0; ) _triggers[_i] && _triggers[_i].update(0, s);
        _direction = 1;
      } else
        for (_i = 0; _i < t; _i++) _triggers[_i] && _triggers[_i].update(0, s);
      ScrollTrigger.isUpdating = !1;
    }
    _rafID = 0;
  },
  _propNamesToCopy = [
    _left,
    _top,
    _bottom,
    _right,
    _margin + _Bottom,
    _margin + _Right,
    _margin + _Top,
    _margin + _Left,
    "display",
    "flexShrink",
    "float",
    "zIndex",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRowStart",
    "gridRowEnd",
    "gridArea",
    "justifySelf",
    "alignSelf",
    "placeSelf",
    "order",
  ],
  _stateProps = _propNamesToCopy.concat([
    _width,
    _height,
    "boxSizing",
    "max" + _Width,
    "max" + _Height,
    "position",
    _margin,
    _padding,
    _padding + _Top,
    _padding + _Right,
    _padding + _Bottom,
    _padding + _Left,
  ]),
  _swapPinOut = function (e, t, r) {
    _setState(r);
    var s = e._gsap;
    if (s.spacerIsNative) _setState(s.spacerState);
    else if (e._gsap.swappedIn) {
      var o = t.parentNode;
      o && (o.insertBefore(e, t), o.removeChild(t));
    }
    e._gsap.swappedIn = !1;
  },
  _swapPinIn = function (e, t, r, s) {
    if (!e._gsap.swappedIn) {
      for (var o = _propNamesToCopy.length, a = t.style, l = e.style, c; o--; )
        (c = _propNamesToCopy[o]), (a[c] = r[c]);
      (a.position = r.position === "absolute" ? "absolute" : "relative"),
        r.display === "inline" && (a.display = "inline-block"),
        (l[_bottom] = l[_right] = "auto"),
        (a.flexBasis = r.flexBasis || "auto"),
        (a.overflow = "visible"),
        (a.boxSizing = "border-box"),
        (a[_width] = _getSize(e, _horizontal) + _px),
        (a[_height] = _getSize(e, _vertical) + _px),
        (a[_padding] = l[_margin] = l[_top] = l[_left] = "0"),
        _setState(s),
        (l[_width] = l["max" + _Width] = r[_width]),
        (l[_height] = l["max" + _Height] = r[_height]),
        (l[_padding] = r[_padding]),
        e.parentNode !== t &&
          (e.parentNode.insertBefore(t, e), t.appendChild(e)),
        (e._gsap.swappedIn = !0);
    }
  },
  _capsExp = /([A-Z])/g,
  _setState = function (e) {
    if (e) {
      var t = e.t.style,
        r = e.length,
        s = 0,
        o,
        a;
      for ((e.t._gsap || gsap.core.getCache(e.t)).uncache = 1; s < r; s += 2)
        (a = e[s + 1]),
          (o = e[s]),
          a
            ? (t[o] = a)
            : t[o] &&
              t.removeProperty(o.replace(_capsExp, "-$1").toLowerCase());
    }
  },
  _getState = function (e) {
    for (var t = _stateProps.length, r = e.style, s = [], o = 0; o < t; o++)
      s.push(_stateProps[o], r[_stateProps[o]]);
    return (s.t = e), s;
  },
  _copyState = function (e, t, r) {
    for (var s = [], o = e.length, a = r ? 8 : 0, l; a < o; a += 2)
      (l = e[a]), s.push(l, l in t ? t[l] : e[a + 1]);
    return (s.t = e.t), s;
  },
  _winOffsets = { left: 0, top: 0 },
  _parsePosition = function (e, t, r, s, o, a, l, c, u, p, N, P, de, me) {
    _isFunction(e) && (e = e(c)),
      _isString(e) &&
        e.substr(0, 3) === "max" &&
        (e = P + (e.charAt(4) === "=" ? _offsetToPx("0" + e.substr(3), r) : 0));
    var Ye = de ? de.time() : 0,
      nt,
      Be,
      ot;
    if ((de && de.seek(0), isNaN(e) || (e = +e), _isNumber(e)))
      de &&
        (e = gsap.utils.mapRange(
          de.scrollTrigger.start,
          de.scrollTrigger.end,
          0,
          P,
          e
        )),
        l && _positionMarker(l, r, s, !0);
    else {
      _isFunction(t) && (t = t(c));
      var st = (e || "0").split(" "),
        vt,
        xt,
        St,
        wt;
      (ot = _getTarget(t, c) || _body),
        (vt = _getBounds(ot) || {}),
        (!vt || (!vt.left && !vt.top)) &&
          _getComputedStyle(ot).display === "none" &&
          ((wt = ot.style.display),
          (ot.style.display = "block"),
          (vt = _getBounds(ot)),
          wt ? (ot.style.display = wt) : ot.style.removeProperty("display")),
        (xt = _offsetToPx(st[0], vt[s.d])),
        (St = _offsetToPx(st[1] || "0", r)),
        (e = vt[s.p] - u[s.p] - p + xt + o - St),
        l && _positionMarker(l, St, s, r - St < 20 || (l._isStart && St > 20)),
        (r -= r - St);
    }
    if ((me && ((c[me] = e || -0.001), e < 0 && (e = 0)), a)) {
      var bt = e + r,
        Tt = a._isStart;
      (nt = "scroll" + s.d2),
        _positionMarker(
          a,
          bt,
          s,
          (Tt && bt > 20) ||
            (!Tt &&
              (N ? Math.max(_body[nt], _docEl[nt]) : a.parentNode[nt]) <=
                bt + 1)
        ),
        N &&
          ((u = _getBounds(l)),
          N && (a.style[s.op.p] = u[s.op.p] - s.op.m - a._offset + _px));
    }
    return (
      de &&
        ot &&
        ((nt = _getBounds(ot)),
        de.seek(P),
        (Be = _getBounds(ot)),
        (de._caScrollDist = nt[s.p] - Be[s.p]),
        (e = (e / de._caScrollDist) * P)),
      de && de.seek(Ye),
      de ? e : Math.round(e)
    );
  },
  _prefixExp = /(webkit|moz|length|cssText|inset)/i,
  _reparent = function (e, t, r, s) {
    if (e.parentNode !== t) {
      var o = e.style,
        a,
        l;
      if (t === _body) {
        (e._stOrig = o.cssText), (l = _getComputedStyle(e));
        for (a in l)
          !+a &&
            !_prefixExp.test(a) &&
            l[a] &&
            typeof o[a] == "string" &&
            a !== "0" &&
            (o[a] = l[a]);
        (o.top = r), (o.left = s);
      } else o.cssText = e._stOrig;
      (gsap.core.getCache(e).uncache = 1), t.appendChild(e);
    }
  },
  _interruptionTracker = function (e, t, r) {
    var s = t,
      o = s;
    return function (a) {
      var l = Math.round(e());
      return (
        l !== s &&
          l !== o &&
          Math.abs(l - s) > 3 &&
          Math.abs(l - o) > 3 &&
          ((a = l), r && r()),
        (o = s),
        (s = Math.round(a)),
        s
      );
    };
  },
  _shiftMarker = function (e, t, r) {
    var s = {};
    (s[t.p] = "+=" + r), gsap.set(e, s);
  },
  _getTweenCreator = function (e, t) {
    var r = _getScrollFunc(e, t),
      s = "_scroll" + t.p2,
      o = function a(l, c, u, p, N) {
        var P = a.tween,
          de = c.onComplete,
          me = {};
        u = u || r();
        var Ye = _interruptionTracker(r, u, function () {
          P.kill(), (a.tween = 0);
        });
        return (
          (N = (p && N) || 0),
          (p = p || l - u),
          P && P.kill(),
          (c[s] = l),
          (c.inherit = !1),
          (c.modifiers = me),
          (me[s] = function () {
            return Ye(u + p * P.ratio + N * P.ratio * P.ratio);
          }),
          (c.onUpdate = function () {
            _scrollers.cache++, a.tween && _updateAll();
          }),
          (c.onComplete = function () {
            (a.tween = 0), de && de.call(P);
          }),
          (P = a.tween = gsap.to(e, c)),
          P
        );
      };
    return (
      (e[s] = r),
      (r.wheelHandler = function () {
        return o.tween && o.tween.kill() && (o.tween = 0);
      }),
      _addListener(e, "wheel", r.wheelHandler),
      ScrollTrigger.isTouch && _addListener(e, "touchmove", r.wheelHandler),
      o
    );
  },
  ScrollTrigger = (function () {
    function n(t, r) {
      _coreInitted ||
        n.register(gsap) ||
        console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        _context(this),
        this.init(t, r);
    }
    var e = n.prototype;
    return (
      (e.init = function (r, s) {
        if (
          ((this.progress = this.start = 0),
          this.vars && this.kill(!0, !0),
          !_enabled)
        ) {
          this.update = this.refresh = this.kill = _passThrough;
          return;
        }
        r = _setDefaults(
          _isString(r) || _isNumber(r) || r.nodeType ? { trigger: r } : r,
          _defaults
        );
        var o = r,
          a = o.onUpdate,
          l = o.toggleClass,
          c = o.id,
          u = o.onToggle,
          p = o.onRefresh,
          N = o.scrub,
          P = o.trigger,
          de = o.pin,
          me = o.pinSpacing,
          Ye = o.invalidateOnRefresh,
          nt = o.anticipatePin,
          Be = o.onScrubComplete,
          ot = o.onSnapComplete,
          st = o.once,
          vt = o.snap,
          xt = o.pinReparent,
          St = o.pinSpacer,
          wt = o.containerAnimation,
          bt = o.fastScrollEnd,
          Tt = o.preventOverlaps,
          Ct =
            r.horizontal || (r.containerAnimation && r.horizontal !== !1)
              ? _horizontal
              : _vertical,
          kt = !N && N !== 0,
          Dt = _getTarget(r.scroller || _win),
          Vt = gsap.core.getCache(Dt),
          Ht = _isViewport(Dt),
          qt =
            ("pinType" in r
              ? r.pinType
              : _getProxyProp(Dt, "pinType") || (Ht && "fixed")) === "fixed",
          Ft = [r.onEnter, r.onLeave, r.onEnterBack, r.onLeaveBack],
          Bt = kt && r.toggleActions.split(" "),
          Mt = "markers" in r ? r.markers : _defaults.markers,
          Pt = Ht
            ? 0
            : parseFloat(_getComputedStyle(Dt)["border" + Ct.p2 + _Width]) || 0,
          It = this,
          Ot =
            r.onRefreshInit &&
            function () {
              return r.onRefreshInit(It);
            },
          Xt = _getSizeFunc(Dt, Ht, Ct),
          sn = _getOffsetsFunc(Dt, Ht),
          Kt = 0,
          tn = 0,
          pn = 0,
          _n = _getScrollFunc(Dt, Ct),
          bn,
          $n,
          tr,
          ur,
          _r,
          Bn,
          jt,
          Yn,
          zn,
          rn,
          In,
          or,
          Gn,
          Yt,
          Gt,
          hn,
          En,
          Ln,
          mn,
          Vn,
          Fn,
          nr,
          yr,
          qn,
          jn,
          Jn,
          mr,
          Sr,
          Ur,
          Pr,
          Hr,
          cn,
          An,
          Mn,
          Hn,
          hr,
          pr,
          jr,
          fi;
        if (
          ((It._startClamp = It._endClamp = !1),
          (It._dir = Ct),
          (nt *= 45),
          (It.scroller = Dt),
          (It.scroll = wt ? wt.time.bind(wt) : _n),
          (ur = _n()),
          (It.vars = r),
          (s = s || r.animation),
          "refreshPriority" in r &&
            ((_sort = 1), r.refreshPriority === -9999 && (_primary = It)),
          (Vt.tweenScroll = Vt.tweenScroll || {
            top: _getTweenCreator(Dt, _vertical),
            left: _getTweenCreator(Dt, _horizontal),
          }),
          (It.tweenTo = bn = Vt.tweenScroll[Ct.p]),
          (It.scrubDuration = function (xr) {
            (An = _isNumber(xr) && xr),
              An
                ? cn
                  ? cn.duration(xr)
                  : (cn = gsap.to(s, {
                      ease: "expo",
                      totalProgress: "+=0",
                      inherit: !1,
                      duration: An,
                      paused: !0,
                      onComplete: function () {
                        return Be && Be(It);
                      },
                    }))
                : (cn && cn.progress(1).kill(), (cn = 0));
          }),
          s &&
            ((s.vars.lazy = !1),
            (s._initted && !It.isReverted) ||
              (s.vars.immediateRender !== !1 &&
                r.immediateRender !== !1 &&
                s.duration() &&
                s.render(0, !0, !0)),
            (It.animation = s.pause()),
            (s.scrollTrigger = It),
            It.scrubDuration(N),
            (Pr = 0),
            c || (c = s.vars.id)),
          vt &&
            ((!_isObject(vt) || vt.push) && (vt = { snapTo: vt }),
            "scrollBehavior" in _body.style &&
              gsap.set(Ht ? [_body, _docEl] : Dt, { scrollBehavior: "auto" }),
            _scrollers.forEach(function (xr) {
              return (
                _isFunction(xr) &&
                xr.target === (Ht ? _doc.scrollingElement || _docEl : Dt) &&
                (xr.smooth = !1)
              );
            }),
            (tr = _isFunction(vt.snapTo)
              ? vt.snapTo
              : vt.snapTo === "labels"
              ? _getClosestLabel(s)
              : vt.snapTo === "labelsDirectional"
              ? _getLabelAtDirection(s)
              : vt.directional !== !1
              ? function (xr, Fr) {
                  return _snapDirectional(vt.snapTo)(
                    xr,
                    _getTime() - tn < 500 ? 0 : Fr.direction
                  );
                }
              : gsap.utils.snap(vt.snapTo)),
            (Mn = vt.duration || { min: 0.1, max: 2 }),
            (Mn = _isObject(Mn) ? _clamp(Mn.min, Mn.max) : _clamp(Mn, Mn)),
            (Hn = gsap
              .delayedCall(vt.delay || An / 2 || 0.1, function () {
                var xr = _n(),
                  Fr = _getTime() - tn < 500,
                  Cr = bn.tween;
                if (
                  (Fr || Math.abs(It.getVelocity()) < 10) &&
                  !Cr &&
                  !_pointerIsDown &&
                  Kt !== xr
                ) {
                  var zr = (xr - Bn) / Yt,
                    pi = s && !kt ? s.totalProgress() : zr,
                    qr = Fr
                      ? 0
                      : ((pi - Hr) / (_getTime() - _time2)) * 1e3 || 0,
                    Ir = gsap.utils.clamp(
                      -zr,
                      1 - zr,
                      (_abs(qr / 2) * qr) / 0.185
                    ),
                    Pi = zr + (vt.inertia === !1 ? 0 : Ir),
                    mi,
                    Ut,
                    $t = vt,
                    un = $t.onStart,
                    yn = $t.onInterrupt,
                    Rn = $t.onComplete;
                  if (
                    ((mi = tr(Pi, It)),
                    _isNumber(mi) || (mi = Pi),
                    (Ut = Math.max(0, Math.round(Bn + mi * Yt))),
                    xr <= jt && xr >= Bn && Ut !== xr)
                  ) {
                    if (Cr && !Cr._initted && Cr.data <= _abs(Ut - xr)) return;
                    vt.inertia === !1 && (Ir = mi - zr),
                      bn(
                        Ut,
                        {
                          duration: Mn(
                            _abs(
                              (Math.max(_abs(Pi - pi), _abs(mi - pi)) * 0.185) /
                                qr /
                                0.05 || 0
                            )
                          ),
                          ease: vt.ease || "power3",
                          data: _abs(Ut - xr),
                          onInterrupt: function () {
                            return Hn.restart(!0) && yn && yn(It);
                          },
                          onComplete: function () {
                            It.update(),
                              (Kt = _n()),
                              s &&
                                !kt &&
                                (cn
                                  ? cn.resetTo(
                                      "totalProgress",
                                      mi,
                                      s._tTime / s._tDur
                                    )
                                  : s.progress(mi)),
                              (Pr = Hr =
                                s && !kt ? s.totalProgress() : It.progress),
                              ot && ot(It),
                              Rn && Rn(It);
                          },
                        },
                        xr,
                        Ir * Yt,
                        Ut - xr - Ir * Yt
                      ),
                      un && un(It, bn.tween);
                  }
                } else It.isActive && Kt !== xr && Hn.restart(!0);
              })
              .pause())),
          c && (_ids[c] = It),
          (P = It.trigger = _getTarget(P || (de !== !0 && de))),
          (fi = P && P._gsap && P._gsap.stRevert),
          fi && (fi = fi(It)),
          (de = de === !0 ? P : _getTarget(de)),
          _isString(l) && (l = { targets: P, className: l }),
          de &&
            (me === !1 ||
              me === _margin ||
              (me =
                !me &&
                de.parentNode &&
                de.parentNode.style &&
                _getComputedStyle(de.parentNode).display === "flex"
                  ? !1
                  : _padding),
            (It.pin = de),
            ($n = gsap.core.getCache(de)),
            $n.spacer
              ? (Gt = $n.pinState)
              : (St &&
                  ((St = _getTarget(St)),
                  St && !St.nodeType && (St = St.current || St.nativeElement),
                  ($n.spacerIsNative = !!St),
                  St && ($n.spacerState = _getState(St))),
                ($n.spacer = Ln = St || _doc.createElement("div")),
                Ln.classList.add("pin-spacer"),
                c && Ln.classList.add("pin-spacer-" + c),
                ($n.pinState = Gt = _getState(de))),
            r.force3D !== !1 && gsap.set(de, { force3D: !0 }),
            (It.spacer = Ln = $n.spacer),
            (Ur = _getComputedStyle(de)),
            (qn = Ur[me + Ct.os2]),
            (Vn = gsap.getProperty(de)),
            (Fn = gsap.quickSetter(de, Ct.a, _px)),
            _swapPinIn(de, Ln, Ur),
            (En = _getState(de))),
          Mt)
        ) {
          (or = _isObject(Mt)
            ? _setDefaults(Mt, _markerDefaults)
            : _markerDefaults),
            (rn = _createMarker("scroller-start", c, Dt, Ct, or, 0)),
            (In = _createMarker("scroller-end", c, Dt, Ct, or, 0, rn)),
            (mn = rn["offset" + Ct.op.d2]);
          var wi = _getTarget(_getProxyProp(Dt, "content") || Dt);
          (Yn = this.markerStart =
            _createMarker("start", c, wi, Ct, or, mn, 0, wt)),
            (zn = this.markerEnd =
              _createMarker("end", c, wi, Ct, or, mn, 0, wt)),
            wt && (jr = gsap.quickSetter([Yn, zn], Ct.a, _px)),
            !qt &&
              !(_proxies.length && _getProxyProp(Dt, "fixedMarkers") === !0) &&
              (_makePositionable(Ht ? _body : Dt),
              gsap.set([rn, In], { force3D: !0 }),
              (Jn = gsap.quickSetter(rn, Ct.a, _px)),
              (Sr = gsap.quickSetter(In, Ct.a, _px)));
        }
        if (wt) {
          var wr = wt.vars.onUpdate,
            Rr = wt.vars.onUpdateParams;
          wt.eventCallback("onUpdate", function () {
            It.update(0, 0, 1), wr && wr.apply(wt, Rr || []);
          });
        }
        if (
          ((It.previous = function () {
            return _triggers[_triggers.indexOf(It) - 1];
          }),
          (It.next = function () {
            return _triggers[_triggers.indexOf(It) + 1];
          }),
          (It.revert = function (xr, Fr) {
            if (!Fr) return It.kill(!0);
            var Cr = xr !== !1 || !It.enabled,
              zr = _refreshing;
            Cr !== It.isReverted &&
              (Cr &&
                ((hr = Math.max(_n(), It.scroll.rec || 0)),
                (pn = It.progress),
                (pr = s && s.progress())),
              Yn &&
                [Yn, zn, rn, In].forEach(function (pi) {
                  return (pi.style.display = Cr ? "none" : "block");
                }),
              Cr && ((_refreshing = It), It.update(Cr)),
              de &&
                (!xt || !It.isActive) &&
                (Cr
                  ? _swapPinOut(de, Ln, Gt)
                  : _swapPinIn(de, Ln, _getComputedStyle(de), jn)),
              Cr || It.update(Cr),
              (_refreshing = zr),
              (It.isReverted = Cr));
          }),
          (It.refresh = function (xr, Fr, Cr, zr) {
            if (!((_refreshing || !It.enabled) && !Fr)) {
              if (de && xr && _lastScrollTime) {
                _addListener(n, "scrollEnd", _softRefresh);
                return;
              }
              !_refreshingAll && Ot && Ot(It),
                (_refreshing = It),
                bn.tween && !Cr && (bn.tween.kill(), (bn.tween = 0)),
                cn && cn.pause(),
                Ye &&
                  s &&
                  (s.revert({ kill: !1 }).invalidate(),
                  s.getChildren &&
                    s.getChildren(!0, !0, !1).forEach(function (gr) {
                      return gr.vars.immediateRender && gr.render(0, !0, !0);
                    })),
                It.isReverted || It.revert(!0, !0),
                (It._subPinOffset = !1);
              var pi = Xt(),
                qr = sn(),
                Ir = wt ? wt.duration() : _maxScroll(Dt, Ct),
                Pi = Yt <= 0.01 || !Yt,
                mi = 0,
                Ut = zr || 0,
                $t = _isObject(Cr) ? Cr.end : r.end,
                un = r.endTrigger || P,
                yn = _isObject(Cr)
                  ? Cr.start
                  : r.start ||
                    (r.start === 0 || !P ? 0 : de ? "0 0" : "0 100%"),
                Rn = (It.pinnedContainer =
                  r.pinnedContainer && _getTarget(r.pinnedContainer, It)),
                kn = (P && Math.max(0, _triggers.indexOf(It))) || 0,
                er = kn,
                Xn,
                zt,
                Zt,
                an,
                Qt,
                fn,
                wn,
                On,
                Kn,
                Zn,
                ar,
                cr,
                Qn;
              for (
                Mt &&
                _isObject(Cr) &&
                ((cr = gsap.getProperty(rn, Ct.p)),
                (Qn = gsap.getProperty(In, Ct.p)));
                er-- > 0;

              )
                (fn = _triggers[er]),
                  fn.end || fn.refresh(0, 1) || (_refreshing = It),
                  (wn = fn.pin),
                  wn &&
                    (wn === P || wn === de || wn === Rn) &&
                    !fn.isReverted &&
                    (Zn || (Zn = []), Zn.unshift(fn), fn.revert(!0, !0)),
                  fn !== _triggers[er] && (kn--, er--);
              for (
                _isFunction(yn) && (yn = yn(It)),
                  yn = _parseClamp(yn, "start", It),
                  Bn =
                    _parsePosition(
                      yn,
                      P,
                      pi,
                      Ct,
                      _n(),
                      Yn,
                      rn,
                      It,
                      qr,
                      Pt,
                      qt,
                      Ir,
                      wt,
                      It._startClamp && "_startClamp"
                    ) || (de ? -0.001 : 0),
                  _isFunction($t) && ($t = $t(It)),
                  _isString($t) &&
                    !$t.indexOf("+=") &&
                    (~$t.indexOf(" ")
                      ? ($t = (_isString(yn) ? yn.split(" ")[0] : "") + $t)
                      : ((mi = _offsetToPx($t.substr(2), pi)),
                        ($t = _isString(yn)
                          ? yn
                          : (wt
                              ? gsap.utils.mapRange(
                                  0,
                                  wt.duration(),
                                  wt.scrollTrigger.start,
                                  wt.scrollTrigger.end,
                                  Bn
                                )
                              : Bn) + mi),
                        (un = P))),
                  $t = _parseClamp($t, "end", It),
                  jt =
                    Math.max(
                      Bn,
                      _parsePosition(
                        $t || (un ? "100% 0" : Ir),
                        un,
                        pi,
                        Ct,
                        _n() + mi,
                        zn,
                        In,
                        It,
                        qr,
                        Pt,
                        qt,
                        Ir,
                        wt,
                        It._endClamp && "_endClamp"
                      )
                    ) || -0.001,
                  mi = 0,
                  er = kn;
                er--;

              )
                (fn = _triggers[er]),
                  (wn = fn.pin),
                  wn &&
                    fn.start - fn._pinPush <= Bn &&
                    !wt &&
                    fn.end > 0 &&
                    ((Xn =
                      fn.end -
                      (It._startClamp ? Math.max(0, fn.start) : fn.start)),
                    ((wn === P && fn.start - fn._pinPush < Bn) || wn === Rn) &&
                      isNaN(yn) &&
                      (mi += Xn * (1 - fn.progress)),
                    wn === de && (Ut += Xn));
              if (
                ((Bn += mi),
                (jt += mi),
                It._startClamp && (It._startClamp += mi),
                It._endClamp &&
                  !_refreshingAll &&
                  ((It._endClamp = jt || -0.001),
                  (jt = Math.min(jt, _maxScroll(Dt, Ct)))),
                (Yt = jt - Bn || ((Bn -= 0.01) && 0.001)),
                Pi &&
                  (pn = gsap.utils.clamp(
                    0,
                    1,
                    gsap.utils.normalize(Bn, jt, hr)
                  )),
                (It._pinPush = Ut),
                Yn &&
                  mi &&
                  ((Xn = {}),
                  (Xn[Ct.a] = "+=" + mi),
                  Rn && (Xn[Ct.p] = "-=" + _n()),
                  gsap.set([Yn, zn], Xn)),
                de && !(_clampingMax && It.end >= _maxScroll(Dt, Ct)))
              )
                (Xn = _getComputedStyle(de)),
                  (an = Ct === _vertical),
                  (Zt = _n()),
                  (nr = parseFloat(Vn(Ct.a)) + Ut),
                  !Ir &&
                    jt > 1 &&
                    ((ar = (Ht ? _doc.scrollingElement || _docEl : Dt).style),
                    (ar = {
                      style: ar,
                      value: ar["overflow" + Ct.a.toUpperCase()],
                    }),
                    Ht &&
                      _getComputedStyle(_body)[
                        "overflow" + Ct.a.toUpperCase()
                      ] !== "scroll" &&
                      (ar.style["overflow" + Ct.a.toUpperCase()] = "scroll")),
                  _swapPinIn(de, Ln, Xn),
                  (En = _getState(de)),
                  (zt = _getBounds(de, !0)),
                  (On =
                    qt && _getScrollFunc(Dt, an ? _horizontal : _vertical)()),
                  me
                    ? ((jn = [me + Ct.os2, Yt + Ut + _px]),
                      (jn.t = Ln),
                      (er = me === _padding ? _getSize(de, Ct) + Yt + Ut : 0),
                      er &&
                        (jn.push(Ct.d, er + _px),
                        Ln.style.flexBasis !== "auto" &&
                          (Ln.style.flexBasis = er + _px)),
                      _setState(jn),
                      Rn &&
                        _triggers.forEach(function (gr) {
                          gr.pin === Rn &&
                            gr.vars.pinSpacing !== !1 &&
                            (gr._subPinOffset = !0);
                        }),
                      qt && _n(hr))
                    : ((er = _getSize(de, Ct)),
                      er &&
                        Ln.style.flexBasis !== "auto" &&
                        (Ln.style.flexBasis = er + _px)),
                  qt &&
                    ((Qt = {
                      top: zt.top + (an ? Zt - Bn : On) + _px,
                      left: zt.left + (an ? On : Zt - Bn) + _px,
                      boxSizing: "border-box",
                      position: "fixed",
                    }),
                    (Qt[_width] = Qt["max" + _Width] =
                      Math.ceil(zt.width) + _px),
                    (Qt[_height] = Qt["max" + _Height] =
                      Math.ceil(zt.height) + _px),
                    (Qt[_margin] =
                      Qt[_margin + _Top] =
                      Qt[_margin + _Right] =
                      Qt[_margin + _Bottom] =
                      Qt[_margin + _Left] =
                        "0"),
                    (Qt[_padding] = Xn[_padding]),
                    (Qt[_padding + _Top] = Xn[_padding + _Top]),
                    (Qt[_padding + _Right] = Xn[_padding + _Right]),
                    (Qt[_padding + _Bottom] = Xn[_padding + _Bottom]),
                    (Qt[_padding + _Left] = Xn[_padding + _Left]),
                    (hn = _copyState(Gt, Qt, xt)),
                    _refreshingAll && _n(0)),
                  s
                    ? ((Kn = s._initted),
                      _suppressOverwrites(1),
                      s.render(s.duration(), !0, !0),
                      (yr = Vn(Ct.a) - nr + Yt + Ut),
                      (mr = Math.abs(Yt - yr) > 1),
                      qt && mr && hn.splice(hn.length - 2, 2),
                      s.render(0, !0, !0),
                      Kn || s.invalidate(!0),
                      s.parent || s.totalTime(s.totalTime()),
                      _suppressOverwrites(0))
                    : (yr = Yt),
                  ar &&
                    (ar.value
                      ? (ar.style["overflow" + Ct.a.toUpperCase()] = ar.value)
                      : ar.style.removeProperty("overflow-" + Ct.a));
              else if (P && _n() && !wt)
                for (zt = P.parentNode; zt && zt !== _body; )
                  zt._pinOffset &&
                    ((Bn -= zt._pinOffset), (jt -= zt._pinOffset)),
                    (zt = zt.parentNode);
              Zn &&
                Zn.forEach(function (gr) {
                  return gr.revert(!1, !0);
                }),
                (It.start = Bn),
                (It.end = jt),
                (ur = _r = _refreshingAll ? hr : _n()),
                !wt &&
                  !_refreshingAll &&
                  (ur < hr && _n(hr), (It.scroll.rec = 0)),
                It.revert(!1, !0),
                (tn = _getTime()),
                Hn && ((Kt = -1), Hn.restart(!0)),
                (_refreshing = 0),
                s &&
                  kt &&
                  (s._initted || pr) &&
                  s.progress() !== pr &&
                  s.progress(pr || 0, !0).render(s.time(), !0, !0),
                (Pi || pn !== It.progress || wt || Ye || (s && !s._initted)) &&
                  (s &&
                    !kt &&
                    (s._initted || pn || s.vars.immediateRender !== !1) &&
                    s.totalProgress(
                      wt && Bn < -0.001 && !pn
                        ? gsap.utils.normalize(Bn, jt, 0)
                        : pn,
                      !0
                    ),
                  (It.progress = Pi || (ur - Bn) / Yt === pn ? 0 : pn)),
                de && me && (Ln._pinOffset = Math.round(It.progress * yr)),
                cn && cn.invalidate(),
                isNaN(cr) ||
                  ((cr -= gsap.getProperty(rn, Ct.p)),
                  (Qn -= gsap.getProperty(In, Ct.p)),
                  _shiftMarker(rn, Ct, cr),
                  _shiftMarker(Yn, Ct, cr - (zr || 0)),
                  _shiftMarker(In, Ct, Qn),
                  _shiftMarker(zn, Ct, Qn - (zr || 0))),
                Pi && !_refreshingAll && It.update(),
                p && !_refreshingAll && !Gn && ((Gn = !0), p(It), (Gn = !1));
            }
          }),
          (It.getVelocity = function () {
            return ((_n() - _r) / (_getTime() - _time2)) * 1e3 || 0;
          }),
          (It.endAnimation = function () {
            _endAnimation(It.callbackAnimation),
              s &&
                (cn
                  ? cn.progress(1)
                  : s.paused()
                  ? kt || _endAnimation(s, It.direction < 0, 1)
                  : _endAnimation(s, s.reversed()));
          }),
          (It.labelToScroll = function (xr) {
            return (
              (s &&
                s.labels &&
                (Bn || It.refresh() || Bn) +
                  (s.labels[xr] / s.duration()) * Yt) ||
              0
            );
          }),
          (It.getTrailing = function (xr) {
            var Fr = _triggers.indexOf(It),
              Cr =
                It.direction > 0
                  ? _triggers.slice(0, Fr).reverse()
                  : _triggers.slice(Fr + 1);
            return (
              _isString(xr)
                ? Cr.filter(function (zr) {
                    return zr.vars.preventOverlaps === xr;
                  })
                : Cr
            ).filter(function (zr) {
              return It.direction > 0 ? zr.end <= Bn : zr.start >= jt;
            });
          }),
          (It.update = function (xr, Fr, Cr) {
            if (!(wt && !Cr && !xr)) {
              var zr = _refreshingAll === !0 ? hr : It.scroll(),
                pi = xr ? 0 : (zr - Bn) / Yt,
                qr = pi < 0 ? 0 : pi > 1 ? 1 : pi || 0,
                Ir = It.progress,
                Pi,
                mi,
                Ut,
                $t,
                un,
                yn,
                Rn,
                kn;
              if (
                (Fr &&
                  ((_r = ur),
                  (ur = wt ? _n() : zr),
                  vt && ((Hr = Pr), (Pr = s && !kt ? s.totalProgress() : qr))),
                nt &&
                  de &&
                  !_refreshing &&
                  !_startup &&
                  _lastScrollTime &&
                  (!qr && Bn < zr + ((zr - _r) / (_getTime() - _time2)) * nt
                    ? (qr = 1e-4)
                    : qr === 1 &&
                      jt > zr + ((zr - _r) / (_getTime() - _time2)) * nt &&
                      (qr = 0.9999)),
                qr !== Ir && It.enabled)
              ) {
                if (
                  ((Pi = It.isActive = !!qr && qr < 1),
                  (mi = !!Ir && Ir < 1),
                  (yn = Pi !== mi),
                  (un = yn || !!qr != !!Ir),
                  (It.direction = qr > Ir ? 1 : -1),
                  (It.progress = qr),
                  un &&
                    !_refreshing &&
                    ((Ut = qr && !Ir ? 0 : qr === 1 ? 1 : Ir === 1 ? 2 : 3),
                    kt &&
                      (($t =
                        (!yn && Bt[Ut + 1] !== "none" && Bt[Ut + 1]) || Bt[Ut]),
                      (kn =
                        s &&
                        ($t === "complete" || $t === "reset" || $t in s)))),
                  Tt &&
                    (yn || kn) &&
                    (kn || N || !s) &&
                    (_isFunction(Tt)
                      ? Tt(It)
                      : It.getTrailing(Tt).forEach(function (Zt) {
                          return Zt.endAnimation();
                        })),
                  kt ||
                    (cn && !_refreshing && !_startup
                      ? (cn._dp._time - cn._start !== cn._time &&
                          cn.render(cn._dp._time - cn._start),
                        cn.resetTo
                          ? cn.resetTo("totalProgress", qr, s._tTime / s._tDur)
                          : ((cn.vars.totalProgress = qr),
                            cn.invalidate().restart()))
                      : s &&
                        s.totalProgress(qr, !!(_refreshing && (tn || xr)))),
                  de)
                ) {
                  if ((xr && me && (Ln.style[me + Ct.os2] = qn), !qt))
                    Fn(_round(nr + yr * qr));
                  else if (un) {
                    if (
                      ((Rn =
                        !xr &&
                        qr > Ir &&
                        jt + 1 > zr &&
                        zr + 1 >= _maxScroll(Dt, Ct)),
                      xt)
                    )
                      if (!xr && (Pi || Rn)) {
                        var er = _getBounds(de, !0),
                          Xn = zr - Bn;
                        _reparent(
                          de,
                          _body,
                          er.top + (Ct === _vertical ? Xn : 0) + _px,
                          er.left + (Ct === _vertical ? 0 : Xn) + _px
                        );
                      } else _reparent(de, Ln);
                    _setState(Pi || Rn ? hn : En),
                      (mr && qr < 1 && Pi) ||
                        Fn(nr + (qr === 1 && !Rn ? yr : 0));
                  }
                }
                vt && !bn.tween && !_refreshing && !_startup && Hn.restart(!0),
                  l &&
                    (yn || (st && qr && (qr < 1 || !_limitCallbacks))) &&
                    _toArray(l.targets).forEach(function (Zt) {
                      return Zt.classList[Pi || st ? "add" : "remove"](
                        l.className
                      );
                    }),
                  a && !kt && !xr && a(It),
                  un && !_refreshing
                    ? (kt &&
                        (kn &&
                          ($t === "complete"
                            ? s.pause().totalProgress(1)
                            : $t === "reset"
                            ? s.restart(!0).pause()
                            : $t === "restart"
                            ? s.restart(!0)
                            : s[$t]()),
                        a && a(It)),
                      (yn || !_limitCallbacks) &&
                        (u && yn && _callback(It, u),
                        Ft[Ut] && _callback(It, Ft[Ut]),
                        st && (qr === 1 ? It.kill(!1, 1) : (Ft[Ut] = 0)),
                        yn ||
                          ((Ut = qr === 1 ? 1 : 3),
                          Ft[Ut] && _callback(It, Ft[Ut]))),
                      bt &&
                        !Pi &&
                        Math.abs(It.getVelocity()) >
                          (_isNumber(bt) ? bt : 2500) &&
                        (_endAnimation(It.callbackAnimation),
                        cn
                          ? cn.progress(1)
                          : _endAnimation(s, $t === "reverse" ? 1 : !qr, 1)))
                    : kt && a && !_refreshing && a(It);
              }
              if (Sr) {
                var zt = wt
                  ? (zr / wt.duration()) * (wt._caScrollDist || 0)
                  : zr;
                Jn(zt + (rn._isFlipped ? 1 : 0)), Sr(zt);
              }
              jr && jr((-zr / wt.duration()) * (wt._caScrollDist || 0));
            }
          }),
          (It.enable = function (xr, Fr) {
            It.enabled ||
              ((It.enabled = !0),
              _addListener(Dt, "resize", _onResize),
              Ht || _addListener(Dt, "scroll", _onScroll),
              Ot && _addListener(n, "refreshInit", Ot),
              xr !== !1 && ((It.progress = pn = 0), (ur = _r = Kt = _n())),
              Fr !== !1 && It.refresh());
          }),
          (It.getTween = function (xr) {
            return xr && bn ? bn.tween : cn;
          }),
          (It.setPositions = function (xr, Fr, Cr, zr) {
            if (wt) {
              var pi = wt.scrollTrigger,
                qr = wt.duration(),
                Ir = pi.end - pi.start;
              (xr = pi.start + (Ir * xr) / qr),
                (Fr = pi.start + (Ir * Fr) / qr);
            }
            It.refresh(
              !1,
              !1,
              {
                start: _keepClamp(xr, Cr && !!It._startClamp),
                end: _keepClamp(Fr, Cr && !!It._endClamp),
              },
              zr
            ),
              It.update();
          }),
          (It.adjustPinSpacing = function (xr) {
            if (jn && xr) {
              var Fr = jn.indexOf(Ct.d) + 1;
              (jn[Fr] = parseFloat(jn[Fr]) + xr + _px),
                (jn[1] = parseFloat(jn[1]) + xr + _px),
                _setState(jn);
            }
          }),
          (It.disable = function (xr, Fr) {
            if (
              It.enabled &&
              (xr !== !1 && It.revert(!0, !0),
              (It.enabled = It.isActive = !1),
              Fr || (cn && cn.pause()),
              (hr = 0),
              $n && ($n.uncache = 1),
              Ot && _removeListener(n, "refreshInit", Ot),
              Hn && (Hn.pause(), bn.tween && bn.tween.kill() && (bn.tween = 0)),
              !Ht)
            ) {
              for (var Cr = _triggers.length; Cr--; )
                if (_triggers[Cr].scroller === Dt && _triggers[Cr] !== It)
                  return;
              _removeListener(Dt, "resize", _onResize),
                Ht || _removeListener(Dt, "scroll", _onScroll);
            }
          }),
          (It.kill = function (xr, Fr) {
            It.disable(xr, Fr), cn && !Fr && cn.kill(), c && delete _ids[c];
            var Cr = _triggers.indexOf(It);
            Cr >= 0 && _triggers.splice(Cr, 1),
              Cr === _i && _direction > 0 && _i--,
              (Cr = 0),
              _triggers.forEach(function (zr) {
                return zr.scroller === It.scroller && (Cr = 1);
              }),
              Cr || _refreshingAll || (It.scroll.rec = 0),
              s &&
                ((s.scrollTrigger = null),
                xr && s.revert({ kill: !1 }),
                Fr || s.kill()),
              Yn &&
                [Yn, zn, rn, In].forEach(function (zr) {
                  return zr.parentNode && zr.parentNode.removeChild(zr);
                }),
              _primary === It && (_primary = 0),
              de &&
                ($n && ($n.uncache = 1),
                (Cr = 0),
                _triggers.forEach(function (zr) {
                  return zr.pin === de && Cr++;
                }),
                Cr || ($n.spacer = 0)),
              r.onKill && r.onKill(It);
          }),
          _triggers.push(It),
          It.enable(!1, !1),
          fi && fi(It),
          s && s.add && !Yt)
        ) {
          var $r = It.update;
          (It.update = function () {
            (It.update = $r), _scrollers.cache++, Bn || jt || It.refresh();
          }),
            gsap.delayedCall(0.01, It.update),
            (Yt = 0.01),
            (Bn = jt = 0);
        } else It.refresh();
        de && _queueRefreshAll();
      }),
      (n.register = function (r) {
        return (
          _coreInitted ||
            ((gsap = r || _getGSAP()),
            _windowExists() && window.document && n.enable(),
            (_coreInitted = _enabled)),
          _coreInitted
        );
      }),
      (n.defaults = function (r) {
        if (r) for (var s in r) _defaults[s] = r[s];
        return _defaults;
      }),
      (n.disable = function (r, s) {
        (_enabled = 0),
          _triggers.forEach(function (a) {
            return a[s ? "kill" : "disable"](r);
          }),
          _removeListener(_win, "wheel", _onScroll),
          _removeListener(_doc, "scroll", _onScroll),
          clearInterval(_syncInterval),
          _removeListener(_doc, "touchcancel", _passThrough),
          _removeListener(_body, "touchstart", _passThrough),
          _multiListener(
            _removeListener,
            _doc,
            "pointerdown,touchstart,mousedown",
            _pointerDownHandler
          ),
          _multiListener(
            _removeListener,
            _doc,
            "pointerup,touchend,mouseup",
            _pointerUpHandler
          ),
          _resizeDelay.kill(),
          _iterateAutoRefresh(_removeListener);
        for (var o = 0; o < _scrollers.length; o += 3)
          _wheelListener(_removeListener, _scrollers[o], _scrollers[o + 1]),
            _wheelListener(_removeListener, _scrollers[o], _scrollers[o + 2]);
      }),
      (n.enable = function () {
        if (
          ((_win = window),
          (_doc = document),
          (_docEl = _doc.documentElement),
          (_body = _doc.body),
          gsap &&
            ((_toArray = gsap.utils.toArray),
            (_clamp = gsap.utils.clamp),
            (_context = gsap.core.context || _passThrough),
            (_suppressOverwrites =
              gsap.core.suppressOverwrites || _passThrough),
            (_scrollRestoration = _win.history.scrollRestoration || "auto"),
            (_lastScroll = _win.pageYOffset || 0),
            gsap.core.globals("ScrollTrigger", n),
            _body))
        ) {
          (_enabled = 1),
            (_div100vh = document.createElement("div")),
            (_div100vh.style.height = "100vh"),
            (_div100vh.style.position = "absolute"),
            _refresh100vh(),
            _rafBugFix(),
            Observer.register(gsap),
            (n.isTouch = Observer.isTouch),
            (_fixIOSBug =
              Observer.isTouch &&
              /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
            (_ignoreMobileResize = Observer.isTouch === 1),
            _addListener(_win, "wheel", _onScroll),
            (_root = [_win, _doc, _docEl, _body]),
            gsap.matchMedia
              ? ((n.matchMedia = function (u) {
                  var p = gsap.matchMedia(),
                    N;
                  for (N in u) p.add(N, u[N]);
                  return p;
                }),
                gsap.addEventListener("matchMediaInit", function () {
                  return _revertAll();
                }),
                gsap.addEventListener("matchMediaRevert", function () {
                  return _revertRecorded();
                }),
                gsap.addEventListener("matchMedia", function () {
                  _refreshAll(0, 1), _dispatch("matchMedia");
                }),
                gsap.matchMedia().add("(orientation: portrait)", function () {
                  return _setBaseDimensions(), _setBaseDimensions;
                }))
              : console.warn("Requires GSAP 3.11.0 or later"),
            _setBaseDimensions(),
            _addListener(_doc, "scroll", _onScroll);
          var r = _body.hasAttribute("style"),
            s = _body.style,
            o = s.borderTopStyle,
            a = gsap.core.Animation.prototype,
            l,
            c;
          for (
            a.revert ||
              Object.defineProperty(a, "revert", {
                value: function () {
                  return this.time(-0.01, !0);
                },
              }),
              s.borderTopStyle = "solid",
              l = _getBounds(_body),
              _vertical.m = Math.round(l.top + _vertical.sc()) || 0,
              _horizontal.m = Math.round(l.left + _horizontal.sc()) || 0,
              o ? (s.borderTopStyle = o) : s.removeProperty("border-top-style"),
              r ||
                (_body.setAttribute("style", ""),
                _body.removeAttribute("style")),
              _syncInterval = setInterval(_sync, 250),
              gsap.delayedCall(0.5, function () {
                return (_startup = 0);
              }),
              _addListener(_doc, "touchcancel", _passThrough),
              _addListener(_body, "touchstart", _passThrough),
              _multiListener(
                _addListener,
                _doc,
                "pointerdown,touchstart,mousedown",
                _pointerDownHandler
              ),
              _multiListener(
                _addListener,
                _doc,
                "pointerup,touchend,mouseup",
                _pointerUpHandler
              ),
              _transformProp = gsap.utils.checkPrefix("transform"),
              _stateProps.push(_transformProp),
              _coreInitted = _getTime(),
              _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause(),
              _autoRefresh = [
                _doc,
                "visibilitychange",
                function () {
                  var u = _win.innerWidth,
                    p = _win.innerHeight;
                  _doc.hidden
                    ? ((_prevWidth = u), (_prevHeight = p))
                    : (_prevWidth !== u || _prevHeight !== p) && _onResize();
                },
                _doc,
                "DOMContentLoaded",
                _refreshAll,
                _win,
                "load",
                _refreshAll,
                _win,
                "resize",
                _onResize,
              ],
              _iterateAutoRefresh(_addListener),
              _triggers.forEach(function (u) {
                return u.enable(0, 1);
              }),
              c = 0;
            c < _scrollers.length;
            c += 3
          )
            _wheelListener(_removeListener, _scrollers[c], _scrollers[c + 1]),
              _wheelListener(_removeListener, _scrollers[c], _scrollers[c + 2]);
        }
      }),
      (n.config = function (r) {
        "limitCallbacks" in r && (_limitCallbacks = !!r.limitCallbacks);
        var s = r.syncInterval;
        (s && clearInterval(_syncInterval)) ||
          ((_syncInterval = s) && setInterval(_sync, s)),
          "ignoreMobileResize" in r &&
            (_ignoreMobileResize = n.isTouch === 1 && r.ignoreMobileResize),
          "autoRefreshEvents" in r &&
            (_iterateAutoRefresh(_removeListener) ||
              _iterateAutoRefresh(_addListener, r.autoRefreshEvents || "none"),
            (_ignoreResize =
              (r.autoRefreshEvents + "").indexOf("resize") === -1));
      }),
      (n.scrollerProxy = function (r, s) {
        var o = _getTarget(r),
          a = _scrollers.indexOf(o),
          l = _isViewport(o);
        ~a && _scrollers.splice(a, l ? 6 : 2),
          s &&
            (l
              ? _proxies.unshift(_win, s, _body, s, _docEl, s)
              : _proxies.unshift(o, s));
      }),
      (n.clearMatchMedia = function (r) {
        _triggers.forEach(function (s) {
          return s._ctx && s._ctx.query === r && s._ctx.kill(!0, !0);
        });
      }),
      (n.isInViewport = function (r, s, o) {
        var a = (_isString(r) ? _getTarget(r) : r).getBoundingClientRect(),
          l = a[o ? _width : _height] * s || 0;
        return o
          ? a.right - l > 0 && a.left + l < _win.innerWidth
          : a.bottom - l > 0 && a.top + l < _win.innerHeight;
      }),
      (n.positionInViewport = function (r, s, o) {
        _isString(r) && (r = _getTarget(r));
        var a = r.getBoundingClientRect(),
          l = a[o ? _width : _height],
          c =
            s == null
              ? l / 2
              : s in _keywords
              ? _keywords[s] * l
              : ~s.indexOf("%")
              ? (parseFloat(s) * l) / 100
              : parseFloat(s) || 0;
        return o
          ? (a.left + c) / _win.innerWidth
          : (a.top + c) / _win.innerHeight;
      }),
      (n.killAll = function (r) {
        if (
          (_triggers.slice(0).forEach(function (o) {
            return o.vars.id !== "ScrollSmoother" && o.kill();
          }),
          r !== !0)
        ) {
          var s = _listeners.killAll || [];
          (_listeners = {}),
            s.forEach(function (o) {
              return o();
            });
        }
      }),
      n
    );
  })();
ScrollTrigger.version = "3.13.0";
ScrollTrigger.saveStyles = function (n) {
  return n
    ? _toArray(n).forEach(function (e) {
        if (e && e.style) {
          var t = _savedStyles.indexOf(e);
          t >= 0 && _savedStyles.splice(t, 5),
            _savedStyles.push(
              e,
              e.style.cssText,
              e.getBBox && e.getAttribute("transform"),
              gsap.core.getCache(e),
              _context()
            );
        }
      })
    : _savedStyles;
};
ScrollTrigger.revert = function (n, e) {
  return _revertAll(!n, e);
};
ScrollTrigger.create = function (n, e) {
  return new ScrollTrigger(n, e);
};
ScrollTrigger.refresh = function (n) {
  return n
    ? _onResize(!0)
    : (_coreInitted || ScrollTrigger.register()) && _refreshAll(!0);
};
ScrollTrigger.update = function (n) {
  return ++_scrollers.cache && _updateAll(n === !0 ? 2 : 0);
};
ScrollTrigger.clearScrollMemory = _clearScrollMemory;
ScrollTrigger.maxScroll = function (n, e) {
  return _maxScroll(n, e ? _horizontal : _vertical);
};
ScrollTrigger.getScrollFunc = function (n, e) {
  return _getScrollFunc(_getTarget(n), e ? _horizontal : _vertical);
};
ScrollTrigger.getById = function (n) {
  return _ids[n];
};
ScrollTrigger.getAll = function () {
  return _triggers.filter(function (n) {
    return n.vars.id !== "ScrollSmoother";
  });
};
ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};
ScrollTrigger.snapDirectional = _snapDirectional;
ScrollTrigger.addEventListener = function (n, e) {
  var t = _listeners[n] || (_listeners[n] = []);
  ~t.indexOf(e) || t.push(e);
};
ScrollTrigger.removeEventListener = function (n, e) {
  var t = _listeners[n],
    r = t && t.indexOf(e);
  r >= 0 && t.splice(r, 1);
};
ScrollTrigger.batch = function (n, e) {
  var t = [],
    r = {},
    s = e.interval || 0.016,
    o = e.batchMax || 1e9,
    a = function (u, p) {
      var N = [],
        P = [],
        de = gsap
          .delayedCall(s, function () {
            p(N, P), (N = []), (P = []);
          })
          .pause();
      return function (me) {
        N.length || de.restart(!0),
          N.push(me.trigger),
          P.push(me),
          o <= N.length && de.progress(1);
      };
    },
    l;
  for (l in e)
    r[l] =
      l.substr(0, 2) === "on" && _isFunction(e[l]) && l !== "onRefreshInit"
        ? a(l, e[l])
        : e[l];
  return (
    _isFunction(o) &&
      ((o = o()),
      _addListener(ScrollTrigger, "refresh", function () {
        return (o = e.batchMax());
      })),
    _toArray(n).forEach(function (c) {
      var u = {};
      for (l in r) u[l] = r[l];
      (u.trigger = c), t.push(ScrollTrigger.create(u));
    }),
    t
  );
};
var _clampScrollAndGetDurationMultiplier = function (e, t, r, s) {
    return (
      t > s ? e(s) : t < 0 && e(0),
      r > s ? (s - t) / (r - t) : r < 0 ? t / (t - r) : 1
    );
  },
  _allowNativePanning = function n(e, t) {
    t === !0
      ? e.style.removeProperty("touch-action")
      : (e.style.touchAction =
          t === !0
            ? "auto"
            : t
            ? "pan-" + t + (Observer.isTouch ? " pinch-zoom" : "")
            : "none"),
      e === _docEl && n(_body, t);
  },
  _overflow = { auto: 1, scroll: 1 },
  _nestedScroll = function (e) {
    var t = e.event,
      r = e.target,
      s = e.axis,
      o = (t.changedTouches ? t.changedTouches[0] : t).target,
      a = o._gsap || gsap.core.getCache(o),
      l = _getTime(),
      c;
    if (!a._isScrollT || l - a._isScrollT > 2e3) {
      for (
        ;
        o &&
        o !== _body &&
        ((o.scrollHeight <= o.clientHeight && o.scrollWidth <= o.clientWidth) ||
          !(
            _overflow[(c = _getComputedStyle(o)).overflowY] ||
            _overflow[c.overflowX]
          ));

      )
        o = o.parentNode;
      (a._isScroll =
        o &&
        o !== r &&
        !_isViewport(o) &&
        (_overflow[(c = _getComputedStyle(o)).overflowY] ||
          _overflow[c.overflowX])),
        (a._isScrollT = l);
    }
    (a._isScroll || s === "x") && (t.stopPropagation(), (t._gsapAllow = !0));
  },
  _inputObserver = function (e, t, r, s) {
    return Observer.create({
      target: e,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: t,
      onWheel: (s = s && _nestedScroll),
      onPress: s,
      onDrag: s,
      onScroll: s,
      onEnable: function () {
        return (
          r &&
          _addListener(_doc, Observer.eventTypes[0], _captureInputs, !1, !0)
        );
      },
      onDisable: function () {
        return _removeListener(
          _doc,
          Observer.eventTypes[0],
          _captureInputs,
          !0
        );
      },
    });
  },
  _inputExp = /(input|label|select|textarea)/i,
  _inputIsFocused,
  _captureInputs = function (e) {
    var t = _inputExp.test(e.target.tagName);
    (t || _inputIsFocused) && ((e._gsapAllow = !0), (_inputIsFocused = t));
  },
  _getScrollNormalizer = function (e) {
    _isObject(e) || (e = {}),
      (e.preventDefault = e.isNormalizer = e.allowClicks = !0),
      e.type || (e.type = "wheel,touch"),
      (e.debounce = !!e.debounce),
      (e.id = e.id || "normalizer");
    var t = e,
      r = t.normalizeScrollX,
      s = t.momentum,
      o = t.allowNestedScroll,
      a = t.onRelease,
      l,
      c,
      u = _getTarget(e.target) || _docEl,
      p = gsap.core.globals().ScrollSmoother,
      N = p && p.get(),
      P =
        _fixIOSBug &&
        ((e.content && _getTarget(e.content)) ||
          (N && e.content !== !1 && !N.smooth() && N.content())),
      de = _getScrollFunc(u, _vertical),
      me = _getScrollFunc(u, _horizontal),
      Ye = 1,
      nt =
        (Observer.isTouch && _win.visualViewport
          ? _win.visualViewport.scale * _win.visualViewport.width
          : _win.outerWidth) / _win.innerWidth,
      Be = 0,
      ot = _isFunction(s)
        ? function () {
            return s(l);
          }
        : function () {
            return s || 2.8;
          },
      st,
      vt,
      xt = _inputObserver(u, e.type, !0, o),
      St = function () {
        return (vt = !1);
      },
      wt = _passThrough,
      bt = _passThrough,
      Tt = function () {
        (c = _maxScroll(u, _vertical)),
          (bt = _clamp(_fixIOSBug ? 1 : 0, c)),
          r && (wt = _clamp(0, _maxScroll(u, _horizontal))),
          (st = _refreshID);
      },
      Ct = function () {
        (P._gsap.y = _round(parseFloat(P._gsap.y) + de.offset) + "px"),
          (P.style.transform =
            "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
            parseFloat(P._gsap.y) +
            ", 0, 1)"),
          (de.offset = de.cacheID = 0);
      },
      kt = function () {
        if (vt) {
          requestAnimationFrame(St);
          var Mt = _round(l.deltaY / 2),
            Pt = bt(de.v - Mt);
          if (P && Pt !== de.v + de.offset) {
            de.offset = Pt - de.v;
            var It = _round((parseFloat(P && P._gsap.y) || 0) - de.offset);
            (P.style.transform =
              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
              It +
              ", 0, 1)"),
              (P._gsap.y = It + "px"),
              (de.cacheID = _scrollers.cache),
              _updateAll();
          }
          return !0;
        }
        de.offset && Ct(), (vt = !0);
      },
      Dt,
      Vt,
      Ht,
      qt,
      Ft = function () {
        Tt(),
          Dt.isActive() &&
            Dt.vars.scrollY > c &&
            (de() > c ? Dt.progress(1) && de(c) : Dt.resetTo("scrollY", c));
      };
    return (
      P && gsap.set(P, { y: "+=0" }),
      (e.ignoreCheck = function (Bt) {
        return (
          (_fixIOSBug && Bt.type === "touchmove" && kt()) ||
          (Ye > 1.05 && Bt.type !== "touchstart") ||
          l.isGesturing ||
          (Bt.touches && Bt.touches.length > 1)
        );
      }),
      (e.onPress = function () {
        vt = !1;
        var Bt = Ye;
        (Ye = _round(
          ((_win.visualViewport && _win.visualViewport.scale) || 1) / nt
        )),
          Dt.pause(),
          Bt !== Ye && _allowNativePanning(u, Ye > 1.01 ? !0 : r ? !1 : "x"),
          (Vt = me()),
          (Ht = de()),
          Tt(),
          (st = _refreshID);
      }),
      (e.onRelease = e.onGestureStart =
        function (Bt, Mt) {
          if ((de.offset && Ct(), !Mt)) qt.restart(!0);
          else {
            _scrollers.cache++;
            var Pt = ot(),
              It,
              Ot;
            r &&
              ((It = me()),
              (Ot = It + (Pt * 0.05 * -Bt.velocityX) / 0.227),
              (Pt *= _clampScrollAndGetDurationMultiplier(
                me,
                It,
                Ot,
                _maxScroll(u, _horizontal)
              )),
              (Dt.vars.scrollX = wt(Ot))),
              (It = de()),
              (Ot = It + (Pt * 0.05 * -Bt.velocityY) / 0.227),
              (Pt *= _clampScrollAndGetDurationMultiplier(
                de,
                It,
                Ot,
                _maxScroll(u, _vertical)
              )),
              (Dt.vars.scrollY = bt(Ot)),
              Dt.invalidate().duration(Pt).play(0.01),
              ((_fixIOSBug && Dt.vars.scrollY >= c) || It >= c - 1) &&
                gsap.to({}, { onUpdate: Ft, duration: Pt });
          }
          a && a(Bt);
        }),
      (e.onWheel = function () {
        Dt._ts && Dt.pause(),
          _getTime() - Be > 1e3 && ((st = 0), (Be = _getTime()));
      }),
      (e.onChange = function (Bt, Mt, Pt, It, Ot) {
        if (
          (_refreshID !== st && Tt(),
          Mt &&
            r &&
            me(wt(It[2] === Mt ? Vt + (Bt.startX - Bt.x) : me() + Mt - It[1])),
          Pt)
        ) {
          de.offset && Ct();
          var Xt = Ot[2] === Pt,
            sn = Xt ? Ht + Bt.startY - Bt.y : de() + Pt - Ot[1],
            Kt = bt(sn);
          Xt && sn !== Kt && (Ht += Kt - sn), de(Kt);
        }
        (Pt || Mt) && _updateAll();
      }),
      (e.onEnable = function () {
        _allowNativePanning(u, r ? !1 : "x"),
          ScrollTrigger.addEventListener("refresh", Ft),
          _addListener(_win, "resize", Ft),
          de.smooth &&
            ((de.target.style.scrollBehavior = "auto"),
            (de.smooth = me.smooth = !1)),
          xt.enable();
      }),
      (e.onDisable = function () {
        _allowNativePanning(u, !0),
          _removeListener(_win, "resize", Ft),
          ScrollTrigger.removeEventListener("refresh", Ft),
          xt.kill();
      }),
      (e.lockAxis = e.lockAxis !== !1),
      (l = new Observer(e)),
      (l.iOS = _fixIOSBug),
      _fixIOSBug && !de() && de(1),
      _fixIOSBug && gsap.ticker.add(_passThrough),
      (qt = l._dc),
      (Dt = gsap.to(l, {
        ease: "power4",
        paused: !0,
        inherit: !1,
        scrollX: r ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
          scrollY: _interruptionTracker(de, de(), function () {
            return Dt.pause();
          }),
        },
        onUpdate: _updateAll,
        onComplete: qt.vars.onComplete,
      })),
      l
    );
  };
ScrollTrigger.sort = function (n) {
  if (_isFunction(n)) return _triggers.sort(n);
  var e = _win.pageYOffset || 0;
  return (
    ScrollTrigger.getAll().forEach(function (t) {
      return (t._sortY = t.trigger
        ? e + t.trigger.getBoundingClientRect().top
        : t.start + _win.innerHeight);
    }),
    _triggers.sort(
      n ||
        function (t, r) {
          return (
            (t.vars.refreshPriority || 0) * -1e6 +
            (t.vars.containerAnimation ? 1e6 : t._sortY) -
            ((r.vars.containerAnimation ? 1e6 : r._sortY) +
              (r.vars.refreshPriority || 0) * -1e6)
          );
        }
    )
  );
};
ScrollTrigger.observe = function (n) {
  return new Observer(n);
};
ScrollTrigger.normalizeScroll = function (n) {
  if (typeof n > "u") return _normalizer;
  if (n === !0 && _normalizer) return _normalizer.enable();
  if (n === !1) {
    _normalizer && _normalizer.kill(), (_normalizer = n);
    return;
  }
  var e = n instanceof Observer ? n : _getScrollNormalizer(n);
  return (
    _normalizer && _normalizer.target === e.target && _normalizer.kill(),
    _isViewport(e.target) && (_normalizer = e),
    e
  );
};
ScrollTrigger.core = {
  _getVelocityProp,
  _inputObserver,
  _scrollers,
  _proxies,
  bridge: {
    ss: function () {
      _lastScrollTime || _dispatch("scrollStart"),
        (_lastScrollTime = _getTime());
    },
    ref: function () {
      return _refreshing;
    },
  },
};
_getGSAP() && gsap.registerPlugin(ScrollTrigger);
gsapWithCSS.registerPlugin(ScrollTrigger);
ScrollTrigger.defaults({ fastScrollEnd: !0, scrub: !0 });
const AnimationProcessor = React.memo(({ particlesRef: n }) => {
  const { deviceType: e, isTouchDevices: t } = useDeviceType(),
    { model: r, setSnakeCameraFactor: s } = useLandingContext(),
    o = document.getElementById("globalCanvas"),
    a = [
      "mainBlock",
      "videoBlock",
      "legend",
      "howItWorks",
      "features",
      "roadmap",
      "workWithUs",
    ],
    l = (N, P, de) => {
      r &&
        ((r.position.x = gsapWithCSS.utils.interpolate(N.pos.x, P.pos.x, de)),
        (r.position.y = gsapWithCSS.utils.interpolate(N.pos.y, P.pos.y, de)),
        (r.position.z = gsapWithCSS.utils.interpolate(N.pos.z, P.pos.z, de)),
        (r.rotation.x = gsapWithCSS.utils.interpolate(
          N.rotation.x,
          P.rotation.x,
          de
        )),
        (r.rotation.y = gsapWithCSS.utils.interpolate(
          N.rotation.y,
          P.rotation.y,
          de
        )),
        (r.rotation.z = gsapWithCSS.utils.interpolate(
          N.rotation.z,
          P.rotation.z,
          de
        )));
    },
    c = (N, P, de) => {
      if (!(n != null && n.current)) return;
      const me = particlesPosition[e][N],
        Ye = particlesPosition[e][P];
      (n.current.position.x = gsapWithCSS.utils.interpolate(
        me.pos.x,
        Ye.pos.x,
        de
      )),
        (n.current.position.y = gsapWithCSS.utils.interpolate(
          me.pos.y,
          Ye.pos.y,
          de
        )),
        (n.current.position.z = gsapWithCSS.utils.interpolate(
          me.pos.z,
          Ye.pos.z,
          de
        )),
        (n.current.rotation.x = gsapWithCSS.utils.interpolate(
          me.rotation.x,
          Ye.rotation.x,
          de
        )),
        (n.current.rotation.y = gsapWithCSS.utils.interpolate(
          me.rotation.y,
          Ye.rotation.y,
          de
        )),
        (n.current.rotation.z = gsapWithCSS.utils.interpolate(
          me.rotation.z,
          Ye.rotation.z,
          de
        ));
    },
    u = (N, P, de) => {
      if (!o) return;
      const me = gradientPosition[N],
        Ye = gradientPosition[P],
        nt = gsapWithCSS.utils.interpolate(me.x, Ye.x, de),
        Be = gsapWithCSS.utils.interpolate(me.y, Ye.y, de),
        ot = gsapWithCSS.utils.interpolate(me.z, Ye.z, de);
      o.style.background = `radial-gradient(circle at ${nt}% ${Be}%, #1b1b2f, #0f0f1f ${ot}%, #000000 100%)`;
    };
  reactExports.useLayoutEffect(() => {
    r &&
      o &&
      a.forEach((N, P) => {
        const de = a[P + 1];
        de &&
          ScrollTrigger.create({
            trigger: `#${N}`,
            start: t ? "center" : "top top",
            end: t ? "bottom 10%" : "bottom",
            scrub: !t,
            onUpdate: (me) => {
              const Ye = me.progress,
                nt = sintPosition[e][N],
                Be = sintPosition[e][de];
              l(nt, Be, Ye),
                e === "desktop" &&
                  (c(N, de, Ye),
                  u(N, de, Ye),
                  Ye > 0.1 && Ye < 0.2 && s(snakeCameraFactor[de]));
            },
          });
      });
  }, [r, n, o, s]);
  const p = reactExports.useCallback(() => {
    ScrollTrigger.refresh();
  }, [ScrollTrigger]);
  return (
    reactExports.useEffect(() => {
      if (e === "desktop") {
        const N = document.getElementById("blocksContainer");
        return (
          N && N.addEventListener("scroll", p),
          () => {
            N && N.removeEventListener("scroll", p);
          }
        );
      }
    }, [e]),
    reactExports.useEffect(() => {
      if (t) {
        const N = () => {
          setTimeout(p, 20);
        };
        return (
          window.addEventListener("orientationchange", N),
          () => {
            window.removeEventListener("orientationchange", N);
          }
        );
      }
    }, [t]),
    null
  );
});
function _extends() {
  return (
    (_extends = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    _extends.apply(null, arguments)
  );
}
const version$1 = parseInt(REVISION.replace(/\D+/g, ""));
var u8 = Uint8Array,
  u16 = Uint16Array,
  u32 = Uint32Array,
  fleb = new u8([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  fdeb = new u8([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  clim = new u8([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  freb = function (n, e) {
    for (var t = new u16(31), r = 0; r < 31; ++r) t[r] = e += 1 << n[r - 1];
    for (var s = new u32(t[30]), r = 1; r < 30; ++r)
      for (var o = t[r]; o < t[r + 1]; ++o) s[o] = ((o - t[r]) << 5) | r;
    return [t, s];
  },
  _a = freb(fleb, 2),
  fl = _a[0],
  revfl = _a[1];
(fl[28] = 258), (revfl[258] = 28);
var _b = freb(fdeb, 0),
  fd = _b[0],
  rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
  var x = ((i & 43690) >>> 1) | ((i & 21845) << 1);
  (x = ((x & 52428) >>> 2) | ((x & 13107) << 2)),
    (x = ((x & 61680) >>> 4) | ((x & 3855) << 4)),
    (rev[i] = (((x & 65280) >>> 8) | ((x & 255) << 8)) >>> 1);
}
var hMap = function (n, e, t) {
    for (var r = n.length, s = 0, o = new u16(e); s < r; ++s) ++o[n[s] - 1];
    var a = new u16(e);
    for (s = 0; s < e; ++s) a[s] = (a[s - 1] + o[s - 1]) << 1;
    var l;
    if (t) {
      l = new u16(1 << e);
      var c = 15 - e;
      for (s = 0; s < r; ++s)
        if (n[s])
          for (
            var u = (s << 4) | n[s],
              p = e - n[s],
              N = a[n[s] - 1]++ << p,
              P = N | ((1 << p) - 1);
            N <= P;
            ++N
          )
            l[rev[N] >>> c] = u;
    } else
      for (l = new u16(r), s = 0; s < r; ++s)
        n[s] && (l[s] = rev[a[n[s] - 1]++] >>> (15 - n[s]));
    return l;
  },
  flt = new u8(288);
for (var i = 0; i < 144; ++i) flt[i] = 8;
for (var i = 144; i < 256; ++i) flt[i] = 9;
for (var i = 256; i < 280; ++i) flt[i] = 7;
for (var i = 280; i < 288; ++i) flt[i] = 8;
var fdt = new u8(32);
for (var i = 0; i < 32; ++i) fdt[i] = 5;
var flrm = hMap(flt, 9, 1),
  fdrm = hMap(fdt, 5, 1),
  max = function (n) {
    for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t]);
    return e;
  },
  bits = function (n, e, t) {
    var r = (e / 8) | 0;
    return ((n[r] | (n[r + 1] << 8)) >> (e & 7)) & t;
  },
  bits16 = function (n, e) {
    var t = (e / 8) | 0;
    return (n[t] | (n[t + 1] << 8) | (n[t + 2] << 16)) >> (e & 7);
  },
  shft = function (n) {
    return ((n / 8) | 0) + (n & 7 && 1);
  },
  slc = function (n, e, t) {
    (t == null || t > n.length) && (t = n.length);
    var r = new (n instanceof u16 ? u16 : n instanceof u32 ? u32 : u8)(t - e);
    return r.set(n.subarray(e, t)), r;
  },
  inflt = function (n, e, t) {
    var r = n.length;
    if (!r || (t && !t.l && r < 5)) return e || new u8(0);
    var s = !e || t,
      o = !t || t.i;
    t || (t = {}), e || (e = new u8(r * 3));
    var a = function (pn) {
        var _n = e.length;
        if (pn > _n) {
          var bn = new u8(Math.max(_n * 2, pn));
          bn.set(e), (e = bn);
        }
      },
      l = t.f || 0,
      c = t.p || 0,
      u = t.b || 0,
      p = t.l,
      N = t.d,
      P = t.m,
      de = t.n,
      me = r * 8;
    do {
      if (!p) {
        t.f = l = bits(n, c, 1);
        var Ye = bits(n, c + 1, 3);
        if (((c += 3), Ye))
          if (Ye == 1) (p = flrm), (N = fdrm), (P = 9), (de = 5);
          else if (Ye == 2) {
            var st = bits(n, c, 31) + 257,
              vt = bits(n, c + 10, 15) + 4,
              xt = st + bits(n, c + 5, 31) + 1;
            c += 14;
            for (var St = new u8(xt), wt = new u8(19), bt = 0; bt < vt; ++bt)
              wt[clim[bt]] = bits(n, c + bt * 3, 7);
            c += vt * 3;
            for (
              var Tt = max(wt),
                Ct = (1 << Tt) - 1,
                kt = hMap(wt, Tt, 1),
                bt = 0;
              bt < xt;

            ) {
              var Dt = kt[bits(n, c, Ct)];
              c += Dt & 15;
              var nt = Dt >>> 4;
              if (nt < 16) St[bt++] = nt;
              else {
                var Vt = 0,
                  Ht = 0;
                for (
                  nt == 16
                    ? ((Ht = 3 + bits(n, c, 3)), (c += 2), (Vt = St[bt - 1]))
                    : nt == 17
                    ? ((Ht = 3 + bits(n, c, 7)), (c += 3))
                    : nt == 18 && ((Ht = 11 + bits(n, c, 127)), (c += 7));
                  Ht--;

                )
                  St[bt++] = Vt;
              }
            }
            var qt = St.subarray(0, st),
              Ft = St.subarray(st);
            (P = max(qt)),
              (de = max(Ft)),
              (p = hMap(qt, P, 1)),
              (N = hMap(Ft, de, 1));
          } else throw "invalid block type";
        else {
          var nt = shft(c) + 4,
            Be = n[nt - 4] | (n[nt - 3] << 8),
            ot = nt + Be;
          if (ot > r) {
            if (o) throw "unexpected EOF";
            break;
          }
          s && a(u + Be),
            e.set(n.subarray(nt, ot), u),
            (t.b = u += Be),
            (t.p = c = ot * 8);
          continue;
        }
        if (c > me) {
          if (o) throw "unexpected EOF";
          break;
        }
      }
      s && a(u + 131072);
      for (var Bt = (1 << P) - 1, Mt = (1 << de) - 1, Pt = c; ; Pt = c) {
        var Vt = p[bits16(n, c) & Bt],
          It = Vt >>> 4;
        if (((c += Vt & 15), c > me)) {
          if (o) throw "unexpected EOF";
          break;
        }
        if (!Vt) throw "invalid length/literal";
        if (It < 256) e[u++] = It;
        else if (It == 256) {
          (Pt = c), (p = null);
          break;
        } else {
          var Ot = It - 254;
          if (It > 264) {
            var bt = It - 257,
              Xt = fleb[bt];
            (Ot = bits(n, c, (1 << Xt) - 1) + fl[bt]), (c += Xt);
          }
          var sn = N[bits16(n, c) & Mt],
            Kt = sn >>> 4;
          if (!sn) throw "invalid distance";
          c += sn & 15;
          var Ft = fd[Kt];
          if (Kt > 3) {
            var Xt = fdeb[Kt];
            (Ft += bits16(n, c) & ((1 << Xt) - 1)), (c += Xt);
          }
          if (c > me) {
            if (o) throw "unexpected EOF";
            break;
          }
          s && a(u + 131072);
          for (var tn = u + Ot; u < tn; u += 4)
            (e[u] = e[u - Ft]),
              (e[u + 1] = e[u + 1 - Ft]),
              (e[u + 2] = e[u + 2 - Ft]),
              (e[u + 3] = e[u + 3 - Ft]);
          u = tn;
        }
      }
      (t.l = p),
        (t.p = Pt),
        (t.b = u),
        p && ((l = 1), (t.m = P), (t.d = N), (t.n = de));
    } while (!l);
    return u == e.length ? e : slc(e, 0, u);
  },
  et = new u8(0),
  zlv = function (n) {
    if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || ((n[0] << 8) | n[1]) % 31)
      throw "invalid zlib data";
    if (n[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
  };
function unzlibSync(n, e) {
  return inflt((zlv(n), n.subarray(2, -4)), e);
}
var td = typeof TextDecoder < "u" && new TextDecoder(),
  tds = 0;
try {
  td.decode(et, { stream: !0 }), (tds = 1);
} catch {}
const isCubeTexture = (n) => n && n.isCubeTexture;
class GroundProjectedEnv extends Mesh {
  constructor(e, t) {
    var r, s;
    const o = isCubeTexture(e),
      l =
        ((s = o
          ? (r = e.image[0]) == null
            ? void 0
            : r.width
          : e.image.width) != null
          ? s
          : 1024) / 4,
      c = Math.floor(Math.log2(l)),
      u = Math.pow(2, c),
      p = 3 * Math.max(u, 16 * 7),
      N = 4 * u,
      P = [
        o ? "#define ENVMAP_TYPE_CUBE" : "",
        `#define CUBEUV_TEXEL_WIDTH ${1 / p}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / N}`,
        `#define CUBEUV_MAX_MIP ${c}.0`,
      ],
      de = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      me =
        P.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${
              version$1 >= 154 ? "colorspace_fragment" : "encodings_fragment"
            }>
        }
        `,
      Ye = {
        map: { value: e },
        height: { value: (t == null ? void 0 : t.height) || 15 },
        radius: { value: (t == null ? void 0 : t.radius) || 100 },
      },
      nt = new IcosahedronGeometry(1, 16),
      Be = new ShaderMaterial({
        uniforms: Ye,
        fragmentShader: me,
        vertexShader: de,
        side: DoubleSide,
      });
    super(nt, Be);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
class RGBELoader extends DataTextureLoader {
  constructor(e) {
    super(e), (this.type = HalfFloatType);
  }
  parse(e) {
    const a = function (bt, Tt) {
        switch (bt) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (Tt || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (Tt || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (Tt || ""));
          default:
          case 4:
            throw new Error("THREE.RGBELoader: Memory Error: " + (Tt || ""));
        }
      },
      p = `
`,
      N = function (bt, Tt, Ct) {
        Tt = Tt || 1024;
        let Dt = bt.pos,
          Vt = -1,
          Ht = 0,
          qt = "",
          Ft = String.fromCharCode.apply(
            null,
            new Uint16Array(bt.subarray(Dt, Dt + 128))
          );
        for (; 0 > (Vt = Ft.indexOf(p)) && Ht < Tt && Dt < bt.byteLength; )
          (qt += Ft),
            (Ht += Ft.length),
            (Dt += 128),
            (Ft += String.fromCharCode.apply(
              null,
              new Uint16Array(bt.subarray(Dt, Dt + 128))
            ));
        return -1 < Vt ? ((bt.pos += Ht + Vt + 1), qt + Ft.slice(0, Vt)) : !1;
      },
      P = function (bt) {
        const Tt = /^#\?(\S+)/,
          Ct = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          kt = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          Dt = /^\s*FORMAT=(\S+)\s*$/,
          Vt = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          Ht = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let qt, Ft;
        for (
          (bt.pos >= bt.byteLength || !(qt = N(bt))) && a(1, "no header found"),
            (Ft = qt.match(Tt)) || a(3, "bad initial token"),
            Ht.valid |= 1,
            Ht.programtype = Ft[1],
            Ht.string +=
              qt +
              `
`;
          (qt = N(bt)), qt !== !1;

        ) {
          if (
            ((Ht.string +=
              qt +
              `
`),
            qt.charAt(0) === "#")
          ) {
            Ht.comments +=
              qt +
              `
`;
            continue;
          }
          if (
            ((Ft = qt.match(Ct)) && (Ht.gamma = parseFloat(Ft[1])),
            (Ft = qt.match(kt)) && (Ht.exposure = parseFloat(Ft[1])),
            (Ft = qt.match(Dt)) && ((Ht.valid |= 2), (Ht.format = Ft[1])),
            (Ft = qt.match(Vt)) &&
              ((Ht.valid |= 4),
              (Ht.height = parseInt(Ft[1], 10)),
              (Ht.width = parseInt(Ft[2], 10))),
            Ht.valid & 2 && Ht.valid & 4)
          )
            break;
        }
        return (
          Ht.valid & 2 || a(3, "missing format specifier"),
          Ht.valid & 4 || a(3, "missing image size specifier"),
          Ht
        );
      },
      de = function (bt, Tt, Ct) {
        const kt = Tt;
        if (kt < 8 || kt > 32767 || bt[0] !== 2 || bt[1] !== 2 || bt[2] & 128)
          return new Uint8Array(bt);
        kt !== ((bt[2] << 8) | bt[3]) && a(3, "wrong scanline width");
        const Dt = new Uint8Array(4 * Tt * Ct);
        Dt.length || a(4, "unable to allocate buffer space");
        let Vt = 0,
          Ht = 0;
        const qt = 4 * kt,
          Ft = new Uint8Array(4),
          Bt = new Uint8Array(qt);
        let Mt = Ct;
        for (; Mt > 0 && Ht < bt.byteLength; ) {
          Ht + 4 > bt.byteLength && a(1),
            (Ft[0] = bt[Ht++]),
            (Ft[1] = bt[Ht++]),
            (Ft[2] = bt[Ht++]),
            (Ft[3] = bt[Ht++]),
            (Ft[0] != 2 || Ft[1] != 2 || ((Ft[2] << 8) | Ft[3]) != kt) &&
              a(3, "bad rgbe scanline format");
          let Pt = 0,
            It;
          for (; Pt < qt && Ht < bt.byteLength; ) {
            It = bt[Ht++];
            const Xt = It > 128;
            if (
              (Xt && (It -= 128),
              (It === 0 || Pt + It > qt) && a(3, "bad scanline data"),
              Xt)
            ) {
              const sn = bt[Ht++];
              for (let Kt = 0; Kt < It; Kt++) Bt[Pt++] = sn;
            } else Bt.set(bt.subarray(Ht, Ht + It), Pt), (Pt += It), (Ht += It);
          }
          const Ot = kt;
          for (let Xt = 0; Xt < Ot; Xt++) {
            let sn = 0;
            (Dt[Vt] = Bt[Xt + sn]),
              (sn += kt),
              (Dt[Vt + 1] = Bt[Xt + sn]),
              (sn += kt),
              (Dt[Vt + 2] = Bt[Xt + sn]),
              (sn += kt),
              (Dt[Vt + 3] = Bt[Xt + sn]),
              (Vt += 4);
          }
          Mt--;
        }
        return Dt;
      },
      me = function (bt, Tt, Ct, kt) {
        const Dt = bt[Tt + 3],
          Vt = Math.pow(2, Dt - 128) / 255;
        (Ct[kt + 0] = bt[Tt + 0] * Vt),
          (Ct[kt + 1] = bt[Tt + 1] * Vt),
          (Ct[kt + 2] = bt[Tt + 2] * Vt),
          (Ct[kt + 3] = 1);
      },
      Ye = function (bt, Tt, Ct, kt) {
        const Dt = bt[Tt + 3],
          Vt = Math.pow(2, Dt - 128) / 255;
        (Ct[kt + 0] = DataUtils.toHalfFloat(Math.min(bt[Tt + 0] * Vt, 65504))),
          (Ct[kt + 1] = DataUtils.toHalfFloat(
            Math.min(bt[Tt + 1] * Vt, 65504)
          )),
          (Ct[kt + 2] = DataUtils.toHalfFloat(
            Math.min(bt[Tt + 2] * Vt, 65504)
          )),
          (Ct[kt + 3] = DataUtils.toHalfFloat(1));
      },
      nt = new Uint8Array(e);
    nt.pos = 0;
    const Be = P(nt),
      ot = Be.width,
      st = Be.height,
      vt = de(nt.subarray(nt.pos), ot, st);
    let xt, St, wt;
    switch (this.type) {
      case FloatType:
        wt = vt.length / 4;
        const bt = new Float32Array(wt * 4);
        for (let Ct = 0; Ct < wt; Ct++) me(vt, Ct * 4, bt, Ct * 4);
        (xt = bt), (St = FloatType);
        break;
      case HalfFloatType:
        wt = vt.length / 4;
        const Tt = new Uint16Array(wt * 4);
        for (let Ct = 0; Ct < wt; Ct++) Ye(vt, Ct * 4, Tt, Ct * 4);
        (xt = Tt), (St = HalfFloatType);
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: ot,
      height: st,
      data: xt,
      header: Be.string,
      gamma: Be.gamma,
      exposure: Be.exposure,
      type: St,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, r, s) {
    function o(a, l) {
      switch (a.type) {
        case FloatType:
        case HalfFloatType:
          "colorSpace" in a
            ? (a.colorSpace = "srgb-linear")
            : (a.encoding = 3e3),
            (a.minFilter = LinearFilter),
            (a.magFilter = LinearFilter),
            (a.generateMipmaps = !1),
            (a.flipY = !0);
          break;
      }
      t && t(a, l);
    }
    return super.load(e, o, r, s);
  }
}
const hasColorSpace = version$1 >= 152;
class EXRLoader extends DataTextureLoader {
  constructor(e) {
    super(e), (this.type = HalfFloatType);
  }
  parse(e) {
    const Tt = Math.pow(2.7182818, 2.2);
    function Ct(Ut, $t) {
      for (var un = 0, yn = 0; yn < 65536; ++yn)
        (yn == 0 || Ut[yn >> 3] & (1 << (yn & 7))) && ($t[un++] = yn);
      for (var Rn = un - 1; un < 65536; ) $t[un++] = 0;
      return Rn;
    }
    function kt(Ut) {
      for (var $t = 0; $t < 16384; $t++)
        (Ut[$t] = {}), (Ut[$t].len = 0), (Ut[$t].lit = 0), (Ut[$t].p = null);
    }
    const Dt = { l: 0, c: 0, lc: 0 };
    function Vt(Ut, $t, un, yn, Rn) {
      for (; un < Ut; ) ($t = ($t << 8) | Sr(yn, Rn)), (un += 8);
      (un -= Ut),
        (Dt.l = ($t >> un) & ((1 << Ut) - 1)),
        (Dt.c = $t),
        (Dt.lc = un);
    }
    const Ht = new Array(59);
    function qt(Ut) {
      for (var $t = 0; $t <= 58; ++$t) Ht[$t] = 0;
      for (var $t = 0; $t < 65537; ++$t) Ht[Ut[$t]] += 1;
      for (var un = 0, $t = 58; $t > 0; --$t) {
        var yn = (un + Ht[$t]) >> 1;
        (Ht[$t] = un), (un = yn);
      }
      for (var $t = 0; $t < 65537; ++$t) {
        var Rn = Ut[$t];
        Rn > 0 && (Ut[$t] = Rn | (Ht[Rn]++ << 6));
      }
    }
    function Ft(Ut, $t, un, yn, Rn, kn, er) {
      for (var Xn = un, zt = 0, Zt = 0; Rn <= kn; Rn++) {
        if (Xn.value - un.value > yn) return !1;
        Vt(6, zt, Zt, Ut, Xn);
        var an = Dt.l;
        if (((zt = Dt.c), (Zt = Dt.lc), (er[Rn] = an), an == 63)) {
          if (Xn.value - un.value > yn)
            throw "Something wrong with hufUnpackEncTable";
          Vt(8, zt, Zt, Ut, Xn);
          var Qt = Dt.l + 6;
          if (((zt = Dt.c), (Zt = Dt.lc), Rn + Qt > kn + 1))
            throw "Something wrong with hufUnpackEncTable";
          for (; Qt--; ) er[Rn++] = 0;
          Rn--;
        } else if (an >= 59) {
          var Qt = an - 59 + 2;
          if (Rn + Qt > kn + 1) throw "Something wrong with hufUnpackEncTable";
          for (; Qt--; ) er[Rn++] = 0;
          Rn--;
        }
      }
      qt(er);
    }
    function Bt(Ut) {
      return Ut & 63;
    }
    function Mt(Ut) {
      return Ut >> 6;
    }
    function Pt(Ut, $t, un, yn) {
      for (; $t <= un; $t++) {
        var Rn = Mt(Ut[$t]),
          kn = Bt(Ut[$t]);
        if (Rn >> kn) throw "Invalid table entry";
        if (kn > 14) {
          var er = yn[Rn >> (kn - 14)];
          if (er.len) throw "Invalid table entry";
          if ((er.lit++, er.p)) {
            var Xn = er.p;
            er.p = new Array(er.lit);
            for (var zt = 0; zt < er.lit - 1; ++zt) er.p[zt] = Xn[zt];
          } else er.p = new Array(1);
          er.p[er.lit - 1] = $t;
        } else if (kn)
          for (var Zt = 0, zt = 1 << (14 - kn); zt > 0; zt--) {
            var er = yn[(Rn << (14 - kn)) + Zt];
            if (er.len || er.p) throw "Invalid table entry";
            (er.len = kn), (er.lit = $t), Zt++;
          }
      }
      return !0;
    }
    const It = { c: 0, lc: 0 };
    function Ot(Ut, $t, un, yn) {
      (Ut = (Ut << 8) | Sr(un, yn)), ($t += 8), (It.c = Ut), (It.lc = $t);
    }
    const Xt = { c: 0, lc: 0 };
    function sn(Ut, $t, un, yn, Rn, kn, er, Xn, zt, Zt) {
      if (Ut == $t) {
        yn < 8 && (Ot(un, yn, Rn, er), (un = It.c), (yn = It.lc)), (yn -= 8);
        var an = un >> yn,
          an = new Uint8Array([an])[0];
        if (zt.value + an > Zt) return !1;
        for (var Qt = Xn[zt.value - 1]; an-- > 0; ) Xn[zt.value++] = Qt;
      } else if (zt.value < Zt) Xn[zt.value++] = Ut;
      else return !1;
      (Xt.c = un), (Xt.lc = yn);
    }
    function Kt(Ut) {
      return Ut & 65535;
    }
    function tn(Ut) {
      var $t = Kt(Ut);
      return $t > 32767 ? $t - 65536 : $t;
    }
    const pn = { a: 0, b: 0 };
    function _n(Ut, $t) {
      var un = tn(Ut),
        yn = tn($t),
        Rn = yn,
        kn = un + (Rn & 1) + (Rn >> 1),
        er = kn,
        Xn = kn - Rn;
      (pn.a = er), (pn.b = Xn);
    }
    function bn(Ut, $t) {
      var un = Kt(Ut),
        yn = Kt($t),
        Rn = (un - (yn >> 1)) & 65535,
        kn = (yn + Rn - 32768) & 65535;
      (pn.a = kn), (pn.b = Rn);
    }
    function $n(Ut, $t, un, yn, Rn, kn, er) {
      for (var Xn = er < 16384, zt = un > Rn ? Rn : un, Zt = 1, an; Zt <= zt; )
        Zt <<= 1;
      for (Zt >>= 1, an = Zt, Zt >>= 1; Zt >= 1; ) {
        for (
          var Qt = 0,
            fn = Qt + kn * (Rn - an),
            wn = kn * Zt,
            On = kn * an,
            Kn = yn * Zt,
            Zn = yn * an,
            ar,
            cr,
            Qn,
            gr;
          Qt <= fn;
          Qt += On
        ) {
          for (var Tr = Qt, Qr = Qt + yn * (un - an); Tr <= Qr; Tr += Zn) {
            var Dr = Tr + Kn,
              Br = Tr + wn,
              Mr = Br + Kn;
            Xn
              ? (_n(Ut[Tr + $t], Ut[Br + $t]),
                (ar = pn.a),
                (Qn = pn.b),
                _n(Ut[Dr + $t], Ut[Mr + $t]),
                (cr = pn.a),
                (gr = pn.b),
                _n(ar, cr),
                (Ut[Tr + $t] = pn.a),
                (Ut[Dr + $t] = pn.b),
                _n(Qn, gr),
                (Ut[Br + $t] = pn.a),
                (Ut[Mr + $t] = pn.b))
              : (bn(Ut[Tr + $t], Ut[Br + $t]),
                (ar = pn.a),
                (Qn = pn.b),
                bn(Ut[Dr + $t], Ut[Mr + $t]),
                (cr = pn.a),
                (gr = pn.b),
                bn(ar, cr),
                (Ut[Tr + $t] = pn.a),
                (Ut[Dr + $t] = pn.b),
                bn(Qn, gr),
                (Ut[Br + $t] = pn.a),
                (Ut[Mr + $t] = pn.b));
          }
          if (un & Zt) {
            var Br = Tr + wn;
            Xn ? _n(Ut[Tr + $t], Ut[Br + $t]) : bn(Ut[Tr + $t], Ut[Br + $t]),
              (ar = pn.a),
              (Ut[Br + $t] = pn.b),
              (Ut[Tr + $t] = ar);
          }
        }
        if (Rn & Zt)
          for (var Tr = Qt, Qr = Qt + yn * (un - an); Tr <= Qr; Tr += Zn) {
            var Dr = Tr + Kn;
            Xn ? _n(Ut[Tr + $t], Ut[Dr + $t]) : bn(Ut[Tr + $t], Ut[Dr + $t]),
              (ar = pn.a),
              (Ut[Dr + $t] = pn.b),
              (Ut[Tr + $t] = ar);
          }
        (an = Zt), (Zt >>= 1);
      }
      return Qt;
    }
    function tr(Ut, $t, un, yn, Rn, kn, er, Xn, zt, Zt) {
      for (
        var an = 0, Qt = 0, fn = Xn, wn = Math.trunc(Rn.value + (kn + 7) / 8);
        Rn.value < wn;

      )
        for (Ot(an, Qt, un, Rn), an = It.c, Qt = It.lc; Qt >= 14; ) {
          var On = (an >> (Qt - 14)) & 16383,
            Kn = $t[On];
          if (Kn.len)
            (Qt -= Kn.len),
              sn(Kn.lit, er, an, Qt, un, yn, Rn, zt, Zt, fn),
              (an = Xt.c),
              (Qt = Xt.lc);
          else {
            if (!Kn.p) throw "hufDecode issues";
            var Zn;
            for (Zn = 0; Zn < Kn.lit; Zn++) {
              for (var ar = Bt(Ut[Kn.p[Zn]]); Qt < ar && Rn.value < wn; )
                Ot(an, Qt, un, Rn), (an = It.c), (Qt = It.lc);
              if (
                Qt >= ar &&
                Mt(Ut[Kn.p[Zn]]) == ((an >> (Qt - ar)) & ((1 << ar) - 1))
              ) {
                (Qt -= ar),
                  sn(Kn.p[Zn], er, an, Qt, un, yn, Rn, zt, Zt, fn),
                  (an = Xt.c),
                  (Qt = Xt.lc);
                break;
              }
            }
            if (Zn == Kn.lit) throw "hufDecode issues";
          }
        }
      var cr = (8 - kn) & 7;
      for (an >>= cr, Qt -= cr; Qt > 0; ) {
        var Kn = $t[(an << (14 - Qt)) & 16383];
        if (Kn.len)
          (Qt -= Kn.len),
            sn(Kn.lit, er, an, Qt, un, yn, Rn, zt, Zt, fn),
            (an = Xt.c),
            (Qt = Xt.lc);
        else throw "hufDecode issues";
      }
      return !0;
    }
    function ur(Ut, $t, un, yn, Rn, kn) {
      var er = { value: 0 },
        Xn = un.value,
        zt = mr($t, un),
        Zt = mr($t, un);
      un.value += 4;
      var an = mr($t, un);
      if (((un.value += 4), zt < 0 || zt >= 65537 || Zt < 0 || Zt >= 65537))
        throw "Something wrong with HUF_ENCSIZE";
      var Qt = new Array(65537),
        fn = new Array(16384);
      kt(fn);
      var wn = yn - (un.value - Xn);
      if ((Ft(Ut, $t, un, wn, zt, Zt, Qt), an > 8 * (yn - (un.value - Xn))))
        throw "Something wrong with hufUncompress";
      Pt(Qt, zt, Zt, fn), tr(Qt, fn, Ut, $t, un, an, Zt, kn, Rn, er);
    }
    function _r(Ut, $t, un) {
      for (var yn = 0; yn < un; ++yn) $t[yn] = Ut[$t[yn]];
    }
    function Bn(Ut) {
      for (var $t = 1; $t < Ut.length; $t++) {
        var un = Ut[$t - 1] + Ut[$t] - 128;
        Ut[$t] = un;
      }
    }
    function jt(Ut, $t) {
      for (
        var un = 0,
          yn = Math.floor((Ut.length + 1) / 2),
          Rn = 0,
          kn = Ut.length - 1;
        !(Rn > kn || (($t[Rn++] = Ut[un++]), Rn > kn));

      )
        $t[Rn++] = Ut[yn++];
    }
    function Yn(Ut) {
      for (
        var $t = Ut.byteLength, un = new Array(), yn = 0, Rn = new DataView(Ut);
        $t > 0;

      ) {
        var kn = Rn.getInt8(yn++);
        if (kn < 0) {
          var er = -kn;
          $t -= er + 1;
          for (var Xn = 0; Xn < er; Xn++) un.push(Rn.getUint8(yn++));
        } else {
          var er = kn;
          $t -= 2;
          for (var zt = Rn.getUint8(yn++), Xn = 0; Xn < er + 1; Xn++)
            un.push(zt);
        }
      }
      return un;
    }
    function zn(Ut, $t, un, yn, Rn, kn) {
      var Dr = new DataView(kn.buffer),
        er = un[Ut.idx[0]].width,
        Xn = un[Ut.idx[0]].height,
        zt = 3,
        Zt = Math.floor(er / 8),
        an = Math.ceil(er / 8),
        Qt = Math.ceil(Xn / 8),
        fn = er - (an - 1) * 8,
        wn = Xn - (Qt - 1) * 8,
        On = { value: 0 },
        Kn = new Array(zt),
        Zn = new Array(zt),
        ar = new Array(zt),
        cr = new Array(zt),
        Qn = new Array(zt);
      for (let ti = 0; ti < zt; ++ti)
        (Qn[ti] = $t[Ut.idx[ti]]),
          (Kn[ti] = ti < 1 ? 0 : Kn[ti - 1] + an * Qt),
          (Zn[ti] = new Float32Array(64)),
          (ar[ti] = new Uint16Array(64)),
          (cr[ti] = new Uint16Array(an * 64));
      for (let ti = 0; ti < Qt; ++ti) {
        var gr = 8;
        ti == Qt - 1 && (gr = wn);
        var Tr = 8;
        for (let ni = 0; ni < an; ++ni) {
          ni == an - 1 && (Tr = fn);
          for (let ai = 0; ai < zt; ++ai)
            ar[ai].fill(0),
              (ar[ai][0] = Rn[Kn[ai]++]),
              rn(On, yn, ar[ai]),
              In(ar[ai], Zn[ai]),
              or(Zn[ai]);
          Gn(Zn);
          for (let ai = 0; ai < zt; ++ai) Yt(Zn[ai], cr[ai], ni * 64);
        }
        let bi = 0;
        for (let ni = 0; ni < zt; ++ni) {
          const ai = un[Ut.idx[ni]].type;
          for (let Kr = 8 * ti; Kr < 8 * ti + gr; ++Kr) {
            bi = Qn[ni][Kr];
            for (let Ii = 0; Ii < Zt; ++Ii) {
              const gi = Ii * 64 + (Kr & 7) * 8;
              Dr.setUint16(bi + 0 * 2 * ai, cr[ni][gi + 0], !0),
                Dr.setUint16(bi + 1 * 2 * ai, cr[ni][gi + 1], !0),
                Dr.setUint16(bi + 2 * 2 * ai, cr[ni][gi + 2], !0),
                Dr.setUint16(bi + 3 * 2 * ai, cr[ni][gi + 3], !0),
                Dr.setUint16(bi + 4 * 2 * ai, cr[ni][gi + 4], !0),
                Dr.setUint16(bi + 5 * 2 * ai, cr[ni][gi + 5], !0),
                Dr.setUint16(bi + 6 * 2 * ai, cr[ni][gi + 6], !0),
                Dr.setUint16(bi + 7 * 2 * ai, cr[ni][gi + 7], !0),
                (bi += 8 * 2 * ai);
            }
          }
          if (Zt != an)
            for (let Kr = 8 * ti; Kr < 8 * ti + gr; ++Kr) {
              const Ii = Qn[ni][Kr] + 8 * Zt * 2 * ai,
                gi = Zt * 64 + (Kr & 7) * 8;
              for (let Mi = 0; Mi < Tr; ++Mi)
                Dr.setUint16(Ii + Mi * 2 * ai, cr[ni][gi + Mi], !0);
            }
        }
      }
      for (
        var Qr = new Uint16Array(er), Dr = new DataView(kn.buffer), Br = 0;
        Br < zt;
        ++Br
      ) {
        un[Ut.idx[Br]].decoded = !0;
        var Mr = un[Ut.idx[Br]].type;
        if (un[Br].type == 2)
          for (var oi = 0; oi < Xn; ++oi) {
            const ti = Qn[Br][oi];
            for (var Xr = 0; Xr < er; ++Xr)
              Qr[Xr] = Dr.getUint16(ti + Xr * 2 * Mr, !0);
            for (var Xr = 0; Xr < er; ++Xr)
              Dr.setFloat32(ti + Xr * 2 * Mr, An(Qr[Xr]), !0);
          }
      }
    }
    function rn(Ut, $t, un) {
      for (var yn, Rn = 1; Rn < 64; )
        (yn = $t[Ut.value]),
          yn == 65280
            ? (Rn = 64)
            : yn >> 8 == 255
            ? (Rn += yn & 255)
            : ((un[Rn] = yn), Rn++),
          Ut.value++;
    }
    function In(Ut, $t) {
      ($t[0] = An(Ut[0])),
        ($t[1] = An(Ut[1])),
        ($t[2] = An(Ut[5])),
        ($t[3] = An(Ut[6])),
        ($t[4] = An(Ut[14])),
        ($t[5] = An(Ut[15])),
        ($t[6] = An(Ut[27])),
        ($t[7] = An(Ut[28])),
        ($t[8] = An(Ut[2])),
        ($t[9] = An(Ut[4])),
        ($t[10] = An(Ut[7])),
        ($t[11] = An(Ut[13])),
        ($t[12] = An(Ut[16])),
        ($t[13] = An(Ut[26])),
        ($t[14] = An(Ut[29])),
        ($t[15] = An(Ut[42])),
        ($t[16] = An(Ut[3])),
        ($t[17] = An(Ut[8])),
        ($t[18] = An(Ut[12])),
        ($t[19] = An(Ut[17])),
        ($t[20] = An(Ut[25])),
        ($t[21] = An(Ut[30])),
        ($t[22] = An(Ut[41])),
        ($t[23] = An(Ut[43])),
        ($t[24] = An(Ut[9])),
        ($t[25] = An(Ut[11])),
        ($t[26] = An(Ut[18])),
        ($t[27] = An(Ut[24])),
        ($t[28] = An(Ut[31])),
        ($t[29] = An(Ut[40])),
        ($t[30] = An(Ut[44])),
        ($t[31] = An(Ut[53])),
        ($t[32] = An(Ut[10])),
        ($t[33] = An(Ut[19])),
        ($t[34] = An(Ut[23])),
        ($t[35] = An(Ut[32])),
        ($t[36] = An(Ut[39])),
        ($t[37] = An(Ut[45])),
        ($t[38] = An(Ut[52])),
        ($t[39] = An(Ut[54])),
        ($t[40] = An(Ut[20])),
        ($t[41] = An(Ut[22])),
        ($t[42] = An(Ut[33])),
        ($t[43] = An(Ut[38])),
        ($t[44] = An(Ut[46])),
        ($t[45] = An(Ut[51])),
        ($t[46] = An(Ut[55])),
        ($t[47] = An(Ut[60])),
        ($t[48] = An(Ut[21])),
        ($t[49] = An(Ut[34])),
        ($t[50] = An(Ut[37])),
        ($t[51] = An(Ut[47])),
        ($t[52] = An(Ut[50])),
        ($t[53] = An(Ut[56])),
        ($t[54] = An(Ut[59])),
        ($t[55] = An(Ut[61])),
        ($t[56] = An(Ut[35])),
        ($t[57] = An(Ut[36])),
        ($t[58] = An(Ut[48])),
        ($t[59] = An(Ut[49])),
        ($t[60] = An(Ut[57])),
        ($t[61] = An(Ut[58])),
        ($t[62] = An(Ut[62])),
        ($t[63] = An(Ut[63]));
    }
    function or(Ut) {
      const $t = 0.5 * Math.cos(0.7853975),
        un = 0.5 * Math.cos(3.14159 / 16),
        yn = 0.5 * Math.cos(3.14159 / 8),
        Rn = 0.5 * Math.cos((3 * 3.14159) / 16),
        kn = 0.5 * Math.cos((5 * 3.14159) / 16),
        er = 0.5 * Math.cos((3 * 3.14159) / 8),
        Xn = 0.5 * Math.cos((7 * 3.14159) / 16);
      for (
        var zt = new Array(4),
          Zt = new Array(4),
          an = new Array(4),
          Qt = new Array(4),
          fn = 0;
        fn < 8;
        ++fn
      ) {
        var wn = fn * 8;
        (zt[0] = yn * Ut[wn + 2]),
          (zt[1] = er * Ut[wn + 2]),
          (zt[2] = yn * Ut[wn + 6]),
          (zt[3] = er * Ut[wn + 6]),
          (Zt[0] =
            un * Ut[wn + 1] +
            Rn * Ut[wn + 3] +
            kn * Ut[wn + 5] +
            Xn * Ut[wn + 7]),
          (Zt[1] =
            Rn * Ut[wn + 1] -
            Xn * Ut[wn + 3] -
            un * Ut[wn + 5] -
            kn * Ut[wn + 7]),
          (Zt[2] =
            kn * Ut[wn + 1] -
            un * Ut[wn + 3] +
            Xn * Ut[wn + 5] +
            Rn * Ut[wn + 7]),
          (Zt[3] =
            Xn * Ut[wn + 1] -
            kn * Ut[wn + 3] +
            Rn * Ut[wn + 5] -
            un * Ut[wn + 7]),
          (an[0] = $t * (Ut[wn + 0] + Ut[wn + 4])),
          (an[3] = $t * (Ut[wn + 0] - Ut[wn + 4])),
          (an[1] = zt[0] + zt[3]),
          (an[2] = zt[1] - zt[2]),
          (Qt[0] = an[0] + an[1]),
          (Qt[1] = an[3] + an[2]),
          (Qt[2] = an[3] - an[2]),
          (Qt[3] = an[0] - an[1]),
          (Ut[wn + 0] = Qt[0] + Zt[0]),
          (Ut[wn + 1] = Qt[1] + Zt[1]),
          (Ut[wn + 2] = Qt[2] + Zt[2]),
          (Ut[wn + 3] = Qt[3] + Zt[3]),
          (Ut[wn + 4] = Qt[3] - Zt[3]),
          (Ut[wn + 5] = Qt[2] - Zt[2]),
          (Ut[wn + 6] = Qt[1] - Zt[1]),
          (Ut[wn + 7] = Qt[0] - Zt[0]);
      }
      for (var On = 0; On < 8; ++On)
        (zt[0] = yn * Ut[16 + On]),
          (zt[1] = er * Ut[16 + On]),
          (zt[2] = yn * Ut[48 + On]),
          (zt[3] = er * Ut[48 + On]),
          (Zt[0] =
            un * Ut[8 + On] +
            Rn * Ut[24 + On] +
            kn * Ut[40 + On] +
            Xn * Ut[56 + On]),
          (Zt[1] =
            Rn * Ut[8 + On] -
            Xn * Ut[24 + On] -
            un * Ut[40 + On] -
            kn * Ut[56 + On]),
          (Zt[2] =
            kn * Ut[8 + On] -
            un * Ut[24 + On] +
            Xn * Ut[40 + On] +
            Rn * Ut[56 + On]),
          (Zt[3] =
            Xn * Ut[8 + On] -
            kn * Ut[24 + On] +
            Rn * Ut[40 + On] -
            un * Ut[56 + On]),
          (an[0] = $t * (Ut[On] + Ut[32 + On])),
          (an[3] = $t * (Ut[On] - Ut[32 + On])),
          (an[1] = zt[0] + zt[3]),
          (an[2] = zt[1] - zt[2]),
          (Qt[0] = an[0] + an[1]),
          (Qt[1] = an[3] + an[2]),
          (Qt[2] = an[3] - an[2]),
          (Qt[3] = an[0] - an[1]),
          (Ut[0 + On] = Qt[0] + Zt[0]),
          (Ut[8 + On] = Qt[1] + Zt[1]),
          (Ut[16 + On] = Qt[2] + Zt[2]),
          (Ut[24 + On] = Qt[3] + Zt[3]),
          (Ut[32 + On] = Qt[3] - Zt[3]),
          (Ut[40 + On] = Qt[2] - Zt[2]),
          (Ut[48 + On] = Qt[1] - Zt[1]),
          (Ut[56 + On] = Qt[0] - Zt[0]);
    }
    function Gn(Ut) {
      for (var $t = 0; $t < 64; ++$t) {
        var un = Ut[0][$t],
          yn = Ut[1][$t],
          Rn = Ut[2][$t];
        (Ut[0][$t] = un + 1.5747 * Rn),
          (Ut[1][$t] = un - 0.1873 * yn - 0.4682 * Rn),
          (Ut[2][$t] = un + 1.8556 * yn);
      }
    }
    function Yt(Ut, $t, un) {
      for (var yn = 0; yn < 64; ++yn)
        $t[un + yn] = DataUtils.toHalfFloat(Gt(Ut[yn]));
    }
    function Gt(Ut) {
      return Ut <= 1
        ? Math.sign(Ut) * Math.pow(Math.abs(Ut), 2.2)
        : Math.sign(Ut) * Math.pow(Tt, Math.abs(Ut) - 1);
    }
    function hn(Ut) {
      return new DataView(Ut.array.buffer, Ut.offset.value, Ut.size);
    }
    function En(Ut) {
      var $t = Ut.viewer.buffer.slice(
          Ut.offset.value,
          Ut.offset.value + Ut.size
        ),
        un = new Uint8Array(Yn($t)),
        yn = new Uint8Array(un.length);
      return Bn(un), jt(un, yn), new DataView(yn.buffer);
    }
    function Ln(Ut) {
      var $t = Ut.array.slice(Ut.offset.value, Ut.offset.value + Ut.size),
        un = unzlibSync($t),
        yn = new Uint8Array(un.length);
      return Bn(un), jt(un, yn), new DataView(yn.buffer);
    }
    function mn(Ut) {
      for (
        var $t = Ut.viewer,
          un = { value: Ut.offset.value },
          yn = new Uint16Array(
            Ut.width * Ut.scanlineBlockSize * (Ut.channels * Ut.type)
          ),
          Rn = new Uint8Array(8192),
          kn = 0,
          er = new Array(Ut.channels),
          Xn = 0;
        Xn < Ut.channels;
        Xn++
      )
        (er[Xn] = {}),
          (er[Xn].start = kn),
          (er[Xn].end = er[Xn].start),
          (er[Xn].nx = Ut.width),
          (er[Xn].ny = Ut.lines),
          (er[Xn].size = Ut.type),
          (kn += er[Xn].nx * er[Xn].ny * er[Xn].size);
      var zt = Mn($t, un),
        Zt = Mn($t, un);
      if (Zt >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (zt <= Zt)
        for (var Xn = 0; Xn < Zt - zt + 1; Xn++) Rn[Xn + zt] = Ur($t, un);
      var an = new Uint16Array(65536),
        Qt = Ct(Rn, an),
        fn = mr($t, un);
      ur(Ut.array, $t, un, fn, yn, kn);
      for (var Xn = 0; Xn < Ut.channels; ++Xn)
        for (var wn = er[Xn], On = 0; On < er[Xn].size; ++On)
          $n(yn, wn.start + On, wn.nx, wn.size, wn.ny, wn.nx * wn.size, Qt);
      _r(an, yn, kn);
      for (
        var Kn = 0, Zn = new Uint8Array(yn.buffer.byteLength), ar = 0;
        ar < Ut.lines;
        ar++
      )
        for (var cr = 0; cr < Ut.channels; cr++) {
          var wn = er[cr],
            Qn = wn.nx * wn.size,
            gr = new Uint8Array(yn.buffer, wn.end * 2, Qn * 2);
          Zn.set(gr, Kn), (Kn += Qn * 2), (wn.end += Qn);
        }
      return new DataView(Zn.buffer);
    }
    function Vn(Ut) {
      var $t = Ut.array.slice(Ut.offset.value, Ut.offset.value + Ut.size),
        un = unzlibSync($t);
      const yn = Ut.lines * Ut.channels * Ut.width,
        Rn = Ut.type == 1 ? new Uint16Array(yn) : new Uint32Array(yn);
      let kn = 0,
        er = 0;
      const Xn = new Array(4);
      for (let zt = 0; zt < Ut.lines; zt++)
        for (let Zt = 0; Zt < Ut.channels; Zt++) {
          let an = 0;
          switch (Ut.type) {
            case 1:
              (Xn[0] = kn), (Xn[1] = Xn[0] + Ut.width), (kn = Xn[1] + Ut.width);
              for (let Qt = 0; Qt < Ut.width; ++Qt) {
                const fn = (un[Xn[0]++] << 8) | un[Xn[1]++];
                (an += fn), (Rn[er] = an), er++;
              }
              break;
            case 2:
              (Xn[0] = kn),
                (Xn[1] = Xn[0] + Ut.width),
                (Xn[2] = Xn[1] + Ut.width),
                (kn = Xn[2] + Ut.width);
              for (let Qt = 0; Qt < Ut.width; ++Qt) {
                const fn =
                  (un[Xn[0]++] << 24) |
                  (un[Xn[1]++] << 16) |
                  (un[Xn[2]++] << 8);
                (an += fn), (Rn[er] = an), er++;
              }
              break;
          }
        }
      return new DataView(Rn.buffer);
    }
    function Fn(Ut) {
      var $t = Ut.viewer,
        un = { value: Ut.offset.value },
        yn = new Uint8Array(Ut.width * Ut.lines * (Ut.channels * Ut.type * 2)),
        Rn = {
          version: Pr($t, un),
          unknownUncompressedSize: Pr($t, un),
          unknownCompressedSize: Pr($t, un),
          acCompressedSize: Pr($t, un),
          dcCompressedSize: Pr($t, un),
          rleCompressedSize: Pr($t, un),
          rleUncompressedSize: Pr($t, un),
          rleRawSize: Pr($t, un),
          totalAcUncompressedCount: Pr($t, un),
          totalDcUncompressedCount: Pr($t, un),
          acCompression: Pr($t, un),
        };
      if (Rn.version < 2)
        throw (
          "EXRLoader.parse: " +
          qr.compression +
          " version " +
          Rn.version +
          " is unsupported"
        );
      for (var kn = new Array(), er = Mn($t, un) - 2; er > 0; ) {
        var Xn = nr($t.buffer, un),
          zt = Ur($t, un),
          Zt = (zt >> 2) & 3,
          an = (zt >> 4) - 1,
          Qt = new Int8Array([an])[0],
          fn = Ur($t, un);
        kn.push({ name: Xn, index: Qt, type: fn, compression: Zt }),
          (er -= Xn.length + 3);
      }
      for (
        var wn = qr.channels, On = new Array(Ut.channels), Kn = 0;
        Kn < Ut.channels;
        ++Kn
      ) {
        var Zn = (On[Kn] = {}),
          ar = wn[Kn];
        (Zn.name = ar.name),
          (Zn.compression = 0),
          (Zn.decoded = !1),
          (Zn.type = ar.pixelType),
          (Zn.pLinear = ar.pLinear),
          (Zn.width = Ut.width),
          (Zn.height = Ut.lines);
      }
      for (var cr = { idx: new Array(3) }, Qn = 0; Qn < Ut.channels; ++Qn)
        for (var Zn = On[Qn], Kn = 0; Kn < kn.length; ++Kn) {
          var gr = kn[Kn];
          Zn.name == gr.name &&
            ((Zn.compression = gr.compression),
            gr.index >= 0 && (cr.idx[gr.index] = Qn),
            (Zn.offset = Qn));
        }
      if (Rn.acCompressedSize > 0)
        switch (Rn.acCompression) {
          case 0:
            var Dr = new Uint16Array(Rn.totalAcUncompressedCount);
            ur(
              Ut.array,
              $t,
              un,
              Rn.acCompressedSize,
              Dr,
              Rn.totalAcUncompressedCount
            );
            break;
          case 1:
            var Tr = Ut.array.slice(
                un.value,
                un.value + Rn.totalAcUncompressedCount
              ),
              Qr = unzlibSync(Tr),
              Dr = new Uint16Array(Qr.buffer);
            un.value += Rn.totalAcUncompressedCount;
            break;
        }
      if (Rn.dcCompressedSize > 0) {
        var Br = { array: Ut.array, offset: un, size: Rn.dcCompressedSize },
          Mr = new Uint16Array(Ln(Br).buffer);
        un.value += Rn.dcCompressedSize;
      }
      if (Rn.rleRawSize > 0) {
        var Tr = Ut.array.slice(un.value, un.value + Rn.rleCompressedSize),
          Qr = unzlibSync(Tr),
          oi = Yn(Qr.buffer);
        un.value += Rn.rleCompressedSize;
      }
      for (var Xr = 0, ti = new Array(On.length), Kn = 0; Kn < ti.length; ++Kn)
        ti[Kn] = new Array();
      for (var bi = 0; bi < Ut.lines; ++bi)
        for (var ni = 0; ni < On.length; ++ni)
          ti[ni].push(Xr), (Xr += On[ni].width * Ut.type * 2);
      zn(cr, ti, On, Dr, Mr, yn);
      for (var Kn = 0; Kn < On.length; ++Kn) {
        var Zn = On[Kn];
        if (!Zn.decoded)
          switch (Zn.compression) {
            case 2:
              for (var ai = 0, Kr = 0, bi = 0; bi < Ut.lines; ++bi) {
                for (var Ii = ti[Kn][ai], gi = 0; gi < Zn.width; ++gi) {
                  for (var Mi = 0; Mi < 2 * Zn.type; ++Mi)
                    yn[Ii++] = oi[Kr + Mi * Zn.width * Zn.height];
                  Kr++;
                }
                ai++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(yn.buffer);
    }
    function nr(Ut, $t) {
      for (var un = new Uint8Array(Ut), yn = 0; un[$t.value + yn] != 0; )
        yn += 1;
      var Rn = new TextDecoder().decode(un.slice($t.value, $t.value + yn));
      return ($t.value = $t.value + yn + 1), Rn;
    }
    function yr(Ut, $t, un) {
      var yn = new TextDecoder().decode(
        new Uint8Array(Ut).slice($t.value, $t.value + un)
      );
      return ($t.value = $t.value + un), yn;
    }
    function qn(Ut, $t) {
      var un = Jn(Ut, $t),
        yn = mr(Ut, $t);
      return [un, yn];
    }
    function jn(Ut, $t) {
      var un = mr(Ut, $t),
        yn = mr(Ut, $t);
      return [un, yn];
    }
    function Jn(Ut, $t) {
      var un = Ut.getInt32($t.value, !0);
      return ($t.value = $t.value + 4), un;
    }
    function mr(Ut, $t) {
      var un = Ut.getUint32($t.value, !0);
      return ($t.value = $t.value + 4), un;
    }
    function Sr(Ut, $t) {
      var un = Ut[$t.value];
      return ($t.value = $t.value + 1), un;
    }
    function Ur(Ut, $t) {
      var un = Ut.getUint8($t.value);
      return ($t.value = $t.value + 1), un;
    }
    const Pr = function (Ut, $t) {
      let un;
      return (
        "getBigInt64" in DataView.prototype
          ? (un = Number(Ut.getBigInt64($t.value, !0)))
          : (un =
              Ut.getUint32($t.value + 4, !0) +
              Number(Ut.getUint32($t.value, !0) << 32)),
        ($t.value += 8),
        un
      );
    };
    function Hr(Ut, $t) {
      var un = Ut.getFloat32($t.value, !0);
      return ($t.value += 4), un;
    }
    function cn(Ut, $t) {
      return DataUtils.toHalfFloat(Hr(Ut, $t));
    }
    function An(Ut) {
      var $t = (Ut & 31744) >> 10,
        un = Ut & 1023;
      return (
        (Ut >> 15 ? -1 : 1) *
        ($t
          ? $t === 31
            ? un
              ? NaN
              : 1 / 0
            : Math.pow(2, $t - 15) * (1 + un / 1024)
          : 6103515625e-14 * (un / 1024))
      );
    }
    function Mn(Ut, $t) {
      var un = Ut.getUint16($t.value, !0);
      return ($t.value += 2), un;
    }
    function Hn(Ut, $t) {
      return An(Mn(Ut, $t));
    }
    function hr(Ut, $t, un, yn) {
      for (var Rn = un.value, kn = []; un.value < Rn + yn - 1; ) {
        var er = nr($t, un),
          Xn = Jn(Ut, un),
          zt = Ur(Ut, un);
        un.value += 3;
        var Zt = Jn(Ut, un),
          an = Jn(Ut, un);
        kn.push({
          name: er,
          pixelType: Xn,
          pLinear: zt,
          xSampling: Zt,
          ySampling: an,
        });
      }
      return (un.value += 1), kn;
    }
    function pr(Ut, $t) {
      var un = Hr(Ut, $t),
        yn = Hr(Ut, $t),
        Rn = Hr(Ut, $t),
        kn = Hr(Ut, $t),
        er = Hr(Ut, $t),
        Xn = Hr(Ut, $t),
        zt = Hr(Ut, $t),
        Zt = Hr(Ut, $t);
      return {
        redX: un,
        redY: yn,
        greenX: Rn,
        greenY: kn,
        blueX: er,
        blueY: Xn,
        whiteX: zt,
        whiteY: Zt,
      };
    }
    function jr(Ut, $t) {
      var un = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        yn = Ur(Ut, $t);
      return un[yn];
    }
    function fi(Ut, $t) {
      var un = mr(Ut, $t),
        yn = mr(Ut, $t),
        Rn = mr(Ut, $t),
        kn = mr(Ut, $t);
      return { xMin: un, yMin: yn, xMax: Rn, yMax: kn };
    }
    function wi(Ut, $t) {
      var un = ["INCREASING_Y"],
        yn = Ur(Ut, $t);
      return un[yn];
    }
    function wr(Ut, $t) {
      var un = Hr(Ut, $t),
        yn = Hr(Ut, $t);
      return [un, yn];
    }
    function Rr(Ut, $t) {
      var un = Hr(Ut, $t),
        yn = Hr(Ut, $t),
        Rn = Hr(Ut, $t);
      return [un, yn, Rn];
    }
    function $r(Ut, $t, un, yn, Rn) {
      if (yn === "string" || yn === "stringvector" || yn === "iccProfile")
        return yr($t, un, Rn);
      if (yn === "chlist") return hr(Ut, $t, un, Rn);
      if (yn === "chromaticities") return pr(Ut, un);
      if (yn === "compression") return jr(Ut, un);
      if (yn === "box2i") return fi(Ut, un);
      if (yn === "lineOrder") return wi(Ut, un);
      if (yn === "float") return Hr(Ut, un);
      if (yn === "v2f") return wr(Ut, un);
      if (yn === "v3f") return Rr(Ut, un);
      if (yn === "int") return Jn(Ut, un);
      if (yn === "rational") return qn(Ut, un);
      if (yn === "timecode") return jn(Ut, un);
      if (yn === "preview") return (un.value += Rn), "skipped";
      un.value += Rn;
    }
    function xr(Ut, $t, un) {
      const yn = {};
      if (Ut.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      yn.version = Ut.getUint8(4);
      const Rn = Ut.getUint8(5);
      (yn.spec = {
        singleTile: !!(Rn & 2),
        longName: !!(Rn & 4),
        deepFormat: !!(Rn & 8),
        multiPart: !!(Rn & 16),
      }),
        (un.value = 8);
      for (var kn = !0; kn; ) {
        var er = nr($t, un);
        if (er == 0) kn = !1;
        else {
          var Xn = nr($t, un),
            zt = mr(Ut, un),
            Zt = $r(Ut, $t, un, Xn, zt);
          Zt === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${Xn}'.`
              )
            : (yn[er] = Zt);
        }
      }
      if ((Rn & -5) != 0)
        throw (
          (console.error("EXRHeader:", yn),
          "THREE.EXRLoader: provided file is currently unsupported.")
        );
      return yn;
    }
    function Fr(Ut, $t, un, yn, Rn) {
      const kn = {
        size: 0,
        viewer: $t,
        array: un,
        offset: yn,
        width: Ut.dataWindow.xMax - Ut.dataWindow.xMin + 1,
        height: Ut.dataWindow.yMax - Ut.dataWindow.yMin + 1,
        channels: Ut.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: Ut.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [hasColorSpace ? "colorSpace" : "encoding"]: null,
      };
      switch (Ut.compression) {
        case "NO_COMPRESSION":
          (kn.lines = 1), (kn.uncompress = hn);
          break;
        case "RLE_COMPRESSION":
          (kn.lines = 1), (kn.uncompress = En);
          break;
        case "ZIPS_COMPRESSION":
          (kn.lines = 1), (kn.uncompress = Ln);
          break;
        case "ZIP_COMPRESSION":
          (kn.lines = 16), (kn.uncompress = Ln);
          break;
        case "PIZ_COMPRESSION":
          (kn.lines = 32), (kn.uncompress = mn);
          break;
        case "PXR24_COMPRESSION":
          (kn.lines = 16), (kn.uncompress = Vn);
          break;
        case "DWAA_COMPRESSION":
          (kn.lines = 32), (kn.uncompress = Fn);
          break;
        case "DWAB_COMPRESSION":
          (kn.lines = 256), (kn.uncompress = Fn);
          break;
        default:
          throw "EXRLoader.parse: " + Ut.compression + " is unsupported";
      }
      if (((kn.scanlineBlockSize = kn.lines), kn.type == 1))
        switch (Rn) {
          case FloatType:
            (kn.getter = Hn), (kn.inputSize = 2);
            break;
          case HalfFloatType:
            (kn.getter = Mn), (kn.inputSize = 2);
            break;
        }
      else if (kn.type == 2)
        switch (Rn) {
          case FloatType:
            (kn.getter = Hr), (kn.inputSize = 4);
            break;
          case HalfFloatType:
            (kn.getter = cn), (kn.inputSize = 4);
        }
      else
        throw (
          "EXRLoader.parse: unsupported pixelType " +
          kn.type +
          " for " +
          Ut.compression +
          "."
        );
      kn.blockCount = (Ut.dataWindow.yMax + 1) / kn.scanlineBlockSize;
      for (var er = 0; er < kn.blockCount; er++) Pr($t, yn);
      kn.outputChannels = kn.channels == 3 ? 4 : kn.channels;
      const Xn = kn.width * kn.height * kn.outputChannels;
      switch (Rn) {
        case FloatType:
          (kn.byteArray = new Float32Array(Xn)),
            kn.channels < kn.outputChannels && kn.byteArray.fill(1, 0, Xn);
          break;
        case HalfFloatType:
          (kn.byteArray = new Uint16Array(Xn)),
            kn.channels < kn.outputChannels && kn.byteArray.fill(15360, 0, Xn);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", Rn);
          break;
      }
      return (
        (kn.bytesPerLine = kn.width * kn.inputSize * kn.channels),
        kn.outputChannels == 4
          ? (kn.format = RGBAFormat)
          : (kn.format = RedFormat),
        hasColorSpace ? (kn.colorSpace = "srgb-linear") : (kn.encoding = 3e3),
        kn
      );
    }
    const Cr = new DataView(e),
      zr = new Uint8Array(e),
      pi = { value: 0 },
      qr = xr(Cr, e, pi),
      Ir = Fr(qr, Cr, zr, pi, this.type),
      Pi = { value: 0 },
      mi = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let Ut = 0; Ut < Ir.height / Ir.scanlineBlockSize; Ut++) {
      const $t = mr(Cr, pi);
      (Ir.size = mr(Cr, pi)),
        (Ir.lines =
          $t + Ir.scanlineBlockSize > Ir.height
            ? Ir.height - $t
            : Ir.scanlineBlockSize);
      const yn =
        Ir.size < Ir.lines * Ir.bytesPerLine ? Ir.uncompress(Ir) : hn(Ir);
      pi.value += Ir.size;
      for (let Rn = 0; Rn < Ir.scanlineBlockSize; Rn++) {
        const kn = Rn + Ut * Ir.scanlineBlockSize;
        if (kn >= Ir.height) break;
        for (let er = 0; er < Ir.channels; er++) {
          const Xn = mi[qr.channels[er].name];
          for (let zt = 0; zt < Ir.width; zt++) {
            Pi.value =
              (Rn * (Ir.channels * Ir.width) + er * Ir.width + zt) *
              Ir.inputSize;
            const Zt =
              (Ir.height - 1 - kn) * (Ir.width * Ir.outputChannels) +
              zt * Ir.outputChannels +
              Xn;
            Ir.byteArray[Zt] = Ir.getter(yn, Pi);
          }
        }
      }
    }
    return {
      header: qr,
      width: Ir.width,
      height: Ir.height,
      data: Ir.byteArray,
      format: Ir.format,
      [hasColorSpace ? "colorSpace" : "encoding"]:
        Ir[hasColorSpace ? "colorSpace" : "encoding"],
      type: this.type,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, r, s) {
    function o(a, l) {
      hasColorSpace ? (a.colorSpace = l.colorSpace) : (a.encoding = l.encoding),
        (a.minFilter = LinearFilter),
        (a.magFilter = LinearFilter),
        (a.generateMipmaps = !1),
        (a.flipY = !1),
        t && t(a, l);
    }
    return super.load(e, o, r, s);
  }
}
const getVersion = () => parseInt(REVISION.replace(/\D+/g, "")),
  version = getVersion();
var propTypes = { exports: {} },
  ReactPropTypesSecret_1,
  hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return (ReactPropTypesSecret_1 = n), ReactPropTypesSecret_1;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var n = requireReactPropTypesSecret();
  function e() {}
  function t() {}
  return (
    (t.resetWarningCache = e),
    (factoryWithThrowingShims = function () {
      function r(a, l, c, u, p, N) {
        if (N !== n) {
          var P = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw ((P.name = "Invariant Violation"), P);
        }
      }
      r.isRequired = r;
      function s() {
        return r;
      }
      var o = {
        array: r,
        bigint: r,
        bool: r,
        func: r,
        number: r,
        object: r,
        string: r,
        symbol: r,
        any: r,
        arrayOf: s,
        element: r,
        elementType: r,
        instanceOf: s,
        node: r,
        objectOf: s,
        oneOf: s,
        oneOfType: s,
        shape: s,
        exact: s,
        checkPropTypes: t,
        resetWarningCache: e,
      };
      return (o.PropTypes = o), o;
    }),
    factoryWithThrowingShims
  );
}
var hasRequiredPropTypes;
function requirePropTypes() {
  return (
    hasRequiredPropTypes ||
      ((hasRequiredPropTypes = 1),
      (propTypes.exports = requireFactoryWithThrowingShims()())),
    propTypes.exports
  );
}
const LinearEncoding = 3e3,
  sRGBEncoding = 3001,
  getBufferForType = (n, e, t) => {
    let r;
    switch (n) {
      case UnsignedByteType:
        r = new Uint8ClampedArray(e * t * 4);
        break;
      case HalfFloatType:
        r = new Uint16Array(e * t * 4);
        break;
      case UnsignedIntType:
        r = new Uint32Array(e * t * 4);
        break;
      case ByteType:
        r = new Int8Array(e * t * 4);
        break;
      case ShortType:
        r = new Int16Array(e * t * 4);
        break;
      case IntType:
        r = new Int32Array(e * t * 4);
        break;
      case FloatType:
        r = new Float32Array(e * t * 4);
        break;
      default:
        throw new Error("Unsupported data type");
    }
    return r;
  };
let _canReadPixelsResult;
const canReadPixels = (n, e, t, r) => {
  if (_canReadPixelsResult !== void 0) return _canReadPixelsResult;
  const s = new WebGLRenderTarget(1, 1, r);
  e.setRenderTarget(s);
  const o = new Mesh(
    new PlaneGeometry(),
    new MeshBasicMaterial({ color: 16777215 })
  );
  e.render(o, t), e.setRenderTarget(null);
  const a = getBufferForType(n, s.width, s.height);
  return (
    e.readRenderTargetPixels(s, 0, 0, s.width, s.height, a),
    s.dispose(),
    o.geometry.dispose(),
    o.material.dispose(),
    (_canReadPixelsResult = a[0] !== 0),
    _canReadPixelsResult
  );
};
class QuadRenderer {
  constructor(e) {
    var t, r, s, o, a, l, c, u, p, N, P, de, me, Ye, nt, Be;
    (this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget);
        try {
          this._renderer.render(this._scene, this._camera);
        } catch (st) {
          throw (this._renderer.setRenderTarget(null), st);
        }
        this._renderer.setRenderTarget(null);
      }),
      (this._width = e.width),
      (this._height = e.height),
      (this._type = e.type),
      (this._colorSpace = e.colorSpace);
    const ot = {
      format: RGBAFormat,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((t = e.renderTargetOptions) === null || t === void 0
          ? void 0
          : t.anisotropy) !== void 0
          ? (r = e.renderTargetOptions) === null || r === void 0
            ? void 0
            : r.anisotropy
          : 1,
      generateMipmaps:
        ((s = e.renderTargetOptions) === null || s === void 0
          ? void 0
          : s.generateMipmaps) !== void 0
          ? (o = e.renderTargetOptions) === null || o === void 0
            ? void 0
            : o.generateMipmaps
          : !1,
      magFilter:
        ((a = e.renderTargetOptions) === null || a === void 0
          ? void 0
          : a.magFilter) !== void 0
          ? (l = e.renderTargetOptions) === null || l === void 0
            ? void 0
            : l.magFilter
          : LinearFilter,
      minFilter:
        ((c = e.renderTargetOptions) === null || c === void 0
          ? void 0
          : c.minFilter) !== void 0
          ? (u = e.renderTargetOptions) === null || u === void 0
            ? void 0
            : u.minFilter
          : LinearFilter,
      samples:
        ((p = e.renderTargetOptions) === null || p === void 0
          ? void 0
          : p.samples) !== void 0
          ? (N = e.renderTargetOptions) === null || N === void 0
            ? void 0
            : N.samples
          : void 0,
      wrapS:
        ((P = e.renderTargetOptions) === null || P === void 0
          ? void 0
          : P.wrapS) !== void 0
          ? (de = e.renderTargetOptions) === null || de === void 0
            ? void 0
            : de.wrapS
          : ClampToEdgeWrapping,
      wrapT:
        ((me = e.renderTargetOptions) === null || me === void 0
          ? void 0
          : me.wrapT) !== void 0
          ? (Ye = e.renderTargetOptions) === null || Ye === void 0
            ? void 0
            : Ye.wrapT
          : ClampToEdgeWrapping,
    };
    if (
      ((this._material = e.material),
      e.renderer
        ? (this._renderer = e.renderer)
        : ((this._renderer = QuadRenderer.instantiateRenderer()),
          (this._rendererIsDisposable = !0)),
      (this._scene = new Scene()),
      (this._camera = new OrthographicCamera()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !canReadPixels(this._type, this._renderer, this._camera, ot))
    ) {
      let st;
      switch (this._type) {
        case HalfFloatType:
          st = this._renderer.extensions.has("EXT_color_buffer_float")
            ? FloatType
            : void 0;
          break;
      }
      st !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`
          ),
          (this._type = st))
        : ((this._supportsReadPixels = !1),
          console.warn(
            "This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"
          ));
    }
    (this._quad = new Mesh(new PlaneGeometry(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new WebGLRenderTarget(this.width, this.height, ot)),
      (this._renderTarget.texture.mapping =
        ((nt = e.renderTargetOptions) === null || nt === void 0
          ? void 0
          : nt.mapping) !== void 0
          ? (Be = e.renderTargetOptions) === null || Be === void 0
            ? void 0
            : Be.mapping
          : UVMapping);
  }
  static instantiateRenderer() {
    const e = new WebGLRenderer();
    return e.setSize(128, 128), e;
  }
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const e = getBufferForType(this._type, this._width, this._height);
    return (
      this._renderer.readRenderTargetPixels(
        this._renderTarget,
        0,
        0,
        this._width,
        this._height,
        e
      ),
      e
    );
  }
  toDataTexture(e) {
    const t = new DataTexture(
      this.toArray(),
      this.width,
      this.height,
      RGBAFormat,
      this._type,
      (e == null ? void 0 : e.mapping) || UVMapping,
      (e == null ? void 0 : e.wrapS) || ClampToEdgeWrapping,
      (e == null ? void 0 : e.wrapT) || ClampToEdgeWrapping,
      (e == null ? void 0 : e.magFilter) || LinearFilter,
      (e == null ? void 0 : e.minFilter) || LinearFilter,
      (e == null ? void 0 : e.anisotropy) || 1,
      LinearSRGBColorSpace
    );
    return (
      (t.generateMipmaps =
        (e == null ? void 0 : e.generateMipmaps) !== void 0
          ? e == null
            ? void 0
            : e.generateMipmaps
          : !1),
      t
    );
  }
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null),
      this._rendererIsDisposable &&
        (this._renderer.dispose(), this._renderer.forceContextLoss());
  }
  dispose(e) {
    this.disposeOnDemandRenderer(),
      e && this.renderTarget.dispose(),
      this.material instanceof ShaderMaterial &&
        Object.values(this.material.uniforms).forEach((t) => {
          t.value instanceof Texture && t.value.dispose();
        }),
      Object.values(this.material).forEach((t) => {
        t instanceof Texture && t.dispose();
      }),
      this.material.dispose(),
      this._quad.geometry.dispose();
  }
  get width() {
    return this._width;
  }
  set width(e) {
    (this._width = e), this._renderTarget.setSize(this._width, this._height);
  }
  get height() {
    return this._height;
  }
  set height(e) {
    (this._height = e), this._renderTarget.setSize(this._width, this._height);
  }
  get renderer() {
    return this._renderer;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(e) {
    (this._renderTarget = e),
      (this._width = e.width),
      (this._height = e.height);
  }
  get material() {
    return this._material;
  }
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const vertexShader = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  fragmentShader = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class GainMapDecoderMaterial extends ShaderMaterial {
  constructor({
    gamma: e,
    offsetHdr: t,
    offsetSdr: r,
    gainMapMin: s,
    gainMapMax: o,
    maxDisplayBoost: a,
    hdrCapacityMin: l,
    hdrCapacityMax: c,
    sdr: u,
    gainMap: p,
  }) {
    super({
      name: "GainMapDecoderMaterial",
      vertexShader,
      fragmentShader,
      uniforms: {
        sdr: { value: u },
        gainMap: { value: p },
        gamma: { value: new Vector3(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new Vector3().fromArray(t) },
        offsetSdr: { value: new Vector3().fromArray(r) },
        gainMapMin: { value: new Vector3().fromArray(s) },
        gainMapMax: { value: new Vector3().fromArray(o) },
        weightFactor: { value: (Math.log2(a) - l) / (c - l) },
      },
      blending: NoBlending,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = a),
      (this._hdrCapacityMin = l),
      (this._hdrCapacityMax = c),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0);
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(e) {
    this.uniforms.sdr.value = e;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e;
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e);
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e);
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e);
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e);
  }
  get gamma() {
    const e = this.uniforms.gamma.value;
    return [1 / e.x, 1 / e.y, 1 / e.z];
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value;
    (t.x = 1 / e[0]), (t.y = 1 / e[1]), (t.z = 1 / e[2]);
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(e) {
    (this._hdrCapacityMin = e), this.calculateWeight();
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(e) {
    (this._hdrCapacityMax = e), this.calculateWeight();
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(e) {
    (this._maxDisplayBoost = Math.max(1, Math.min(65504, e))),
      this.calculateWeight();
  }
  calculateWeight() {
    const e =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e));
  }
}
class GainMapNotFoundError extends Error {}
class XMPMetadataNotFoundError extends Error {}
const getXMLValue = (n, e, t) => {
    const r = new RegExp(`${e}="([^"]*)"`, "i").exec(n);
    if (r) return r[1];
    const s = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, "i").exec(n);
    if (s) {
      const o = s[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
      return o && o.length === 3
        ? o.map((a) => a.replace(/<\/?rdf:li>/g, ""))
        : s[1].trim();
    }
    if (t !== void 0) return t;
    throw new Error(`Can't find ${e} in gainmap metadata`);
  },
  extractXMP = (n) => {
    let e;
    typeof TextDecoder < "u"
      ? (e = new TextDecoder().decode(n))
      : (e = n.toString());
    let t = e.indexOf("<x:xmpmeta");
    for (; t !== -1; ) {
      const r = e.indexOf("x:xmpmeta>", t),
        s = e.slice(t, r + 10);
      try {
        const o = getXMLValue(s, "hdrgm:GainMapMin", "0"),
          a = getXMLValue(s, "hdrgm:GainMapMax"),
          l = getXMLValue(s, "hdrgm:Gamma", "1"),
          c = getXMLValue(s, "hdrgm:OffsetSDR", "0.015625"),
          u = getXMLValue(s, "hdrgm:OffsetHDR", "0.015625"),
          p = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(s),
          N = p ? p[1] : "0",
          P = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(s);
        if (!P) throw new Error("Incomplete gainmap metadata");
        const de = P[1];
        return {
          gainMapMin: Array.isArray(o)
            ? o.map((me) => parseFloat(me))
            : [parseFloat(o), parseFloat(o), parseFloat(o)],
          gainMapMax: Array.isArray(a)
            ? a.map((me) => parseFloat(me))
            : [parseFloat(a), parseFloat(a), parseFloat(a)],
          gamma: Array.isArray(l)
            ? l.map((me) => parseFloat(me))
            : [parseFloat(l), parseFloat(l), parseFloat(l)],
          offsetSdr: Array.isArray(c)
            ? c.map((me) => parseFloat(me))
            : [parseFloat(c), parseFloat(c), parseFloat(c)],
          offsetHdr: Array.isArray(u)
            ? u.map((me) => parseFloat(me))
            : [parseFloat(u), parseFloat(u), parseFloat(u)],
          hdrCapacityMin: parseFloat(N),
          hdrCapacityMax: parseFloat(de),
        };
      } catch {}
      t = e.indexOf("<x:xmpmeta", r);
    }
  };
class MPFExtractor {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0,
    };
  }
  extract(e) {
    return new Promise((t, r) => {
      const s = this.options.debug,
        o = new DataView(e.buffer);
      if (o.getUint16(0) !== 65496) {
        r(new Error("Not a valid jpeg"));
        return;
      }
      const a = o.byteLength;
      let l = 2,
        c = 0,
        u;
      for (; l < a; ) {
        if (++c > 250) {
          r(new Error(`Found no marker after ${c} loops `));
          return;
        }
        if (o.getUint8(l) !== 255) {
          r(
            new Error(
              `Not a valid marker at offset 0x${l.toString(16)}, found: 0x${o
                .getUint8(l)
                .toString(16)}`
            )
          );
          return;
        }
        if (
          ((u = o.getUint8(l + 1)),
          s && console.log(`Marker: ${u.toString(16)}`),
          u === 226)
        ) {
          s && console.log("Found APP2 marker (0xffe2)");
          const p = l + 4;
          if (o.getUint32(p) === 1297106432) {
            const N = p + 4;
            let P;
            if (o.getUint16(N) === 18761) P = !1;
            else if (o.getUint16(N) === 19789) P = !0;
            else {
              r(new Error("No valid endianness marker found in TIFF header"));
              return;
            }
            if (o.getUint16(N + 2, !P) !== 42) {
              r(new Error("Not valid TIFF data! (no 0x002A marker)"));
              return;
            }
            const de = o.getUint32(N + 4, !P);
            if (de < 8) {
              r(new Error("Not valid TIFF data! (First offset less than 8)"));
              return;
            }
            const me = N + de,
              Ye = o.getUint16(me, !P),
              nt = me + 2;
            let Be = 0;
            for (let xt = nt; xt < nt + 12 * Ye; xt += 12)
              o.getUint16(xt, !P) === 45057 && (Be = o.getUint32(xt + 8, !P));
            const st = me + 2 + Ye * 12 + 4,
              vt = [];
            for (let xt = st; xt < st + Be * 16; xt += 16) {
              const St = {
                MPType: o.getUint32(xt, !P),
                size: o.getUint32(xt + 4, !P),
                dataOffset: o.getUint32(xt + 8, !P),
                dependantImages: o.getUint32(xt + 12, !P),
                start: -1,
                end: -1,
                isFII: !1,
              };
              St.dataOffset
                ? ((St.start = N + St.dataOffset), (St.isFII = !1))
                : ((St.start = 0), (St.isFII = !0)),
                (St.end = St.start + St.size),
                vt.push(St);
            }
            if (this.options.extractNonFII && vt.length) {
              const xt = new Blob([o]),
                St = [];
              for (const wt of vt) {
                if (wt.isFII && !this.options.extractFII) continue;
                const bt = xt.slice(wt.start, wt.end + 1, "image/jpeg");
                St.push(bt);
              }
              t(St);
            }
          }
        }
        l += 2 + o.getUint16(l + 2);
      }
    });
  }
}
const extractGainmapFromJPEG = async (n) => {
    const e = extractXMP(n);
    if (!e)
      throw new XMPMetadataNotFoundError("Gain map XMP metadata not found");
    const r = await new MPFExtractor({
      extractFII: !0,
      extractNonFII: !0,
    }).extract(n);
    if (r.length !== 2)
      throw new GainMapNotFoundError("Gain map recovery image not found");
    return {
      sdr: new Uint8Array(await r[0].arrayBuffer()),
      gainMap: new Uint8Array(await r[1].arrayBuffer()),
      metadata: e,
    };
  },
  getHTMLImageFromBlob = (n) =>
    new Promise((e, t) => {
      const r = document.createElement("img");
      (r.onload = () => {
        e(r);
      }),
        (r.onerror = (s) => {
          t(s);
        }),
        (r.src = URL.createObjectURL(n));
    });
class LoaderBase extends Loader$2 {
  constructor(e, t) {
    super(t),
      e && (this._renderer = e),
      (this._internalLoadingManager = new LoadingManager());
  }
  setRenderer(e) {
    return (this._renderer = e), this;
  }
  setRenderTargetOptions(e) {
    return (this._renderTargetOptions = e), this;
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        "WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer."
      );
    const e = new GainMapDecoderMaterial({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Texture(),
      sdr: new Texture(),
    });
    return new QuadRenderer({
      width: 16,
      height: 16,
      type: HalfFloatType,
      colorSpace: LinearSRGBColorSpace,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    });
  }
  async render(e, t, r, s) {
    const o = s ? new Blob([s], { type: "image/jpeg" }) : void 0,
      a = new Blob([r], { type: "image/jpeg" });
    let l,
      c,
      u = !1;
    if (typeof createImageBitmap > "u") {
      const P = await Promise.all([
        o ? getHTMLImageFromBlob(o) : Promise.resolve(void 0),
        getHTMLImageFromBlob(a),
      ]);
      (c = P[0]), (l = P[1]), (u = !0);
    } else {
      const P = await Promise.all([
        o
          ? createImageBitmap(o, { imageOrientation: "flipY" })
          : Promise.resolve(void 0),
        createImageBitmap(a, { imageOrientation: "flipY" }),
      ]);
      (c = P[0]), (l = P[1]);
    }
    const p = new Texture(
      c || new ImageData(2, 2),
      UVMapping,
      ClampToEdgeWrapping,
      ClampToEdgeWrapping,
      LinearFilter,
      LinearMipMapLinearFilter,
      RGBAFormat,
      UnsignedByteType,
      1,
      LinearSRGBColorSpace
    );
    (p.flipY = u), (p.needsUpdate = !0);
    const N = new Texture(
      l,
      UVMapping,
      ClampToEdgeWrapping,
      ClampToEdgeWrapping,
      LinearFilter,
      LinearMipMapLinearFilter,
      RGBAFormat,
      UnsignedByteType,
      1,
      SRGBColorSpace
    );
    (N.flipY = u),
      (N.needsUpdate = !0),
      (e.width = l.width),
      (e.height = l.height),
      (e.material.gainMap = p),
      (e.material.sdr = N),
      (e.material.gainMapMin = t.gainMapMin),
      (e.material.gainMapMax = t.gainMapMax),
      (e.material.offsetHdr = t.offsetHdr),
      (e.material.offsetSdr = t.offsetSdr),
      (e.material.gamma = t.gamma),
      (e.material.hdrCapacityMin = t.hdrCapacityMin),
      (e.material.hdrCapacityMax = t.hdrCapacityMax),
      (e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax)),
      (e.material.needsUpdate = !0),
      e.render();
  }
}
class GainMapLoader extends LoaderBase {
  load([e, t, r], s, o, a) {
    const l = this.prepareQuadRenderer();
    let c, u, p;
    const N = async () => {
      if (c && u && p) {
        try {
          await this.render(l, p, c, u);
        } catch (Tt) {
          this.manager.itemError(e),
            this.manager.itemError(t),
            this.manager.itemError(r),
            typeof a == "function" && a(Tt),
            l.disposeOnDemandRenderer();
          return;
        }
        typeof s == "function" && s(l),
          this.manager.itemEnd(e),
          this.manager.itemEnd(t),
          this.manager.itemEnd(r),
          l.disposeOnDemandRenderer();
      }
    };
    let P = !0,
      de = 0,
      me = 0,
      Ye = !0,
      nt = 0,
      Be = 0,
      ot = !0,
      st = 0,
      vt = 0;
    const xt = () => {
      if (typeof o == "function") {
        const Tt = de + nt + st,
          Ct = me + Be + vt,
          kt = P && Ye && ot;
        o(
          new ProgressEvent("progress", {
            lengthComputable: kt,
            loaded: Ct,
            total: Tt,
          })
        );
      }
    };
    this.manager.itemStart(e),
      this.manager.itemStart(t),
      this.manager.itemStart(r);
    const St = new FileLoader(this._internalLoadingManager);
    St.setResponseType("arraybuffer"),
      St.setRequestHeader(this.requestHeader),
      St.setPath(this.path),
      St.setWithCredentials(this.withCredentials),
      St.load(
        e,
        async (Tt) => {
          if (typeof Tt == "string") throw new Error("Invalid sdr buffer");
          (c = Tt), await N();
        },
        (Tt) => {
          (P = Tt.lengthComputable), (me = Tt.loaded), (de = Tt.total), xt();
        },
        (Tt) => {
          this.manager.itemError(e), typeof a == "function" && a(Tt);
        }
      );
    const wt = new FileLoader(this._internalLoadingManager);
    wt.setResponseType("arraybuffer"),
      wt.setRequestHeader(this.requestHeader),
      wt.setPath(this.path),
      wt.setWithCredentials(this.withCredentials),
      wt.load(
        t,
        async (Tt) => {
          if (typeof Tt == "string") throw new Error("Invalid gainmap buffer");
          (u = Tt), await N();
        },
        (Tt) => {
          (Ye = Tt.lengthComputable), (Be = Tt.loaded), (nt = Tt.total), xt();
        },
        (Tt) => {
          this.manager.itemError(t), typeof a == "function" && a(Tt);
        }
      );
    const bt = new FileLoader(this._internalLoadingManager);
    return (
      bt.setRequestHeader(this.requestHeader),
      bt.setPath(this.path),
      bt.setWithCredentials(this.withCredentials),
      bt.load(
        r,
        async (Tt) => {
          if (typeof Tt != "string") throw new Error("Invalid metadata string");
          (p = JSON.parse(Tt)), await N();
        },
        (Tt) => {
          (ot = Tt.lengthComputable), (vt = Tt.loaded), (st = Tt.total), xt();
        },
        (Tt) => {
          this.manager.itemError(r), typeof a == "function" && a(Tt);
        }
      ),
      l
    );
  }
}
class HDRJPGLoader extends LoaderBase {
  load(e, t, r, s) {
    const o = this.prepareQuadRenderer(),
      a = new FileLoader(this._internalLoadingManager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(this.withCredentials),
      this.manager.itemStart(e),
      a.load(
        e,
        async (l) => {
          if (typeof l == "string")
            throw new Error(
              "Invalid buffer, received [string], was expecting [ArrayBuffer]"
            );
          const c = new Uint8Array(l);
          let u, p, N;
          try {
            const P = await extractGainmapFromJPEG(c);
            (u = P.sdr), (p = P.gainMap), (N = P.metadata);
          } catch (P) {
            if (
              P instanceof XMPMetadataNotFoundError ||
              P instanceof GainMapNotFoundError
            )
              console.warn(
                `Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`
              ),
                (N = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (u = c);
            else throw P;
          }
          try {
            await this.render(o, N, u, p);
          } catch (P) {
            this.manager.itemError(e),
              typeof s == "function" && s(P),
              o.disposeOnDemandRenderer();
            return;
          }
          typeof t == "function" && t(o),
            this.manager.itemEnd(e),
            o.disposeOnDemandRenderer();
        },
        r,
        (l) => {
          this.manager.itemError(e), typeof s == "function" && s(l);
        }
      ),
      o
    );
  }
}
const presetsObj = {
    apartment: "lebombo_1k.hdr",
    city: "potsdamer_platz_1k.hdr",
    dawn: "kiara_1_dawn_1k.hdr",
    forest: "forest_slope_1k.hdr",
    lobby: "st_fagans_interior_1k.hdr",
    night: "dikhololo_night_1k.hdr",
    park: "rooitou_park_1k.hdr",
    studio: "studio_small_03_1k.hdr",
    sunset: "venice_sunset_1k.hdr",
    warehouse: "empty_warehouse_01_1k.hdr",
  },
  CUBEMAP_ROOT =
    "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
  isArray = (n) => Array.isArray(n),
  defaultFiles = [
    "/px.png",
    "/nx.png",
    "/py.png",
    "/ny.png",
    "/pz.png",
    "/nz.png",
  ];
function useEnvironment({
  files: n = defaultFiles,
  path: e = "",
  preset: t = void 0,
  encoding: r = void 0,
  extensions: s,
} = {}) {
  let o = null,
    a = !1;
  t && (validatePreset(t), (n = presetsObj[t]), (e = CUBEMAP_ROOT)),
    (a = isArray(n));
  const { extension: l, isCubemap: c } = getExtension(n);
  if (((o = getLoader(l)), !o))
    throw new Error("useEnvironment: Unrecognized file extension: " + n);
  const u = useThree((de) => de.gl);
  reactExports.useLayoutEffect(() => {
    if (l !== "webp" && l !== "jpg" && l !== "jpeg") return;
    function de() {
      useLoader.clear(o, a ? [n] : n);
    }
    u.domElement.addEventListener("webglcontextlost", de, { once: !0 });
  }, [n, u.domElement]);
  const p = useLoader(o, a ? [n] : n, (de) => {
    (l === "webp" || l === "jpg" || l === "jpeg") && de.setRenderer(u),
      de.setPath == null || de.setPath(e),
      s && s(de);
  });
  let N = a ? p[0] : p;
  if (l === "jpg" || l === "jpeg" || l === "webp") {
    var P;
    N = (P = N.renderTarget) == null ? void 0 : P.texture;
  }
  return (
    (N.mapping = c ? CubeReflectionMapping : EquirectangularReflectionMapping),
    "colorSpace" in N
      ? (N.colorSpace = r ?? c ? "srgb" : "srgb-linear")
      : (N.encoding = r ?? c ? sRGBEncoding : LinearEncoding),
    N
  );
}
const preloadDefaultOptions = {
  files: defaultFiles,
  path: "",
  preset: void 0,
  extensions: void 0,
};
useEnvironment.preload = (n) => {
  const e = { ...preloadDefaultOptions, ...n };
  let { files: t, path: r = "" } = e;
  const { preset: s, extensions: o } = e;
  s && (validatePreset(s), (t = presetsObj[s]), (r = CUBEMAP_ROOT));
  const { extension: a } = getExtension(t);
  if (a === "webp" || a === "jpg" || a === "jpeg")
    throw new Error("useEnvironment: Preloading gainmaps is not supported");
  const l = getLoader(a);
  if (!l) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  useLoader.preload(l, isArray(t) ? [t] : t, (c) => {
    c.setPath == null || c.setPath(r), o && o(c);
  });
};
const clearDefaultOptins = { files: defaultFiles, preset: void 0 };
useEnvironment.clear = (n) => {
  const e = { ...clearDefaultOptins, ...n };
  let { files: t } = e;
  const { preset: r } = e;
  r && (validatePreset(r), (t = presetsObj[r]));
  const { extension: s } = getExtension(t),
    o = getLoader(s);
  if (!o) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  useLoader.clear(o, isArray(t) ? [t] : t);
};
function validatePreset(n) {
  if (!(n in presetsObj))
    throw new Error(
      "Preset must be one of: " + Object.keys(presetsObj).join(", ")
    );
}
function getExtension(n) {
  var e;
  const t = isArray(n) && n.length === 6,
    r = isArray(n) && n.length === 3 && n.some((a) => a.endsWith("json")),
    s = isArray(n) ? n[0] : n;
  return {
    extension: t
      ? "cube"
      : r
      ? "webp"
      : s.startsWith("data:application/exr")
      ? "exr"
      : s.startsWith("data:application/hdr")
      ? "hdr"
      : s.startsWith("data:image/jpeg")
      ? "jpg"
      : (e = s.split(".").pop()) == null ||
        (e = e.split("?")) == null ||
        (e = e.shift()) == null
      ? void 0
      : e.toLowerCase(),
    isCubemap: t,
    isGainmap: r,
  };
}
function getLoader(n) {
  return n === "cube"
    ? CubeTextureLoader
    : n === "hdr"
    ? RGBELoader
    : n === "exr"
    ? EXRLoader
    : n === "jpg" || n === "jpeg"
    ? HDRJPGLoader
    : n === "webp"
    ? GainMapLoader
    : null;
}
const isRef = (n) => n.current && n.current.isScene,
  resolveScene = (n) => (isRef(n) ? n.current : n);
function setEnvProps(n, e, t, r, s = {}) {
  var o, a, l, c;
  s = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...s,
  };
  const u = resolveScene(e || t),
    p = u.background,
    N = u.environment,
    P = {
      backgroundBlurriness: u.backgroundBlurriness,
      backgroundIntensity: u.backgroundIntensity,
      backgroundRotation:
        (o =
          (a = u.backgroundRotation) == null || a.clone == null
            ? void 0
            : a.clone()) !== null && o !== void 0
          ? o
          : [0, 0, 0],
      environmentIntensity: u.environmentIntensity,
      environmentRotation:
        (l =
          (c = u.environmentRotation) == null || c.clone == null
            ? void 0
            : c.clone()) !== null && l !== void 0
          ? l
          : [0, 0, 0],
    };
  return (
    n !== "only" && (u.environment = r),
    n && (u.background = r),
    applyProps(u, s),
    () => {
      n !== "only" && (u.environment = N),
        n && (u.background = p),
        applyProps(u, P);
    }
  );
}
function EnvironmentMap({ scene: n, background: e = !1, map: t, ...r }) {
  const s = useThree((o) => o.scene);
  return (
    reactExports.useLayoutEffect(() => {
      if (t) return setEnvProps(e, n, s, t, r);
    }),
    null
  );
}
function EnvironmentCube({
  background: n = !1,
  scene: e,
  blur: t,
  backgroundBlurriness: r,
  backgroundIntensity: s,
  backgroundRotation: o,
  environmentIntensity: a,
  environmentRotation: l,
  ...c
}) {
  const u = useEnvironment(c),
    p = useThree((N) => N.scene);
  return (
    reactExports.useLayoutEffect(() =>
      setEnvProps(n, e, p, u, {
        backgroundBlurriness: t ?? r,
        backgroundIntensity: s,
        backgroundRotation: o,
        environmentIntensity: a,
        environmentRotation: l,
      })
    ),
    reactExports.useEffect(
      () => () => {
        u.dispose();
      },
      [u]
    ),
    null
  );
}
function EnvironmentPortal({
  children: n,
  near: e = 0.1,
  far: t = 1e3,
  resolution: r = 256,
  frames: s = 1,
  map: o,
  background: a = !1,
  blur: l,
  backgroundBlurriness: c,
  backgroundIntensity: u,
  backgroundRotation: p,
  environmentIntensity: N,
  environmentRotation: P,
  scene: de,
  files: me,
  path: Ye,
  preset: nt = void 0,
  extensions: Be,
}) {
  const ot = useThree((bt) => bt.gl),
    st = useThree((bt) => bt.scene),
    vt = reactExports.useRef(null),
    [xt] = reactExports.useState(() => new Scene()),
    St = reactExports.useMemo(() => {
      const bt = new WebGLCubeRenderTarget(r);
      return (bt.texture.type = HalfFloatType), bt;
    }, [r]);
  reactExports.useEffect(
    () => () => {
      St.dispose();
    },
    [St]
  ),
    reactExports.useLayoutEffect(() => {
      if (s === 1) {
        const bt = ot.autoClear;
        (ot.autoClear = !0), vt.current.update(ot, xt), (ot.autoClear = bt);
      }
      return setEnvProps(a, de, st, St.texture, {
        backgroundBlurriness: l ?? c,
        backgroundIntensity: u,
        backgroundRotation: p,
        environmentIntensity: N,
        environmentRotation: P,
      });
    }, [n, xt, St.texture, de, st, a, s, ot]);
  let wt = 1;
  return (
    useFrame(() => {
      if (s === 1 / 0 || wt < s) {
        const bt = ot.autoClear;
        (ot.autoClear = !0),
          vt.current.update(ot, xt),
          (ot.autoClear = bt),
          wt++;
      }
    }),
    reactExports.createElement(
      reactExports.Fragment,
      null,
      createPortal(
        reactExports.createElement(
          reactExports.Fragment,
          null,
          n,
          reactExports.createElement("cubeCamera", {
            ref: vt,
            args: [e, t, St],
          }),
          me || nt
            ? reactExports.createElement(EnvironmentCube, {
                background: !0,
                files: me,
                preset: nt,
                path: Ye,
                extensions: Be,
              })
            : o
            ? reactExports.createElement(EnvironmentMap, {
                background: !0,
                map: o,
                extensions: Be,
              })
            : null
        ),
        xt
      )
    )
  );
}
function EnvironmentGround(n) {
  var e, t, r, s;
  const o = useEnvironment(n),
    a = n.map || o;
  reactExports.useMemo(
    () => extend({ GroundProjectedEnvImpl: GroundProjectedEnv }),
    []
  ),
    reactExports.useEffect(
      () => () => {
        o.dispose();
      },
      [o]
    );
  const l = reactExports.useMemo(() => [a], [a]),
    c = (e = n.ground) == null ? void 0 : e.height,
    u = (t = n.ground) == null ? void 0 : t.radius,
    p =
      (r = (s = n.ground) == null ? void 0 : s.scale) !== null && r !== void 0
        ? r
        : 1e3;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    reactExports.createElement(EnvironmentMap, _extends({}, n, { map: a })),
    reactExports.createElement("groundProjectedEnvImpl", {
      args: l,
      scale: p,
      height: c,
      radius: u,
    })
  );
}
function Environment(n) {
  return n.ground
    ? reactExports.createElement(EnvironmentGround, n)
    : n.map
    ? reactExports.createElement(EnvironmentMap, n)
    : n.children
    ? reactExports.createElement(EnvironmentPortal, n)
    : reactExports.createElement(EnvironmentCube, n);
}
class SparklesImplMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: { time: { value: 0 }, pixelRatio: { value: 1 } },
      vertexShader: `
        uniform float pixelRatio;
        uniform float time;
        attribute float size;  
        attribute float speed;  
        attribute float opacity;
        attribute vec3 noise;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vOpacity;

        void main() {
          vec4 modelPosition = modelMatrix * vec4(position, 1.0);
          modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;
          modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;
          modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;
          vec4 viewPosition = viewMatrix * modelPosition;
          vec4 projectionPostion = projectionMatrix * viewPosition;
          gl_Position = projectionPostion;
          gl_PointSize = size * 25. * pixelRatio;
          gl_PointSize *= (1.0 / - viewPosition.z);
          vColor = color;
          vOpacity = opacity;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        varying float vOpacity;
        void main() {
          float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
          float strength = 0.05 / distanceToCenter - 0.1;
          gl_FragColor = vec4(vColor, strength * vOpacity);
          #include <tonemapping_fragment>
          #include <${
            version >= 154 ? "colorspace_fragment" : "encodings_fragment"
          }>
        }
      `,
    });
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(e) {
    this.uniforms.time.value = e;
  }
  get pixelRatio() {
    return this.uniforms.pixelRatio.value;
  }
  set pixelRatio(e) {
    this.uniforms.pixelRatio.value = e;
  }
}
const isFloat32Array = (n) => n && n.constructor === Float32Array,
  expandColor = (n) => [n.r, n.g, n.b],
  isVector = (n) =>
    n instanceof Vector2 || n instanceof Vector3 || n instanceof Vector4,
  normalizeVector = (n) =>
    Array.isArray(n) ? n : isVector(n) ? n.toArray() : [n, n, n];
function usePropAsIsOrAsAttribute(n, e, t) {
  return reactExports.useMemo(() => {
    if (e !== void 0) {
      if (isFloat32Array(e)) return e;
      if (e instanceof Color) {
        const r = Array.from({ length: n * 3 }, () => expandColor(e)).flat();
        return Float32Array.from(r);
      } else if (isVector(e) || Array.isArray(e)) {
        const r = Array.from({ length: n * 3 }, () =>
          normalizeVector(e)
        ).flat();
        return Float32Array.from(r);
      }
      return Float32Array.from({ length: n }, () => e);
    }
    return Float32Array.from({ length: n }, t);
  }, [e]);
}
const Sparkles = reactExports.forwardRef(
  (
    {
      noise: n = 1,
      count: e = 100,
      speed: t = 1,
      opacity: r = 1,
      scale: s = 1,
      size: o,
      color: a,
      children: l,
      ...c
    },
    u
  ) => {
    reactExports.useMemo(() => extend({ SparklesImplMaterial }), []);
    const p = reactExports.useRef(null),
      N = useThree((st) => st.viewport.dpr),
      P = normalizeVector(s),
      de = reactExports.useMemo(
        () =>
          Float32Array.from(
            Array.from({ length: e }, () =>
              P.map(MathUtils.randFloatSpread)
            ).flat()
          ),
        [e, ...P]
      ),
      me = usePropAsIsOrAsAttribute(e, o, Math.random),
      Ye = usePropAsIsOrAsAttribute(e, r),
      nt = usePropAsIsOrAsAttribute(e, t),
      Be = usePropAsIsOrAsAttribute(e * 3, n),
      ot = usePropAsIsOrAsAttribute(
        a === void 0 ? e * 3 : e,
        isFloat32Array(a) ? a : new Color(a),
        () => 1
      );
    return (
      useFrame((st) => {
        p.current &&
          p.current.material &&
          (p.current.material.time = st.clock.elapsedTime);
      }),
      reactExports.useImperativeHandle(u, () => p.current, []),
      reactExports.createElement(
        "points",
        _extends({ key: `particle-${e}-${JSON.stringify(s)}` }, c, { ref: p }),
        reactExports.createElement(
          "bufferGeometry",
          null,
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-position",
            args: [de, 3],
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-size",
            args: [me, 1],
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-opacity",
            args: [Ye, 1],
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-speed",
            args: [nt, 1],
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-color",
            args: [ot, 3],
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-noise",
            args: [Be, 3],
          })
        ),
        l ||
          reactExports.createElement("sparklesImplMaterial", {
            transparent: !0,
            pixelRatio: N,
            depthWrite: !1,
          })
      )
    );
  }
);
function GlobalScene() {
  const { isTouchDevices: n } = useDeviceType(),
    e = reactExports.useRef(null),
    t = (r) => {
      const s = r.scene.getObjectByName("Scene");
      console.log(
        s ? "MODEL is present in the scene" : "MODEL is not yet loaded"
      );
    };
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsxs(Canvas, {
      id: "globalCanvas",
      style: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: -1,
        position: "fixed",
        background:
          "radial-gradient(circle at 50% 50%, #1b1b2f, #0f0f1f 50%, #000000 100%)",
      },
      gl: { alpha: !0, antialias: !n, premultipliedAlpha: !0 },
      onCreated: (r) => {
        r.gl.setClearColor(0, 0), t(r);
      },
      children: [
        jsxRuntimeExports.jsx(CameraControl, {}),
        !n &&
          jsxRuntimeExports.jsx(Sparkles, {
            ref: e,
            position: [0, 0, 0],
            count: 150,
            speed: 0.5,
            opacity: 1,
            color: new Color(1, 1, 1),
            size: 3,
            scale: 8,
            noise: [0.1, 0.5, 0.25],
          }),
        jsxRuntimeExports.jsx("ambientLight", {
          color: colors.primaryColor3DScene,
          intensity: 2,
        }),
        jsxRuntimeExports.jsx("directionalLight", {
          color: colors.sceneLight3D_Direction_Second,
          position: [1, 2, 2],
          intensity: 1.5,
        }),
        jsxRuntimeExports.jsx("directionalLight", {
          color: colors.sceneLight3D_Direction_Second,
          position: [-1, 3, 1],
          intensity: 1,
        }),
        jsxRuntimeExports.jsx(Model, {}),
        jsxRuntimeExports.jsx(Environment, {
          files: "/textures/hdri/Atelier_hdr_512.hdr",
        }),
        jsxRuntimeExports.jsx(AnimationProcessor, { particlesRef: e }),
      ],
    }),
  });
}
const Loader$1 = () => {
    const { isModelRendered: n } = useLandingContext();
    return n
      ? null
      : ReactDOM.createPortal(
          jsxRuntimeExports.jsx(MainLoaderPortal, {
            children: jsxRuntimeExports.jsx(AnimatedBG, {
              children: jsxRuntimeExports.jsx(SpinnerWrapper, {
                children: jsxRuntimeExports.jsxs(SpinnerGroup, {
                  children: [
                    jsxRuntimeExports.jsx(SpinnerCircle, {
                      size: 125,
                      borderPx: 2,
                      borderTopPx: 2,
                      color: "#fff",
                      duration: "5s",
                      direction: "normal",
                    }),
                    jsxRuntimeExports.jsx(SpinnerCircle, {
                      size: 135,
                      borderPx: 2,
                      borderTopPx: 2,
                      color: "#e0e0e0",
                      duration: "4s",
                      direction: "reverse",
                    }),
                    jsxRuntimeExports.jsx(SpinnerCircle, {
                      size: 145,
                      borderPx: 2,
                      borderTopPx: 2,
                      color: "#cccccc",
                      duration: "3s",
                      direction: "normal",
                    }),
                  ],
                }),
              }),
            }),
          }),
          document.getElementById("loader-root")
        );
  },
  Main = dt.div`
  width: 100vw;
  height: 100vh;
`,
  Content$5 = dt.div`
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  @media (min-width: 80rem) {
  }
`,
  TextContainer$1 = dt.div`
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
    h1 {
    position: absolute;
    top: 0;
    left: 0;
    font-size: 1.875rem;
    line-height: 130%;
    letter-spacing: 0.16rem;
    text-transform: uppercase;
    opacity: 0;
    z-index: -1;
  }
`,
  moveUpDescr$2 = mt`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`,
  TextDescr$1 = dt.h2`
  line-height: 130%;
  letter-spacing: 0.16rem;
  text-transform: uppercase;
  text-align: center;
  opacity: 0;
  font-size: 1rem;
  &.animateDescr {
    animation: ${moveUpDescr$2} 1.5s ease-out;
  }
  &.visible {
    opacity: 1;
  }
  @media (min-width: 48rem) {
    font-size: 1.375rem;
    br {
      display: none;
    }
  }
`,
  ButtonContainer$1 = dt.div`
  width: 10.8125rem;
  height: 3.5rem;
  position: absolute;
  bottom: 7.5rem;
  @media (min-width: 48rem) {
    bottom: 5.25rem;
`,
  Hint = dt.div`
  position: absolute;
  bottom: 5rem;
  right: 0;
  align-items: center;
  opacity: 0;
  display: none;
  &.animateDescr {
    animation: ${moveUpDescr$2} 1.8s ease-out;
  }
  @media (min-width: 48rem) {
    display: block;
  }
  &.visible {
    opacity: 1;
  }
  @media (min-width: 48rem) {
    display: flex;
  }
  span {
    font-weight: 400;
    font-size: 0.75rem;
    letter-spacing: 0.12rem;
    text-transform: uppercase;
    color: var(--colors-white-50);
    opacity: 0.5;
  }
  svg {
    margin-left: 16px;
  }
`,
  BurgerIcon = (n) =>
    jsxRuntimeExports.jsxs("svg", {
      width: "25",
      height: "25",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...n,
      children: [
        jsxRuntimeExports.jsx("path", {
          d: "M3.125 12.5H21.875",
          stroke: "white",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        jsxRuntimeExports.jsx("path", {
          d: "M3.125 6.25H15.625M9.375 18.75H21.875",
          stroke: "white",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      ],
    }),
  LogoIcon = (n) =>
    jsxRuntimeExports.jsx("svg", {
      width: "45",
      height: "45",
      viewBox: "0 0 45 45",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...n,
      children: jsxRuntimeExports.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M 0 0.003 L 22.498 0.003 Q 31.835 0.003 38.416 6.584 Q 44.997 13.165 44.997 22.501 Q 44.997 31.838 38.416 38.419 Q 31.835 45 22.498 45 L 0 45 L 0 41.231 L 22.498 41.231 Q 27.561 41.231 31.891 38.728 Q 36.222 36.225 38.725 31.894 Q 41.228 27.564 41.228 22.501 Q 41.228 17.439 38.725 13.108 Q 36.222 8.777 31.891 6.274 Q 27.561 3.771 22.498 3.771 L 0 3.771 L 0 0.003 Z",
        fill: "white",
      }),
    }),
  LogoHover = (n) =>
    jsxRuntimeExports.jsxs("svg", {
      width: "32",
      height: "32",
      viewBox: "0 0 32 32",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...n,
      children: [
        jsxRuntimeExports.jsx("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M 0 0.002 L 15.999 0.002 Q 22.638 0.002 27.318 4.682 Q 31.998 9.361 31.998 16.001 Q 31.998 22.64 27.318 27.32 Q 22.638 32 15.999 32 L 0 32 L 0 29.32 L 15.999 29.32 Q 19.599 29.32 22.678 27.54 Q 25.758 25.76 27.538 22.68 Q 29.318 19.601 29.318 16.001 Q 29.318 12.401 27.538 9.321 Q 25.758 6.242 22.678 4.462 Q 19.599 2.682 15.999 2.682 L 0 2.682 L 0 0.002 Z",
          fill: "url(#paint0_linear_7609_7415)",
        }),
        jsxRuntimeExports.jsx("defs", {
          children: jsxRuntimeExports.jsxs("linearGradient", {
            id: "paint0_linear_7609_7415",
            x1: "-0.195668",
            y1: "14.631",
            x2: "32.1997",
            y2: "15.0643",
            gradientUnits: "userSpaceOnUse",
            children: [
              jsxRuntimeExports.jsx("stop", { stopColor: "#C7ACFF" }),
              jsxRuntimeExports.jsx("stop", {
                offset: "0.8706",
                stopColor: "white",
              }),
            ],
          }),
        }),
      ],
    }),
  DArrow = ({}) =>
    jsxRuntimeExports.jsx("svg", {
      width: "16",
      height: "18",
      viewBox: "0 0 16 18",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: jsxRuntimeExports.jsx("path", {
        d: "M0.984903 10.2349C1.01971 10.2 1.06105 10.1724 1.10654 10.1536C1.15203 10.1347 1.2008 10.125 1.25004 10.125C1.29928 10.125 1.34805 10.1347 1.39354 10.1536C1.43903 10.1724 1.48036 10.2 1.51518 10.2349L7.62504 16.3446L7.62504 0.750001C7.62504 0.650544 7.66455 0.555161 7.73487 0.484835C7.8052 0.414509 7.90058 0.375001 8.00004 0.375001C8.09949 0.375001 8.19488 0.414509 8.2652 0.484835C8.33553 0.555161 8.37504 0.650544 8.37504 0.750001L8.37504 16.3446L14.4849 10.2349C14.5552 10.1645 14.6506 10.125 14.75 10.125C14.8495 10.125 14.9449 10.1645 15.0152 10.2349C15.0855 10.3052 15.125 10.4006 15.125 10.5C15.125 10.5994 15.0855 10.6948 15.0152 10.7651L8.26518 17.5151C8.23036 17.55 8.18903 17.5776 8.14354 17.5964C8.09805 17.6153 8.04928 17.625 8.00004 17.625C7.9508 17.625 7.90204 17.6153 7.85654 17.5964C7.81105 17.5776 7.76972 17.55 7.7349 17.5151L0.984903 10.7651C0.950073 10.7303 0.922443 10.689 0.903592 10.6435C0.884742 10.598 0.875039 10.5492 0.875039 10.5C0.875039 10.4508 0.884742 10.402 0.903592 10.3565C0.922443 10.311 0.950073 10.2697 0.984903 10.2349Z",
        fill: "white",
        fillOpacity: "0.5",
      }),
    }),
  borderScaleAnimation = mt`
  0% {
    transform: scaleX(0);
    opacity: 0; /*  */
  }
  50% {
    transform: scaleX(0);
    opacity: 0;
  }
  51% {
    opacity: 1;
  }
  100% {
    transform: scaleX(1);
    opacity: 1;
  }
`,
  Border = dt.div`
  position: absolute;
  height: 0.5px;
  background: #7f64f2;
  width: 100%;
  transform-origin: center;
  transform: scaleX(0);
  opacity: 0;
  &.animateBorder {
    animation: ${borderScaleAnimation} 1.5s ease-in-out 0.32s forwards;
  }
`,
  BorderTop = dt(Border)`
  top: 0;
`,
  BorderBottom = dt(Border)`
  bottom: 0;
`,
  leftCombinedAnimation = mt`
  0% {
    height: 0;
    left: 50%;
    transform: translateX(-50%);
  }
  50% {
    height: 100%;
    left: 50%;
    transform: translateX(-50%);
  }
  100% {
    height: 100%;
    left: 0;
    transform: translateX(0);
  }
`,
  LeftDecoration = dt.div`
  position: absolute;
  left: 0;
  height: 100%;
  opacity: 0;
  &.animateDecor {
    animation: fadeIn 0.3s ease-in-out 0.3s forwards,
      ${leftCombinedAnimation} 1.5s ease-in-out 0.3s forwards;
  }
  @keyframes fadeIn {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }

  svg {
    transform: rotate(180deg);
    height: 100%;
  }
`,
  rightCombinedAnimation = mt`
  0% {
    height: 0;
    right: 50%;
    transform: translateX(50%);
  }
  50% {
    height: 100%;
    right: 50%;
    transform: translateX(50%);
  }
  100% {
    height: 100%;
    right: 0;
    transform: translateX(0);
  }`,
  RightDecoration = dt.div`
  position: absolute;
  right: 0;
  height: 100%;
  opacity: 0;
  &.animateDecor {
    animation: fadeIn 0.3s ease-in-out 0.3s forwards,
      ${rightCombinedAnimation} 1.5s ease-in-out 0.3s forwards;
  }
  @keyframes fadeIn {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
  svg {
    height: 100%;
  }
`,
  backgroundCombinedAnimation = mt`
0% {
  width: 0;
  height: 0;
  top: 50%;
  left: 50%;
  opacity: 0.5;
}
50% {
  width: 2px;     
  height: 100%;    
  top: 0;
  left: 50%;       
  opacity: 0.7;
}
100% {
  width: 100%;      
  height: 100%;
  top: 0;
  left: 0;
  opacity: 1;
}
`;
dt.div`
  position: absolute;
  top: 0;
  left: 0;
  background: radial-gradient(
    50% 50% at 50% 50%,
    #7f64f2 0%,
    rgba(127, 100, 242, 0.1) 100%
  );
  box-shadow: 0 4px 24px 0 rgba(0, 0, 0, 0.09);
  height: 100%;
  width: 100%;
  will-change: transform, opacity;
  opacity: 0;
  &.animateDecor {
    animation: ${backgroundCombinedAnimation} 1.5s ease-in-out;
  }
  &.visible {
    opacity: 1;
  }
`;
const gradientAnimation = mt`
  0% {
    opacity: 0;
    transform: scale(0.8); 
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
`,
  GradientWrapper = dt.div`
  opacity: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  text-transform: uppercase;
  position: relative;
  z-index: 1;
  width: 100%;
  height: 100%;
  position: absolute;
  &.animateGradient {
    animation: ${gradientAnimation} 0.8s ease-in-out 1.5s forwards;
  }
  &.visible {
    opacity: 1;
  }
`,
  letterScaleAnimation = mt`
  0% {
    opacity: 0; 
    transform: scale(0); 
  }
  100% {
    opacity: 1; 
    transform: scale(1); 
  }
`,
  ButtonText = dt.span`
  position: relative;
  z-index: 15;
  color: white;
  font-size: 1rem;
  font-weight: 400;
  text-transform: uppercase;
  display: inline-block;
  overflow: hidden;
  span {
    opacity: 0;
    display: inline-block;
    animation: ${letterScaleAnimation} 0.5s ease-out forwards;
    &.resetAnimation {
      animation: none;
      &.visible {
        opacity: 1;
      }
    }
  }
`,
  ButtonContainer = dt.div`
  border-radius: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 10.8125rem;
  height: 3.5rem;
  font-size: 0.875rem;
  letter-spacing: 0.2rem;
  position: relative;
  cursor: pointer;
  transition: clip-path 0.3s ease-in-out, background 0.3s ease-in-out;
  &:hover {
    @media (min-width: 48rem) {
    clip-path: polygon(
      2% 22%, 
      4% 18%, 
      4% 0%, 
  
      96% 0%, 
      96% 17%, 
      98% 22%, 
  
      98% 78%, 
      96% 83%, 
      96% 100%, 
  
      4% 100%, 
      4% 82%, 
      2% 78%);
      background: #7F64F2;
  }
}
`,
  ButtonAnimate = ({ text: n = "join now", link: e = "/apply/" }) => {
    const [t, r] = reactExports.useState(!1),
      { ref: s, inView: o } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: a, inView: l } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: c, inView: u } = useInView({ triggerOnce: !1, threshold: 0 });
    useInView({ triggerOnce: !1, threshold: 0 });
    const { ref: p, inView: N } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: P, inView: de } = useInView({ triggerOnce: !1, threshold: 0 }),
      me = (Ye) => {
        const nt = Ye.length,
          Be = Math.floor(nt / 2);
        return Ye.split("").map((ot, st) => {
          const vt = Math.abs(st - Be) * 0.1 + 1.4;
          return ot === " "
            ? jsxRuntimeExports.jsx("span", { children: "" }, st)
            : jsxRuntimeExports.jsx(
                "span",
                {
                  className: t ? "resetAnimation" : "",
                  style: { animationDelay: `${vt}s` },
                  children: ot,
                },
                st
              );
        });
      };
    return (
      reactExports.useEffect(() => {
        de ||
          (r(!0),
          setTimeout(() => {
            r(!1);
          }, 10));
      }, [de]),
      jsxRuntimeExports.jsxs(ButtonContainer, {
        onClick: () => window.open(e, "_blank"),
        children: [
          jsxRuntimeExports.jsx(BorderTop, {
            ref: s,
            className: o ? "animateBorder" : "",
          }),
          jsxRuntimeExports.jsx(BorderBottom, {
            className: o ? "animateBorder" : "",
          }),
          jsxRuntimeExports.jsx(LeftDecoration, {
            ref: a,
            className: l ? "animateDecor visible" : "",
            children: jsxRuntimeExports.jsx(BorderIcon, { color: "#7F64F2" }),
          }),
          jsxRuntimeExports.jsx(GradientWrapper, {
            ref: p,
            className: N ? "animateGradient" : "",
            children: jsxRuntimeExports.jsx(Gradient, {
              color: colors.primaryColor,
            }),
          }),
          jsxRuntimeExports.jsx(
            ButtonText,
            {
              ref: P,
              className: de ? "animateText visible" : "",
              children: me(n),
            },
            de ? "active" : "inactive"
          ),
          jsxRuntimeExports.jsx(RightDecoration, {
            ref: c,
            className: u ? "animateDecor visible" : "",
            children: jsxRuntimeExports.jsx(BorderIcon, { color: "#7F64F2" }),
          }),
        ],
      })
    );
  },
  HeaderBlock = dt.div`
  width: 100%;
  height: auto;
  min-height: 4.8125rem;
  background: transparent;
  display: flex;
  align-items: center;
  color: white;
  position: absolute;
  z-index: 20;
  overflow: hidden;
  text-transform: uppercase;
  @media (min-width: 48rem) {
    min-height: 7.1875rem;
  }
`,
  Content$4 = dt.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  @media (min-width: 48rem) {
    justify-content: start;
    gap: 4rem;
  }
`,
  HeaderSection = dt.div`
  display: flex;
`,
  StyledList$1 = dt.ul`
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  gap: 2rem;

  ${({ vertical: n }) =>
    n &&
    lt`
      flex-direction: column;
      text-align: center;
    `}
`,
  StyledListItem$1 = dt.li`
  position: relative; /*   */
  letter-spacing: 0.09rem;
  cursor: pointer;

  &::before,
  &::after {
    content: '';
    position: absolute;
    width: 0;
    height: 1px;
    bottom: -1px;
    background-color: var(--white-color);
    transition: width 0.3s ease;
  }

  &::before {
    left: 50%;
    transform: translateX(-50%);
  }

  &::after {
    right: 50%;
    transform: translateX(50%);
  }

  &:hover::before,
  &:hover::after {
    width: 98%;
  }
`,
  BurgerMenu = dt.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 3rem;
  width: 3rem;
  cursor: pointer;
`;
dt.div`
  display: flex;
  height: 3rem;
  width: 3rem;
  align-items: center;
  justify-content: center;
`;
const MobileMenu = dt.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: ${colors.gradient};
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: start;
  gap: 4.75rem;
  color: white;
  z-index: 25;
`,
  MobileMenuHeader = dt.div`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  position: absolute;
  padding: 0 1rem;
  top: 0.9375rem;
`,
  CloseBtn = dt.div`
  display: flex;
  height: 3rem;
  width: 3rem;
  align-items: center;
  justify-content: center;
`,
  sizeStyles = {
    l: lt`
    width: 160px;
    height: 56px;
  `,
    m: lt`
    width: 132px;
    height: 42px;
  `,
    s: lt`
    width: 100px;
    height: 42px;
  `,
    xs: lt`
    width: 27px;
    height: 27px;
  `,
  },
  roundSizeStyles = {
    s: lt`
    width: 27px;
    height: 27px;
  `,
    m: lt`
    width: 50px;
    height: 50px;
  `,
    l: lt`
    width: 68px;
    height: 68px;
  `,
  },
  borderWidth = 1,
  StyledButton = dt.button.withConfig({
    shouldForwardProp: (n) =>
      ![
        "size",
        "shape",
        "borderColor",
        "decoration",
        "color",
        "borderSize",
      ].includes(n),
  })`
    ${({
      size: n,
      shape: e,
      borderColor: t,
      decoration: r,
      color: s,
      borderSize: o,
    }) => lt`
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: var(--white-color);
        overflow: visible;
        box-sizing: border-box;
        position: relative;
        cursor: pointer;
        background-color: ${s || "transparent"};
        border: ${t ? `${o}px solid ${t}` : "none"};

        ${
          r === "reverse" &&
          lt`
            border-right-color: transparent;
            border-left-color: transparent;
        `
        }

        ${
          e === "round"
            ? lt`
                    ${roundSizeStyles[n] || roundSizeStyles.s}
                    border-radius: 50%;
                `
            : sizeStyles[n]
        };
    `}

    &:active {
        transform: scale(0.98);
    }
`,
  StyledBorderIcon = dt(BorderIcon).withConfig({
    shouldForwardProp: (n) =>
      !["isFirst", "decoration", "isShifted", "isParentHeight"].includes(n),
  })`
    height: ${({ isParentHeight: n = !0 }) =>
      n ? `calc(100% + ${borderWidth * 2}px)` : "100%"};
    position: relative;
    display: ${({ decoration: n }) => (n ? "block" : "none")};
    top: 0.2px;
    ${({ isFirst: n, decoration: e, isShifted: t = !0 }) =>
      n
        ? lt`
                        left: ${t ? "-1.3px" : "0"};
                        transform: ${
                          e === "reverse" ? "none" : "rotate(180deg)"
                        };
                    `
        : lt`
                        right: ${t ? "-1.3px" : "0"};
                        transform: ${
                          e === "reverse" ? "rotate(180deg)" : "none"
                        };
                    `}
`,
  Content$3 = dt.div`
  border-radius: inherit;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 95%;
`,
  loaderAnimation = mt`
  0%, 30% {
    background-position: 0 0, 50% 0, 100% 0, 0 50%, 100% 50%, 0 100%, 50% 100%, 100% 100%;
  }
  70%, 100% {
    background-position: 15% 15%, 50% 0, 85% 15%, 0 50%, 100% 50%, 15% 85%, 50% 100%, 85% 85%;
  }
`,
  AnimatedLoader = dt.div`
  width: ${({ size: n = "30px" }) => n};
  aspect-ratio: 1; /*   1:1 */

  --g: no-repeat
    radial-gradient(
      farthest-side,
      ${({ secondaryColor: n }) => n} calc(95% - 2px),
      ${({ primaryColor: n }) => n} calc(100% - 2px) 98%,
      ${({ secondaryColor: n }) => n} 101%
    );

  background: var(--g), var(--g), var(--g), var(--g), var(--g), var(--g),
    var(--g), var(--g);
  background-size: ${({ size: n = "30px" }) => `calc(${n} / 5) calc(${n} / 5)`};
  animation: ${loaderAnimation} 0.5s infinite alternate linear;
`,
  gifImage = "/assets/bg-DsyVMry0.gif",
  animateBg = mt`
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.2);
  }
`,
  animateSpan = mt`
  0% {
    transform: rotate(315deg) translateX(0);
    opacity: 1;
  }
  70% {
    opacity: 1;
  }
  100% {
    transform: rotate(315deg) translateX(-1000px);
    opacity: 0;
  }
`;
dt.div`
  background: var(--gradient);
  overflow-x: hidden;
  overflow-y: hidden;
  height: 100vh;
  position: relative;
  /* background-image: url(${gifImage}); */
`;
dt.div`
  padding: 15px;
  z-index: 2;
  position: absolute;
  width: 100vw;
  height: calc(100vh - 68px);
`;
dt.div`
  position: absolute;
  top: 0;
  left: 0;
  overflow: hidden;
  height: 100%;
  width: 100%;
  background-size: cover;
  animation: ${animateBg} 30s linear infinite;
`;
dt.span`
  position: absolute;
  top: 50%;
  left: 50%;
  width: 4px;
  height: 4px;
  background: #fff;
  border-radius: 50%;
  box-shadow:
    0 0 0 4px rgba(255, 255, 255, 0.1),
    0 0 0 8px rgba(255, 255, 255, 0.1),
    0 0 20px rgba(255, 255, 255, 0.1);
  animation: ${animateSpan} 3s linear infinite;

  &::before {
    content: '';
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 300px;
    height: 1px;
    background: linear-gradient(90deg, #fff, transparent);
  }

  &:nth-child(1) {
    top: 0;
    right: 0;
    left: initial;
    animation-delay: 0s;
    animation-duration: 1s;
  }

  &:nth-child(2) {
    top: 0;
    right: 80px;
    left: initial;
    animation-delay: 0.2s;
    animation-duration: 3s;
  }

  &:nth-child(3) {
    top: 80;
    right: 0px;
    left: initial;
    animation-delay: 0.4s;
    animation-duration: 2s;
  }

  &:nth-child(4) {
    top: 0;
    right: 180px;
    left: initial;
    animation-delay: 0.6s;
    animation-duration: 1.5s;
  }

  &:nth-child(5) {
    top: 0;
    right: 400px;
    left: initial;
    animation-delay: 0.8s;
    animation-duration: 2.5s;
  }

  &:nth-child(6) {
    top: 0;
    right: 600px;
    left: initial;
    animation-delay: 1s;
    animation-duration: 3s;
  }

  &:nth-child(7) {
    top: 300px;
    right: 0px;
    left: initial;
    animation-delay: 1.2s;
    animation-duration: 1.75s;
  }

  &:nth-child(8) {
    top: 0px;
    right: 700px;
    left: initial;
    animation-delay: 1.4s;
    animation-duration: 1.25s;
  }

  &:nth-child(9) {
    top: 0px;
    right: 1000px;
    left: initial;
    animation-delay: 0.75s;
    animation-duration: 2.25s;
  }

  &:nth-child(10) {
    top: 0px;
    right: 450px;
    left: initial;
    animation-delay: 2.75s;
    animation-duration: 2.75s;
  }
`;
dt.div`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
`;
dt.div`
  height: 100%;
  position: relative;
`;
const CentredWrapper = dt.div`
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
`,
  Loader = ({
    size: n = "20px",
    primaryColor: e = colors.whiteColor,
    secondaryColor: t = colors.blackColor,
  }) =>
    jsxRuntimeExports.jsx(CentredWrapper, {
      children: jsxRuntimeExports.jsx(AnimatedLoader, {
        size: n,
        primaryColor: e,
        secondaryColor: t,
      }),
    }),
  Button$1 = ({
    shape: n = "default",
    color: e,
    borderColor: t,
    borderSize: r = 1,
    children: s,
    isLoading: o = !1,
    decoration: a,
    size: l = "m",
    ...c
  }) =>
    jsxRuntimeExports.jsxs(StyledButton, {
      borderColor: o ? colors.transperent : t,
      borderSize: r,
      shape: n,
      color: o ? colors.transperent : e,
      decoration: o ? void 0 : a,
      size: l,
      ...c,
      children: [
        jsxRuntimeExports.jsx(StyledBorderIcon, {
          decoration: o ? void 0 : a,
          color: t || e,
          height: "100%",
          isFirst: !0,
        }),
        jsxRuntimeExports.jsx(Content$3, {
          children: o ? jsxRuntimeExports.jsx(Loader, {}) : s,
        }),
        jsxRuntimeExports.jsx(StyledBorderIcon, {
          color: t || e,
          decoration: o ? void 0 : a,
          height: "100%",
        }),
      ],
    });
var modules = {},
  Link = {},
  scrollLink = {},
  scrollSpy = {},
  lodash_throttle,
  hasRequiredLodash_throttle;
function requireLodash_throttle() {
  if (hasRequiredLodash_throttle) return lodash_throttle;
  hasRequiredLodash_throttle = 1;
  var n = "Expected a function",
    e = NaN,
    t = "[object Symbol]",
    r = /^\s+|\s+$/g,
    s = /^[-+]0x[0-9a-f]+$/i,
    o = /^0b[01]+$/i,
    a = /^0o[0-7]+$/i,
    l = parseInt,
    c =
      typeof commonjsGlobal == "object" &&
      commonjsGlobal &&
      commonjsGlobal.Object === Object &&
      commonjsGlobal,
    u = typeof self == "object" && self && self.Object === Object && self,
    p = c || u || Function("return this")(),
    N = Object.prototype,
    P = N.toString,
    de = Math.max,
    me = Math.min,
    Ye = function () {
      return p.Date.now();
    };
  function nt(St, wt, bt) {
    var Tt,
      Ct,
      kt,
      Dt,
      Vt,
      Ht,
      qt = 0,
      Ft = !1,
      Bt = !1,
      Mt = !0;
    if (typeof St != "function") throw new TypeError(n);
    (wt = xt(wt) || 0),
      ot(bt) &&
        ((Ft = !!bt.leading),
        (Bt = "maxWait" in bt),
        (kt = Bt ? de(xt(bt.maxWait) || 0, wt) : kt),
        (Mt = "trailing" in bt ? !!bt.trailing : Mt));
    function Pt(bn) {
      var $n = Tt,
        tr = Ct;
      return (Tt = Ct = void 0), (qt = bn), (Dt = St.apply(tr, $n)), Dt;
    }
    function It(bn) {
      return (qt = bn), (Vt = setTimeout(sn, wt)), Ft ? Pt(bn) : Dt;
    }
    function Ot(bn) {
      var $n = bn - Ht,
        tr = bn - qt,
        ur = wt - $n;
      return Bt ? me(ur, kt - tr) : ur;
    }
    function Xt(bn) {
      var $n = bn - Ht,
        tr = bn - qt;
      return Ht === void 0 || $n >= wt || $n < 0 || (Bt && tr >= kt);
    }
    function sn() {
      var bn = Ye();
      if (Xt(bn)) return Kt(bn);
      Vt = setTimeout(sn, Ot(bn));
    }
    function Kt(bn) {
      return (Vt = void 0), Mt && Tt ? Pt(bn) : ((Tt = Ct = void 0), Dt);
    }
    function tn() {
      Vt !== void 0 && clearTimeout(Vt), (qt = 0), (Tt = Ht = Ct = Vt = void 0);
    }
    function pn() {
      return Vt === void 0 ? Dt : Kt(Ye());
    }
    function _n() {
      var bn = Ye(),
        $n = Xt(bn);
      if (((Tt = arguments), (Ct = this), (Ht = bn), $n)) {
        if (Vt === void 0) return It(Ht);
        if (Bt) return (Vt = setTimeout(sn, wt)), Pt(Ht);
      }
      return Vt === void 0 && (Vt = setTimeout(sn, wt)), Dt;
    }
    return (_n.cancel = tn), (_n.flush = pn), _n;
  }
  function Be(St, wt, bt) {
    var Tt = !0,
      Ct = !0;
    if (typeof St != "function") throw new TypeError(n);
    return (
      ot(bt) &&
        ((Tt = "leading" in bt ? !!bt.leading : Tt),
        (Ct = "trailing" in bt ? !!bt.trailing : Ct)),
      nt(St, wt, { leading: Tt, maxWait: wt, trailing: Ct })
    );
  }
  function ot(St) {
    var wt = typeof St;
    return !!St && (wt == "object" || wt == "function");
  }
  function st(St) {
    return !!St && typeof St == "object";
  }
  function vt(St) {
    return typeof St == "symbol" || (st(St) && P.call(St) == t);
  }
  function xt(St) {
    if (typeof St == "number") return St;
    if (vt(St)) return e;
    if (ot(St)) {
      var wt = typeof St.valueOf == "function" ? St.valueOf() : St;
      St = ot(wt) ? wt + "" : wt;
    }
    if (typeof St != "string") return St === 0 ? St : +St;
    St = St.replace(r, "");
    var bt = o.test(St);
    return bt || a.test(St) ? l(St.slice(2), bt ? 2 : 8) : s.test(St) ? e : +St;
  }
  return (lodash_throttle = Be), lodash_throttle;
}
var passiveEventListeners = {},
  hasRequiredPassiveEventListeners;
function requirePassiveEventListeners() {
  if (hasRequiredPassiveEventListeners) return passiveEventListeners;
  (hasRequiredPassiveEventListeners = 1),
    Object.defineProperty(passiveEventListeners, "__esModule", { value: !0 }),
    (passiveEventListeners.addPassiveEventListener = function (t, r, s) {
      var o = s.name;
      o || ((o = r), console.warn("Listener must be a named function.")),
        n.has(r) || n.set(r, new Set());
      var a = n.get(r);
      if (!a.has(o)) {
        var l = (function () {
          var c = !1;
          try {
            var u = Object.defineProperty({}, "passive", {
              get: function () {
                c = !0;
              },
            });
            window.addEventListener("test", null, u);
          } catch {}
          return c;
        })();
        t.addEventListener(r, s, l ? { passive: !0 } : !1), a.add(o);
      }
    }),
    (passiveEventListeners.removePassiveEventListener = function (t, r, s) {
      t.removeEventListener(r, s), n.get(r).delete(s.name || r);
    });
  var n = new Map();
  return passiveEventListeners;
}
var hasRequiredScrollSpy;
function requireScrollSpy() {
  if (hasRequiredScrollSpy) return scrollSpy;
  (hasRequiredScrollSpy = 1),
    Object.defineProperty(scrollSpy, "__esModule", { value: !0 });
  var n = requireLodash_throttle(),
    e = r(n),
    t = requirePassiveEventListeners();
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var s = function (l) {
      var c =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
      return (0, e.default)(l, c);
    },
    o = {
      spyCallbacks: [],
      spySetState: [],
      scrollSpyContainers: [],
      mount: function (l, c) {
        if (l) {
          var u = s(function (p) {
            o.scrollHandler(l);
          }, c);
          return (
            o.scrollSpyContainers.push(l),
            (0, t.addPassiveEventListener)(l, "scroll", u),
            function () {
              (0, t.removePassiveEventListener)(l, "scroll", u),
                o.scrollSpyContainers.splice(
                  o.scrollSpyContainers.indexOf(l),
                  1
                );
            }
          );
        }
        return function () {};
      },
      isMounted: function (l) {
        return o.scrollSpyContainers.indexOf(l) !== -1;
      },
      currentPositionX: function (l) {
        if (l === document) {
          var c = window.scrollY !== void 0,
            u = (document.compatMode || "") === "CSS1Compat";
          return c
            ? window.scrollX
            : u
            ? document.documentElement.scrollLeft
            : document.body.scrollLeft;
        } else return l.scrollLeft;
      },
      currentPositionY: function (l) {
        if (l === document) {
          var c = window.scrollX !== void 0,
            u = (document.compatMode || "") === "CSS1Compat";
          return c
            ? window.scrollY
            : u
            ? document.documentElement.scrollTop
            : document.body.scrollTop;
        } else return l.scrollTop;
      },
      scrollHandler: function (l) {
        var c =
          o.scrollSpyContainers[o.scrollSpyContainers.indexOf(l)]
            .spyCallbacks || [];
        c.forEach(function (u) {
          return u(o.currentPositionX(l), o.currentPositionY(l));
        });
      },
      addStateHandler: function (l) {
        o.spySetState.push(l);
      },
      addSpyHandler: function (l, c) {
        var u = o.scrollSpyContainers[o.scrollSpyContainers.indexOf(c)];
        u.spyCallbacks || (u.spyCallbacks = []), u.spyCallbacks.push(l);
      },
      updateStates: function () {
        o.spySetState.forEach(function (l) {
          return l();
        });
      },
      unmount: function (l, c) {
        o.scrollSpyContainers.forEach(function (u) {
          return (
            u.spyCallbacks &&
            u.spyCallbacks.length &&
            u.spyCallbacks.indexOf(c) > -1 &&
            u.spyCallbacks.splice(u.spyCallbacks.indexOf(c), 1)
          );
        }),
          o.spySetState &&
            o.spySetState.length &&
            o.spySetState.indexOf(l) > -1 &&
            o.spySetState.splice(o.spySetState.indexOf(l), 1),
          document.removeEventListener("scroll", o.scrollHandler);
      },
      update: function () {
        return o.scrollSpyContainers.forEach(function (l) {
          return o.scrollHandler(l);
        });
      },
    };
  return (scrollSpy.default = o), scrollSpy;
}
var scroller = {},
  utils$1 = {},
  hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  (hasRequiredUtils$1 = 1),
    Object.defineProperty(utils$1, "__esModule", { value: !0 });
  var n = function (l, c) {
      var u = l.indexOf("#") === 0 ? l.substring(1) : l,
        p = u ? "#" + u : "",
        N = window && window.location,
        P = p ? N.pathname + N.search + p : N.pathname + N.search;
      c
        ? history.pushState(history.state, "", P)
        : history.replaceState(history.state, "", P);
    },
    e = function () {
      return window.location.hash.replace(/^#/, "");
    },
    t = function (l) {
      return function (c) {
        return l.contains
          ? l != c && l.contains(c)
          : !!(l.compareDocumentPosition(c) & 16);
      };
    },
    r = function (l) {
      return getComputedStyle(l).position !== "static";
    },
    s = function (l, c) {
      for (var u = l.offsetTop, p = l.offsetParent; p && !c(p); )
        (u += p.offsetTop), (p = p.offsetParent);
      return { offsetTop: u, offsetParent: p };
    },
    o = function (l, c, u) {
      if (u)
        return l === document
          ? c.getBoundingClientRect().left +
              (window.scrollX || window.pageXOffset)
          : getComputedStyle(l).position !== "static"
          ? c.offsetLeft
          : c.offsetLeft - l.offsetLeft;
      if (l === document)
        return (
          c.getBoundingClientRect().top + (window.scrollY || window.pageYOffset)
        );
      if (r(l)) {
        if (c.offsetParent !== l) {
          var p = function (nt) {
              return nt === l || nt === document;
            },
            N = s(c, p),
            P = N.offsetTop,
            de = N.offsetParent;
          if (de !== l)
            throw new Error(
              "Seems containerElement is not an ancestor of the Element"
            );
          return P;
        }
        return c.offsetTop;
      }
      if (c.offsetParent === l.offsetParent) return c.offsetTop - l.offsetTop;
      var me = function (nt) {
        return nt === document;
      };
      return s(c, me).offsetTop - s(l, me).offsetTop;
    };
  return (
    (utils$1.default = {
      updateHash: n,
      getHash: e,
      filterElementInContainer: t,
      scrollOffset: o,
    }),
    utils$1
  );
}
var animateScroll = {},
  smooth = {},
  hasRequiredSmooth;
function requireSmooth() {
  return (
    hasRequiredSmooth ||
      ((hasRequiredSmooth = 1),
      Object.defineProperty(smooth, "__esModule", { value: !0 }),
      (smooth.default = {
        defaultEasing: function (e) {
          return e < 0.5
            ? Math.pow(e * 2, 2) / 2
            : 1 - Math.pow((1 - e) * 2, 2) / 2;
        },
        linear: function (e) {
          return e;
        },
        easeInQuad: function (e) {
          return e * e;
        },
        easeOutQuad: function (e) {
          return e * (2 - e);
        },
        easeInOutQuad: function (e) {
          return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
        },
        easeInCubic: function (e) {
          return e * e * e;
        },
        easeOutCubic: function (e) {
          return --e * e * e + 1;
        },
        easeInOutCubic: function (e) {
          return e < 0.5
            ? 4 * e * e * e
            : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
        },
        easeInQuart: function (e) {
          return e * e * e * e;
        },
        easeOutQuart: function (e) {
          return 1 - --e * e * e * e;
        },
        easeInOutQuart: function (e) {
          return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
        },
        easeInQuint: function (e) {
          return e * e * e * e * e;
        },
        easeOutQuint: function (e) {
          return 1 + --e * e * e * e * e;
        },
        easeInOutQuint: function (e) {
          return e < 0.5
            ? 16 * e * e * e * e * e
            : 1 + 16 * --e * e * e * e * e;
        },
      })),
    smooth
  );
}
var cancelEvents = {},
  hasRequiredCancelEvents;
function requireCancelEvents() {
  if (hasRequiredCancelEvents) return cancelEvents;
  (hasRequiredCancelEvents = 1),
    Object.defineProperty(cancelEvents, "__esModule", { value: !0 });
  var n = requirePassiveEventListeners(),
    e = ["mousedown", "wheel", "touchmove", "keydown"];
  return (
    (cancelEvents.default = {
      subscribe: function (r) {
        return (
          typeof document < "u" &&
          e.forEach(function (s) {
            return (0, n.addPassiveEventListener)(document, s, r);
          })
        );
      },
    }),
    cancelEvents
  );
}
var scrollEvents = {},
  hasRequiredScrollEvents;
function requireScrollEvents() {
  if (hasRequiredScrollEvents) return scrollEvents;
  (hasRequiredScrollEvents = 1),
    Object.defineProperty(scrollEvents, "__esModule", { value: !0 });
  var n = {
    registered: {},
    scrollEvent: {
      register: function (t, r) {
        n.registered[t] = r;
      },
      remove: function (t) {
        n.registered[t] = null;
      },
    },
  };
  return (scrollEvents.default = n), scrollEvents;
}
var hasRequiredAnimateScroll;
function requireAnimateScroll() {
  if (hasRequiredAnimateScroll) return animateScroll;
  (hasRequiredAnimateScroll = 1),
    Object.defineProperty(animateScroll, "__esModule", { value: !0 });
  var n =
      Object.assign ||
      function (Ct) {
        for (var kt = 1; kt < arguments.length; kt++) {
          var Dt = arguments[kt];
          for (var Vt in Dt)
            Object.prototype.hasOwnProperty.call(Dt, Vt) && (Ct[Vt] = Dt[Vt]);
        }
        return Ct;
      },
    e = requireUtils$1();
  c(e);
  var t = requireSmooth(),
    r = c(t),
    s = requireCancelEvents(),
    o = c(s),
    a = requireScrollEvents(),
    l = c(a);
  function c(Ct) {
    return Ct && Ct.__esModule ? Ct : { default: Ct };
  }
  var u = function (kt) {
      return r.default[kt.smooth] || r.default.defaultEasing;
    },
    p = function (kt) {
      return typeof kt == "function"
        ? kt
        : function () {
            return kt;
          };
    },
    N = function () {
      if (typeof window < "u")
        return (
          window.requestAnimationFrame || window.webkitRequestAnimationFrame
        );
    },
    P = (function () {
      return (
        N() ||
        function (Ct, kt, Dt) {
          window.setTimeout(Ct, Dt || 1e3 / 60, new Date().getTime());
        }
      );
    })(),
    de = function () {
      return {
        currentPosition: 0,
        startPosition: 0,
        targetPosition: 0,
        progress: 0,
        duration: 0,
        cancel: !1,
        target: null,
        containerElement: null,
        to: null,
        start: null,
        delta: null,
        percent: null,
        delayTimeout: null,
      };
    },
    me = function (kt) {
      var Dt = kt.data.containerElement;
      if (Dt && Dt !== document && Dt !== document.body) return Dt.scrollLeft;
      var Vt = window.pageXOffset !== void 0,
        Ht = (document.compatMode || "") === "CSS1Compat";
      return Vt
        ? window.pageXOffset
        : Ht
        ? document.documentElement.scrollLeft
        : document.body.scrollLeft;
    },
    Ye = function (kt) {
      var Dt = kt.data.containerElement;
      if (Dt && Dt !== document && Dt !== document.body) return Dt.scrollTop;
      var Vt = window.pageXOffset !== void 0,
        Ht = (document.compatMode || "") === "CSS1Compat";
      return Vt
        ? window.pageYOffset
        : Ht
        ? document.documentElement.scrollTop
        : document.body.scrollTop;
    },
    nt = function (kt) {
      var Dt = kt.data.containerElement;
      if (Dt && Dt !== document && Dt !== document.body)
        return Dt.scrollWidth - Dt.offsetWidth;
      var Vt = document.body,
        Ht = document.documentElement;
      return Math.max(
        Vt.scrollWidth,
        Vt.offsetWidth,
        Ht.clientWidth,
        Ht.scrollWidth,
        Ht.offsetWidth
      );
    },
    Be = function (kt) {
      var Dt = kt.data.containerElement;
      if (Dt && Dt !== document && Dt !== document.body)
        return Dt.scrollHeight - Dt.offsetHeight;
      var Vt = document.body,
        Ht = document.documentElement;
      return Math.max(
        Vt.scrollHeight,
        Vt.offsetHeight,
        Ht.clientHeight,
        Ht.scrollHeight,
        Ht.offsetHeight
      );
    },
    ot = function Ct(kt, Dt, Vt) {
      var Ht = Dt.data;
      if (!Dt.ignoreCancelEvents && Ht.cancel) {
        l.default.registered.end &&
          l.default.registered.end(Ht.to, Ht.target, Ht.currentPositionY);
        return;
      }
      if (
        ((Ht.delta = Math.round(Ht.targetPosition - Ht.startPosition)),
        Ht.start === null && (Ht.start = Vt),
        (Ht.progress = Vt - Ht.start),
        (Ht.percent =
          Ht.progress >= Ht.duration ? 1 : kt(Ht.progress / Ht.duration)),
        (Ht.currentPosition =
          Ht.startPosition + Math.ceil(Ht.delta * Ht.percent)),
        Ht.containerElement &&
        Ht.containerElement !== document &&
        Ht.containerElement !== document.body
          ? Dt.horizontal
            ? (Ht.containerElement.scrollLeft = Ht.currentPosition)
            : (Ht.containerElement.scrollTop = Ht.currentPosition)
          : Dt.horizontal
          ? window.scrollTo(Ht.currentPosition, 0)
          : window.scrollTo(0, Ht.currentPosition),
        Ht.percent < 1)
      ) {
        var qt = Ct.bind(null, kt, Dt);
        P.call(window, qt);
        return;
      }
      l.default.registered.end &&
        l.default.registered.end(Ht.to, Ht.target, Ht.currentPosition);
    },
    st = function (kt) {
      kt.data.containerElement = kt
        ? kt.containerId
          ? document.getElementById(kt.containerId)
          : kt.container && kt.container.nodeType
          ? kt.container
          : document
        : null;
    },
    vt = function (kt, Dt, Vt, Ht) {
      (Dt.data = Dt.data || de()), window.clearTimeout(Dt.data.delayTimeout);
      var qt = function () {
        Dt.data.cancel = !0;
      };
      if (
        (o.default.subscribe(qt),
        st(Dt),
        (Dt.data.start = null),
        (Dt.data.cancel = !1),
        (Dt.data.startPosition = Dt.horizontal ? me(Dt) : Ye(Dt)),
        (Dt.data.targetPosition = Dt.absolute
          ? kt
          : kt + Dt.data.startPosition),
        Dt.data.startPosition === Dt.data.targetPosition)
      ) {
        l.default.registered.end &&
          l.default.registered.end(
            Dt.data.to,
            Dt.data.target,
            Dt.data.currentPosition
          );
        return;
      }
      (Dt.data.delta = Math.round(
        Dt.data.targetPosition - Dt.data.startPosition
      )),
        (Dt.data.duration = p(Dt.duration)(Dt.data.delta)),
        (Dt.data.duration = isNaN(parseFloat(Dt.data.duration))
          ? 1e3
          : parseFloat(Dt.data.duration)),
        (Dt.data.to = Vt),
        (Dt.data.target = Ht);
      var Ft = u(Dt),
        Bt = ot.bind(null, Ft, Dt);
      if (Dt && Dt.delay > 0) {
        Dt.data.delayTimeout = window.setTimeout(function () {
          l.default.registered.begin &&
            l.default.registered.begin(Dt.data.to, Dt.data.target),
            P.call(window, Bt);
        }, Dt.delay);
        return;
      }
      l.default.registered.begin &&
        l.default.registered.begin(Dt.data.to, Dt.data.target),
        P.call(window, Bt);
    },
    xt = function (kt) {
      return (
        (kt = n({}, kt)), (kt.data = kt.data || de()), (kt.absolute = !0), kt
      );
    },
    St = function (kt) {
      vt(0, xt(kt));
    },
    wt = function (kt, Dt) {
      vt(kt, xt(Dt));
    },
    bt = function (kt) {
      (kt = xt(kt)), st(kt), vt(kt.horizontal ? nt(kt) : Be(kt), kt);
    },
    Tt = function (kt, Dt) {
      (Dt = xt(Dt)), st(Dt);
      var Vt = Dt.horizontal ? me(Dt) : Ye(Dt);
      vt(kt + Vt, Dt);
    };
  return (
    (animateScroll.default = {
      animateTopScroll: vt,
      getAnimationType: u,
      scrollToTop: St,
      scrollToBottom: bt,
      scrollTo: wt,
      scrollMore: Tt,
    }),
    animateScroll
  );
}
var hasRequiredScroller;
function requireScroller() {
  if (hasRequiredScroller) return scroller;
  (hasRequiredScroller = 1),
    Object.defineProperty(scroller, "__esModule", { value: !0 });
  var n =
      Object.assign ||
      function (p) {
        for (var N = 1; N < arguments.length; N++) {
          var P = arguments[N];
          for (var de in P)
            Object.prototype.hasOwnProperty.call(P, de) && (p[de] = P[de]);
        }
        return p;
      },
    e = requireUtils$1(),
    t = l(e),
    r = requireAnimateScroll(),
    s = l(r),
    o = requireScrollEvents(),
    a = l(o);
  function l(p) {
    return p && p.__esModule ? p : { default: p };
  }
  var c = {},
    u = void 0;
  return (
    (scroller.default = {
      unmount: function () {
        c = {};
      },
      register: function (N, P) {
        c[N] = P;
      },
      unregister: function (N) {
        delete c[N];
      },
      get: function (N) {
        return (
          c[N] ||
          document.getElementById(N) ||
          document.getElementsByName(N)[0] ||
          document.getElementsByClassName(N)[0]
        );
      },
      setActiveLink: function (N) {
        return (u = N);
      },
      getActiveLink: function () {
        return u;
      },
      scrollTo: function (N, P) {
        var de = this.get(N);
        if (!de) {
          console.warn("target Element not found");
          return;
        }
        P = n({}, P, { absolute: !1 });
        var me = P.containerId,
          Ye = P.container,
          nt = void 0;
        me
          ? (nt = document.getElementById(me))
          : Ye && Ye.nodeType
          ? (nt = Ye)
          : (nt = document),
          (P.absolute = !0);
        var Be = P.horizontal,
          ot = t.default.scrollOffset(nt, de, Be) + (P.offset || 0);
        if (!P.smooth) {
          a.default.registered.begin && a.default.registered.begin(N, de),
            nt === document
              ? P.horizontal
                ? window.scrollTo(ot, 0)
                : window.scrollTo(0, ot)
              : (nt.scrollTop = ot),
            a.default.registered.end && a.default.registered.end(N, de);
          return;
        }
        s.default.animateTopScroll(ot, P, N, de);
      },
    }),
    scroller
  );
}
var scrollHash = {},
  hasRequiredScrollHash;
function requireScrollHash() {
  if (hasRequiredScrollHash) return scrollHash;
  (hasRequiredScrollHash = 1),
    Object.defineProperty(scrollHash, "__esModule", { value: !0 }),
    requirePassiveEventListeners();
  var n = requireUtils$1(),
    e = t(n);
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var r = {
    mountFlag: !1,
    initialized: !1,
    scroller: null,
    containers: {},
    mount: function (o) {
      (this.scroller = o),
        (this.handleHashChange = this.handleHashChange.bind(this)),
        window.addEventListener("hashchange", this.handleHashChange),
        this.initStateFromHash(),
        (this.mountFlag = !0);
    },
    mapContainer: function (o, a) {
      this.containers[o] = a;
    },
    isMounted: function () {
      return this.mountFlag;
    },
    isInitialized: function () {
      return this.initialized;
    },
    initStateFromHash: function () {
      var o = this,
        a = this.getHash();
      a
        ? window.setTimeout(function () {
            o.scrollTo(a, !0), (o.initialized = !0);
          }, 10)
        : (this.initialized = !0);
    },
    scrollTo: function (o, a) {
      var l = this.scroller,
        c = l.get(o);
      if (c && (a || o !== l.getActiveLink())) {
        var u = this.containers[o] || document;
        l.scrollTo(o, { container: u });
      }
    },
    getHash: function () {
      return e.default.getHash();
    },
    changeHash: function (o, a) {
      this.isInitialized() &&
        e.default.getHash() !== o &&
        e.default.updateHash(o, a);
    },
    handleHashChange: function () {
      this.scrollTo(this.getHash());
    },
    unmount: function () {
      (this.scroller = null),
        (this.containers = null),
        window.removeEventListener("hashchange", this.handleHashChange);
    },
  };
  return (scrollHash.default = r), scrollHash;
}
var hasRequiredScrollLink;
function requireScrollLink() {
  if (hasRequiredScrollLink) return scrollLink;
  (hasRequiredScrollLink = 1),
    Object.defineProperty(scrollLink, "__esModule", { value: !0 });
  var n =
      Object.assign ||
      function (Be) {
        for (var ot = 1; ot < arguments.length; ot++) {
          var st = arguments[ot];
          for (var vt in st)
            Object.prototype.hasOwnProperty.call(st, vt) && (Be[vt] = st[vt]);
        }
        return Be;
      },
    e = (function () {
      function Be(ot, st) {
        for (var vt = 0; vt < st.length; vt++) {
          var xt = st[vt];
          (xt.enumerable = xt.enumerable || !1),
            (xt.configurable = !0),
            "value" in xt && (xt.writable = !0),
            Object.defineProperty(ot, xt.key, xt);
        }
      }
      return function (ot, st, vt) {
        return st && Be(ot.prototype, st), vt && Be(ot, vt), ot;
      };
    })(),
    t = requireReact(),
    r = P(t),
    s = requireScrollSpy(),
    o = P(s),
    a = requireScroller(),
    l = P(a),
    c = requirePropTypes(),
    u = P(c),
    p = requireScrollHash(),
    N = P(p);
  function P(Be) {
    return Be && Be.__esModule ? Be : { default: Be };
  }
  function de(Be, ot) {
    if (!(Be instanceof ot))
      throw new TypeError("Cannot call a class as a function");
  }
  function me(Be, ot) {
    if (!Be)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return ot && (typeof ot == "object" || typeof ot == "function") ? ot : Be;
  }
  function Ye(Be, ot) {
    if (typeof ot != "function" && ot !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof ot
      );
    (Be.prototype = Object.create(ot && ot.prototype, {
      constructor: {
        value: Be,
        enumerable: !1,
        writable: !0,
        configurable: !0,
      },
    })),
      ot &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(Be, ot)
          : (Be.__proto__ = ot));
  }
  var nt = {
    to: u.default.string.isRequired,
    containerId: u.default.string,
    container: u.default.object,
    activeClass: u.default.string,
    activeStyle: u.default.object,
    spy: u.default.bool,
    horizontal: u.default.bool,
    smooth: u.default.oneOfType([u.default.bool, u.default.string]),
    offset: u.default.number,
    delay: u.default.number,
    isDynamic: u.default.bool,
    onClick: u.default.func,
    duration: u.default.oneOfType([u.default.number, u.default.func]),
    absolute: u.default.bool,
    onSetActive: u.default.func,
    onSetInactive: u.default.func,
    ignoreCancelEvents: u.default.bool,
    hashSpy: u.default.bool,
    saveHashHistory: u.default.bool,
    spyThrottle: u.default.number,
  };
  return (
    (scrollLink.default = function (Be, ot) {
      var st = ot || l.default,
        vt = (function (St) {
          Ye(wt, St);
          function wt(bt) {
            de(this, wt);
            var Tt = me(
              this,
              (wt.__proto__ || Object.getPrototypeOf(wt)).call(this, bt)
            );
            return (
              xt.call(Tt),
              (Tt.state = { active: !1 }),
              (Tt.beforeUnmountCallbacks = []),
              Tt
            );
          }
          return (
            e(wt, [
              {
                key: "getScrollSpyContainer",
                value: function () {
                  var Tt = this.props.containerId,
                    Ct = this.props.container;
                  return Tt && !Ct
                    ? document.getElementById(Tt)
                    : Ct && Ct.nodeType
                    ? Ct
                    : document;
                },
              },
              {
                key: "componentDidMount",
                value: function () {
                  if (this.props.spy || this.props.hashSpy) {
                    var Tt = this.getScrollSpyContainer();
                    if (!o.default.isMounted(Tt)) {
                      var Ct = o.default.mount(Tt, this.props.spyThrottle);
                      this.beforeUnmountCallbacks.push(Ct);
                    }
                    this.props.hashSpy &&
                      (N.default.isMounted() || N.default.mount(st),
                      N.default.mapContainer(this.props.to, Tt)),
                      o.default.addSpyHandler(this.spyHandler, Tt),
                      this.setState({ container: Tt });
                  }
                },
              },
              {
                key: "componentWillUnmount",
                value: function () {
                  o.default.unmount(this.stateHandler, this.spyHandler),
                    this.beforeUnmountCallbacks.forEach(function (Tt) {
                      return Tt();
                    });
                },
              },
              {
                key: "render",
                value: function () {
                  var Tt = "";
                  this.state && this.state.active
                    ? (Tt = (
                        (this.props.className || "") +
                        " " +
                        (this.props.activeClass || "active")
                      ).trim())
                    : (Tt = this.props.className);
                  var Ct = {};
                  this.state && this.state.active
                    ? (Ct = n({}, this.props.style, this.props.activeStyle))
                    : (Ct = n({}, this.props.style));
                  var kt = n({}, this.props);
                  for (var Dt in nt) kt.hasOwnProperty(Dt) && delete kt[Dt];
                  return (
                    (kt.className = Tt),
                    (kt.style = Ct),
                    (kt.onClick = this.handleClick),
                    r.default.createElement(Be, kt)
                  );
                },
              },
            ]),
            wt
          );
        })(r.default.PureComponent),
        xt = function () {
          var wt = this;
          (this.scrollTo = function (bt, Tt) {
            st.scrollTo(bt, n({}, wt.state, Tt));
          }),
            (this.handleClick = function (bt) {
              wt.props.onClick && wt.props.onClick(bt),
                bt.stopPropagation && bt.stopPropagation(),
                bt.preventDefault && bt.preventDefault(),
                wt.scrollTo(wt.props.to, wt.props);
            }),
            (this.spyHandler = function (bt, Tt) {
              var Ct = wt.getScrollSpyContainer();
              if (!(N.default.isMounted() && !N.default.isInitialized())) {
                var kt = wt.props.horizontal,
                  Dt = wt.props.to,
                  Vt = null,
                  Ht = void 0,
                  qt = void 0;
                if (kt) {
                  var Ft = 0,
                    Bt = 0,
                    Mt = 0;
                  if (Ct.getBoundingClientRect) {
                    var Pt = Ct.getBoundingClientRect();
                    Mt = Pt.left;
                  }
                  if (!Vt || wt.props.isDynamic) {
                    if (((Vt = st.get(Dt)), !Vt)) return;
                    var It = Vt.getBoundingClientRect();
                    (Ft = It.left - Mt + bt), (Bt = Ft + It.width);
                  }
                  var Ot = bt - wt.props.offset;
                  (Ht = Ot >= Math.floor(Ft) && Ot < Math.floor(Bt)),
                    (qt = Ot < Math.floor(Ft) || Ot >= Math.floor(Bt));
                } else {
                  var Xt = 0,
                    sn = 0,
                    Kt = 0;
                  if (Ct.getBoundingClientRect) {
                    var tn = Ct.getBoundingClientRect();
                    Kt = tn.top;
                  }
                  if (!Vt || wt.props.isDynamic) {
                    if (((Vt = st.get(Dt)), !Vt)) return;
                    var pn = Vt.getBoundingClientRect();
                    (Xt = pn.top - Kt + Tt), (sn = Xt + pn.height);
                  }
                  var _n = Tt - wt.props.offset;
                  (Ht = _n >= Math.floor(Xt) && _n < Math.floor(sn)),
                    (qt = _n < Math.floor(Xt) || _n >= Math.floor(sn));
                }
                var bn = st.getActiveLink();
                if (qt) {
                  if (
                    (Dt === bn && st.setActiveLink(void 0),
                    wt.props.hashSpy && N.default.getHash() === Dt)
                  ) {
                    var $n = wt.props.saveHashHistory,
                      tr = $n === void 0 ? !1 : $n;
                    N.default.changeHash("", tr);
                  }
                  wt.props.spy &&
                    wt.state.active &&
                    (wt.setState({ active: !1 }),
                    wt.props.onSetInactive && wt.props.onSetInactive(Dt, Vt));
                }
                if (Ht && (bn !== Dt || wt.state.active === !1)) {
                  st.setActiveLink(Dt);
                  var ur = wt.props.saveHashHistory,
                    _r = ur === void 0 ? !1 : ur;
                  wt.props.hashSpy && N.default.changeHash(Dt, _r),
                    wt.props.spy &&
                      (wt.setState({ active: !0 }),
                      wt.props.onSetActive && wt.props.onSetActive(Dt, Vt));
                }
              }
            });
        };
      return (vt.propTypes = nt), (vt.defaultProps = { offset: 0 }), vt;
    }),
    scrollLink
  );
}
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return Link;
  (hasRequiredLink = 1),
    Object.defineProperty(Link, "__esModule", { value: !0 });
  var n = requireReact(),
    e = s(n),
    t = requireScrollLink(),
    r = s(t);
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, p) {
    if (!(u instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, p) {
    if (!u)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return p && (typeof p == "object" || typeof p == "function") ? p : u;
  }
  function l(u, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof p
      );
    (u.prototype = Object.create(p && p.prototype, {
      constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 },
    })),
      p &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(u, p)
          : (u.__proto__ = p));
  }
  var c = (function (u) {
    l(p, u);
    function p() {
      var N, P, de, me;
      o(this, p);
      for (var Ye = arguments.length, nt = Array(Ye), Be = 0; Be < Ye; Be++)
        nt[Be] = arguments[Be];
      return (
        (me =
          ((P =
            ((de = a(
              this,
              (N = p.__proto__ || Object.getPrototypeOf(p)).call.apply(
                N,
                [this].concat(nt)
              )
            )),
            de)),
          (de.render = function () {
            return e.default.createElement("a", de.props, de.props.children);
          }),
          P)),
        a(de, me)
      );
    }
    return p;
  })(e.default.Component);
  return (Link.default = (0, r.default)(c)), Link;
}
var Button = {},
  hasRequiredButton;
function requireButton() {
  if (hasRequiredButton) return Button;
  (hasRequiredButton = 1),
    Object.defineProperty(Button, "__esModule", { value: !0 });
  var n = (function () {
      function p(N, P) {
        for (var de = 0; de < P.length; de++) {
          var me = P[de];
          (me.enumerable = me.enumerable || !1),
            (me.configurable = !0),
            "value" in me && (me.writable = !0),
            Object.defineProperty(N, me.key, me);
        }
      }
      return function (N, P, de) {
        return P && p(N.prototype, P), de && p(N, de), N;
      };
    })(),
    e = requireReact(),
    t = o(e),
    r = requireScrollLink(),
    s = o(r);
  function o(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, N) {
    if (!(p instanceof N))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, N) {
    if (!p)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return N && (typeof N == "object" || typeof N == "function") ? N : p;
  }
  function c(p, N) {
    if (typeof N != "function" && N !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof N
      );
    (p.prototype = Object.create(N && N.prototype, {
      constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 },
    })),
      N &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(p, N)
          : (p.__proto__ = N));
  }
  var u = (function (p) {
    c(N, p);
    function N() {
      return (
        a(this, N),
        l(
          this,
          (N.__proto__ || Object.getPrototypeOf(N)).apply(this, arguments)
        )
      );
    }
    return (
      n(N, [
        {
          key: "render",
          value: function () {
            return t.default.createElement(
              "button",
              this.props,
              this.props.children
            );
          },
        },
      ]),
      N
    );
  })(t.default.Component);
  return (Button.default = (0, s.default)(u)), Button;
}
var Element$1 = {},
  scrollElement = {},
  hasRequiredScrollElement;
function requireScrollElement() {
  if (hasRequiredScrollElement) return scrollElement;
  (hasRequiredScrollElement = 1),
    Object.defineProperty(scrollElement, "__esModule", { value: !0 });
  var n =
      Object.assign ||
      function (de) {
        for (var me = 1; me < arguments.length; me++) {
          var Ye = arguments[me];
          for (var nt in Ye)
            Object.prototype.hasOwnProperty.call(Ye, nt) && (de[nt] = Ye[nt]);
        }
        return de;
      },
    e = (function () {
      function de(me, Ye) {
        for (var nt = 0; nt < Ye.length; nt++) {
          var Be = Ye[nt];
          (Be.enumerable = Be.enumerable || !1),
            (Be.configurable = !0),
            "value" in Be && (Be.writable = !0),
            Object.defineProperty(me, Be.key, Be);
        }
      }
      return function (me, Ye, nt) {
        return Ye && de(me.prototype, Ye), nt && de(me, nt), me;
      };
    })(),
    t = requireReact(),
    r = u(t),
    s = requireReactDom();
  u(s);
  var o = requireScroller(),
    a = u(o),
    l = requirePropTypes(),
    c = u(l);
  function u(de) {
    return de && de.__esModule ? de : { default: de };
  }
  function p(de, me) {
    if (!(de instanceof me))
      throw new TypeError("Cannot call a class as a function");
  }
  function N(de, me) {
    if (!de)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return me && (typeof me == "object" || typeof me == "function") ? me : de;
  }
  function P(de, me) {
    if (typeof me != "function" && me !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof me
      );
    (de.prototype = Object.create(me && me.prototype, {
      constructor: {
        value: de,
        enumerable: !1,
        writable: !0,
        configurable: !0,
      },
    })),
      me &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(de, me)
          : (de.__proto__ = me));
  }
  return (
    (scrollElement.default = function (de) {
      var me = (function (Ye) {
        P(nt, Ye);
        function nt(Be) {
          p(this, nt);
          var ot = N(
            this,
            (nt.__proto__ || Object.getPrototypeOf(nt)).call(this, Be)
          );
          return (ot.childBindings = { domNode: null }), ot;
        }
        return (
          e(nt, [
            {
              key: "componentDidMount",
              value: function () {
                if (typeof window > "u") return !1;
                this.registerElems(this.props.name);
              },
            },
            {
              key: "componentDidUpdate",
              value: function (ot) {
                this.props.name !== ot.name &&
                  this.registerElems(this.props.name);
              },
            },
            {
              key: "componentWillUnmount",
              value: function () {
                if (typeof window > "u") return !1;
                a.default.unregister(this.props.name);
              },
            },
            {
              key: "registerElems",
              value: function (ot) {
                a.default.register(ot, this.childBindings.domNode);
              },
            },
            {
              key: "render",
              value: function () {
                return r.default.createElement(
                  de,
                  n({}, this.props, { parentBindings: this.childBindings })
                );
              },
            },
          ]),
          nt
        );
      })(r.default.Component);
      return (
        (me.propTypes = { name: c.default.string, id: c.default.string }), me
      );
    }),
    scrollElement
  );
}
var hasRequiredElement;
function requireElement() {
  if (hasRequiredElement) return Element$1;
  (hasRequiredElement = 1),
    Object.defineProperty(Element$1, "__esModule", { value: !0 });
  var n =
      Object.assign ||
      function (de) {
        for (var me = 1; me < arguments.length; me++) {
          var Ye = arguments[me];
          for (var nt in Ye)
            Object.prototype.hasOwnProperty.call(Ye, nt) && (de[nt] = Ye[nt]);
        }
        return de;
      },
    e = (function () {
      function de(me, Ye) {
        for (var nt = 0; nt < Ye.length; nt++) {
          var Be = Ye[nt];
          (Be.enumerable = Be.enumerable || !1),
            (Be.configurable = !0),
            "value" in Be && (Be.writable = !0),
            Object.defineProperty(me, Be.key, Be);
        }
      }
      return function (me, Ye, nt) {
        return Ye && de(me.prototype, Ye), nt && de(me, nt), me;
      };
    })(),
    t = requireReact(),
    r = c(t),
    s = requireScrollElement(),
    o = c(s),
    a = requirePropTypes(),
    l = c(a);
  function c(de) {
    return de && de.__esModule ? de : { default: de };
  }
  function u(de, me) {
    if (!(de instanceof me))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(de, me) {
    if (!de)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return me && (typeof me == "object" || typeof me == "function") ? me : de;
  }
  function N(de, me) {
    if (typeof me != "function" && me !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof me
      );
    (de.prototype = Object.create(me && me.prototype, {
      constructor: {
        value: de,
        enumerable: !1,
        writable: !0,
        configurable: !0,
      },
    })),
      me &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(de, me)
          : (de.__proto__ = me));
  }
  var P = (function (de) {
    N(me, de);
    function me() {
      return (
        u(this, me),
        p(
          this,
          (me.__proto__ || Object.getPrototypeOf(me)).apply(this, arguments)
        )
      );
    }
    return (
      e(me, [
        {
          key: "render",
          value: function () {
            var nt = this,
              Be = n({}, this.props);
            return (
              delete Be.name,
              Be.parentBindings && delete Be.parentBindings,
              r.default.createElement(
                "div",
                n({}, Be, {
                  ref: function (st) {
                    nt.props.parentBindings.domNode = st;
                  },
                }),
                this.props.children
              )
            );
          },
        },
      ]),
      me
    );
  })(r.default.Component);
  return (
    (P.propTypes = { name: l.default.string, id: l.default.string }),
    (Element$1.default = (0, o.default)(P)),
    Element$1
  );
}
var Helpers_1, hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return Helpers_1;
  hasRequiredHelpers = 1;
  var n =
      Object.assign ||
      function (P) {
        for (var de = 1; de < arguments.length; de++) {
          var me = arguments[de];
          for (var Ye in me)
            Object.prototype.hasOwnProperty.call(me, Ye) && (P[Ye] = me[Ye]);
        }
        return P;
      },
    e = (function () {
      function P(de, me) {
        for (var Ye = 0; Ye < me.length; Ye++) {
          var nt = me[Ye];
          (nt.enumerable = nt.enumerable || !1),
            (nt.configurable = !0),
            "value" in nt && (nt.writable = !0),
            Object.defineProperty(de, nt.key, nt);
        }
      }
      return function (de, me, Ye) {
        return me && P(de.prototype, me), Ye && P(de, Ye), de;
      };
    })();
  function t(P, de) {
    if (!(P instanceof de))
      throw new TypeError("Cannot call a class as a function");
  }
  function r(P, de) {
    if (!P)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return de && (typeof de == "object" || typeof de == "function") ? de : P;
  }
  function s(P, de) {
    if (typeof de != "function" && de !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof de
      );
    (P.prototype = Object.create(de && de.prototype, {
      constructor: { value: P, enumerable: !1, writable: !0, configurable: !0 },
    })),
      de &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(P, de)
          : (P.__proto__ = de));
  }
  var o = requireReact();
  requireReactDom(), requireUtils$1();
  var a = requireScrollSpy(),
    l = requireScroller(),
    c = requirePropTypes(),
    u = requireScrollHash(),
    p = {
      to: c.string.isRequired,
      containerId: c.string,
      container: c.object,
      activeClass: c.string,
      spy: c.bool,
      smooth: c.oneOfType([c.bool, c.string]),
      offset: c.number,
      delay: c.number,
      isDynamic: c.bool,
      onClick: c.func,
      duration: c.oneOfType([c.number, c.func]),
      absolute: c.bool,
      onSetActive: c.func,
      onSetInactive: c.func,
      ignoreCancelEvents: c.bool,
      hashSpy: c.bool,
      spyThrottle: c.number,
    },
    N = {
      Scroll: function (de, me) {
        console.warn("Helpers.Scroll is deprecated since v1.7.0");
        var Ye = me || l,
          nt = (function (ot) {
            s(st, ot);
            function st(vt) {
              t(this, st);
              var xt = r(
                this,
                (st.__proto__ || Object.getPrototypeOf(st)).call(this, vt)
              );
              return Be.call(xt), (xt.state = { active: !1 }), xt;
            }
            return (
              e(st, [
                {
                  key: "getScrollSpyContainer",
                  value: function () {
                    var xt = this.props.containerId,
                      St = this.props.container;
                    return xt
                      ? document.getElementById(xt)
                      : St && St.nodeType
                      ? St
                      : document;
                  },
                },
                {
                  key: "componentDidMount",
                  value: function () {
                    if (this.props.spy || this.props.hashSpy) {
                      var xt = this.getScrollSpyContainer();
                      a.isMounted(xt) || a.mount(xt, this.props.spyThrottle),
                        this.props.hashSpy &&
                          (u.isMounted() || u.mount(Ye),
                          u.mapContainer(this.props.to, xt)),
                        this.props.spy && a.addStateHandler(this.stateHandler),
                        a.addSpyHandler(this.spyHandler, xt),
                        this.setState({ container: xt });
                    }
                  },
                },
                {
                  key: "componentWillUnmount",
                  value: function () {
                    a.unmount(this.stateHandler, this.spyHandler);
                  },
                },
                {
                  key: "render",
                  value: function () {
                    var xt = "";
                    this.state && this.state.active
                      ? (xt = (
                          (this.props.className || "") +
                          " " +
                          (this.props.activeClass || "active")
                        ).trim())
                      : (xt = this.props.className);
                    var St = n({}, this.props);
                    for (var wt in p) St.hasOwnProperty(wt) && delete St[wt];
                    return (
                      (St.className = xt),
                      (St.onClick = this.handleClick),
                      o.createElement(de, St)
                    );
                  },
                },
              ]),
              st
            );
          })(o.Component),
          Be = function () {
            var st = this;
            (this.scrollTo = function (vt, xt) {
              Ye.scrollTo(vt, n({}, st.state, xt));
            }),
              (this.handleClick = function (vt) {
                st.props.onClick && st.props.onClick(vt),
                  vt.stopPropagation && vt.stopPropagation(),
                  vt.preventDefault && vt.preventDefault(),
                  st.scrollTo(st.props.to, st.props);
              }),
              (this.stateHandler = function () {
                Ye.getActiveLink() !== st.props.to &&
                  (st.state !== null &&
                    st.state.active &&
                    st.props.onSetInactive &&
                    st.props.onSetInactive(),
                  st.setState({ active: !1 }));
              }),
              (this.spyHandler = function (vt) {
                var xt = st.getScrollSpyContainer();
                if (!(u.isMounted() && !u.isInitialized())) {
                  var St = st.props.to,
                    wt = null,
                    bt = 0,
                    Tt = 0,
                    Ct = 0;
                  if (xt.getBoundingClientRect) {
                    var kt = xt.getBoundingClientRect();
                    Ct = kt.top;
                  }
                  if (!wt || st.props.isDynamic) {
                    if (((wt = Ye.get(St)), !wt)) return;
                    var Dt = wt.getBoundingClientRect();
                    (bt = Dt.top - Ct + vt), (Tt = bt + Dt.height);
                  }
                  var Vt = vt - st.props.offset,
                    Ht = Vt >= Math.floor(bt) && Vt < Math.floor(Tt),
                    qt = Vt < Math.floor(bt) || Vt >= Math.floor(Tt),
                    Ft = Ye.getActiveLink();
                  if (qt)
                    return (
                      St === Ft && Ye.setActiveLink(void 0),
                      st.props.hashSpy && u.getHash() === St && u.changeHash(),
                      st.props.spy &&
                        st.state.active &&
                        (st.setState({ active: !1 }),
                        st.props.onSetInactive && st.props.onSetInactive()),
                      a.updateStates()
                    );
                  if (Ht && Ft !== St)
                    return (
                      Ye.setActiveLink(St),
                      st.props.hashSpy && u.changeHash(St),
                      st.props.spy &&
                        (st.setState({ active: !0 }),
                        st.props.onSetActive && st.props.onSetActive(St)),
                      a.updateStates()
                    );
                }
              });
          };
        return (nt.propTypes = p), (nt.defaultProps = { offset: 0 }), nt;
      },
      Element: function (de) {
        console.warn("Helpers.Element is deprecated since v1.7.0");
        var me = (function (Ye) {
          s(nt, Ye);
          function nt(Be) {
            t(this, nt);
            var ot = r(
              this,
              (nt.__proto__ || Object.getPrototypeOf(nt)).call(this, Be)
            );
            return (ot.childBindings = { domNode: null }), ot;
          }
          return (
            e(nt, [
              {
                key: "componentDidMount",
                value: function () {
                  if (typeof window > "u") return !1;
                  this.registerElems(this.props.name);
                },
              },
              {
                key: "componentDidUpdate",
                value: function (ot) {
                  this.props.name !== ot.name &&
                    this.registerElems(this.props.name);
                },
              },
              {
                key: "componentWillUnmount",
                value: function () {
                  if (typeof window > "u") return !1;
                  l.unregister(this.props.name);
                },
              },
              {
                key: "registerElems",
                value: function (ot) {
                  l.register(ot, this.childBindings.domNode);
                },
              },
              {
                key: "render",
                value: function () {
                  return o.createElement(
                    de,
                    n({}, this.props, { parentBindings: this.childBindings })
                  );
                },
              },
            ]),
            nt
          );
        })(o.Component);
        return (me.propTypes = { name: c.string, id: c.string }), me;
      },
    };
  return (Helpers_1 = N), Helpers_1;
}
var hasRequiredModules;
function requireModules() {
  if (hasRequiredModules) return modules;
  (hasRequiredModules = 1),
    Object.defineProperty(modules, "__esModule", { value: !0 }),
    (modules.Helpers =
      modules.ScrollElement =
      modules.ScrollLink =
      modules.animateScroll =
      modules.scrollSpy =
      modules.Events =
      modules.scroller =
      modules.Element =
      modules.Button =
      modules.Link =
        void 0);
  var n = requireLink(),
    e = vt(n),
    t = requireButton(),
    r = vt(t),
    s = requireElement(),
    o = vt(s),
    a = requireScroller(),
    l = vt(a),
    c = requireScrollEvents(),
    u = vt(c),
    p = requireScrollSpy(),
    N = vt(p),
    P = requireAnimateScroll(),
    de = vt(P),
    me = requireScrollLink(),
    Ye = vt(me),
    nt = requireScrollElement(),
    Be = vt(nt),
    ot = requireHelpers(),
    st = vt(ot);
  function vt(xt) {
    return xt && xt.__esModule ? xt : { default: xt };
  }
  return (
    (modules.Link = e.default),
    (modules.Button = r.default),
    (modules.Element = o.default),
    (modules.scroller = l.default),
    (modules.Events = u.default),
    (modules.scrollSpy = N.default),
    (modules.animateScroll = de.default),
    (modules.ScrollLink = Ye.default),
    (modules.ScrollElement = Be.default),
    (modules.Helpers = st.default),
    (modules.default = {
      Link: e.default,
      Button: r.default,
      Element: o.default,
      scroller: l.default,
      Events: u.default,
      scrollSpy: N.default,
      animateScroll: de.default,
      ScrollLink: Ye.default,
      ScrollElement: Be.default,
      Helpers: st.default,
    }),
    modules
  );
}
var modulesExports = requireModules();
const scrollToBlock = (n, e, t = 0, r = 2e3) => {
  modulesExports.scroller.scrollTo(n, {
    duration: r,
    delay: 0,
    smooth: !1,
    offset: t,
    containerId: libExports.isMobileOnly ? "" : "blocksContainer",
  }),
    e && setTimeout(() => e(!1), 100);
};
function on(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  n && n.addEventListener && n.addEventListener.apply(n, e);
}
function off(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  n && n.removeEventListener && n.removeEventListener.apply(n, e);
}
var isBrowser = typeof window < "u";
function getClosestBody(n) {
  if (n) {
    if (n.tagName === "BODY") return n;
    if (n.tagName === "IFRAME") {
      var e = n.contentDocument;
      return e ? e.body : null;
    } else if (!n.offsetParent) return null;
  } else return null;
  return getClosestBody(n.offsetParent);
}
function preventDefault(n) {
  var e = n || window.event;
  return e.touches.length > 1
    ? !0
    : (e.preventDefault && e.preventDefault(), !1);
}
var isIosDevice =
    isBrowser &&
    window.navigator &&
    window.navigator.platform &&
    /iP(ad|hone|od)/.test(window.navigator.platform),
  bodies = new Map(),
  doc = typeof document == "object" ? document : void 0,
  documentListenerAdded = !1;
const useLockBodyScroll = doc
    ? function (e, t) {
        e === void 0 && (e = !0);
        var r = reactExports.useRef(doc.body);
        t = t || r;
        var s = function (a) {
            var l = bodies.get(a);
            l
              ? bodies.set(a, {
                  counter: l.counter + 1,
                  initialOverflow: l.initialOverflow,
                })
              : (bodies.set(a, {
                  counter: 1,
                  initialOverflow: a.style.overflow,
                }),
                isIosDevice
                  ? documentListenerAdded ||
                    (on(document, "touchmove", preventDefault, { passive: !1 }),
                    (documentListenerAdded = !0))
                  : (a.style.overflow = "hidden"));
          },
          o = function (a) {
            var l = bodies.get(a);
            l &&
              (l.counter === 1
                ? (bodies.delete(a),
                  isIosDevice
                    ? ((a.ontouchmove = null),
                      documentListenerAdded &&
                        (off(document, "touchmove", preventDefault),
                        (documentListenerAdded = !1)))
                    : (a.style.overflow = l.initialOverflow))
                : bodies.set(a, {
                    counter: l.counter - 1,
                    initialOverflow: l.initialOverflow,
                  }));
          };
        reactExports.useEffect(
          function () {
            var a = getClosestBody(t.current);
            a && (e ? s(a) : o(a));
          },
          [e, t.current]
        ),
          reactExports.useEffect(function () {
            var a = getClosestBody(t.current);
            if (a)
              return function () {
                o(a);
              };
          }, []);
      }
    : function (e, t) {},
  Header = () => {
    const n = useBreakpoints(),
      [e, t] = reactExports.useState(!1);
    return (
      useLockBodyScroll(e),
      jsxRuntimeExports.jsxs(HeaderBlock, {
        id: "headerBlock",
        children: [
          jsxRuntimeExports.jsx(Container, {
            children: jsxRuntimeExports.jsxs(Content$4, {
              children: [
                jsxRuntimeExports.jsx(HeaderSection, {
                  style: { cursor: "pointer" },
                  children: jsxRuntimeExports.jsx(LogoIcon, {
                    style: { width: "2.8125rem", height: "2.625rem" },
                  }),
                }),
                n === "small" &&
                  jsxRuntimeExports.jsx(BurgerMenu, {
                    onClick: () => t(!0),
                    "aria-label": "Open Menu",
                    children: jsxRuntimeExports.jsx(Button$1, {
                      decoration: "basic",
                      style: {
                        height: "100%",
                        width: "100%",
                        position: "relative",
                      },
                      children: jsxRuntimeExports.jsx(BurgerIcon, {
                        style: {
                          width: "1.5rem",
                          height: "1.5rem",
                          position: "absolute",
                        },
                      }),
                    }),
                  }),
                n !== "small" &&
                  jsxRuntimeExports.jsxs(HeaderSection, {
                    style: { justifyContent: "space-between", width: "100%" },
                    children: [
                      jsxRuntimeExports.jsxs(StyledList$1, {
                        children: [
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            onClick: () => scrollToBlock("legend"),
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "Legend",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            onClick: () => scrollToBlock("howItWorks"),
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "How it works",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            onClick: () => scrollToBlock("features"),
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "AI Future",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            onClick: () => {
                              scrollToBlock("roadmap");
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "RoadMap",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            onClick: () => scrollToBlock("workWithUs"),
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "Apply Now",
                            }),
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsxs(StyledList$1, {
                        style: {
                          alignItems: "flex-start",
                          gap: "1.25rem",
                          fontSize: "0.875rem",
                        },
                        children: [
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://x.com/docca",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              children: "X",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem$1, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://www.linkedin.com/",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              children: "LI",
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
              ],
            }),
          }),
          n === "small" &&
            e &&
            jsxRuntimeExports.jsx(MobileMenu, {
              children: jsxRuntimeExports.jsx(AnimatedBG, {
                children: jsxRuntimeExports.jsxs(Content$4, {
                  style: {
                    flexDirection: "column",
                    alignItems: "start",
                    zIndex: "10",
                  },
                  children: [
                    jsxRuntimeExports.jsxs(MobileMenuHeader, {
                      children: [
                        jsxRuntimeExports.jsx("div", {
                          style: {
                            display: "flex",
                            cursor: "pointer",
                            alignItems: "center",
                          },
                          onClick: () => scrollToBlock("mainBlock", t),
                          children: jsxRuntimeExports.jsx(LogoIcon, {
                            style: { width: "2.8125rem", height: "2.625rem" },
                          }),
                        }),
                        jsxRuntimeExports.jsx(CloseBtn, {
                          onClick: () => t(!1),
                          children: jsxRuntimeExports.jsx(Button$1, {
                            decoration: "basic",
                            style: {
                              height: "100%",
                              width: "100%",
                              position: "relative",
                            },
                            children: jsxRuntimeExports.jsx(CloseIcon, {
                              "aria-label": "Close Menu",
                              style: {
                                width: "1.5rem",
                                height: "1.5rem",
                                position: "absolute",
                              },
                            }),
                          }),
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsxs(StyledList$1, {
                      vertical: !0,
                      style: {
                        alignItems: "flex-start",
                        gap: "1.625rem",
                        marginLeft: "2rem",
                        fontSize: "1.125rem",
                      },
                      children: [
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          onClick: () => scrollToBlock("legend", t),
                          children: jsxRuntimeExports.jsx("h4", {
                            children: "Legend",
                          }),
                        }),
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          onClick: () => scrollToBlock("howItWorks", t),
                          children: jsxRuntimeExports.jsx("h4", {
                            children: "How it works",
                          }),
                        }),
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          onClick: () => scrollToBlock("features", t),
                          children: jsxRuntimeExports.jsx("h4", {
                            children: "AI Future",
                          }),
                        }),
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          onClick: () => scrollToBlock("roadmap", t),
                          children: jsxRuntimeExports.jsx("h4", {
                            children: "RoadMap",
                          }),
                        }),
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          onClick: () => scrollToBlock("workWithUs", t),
                          children: jsxRuntimeExports.jsx("h4", {
                            children: "Apply Now",
                          }),
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsxs(StyledList$1, {
                      vertical: !0,
                      style: {
                        alignItems: "flex-start",
                        gap: "1.25rem",
                        marginLeft: "2rem",
                        fontSize: "0.875rem",
                        marginTop: "4.5rem",
                      },
                      children: [
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          children: jsxRuntimeExports.jsx("a", {
                            href: "https://x.com/docca",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            children: "TWITTER",
                          }),
                        }),
                        jsxRuntimeExports.jsx(StyledListItem$1, {
                          children: jsxRuntimeExports.jsx("a", {
                            href: "https://www.linkedin.com/",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            children: "LINKEDIN",
                          }),
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            }),
        ],
      })
    );
  };
var lottie$2 = { exports: {} },
  lottie$1 = lottie$2.exports,
  hasRequiredLottie;
function requireLottie() {
  return (
    hasRequiredLottie ||
      ((hasRequiredLottie = 1),
      (function (module, exports) {
        typeof document < "u" &&
          typeof navigator < "u" &&
          (function (n, e) {
            module.exports = e();
          })(lottie$1, function () {
            var svgNS = "http://www.w3.org/2000/svg",
              locationHref = "",
              _useWebWorker = !1,
              initialDefaultFrame = -999999,
              setWebWorker = function (e) {
                _useWebWorker = !!e;
              },
              getWebWorker = function () {
                return _useWebWorker;
              },
              setLocationHref = function (e) {
                locationHref = e;
              },
              getLocationHref = function () {
                return locationHref;
              };
            function createTag(n) {
              return document.createElement(n);
            }
            function extendPrototype(n, e) {
              var t,
                r = n.length,
                s;
              for (t = 0; t < r; t += 1) {
                s = n[t].prototype;
                for (var o in s)
                  Object.prototype.hasOwnProperty.call(s, o) &&
                    (e.prototype[o] = s[o]);
              }
            }
            function getDescriptor(n, e) {
              return Object.getOwnPropertyDescriptor(n, e);
            }
            function createProxyFunction(n) {
              function e() {}
              return (e.prototype = n), e;
            }
            var audioControllerFactory = (function () {
                function n(e) {
                  (this.audios = []),
                    (this.audioFactory = e),
                    (this._volume = 1),
                    (this._isMuted = !1);
                }
                return (
                  (n.prototype = {
                    addAudio: function (t) {
                      this.audios.push(t);
                    },
                    pause: function () {
                      var t,
                        r = this.audios.length;
                      for (t = 0; t < r; t += 1) this.audios[t].pause();
                    },
                    resume: function () {
                      var t,
                        r = this.audios.length;
                      for (t = 0; t < r; t += 1) this.audios[t].resume();
                    },
                    setRate: function (t) {
                      var r,
                        s = this.audios.length;
                      for (r = 0; r < s; r += 1) this.audios[r].setRate(t);
                    },
                    createAudio: function (t) {
                      return this.audioFactory
                        ? this.audioFactory(t)
                        : window.Howl
                        ? new window.Howl({ src: [t] })
                        : {
                            isPlaying: !1,
                            play: function () {
                              this.isPlaying = !0;
                            },
                            seek: function () {
                              this.isPlaying = !1;
                            },
                            playing: function () {},
                            rate: function () {},
                            setVolume: function () {},
                          };
                    },
                    setAudioFactory: function (t) {
                      this.audioFactory = t;
                    },
                    setVolume: function (t) {
                      (this._volume = t), this._updateVolume();
                    },
                    mute: function () {
                      (this._isMuted = !0), this._updateVolume();
                    },
                    unmute: function () {
                      (this._isMuted = !1), this._updateVolume();
                    },
                    getVolume: function () {
                      return this._volume;
                    },
                    _updateVolume: function () {
                      var t,
                        r = this.audios.length;
                      for (t = 0; t < r; t += 1)
                        this.audios[t].volume(
                          this._volume * (this._isMuted ? 0 : 1)
                        );
                    },
                  }),
                  function () {
                    return new n();
                  }
                );
              })(),
              createTypedArray = (function () {
                function n(t, r) {
                  var s = 0,
                    o = [],
                    a;
                  switch (t) {
                    case "int16":
                    case "uint8c":
                      a = 1;
                      break;
                    default:
                      a = 1.1;
                      break;
                  }
                  for (s = 0; s < r; s += 1) o.push(a);
                  return o;
                }
                function e(t, r) {
                  return t === "float32"
                    ? new Float32Array(r)
                    : t === "int16"
                    ? new Int16Array(r)
                    : t === "uint8c"
                    ? new Uint8ClampedArray(r)
                    : n(t, r);
                }
                return typeof Uint8ClampedArray == "function" &&
                  typeof Float32Array == "function"
                  ? e
                  : n;
              })();
            function createSizedArray(n) {
              return Array.apply(null, { length: n });
            }
            function _typeof$6(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof$6 =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof$6(n)
              );
            }
            var subframeEnabled = !0,
              expressionsPlugin = null,
              expressionsInterfaces = null,
              idPrefix$1 = "",
              isSafari = /^((?!chrome|android).)*safari/i.test(
                navigator.userAgent
              ),
              bmPow = Math.pow,
              bmSqrt = Math.sqrt,
              bmFloor = Math.floor,
              bmMax = Math.max,
              bmMin = Math.min,
              BMMath = {};
            (function () {
              var n = [
                  "abs",
                  "acos",
                  "acosh",
                  "asin",
                  "asinh",
                  "atan",
                  "atanh",
                  "atan2",
                  "ceil",
                  "cbrt",
                  "expm1",
                  "clz32",
                  "cos",
                  "cosh",
                  "exp",
                  "floor",
                  "fround",
                  "hypot",
                  "imul",
                  "log",
                  "log1p",
                  "log2",
                  "log10",
                  "max",
                  "min",
                  "pow",
                  "random",
                  "round",
                  "sign",
                  "sin",
                  "sinh",
                  "sqrt",
                  "tan",
                  "tanh",
                  "trunc",
                  "E",
                  "LN10",
                  "LN2",
                  "LOG10E",
                  "LOG2E",
                  "PI",
                  "SQRT1_2",
                  "SQRT2",
                ],
                e,
                t = n.length;
              for (e = 0; e < t; e += 1) BMMath[n[e]] = Math[n[e]];
            })(),
              (BMMath.random = Math.random),
              (BMMath.abs = function (n) {
                var e = _typeof$6(n);
                if (e === "object" && n.length) {
                  var t = createSizedArray(n.length),
                    r,
                    s = n.length;
                  for (r = 0; r < s; r += 1) t[r] = Math.abs(n[r]);
                  return t;
                }
                return Math.abs(n);
              });
            var defaultCurveSegments = 150,
              degToRads = Math.PI / 180,
              roundCorner = 0.5519;
            function styleDiv(n) {
              (n.style.position = "absolute"),
                (n.style.top = 0),
                (n.style.left = 0),
                (n.style.display = "block"),
                (n.style.transformOrigin = "0 0"),
                (n.style.webkitTransformOrigin = "0 0"),
                (n.style.backfaceVisibility = "visible"),
                (n.style.webkitBackfaceVisibility = "visible"),
                (n.style.transformStyle = "preserve-3d"),
                (n.style.webkitTransformStyle = "preserve-3d"),
                (n.style.mozTransformStyle = "preserve-3d");
            }
            function BMEnterFrameEvent(n, e, t, r) {
              (this.type = n),
                (this.currentTime = e),
                (this.totalTime = t),
                (this.direction = r < 0 ? -1 : 1);
            }
            function BMCompleteEvent(n, e) {
              (this.type = n), (this.direction = e < 0 ? -1 : 1);
            }
            function BMCompleteLoopEvent(n, e, t, r) {
              (this.type = n),
                (this.currentLoop = t),
                (this.totalLoops = e),
                (this.direction = r < 0 ? -1 : 1);
            }
            function BMSegmentStartEvent(n, e, t) {
              (this.type = n), (this.firstFrame = e), (this.totalFrames = t);
            }
            function BMDestroyEvent(n, e) {
              (this.type = n), (this.target = e);
            }
            function BMRenderFrameErrorEvent(n, e) {
              (this.type = "renderFrameError"),
                (this.nativeError = n),
                (this.currentTime = e);
            }
            function BMConfigErrorEvent(n) {
              (this.type = "configError"), (this.nativeError = n);
            }
            var createElementID = (function () {
              var n = 0;
              return function () {
                return (n += 1), idPrefix$1 + "__lottie_element_" + n;
              };
            })();
            function HSVtoRGB(n, e, t) {
              var r, s, o, a, l, c, u, p;
              switch (
                ((a = Math.floor(n * 6)),
                (l = n * 6 - a),
                (c = t * (1 - e)),
                (u = t * (1 - l * e)),
                (p = t * (1 - (1 - l) * e)),
                a % 6)
              ) {
                case 0:
                  (r = t), (s = p), (o = c);
                  break;
                case 1:
                  (r = u), (s = t), (o = c);
                  break;
                case 2:
                  (r = c), (s = t), (o = p);
                  break;
                case 3:
                  (r = c), (s = u), (o = t);
                  break;
                case 4:
                  (r = p), (s = c), (o = t);
                  break;
                case 5:
                  (r = t), (s = c), (o = u);
                  break;
              }
              return [r, s, o];
            }
            function RGBtoHSV(n, e, t) {
              var r = Math.max(n, e, t),
                s = Math.min(n, e, t),
                o = r - s,
                a,
                l = r === 0 ? 0 : o / r,
                c = r / 255;
              switch (r) {
                case s:
                  a = 0;
                  break;
                case n:
                  (a = e - t + o * (e < t ? 6 : 0)), (a /= 6 * o);
                  break;
                case e:
                  (a = t - n + o * 2), (a /= 6 * o);
                  break;
                case t:
                  (a = n - e + o * 4), (a /= 6 * o);
                  break;
              }
              return [a, l, c];
            }
            function addSaturationToRGB(n, e) {
              var t = RGBtoHSV(n[0] * 255, n[1] * 255, n[2] * 255);
              return (
                (t[1] += e),
                t[1] > 1 ? (t[1] = 1) : t[1] <= 0 && (t[1] = 0),
                HSVtoRGB(t[0], t[1], t[2])
              );
            }
            function addBrightnessToRGB(n, e) {
              var t = RGBtoHSV(n[0] * 255, n[1] * 255, n[2] * 255);
              return (
                (t[2] += e),
                t[2] > 1 ? (t[2] = 1) : t[2] < 0 && (t[2] = 0),
                HSVtoRGB(t[0], t[1], t[2])
              );
            }
            function addHueToRGB(n, e) {
              var t = RGBtoHSV(n[0] * 255, n[1] * 255, n[2] * 255);
              return (
                (t[0] += e / 360),
                t[0] > 1 ? (t[0] -= 1) : t[0] < 0 && (t[0] += 1),
                HSVtoRGB(t[0], t[1], t[2])
              );
            }
            var rgbToHex = (function () {
                var n = [],
                  e,
                  t;
                for (e = 0; e < 256; e += 1)
                  (t = e.toString(16)), (n[e] = t.length === 1 ? "0" + t : t);
                return function (r, s, o) {
                  return (
                    r < 0 && (r = 0),
                    s < 0 && (s = 0),
                    o < 0 && (o = 0),
                    "#" + n[r] + n[s] + n[o]
                  );
                };
              })(),
              setSubframeEnabled = function (e) {
                subframeEnabled = !!e;
              },
              getSubframeEnabled = function () {
                return subframeEnabled;
              },
              setExpressionsPlugin = function (e) {
                expressionsPlugin = e;
              },
              getExpressionsPlugin = function () {
                return expressionsPlugin;
              },
              setExpressionInterfaces = function (e) {
                expressionsInterfaces = e;
              },
              getExpressionInterfaces = function () {
                return expressionsInterfaces;
              },
              setDefaultCurveSegments = function (e) {
                defaultCurveSegments = e;
              },
              getDefaultCurveSegments = function () {
                return defaultCurveSegments;
              },
              setIdPrefix = function (e) {
                idPrefix$1 = e;
              };
            function createNS(n) {
              return document.createElementNS(svgNS, n);
            }
            function _typeof$5(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof$5 =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof$5(n)
              );
            }
            var dataManager = (function () {
                var n = 1,
                  e = [],
                  t,
                  r,
                  s = {
                    onmessage: function () {},
                    postMessage: function (de) {
                      t({ data: de });
                    },
                  },
                  o = {
                    postMessage: function (de) {
                      s.onmessage({ data: de });
                    },
                  };
                function a(P) {
                  if (window.Worker && window.Blob && getWebWorker()) {
                    var de = new Blob(
                        [
                          "var _workerSelf = self; self.onmessage = ",
                          P.toString(),
                        ],
                        { type: "text/javascript" }
                      ),
                      me = URL.createObjectURL(de);
                    return new Worker(me);
                  }
                  return (t = P), s;
                }
                function l() {
                  r ||
                    ((r = a(function (de) {
                      function me() {
                        function nt(qt, Ft) {
                          var Bt,
                            Mt,
                            Pt = qt.length,
                            It,
                            Ot,
                            Xt,
                            sn;
                          for (Mt = 0; Mt < Pt; Mt += 1)
                            if (((Bt = qt[Mt]), "ks" in Bt && !Bt.completed)) {
                              if (((Bt.completed = !0), Bt.hasMask)) {
                                var Kt = Bt.masksProperties;
                                for (Ot = Kt.length, It = 0; It < Ot; It += 1)
                                  if (Kt[It].pt.k.i) xt(Kt[It].pt.k);
                                  else
                                    for (
                                      sn = Kt[It].pt.k.length, Xt = 0;
                                      Xt < sn;
                                      Xt += 1
                                    )
                                      Kt[It].pt.k[Xt].s &&
                                        xt(Kt[It].pt.k[Xt].s[0]),
                                        Kt[It].pt.k[Xt].e &&
                                          xt(Kt[It].pt.k[Xt].e[0]);
                              }
                              Bt.ty === 0
                                ? ((Bt.layers = st(Bt.refId, Ft)),
                                  nt(Bt.layers, Ft))
                                : Bt.ty === 4
                                ? vt(Bt.shapes)
                                : Bt.ty === 5 && Vt(Bt);
                            }
                        }
                        function Be(qt, Ft) {
                          if (qt) {
                            var Bt = 0,
                              Mt = qt.length;
                            for (Bt = 0; Bt < Mt; Bt += 1)
                              qt[Bt].t === 1 &&
                                ((qt[Bt].data.layers = st(
                                  qt[Bt].data.refId,
                                  Ft
                                )),
                                nt(qt[Bt].data.layers, Ft));
                          }
                        }
                        function ot(qt, Ft) {
                          for (var Bt = 0, Mt = Ft.length; Bt < Mt; ) {
                            if (Ft[Bt].id === qt) return Ft[Bt];
                            Bt += 1;
                          }
                          return null;
                        }
                        function st(qt, Ft) {
                          var Bt = ot(qt, Ft);
                          return Bt
                            ? Bt.layers.__used
                              ? JSON.parse(JSON.stringify(Bt.layers))
                              : ((Bt.layers.__used = !0), Bt.layers)
                            : null;
                        }
                        function vt(qt) {
                          var Ft,
                            Bt = qt.length,
                            Mt,
                            Pt;
                          for (Ft = Bt - 1; Ft >= 0; Ft -= 1)
                            if (qt[Ft].ty === "sh")
                              if (qt[Ft].ks.k.i) xt(qt[Ft].ks.k);
                              else
                                for (
                                  Pt = qt[Ft].ks.k.length, Mt = 0;
                                  Mt < Pt;
                                  Mt += 1
                                )
                                  qt[Ft].ks.k[Mt].s && xt(qt[Ft].ks.k[Mt].s[0]),
                                    qt[Ft].ks.k[Mt].e &&
                                      xt(qt[Ft].ks.k[Mt].e[0]);
                            else qt[Ft].ty === "gr" && vt(qt[Ft].it);
                        }
                        function xt(qt) {
                          var Ft,
                            Bt = qt.i.length;
                          for (Ft = 0; Ft < Bt; Ft += 1)
                            (qt.i[Ft][0] += qt.v[Ft][0]),
                              (qt.i[Ft][1] += qt.v[Ft][1]),
                              (qt.o[Ft][0] += qt.v[Ft][0]),
                              (qt.o[Ft][1] += qt.v[Ft][1]);
                        }
                        function St(qt, Ft) {
                          var Bt = Ft ? Ft.split(".") : [100, 100, 100];
                          return qt[0] > Bt[0]
                            ? !0
                            : Bt[0] > qt[0]
                            ? !1
                            : qt[1] > Bt[1]
                            ? !0
                            : Bt[1] > qt[1]
                            ? !1
                            : qt[2] > Bt[2]
                            ? !0
                            : Bt[2] > qt[2]
                            ? !1
                            : null;
                        }
                        var wt = (function () {
                            var qt = [4, 4, 14];
                            function Ft(Mt) {
                              var Pt = Mt.t.d;
                              Mt.t.d = { k: [{ s: Pt, t: 0 }] };
                            }
                            function Bt(Mt) {
                              var Pt,
                                It = Mt.length;
                              for (Pt = 0; Pt < It; Pt += 1)
                                Mt[Pt].ty === 5 && Ft(Mt[Pt]);
                            }
                            return function (Mt) {
                              if (St(qt, Mt.v) && (Bt(Mt.layers), Mt.assets)) {
                                var Pt,
                                  It = Mt.assets.length;
                                for (Pt = 0; Pt < It; Pt += 1)
                                  Mt.assets[Pt].layers &&
                                    Bt(Mt.assets[Pt].layers);
                              }
                            };
                          })(),
                          bt = (function () {
                            var qt = [4, 7, 99];
                            return function (Ft) {
                              if (Ft.chars && !St(qt, Ft.v)) {
                                var Bt,
                                  Mt = Ft.chars.length;
                                for (Bt = 0; Bt < Mt; Bt += 1) {
                                  var Pt = Ft.chars[Bt];
                                  Pt.data &&
                                    Pt.data.shapes &&
                                    (vt(Pt.data.shapes),
                                    (Pt.data.ip = 0),
                                    (Pt.data.op = 99999),
                                    (Pt.data.st = 0),
                                    (Pt.data.sr = 1),
                                    (Pt.data.ks = {
                                      p: { k: [0, 0], a: 0 },
                                      s: { k: [100, 100], a: 0 },
                                      a: { k: [0, 0], a: 0 },
                                      r: { k: 0, a: 0 },
                                      o: { k: 100, a: 0 },
                                    }),
                                    Ft.chars[Bt].t ||
                                      (Pt.data.shapes.push({ ty: "no" }),
                                      Pt.data.shapes[0].it.push({
                                        p: { k: [0, 0], a: 0 },
                                        s: { k: [100, 100], a: 0 },
                                        a: { k: [0, 0], a: 0 },
                                        r: { k: 0, a: 0 },
                                        o: { k: 100, a: 0 },
                                        sk: { k: 0, a: 0 },
                                        sa: { k: 0, a: 0 },
                                        ty: "tr",
                                      })));
                                }
                              }
                            };
                          })(),
                          Tt = (function () {
                            var qt = [5, 7, 15];
                            function Ft(Mt) {
                              var Pt = Mt.t.p;
                              typeof Pt.a == "number" &&
                                (Pt.a = { a: 0, k: Pt.a }),
                                typeof Pt.p == "number" &&
                                  (Pt.p = { a: 0, k: Pt.p }),
                                typeof Pt.r == "number" &&
                                  (Pt.r = { a: 0, k: Pt.r });
                            }
                            function Bt(Mt) {
                              var Pt,
                                It = Mt.length;
                              for (Pt = 0; Pt < It; Pt += 1)
                                Mt[Pt].ty === 5 && Ft(Mt[Pt]);
                            }
                            return function (Mt) {
                              if (St(qt, Mt.v) && (Bt(Mt.layers), Mt.assets)) {
                                var Pt,
                                  It = Mt.assets.length;
                                for (Pt = 0; Pt < It; Pt += 1)
                                  Mt.assets[Pt].layers &&
                                    Bt(Mt.assets[Pt].layers);
                              }
                            };
                          })(),
                          Ct = (function () {
                            var qt = [4, 1, 9];
                            function Ft(Mt) {
                              var Pt,
                                It = Mt.length,
                                Ot,
                                Xt;
                              for (Pt = 0; Pt < It; Pt += 1)
                                if (Mt[Pt].ty === "gr") Ft(Mt[Pt].it);
                                else if (
                                  Mt[Pt].ty === "fl" ||
                                  Mt[Pt].ty === "st"
                                )
                                  if (Mt[Pt].c.k && Mt[Pt].c.k[0].i)
                                    for (
                                      Xt = Mt[Pt].c.k.length, Ot = 0;
                                      Ot < Xt;
                                      Ot += 1
                                    )
                                      Mt[Pt].c.k[Ot].s &&
                                        ((Mt[Pt].c.k[Ot].s[0] /= 255),
                                        (Mt[Pt].c.k[Ot].s[1] /= 255),
                                        (Mt[Pt].c.k[Ot].s[2] /= 255),
                                        (Mt[Pt].c.k[Ot].s[3] /= 255)),
                                        Mt[Pt].c.k[Ot].e &&
                                          ((Mt[Pt].c.k[Ot].e[0] /= 255),
                                          (Mt[Pt].c.k[Ot].e[1] /= 255),
                                          (Mt[Pt].c.k[Ot].e[2] /= 255),
                                          (Mt[Pt].c.k[Ot].e[3] /= 255));
                                  else
                                    (Mt[Pt].c.k[0] /= 255),
                                      (Mt[Pt].c.k[1] /= 255),
                                      (Mt[Pt].c.k[2] /= 255),
                                      (Mt[Pt].c.k[3] /= 255);
                            }
                            function Bt(Mt) {
                              var Pt,
                                It = Mt.length;
                              for (Pt = 0; Pt < It; Pt += 1)
                                Mt[Pt].ty === 4 && Ft(Mt[Pt].shapes);
                            }
                            return function (Mt) {
                              if (St(qt, Mt.v) && (Bt(Mt.layers), Mt.assets)) {
                                var Pt,
                                  It = Mt.assets.length;
                                for (Pt = 0; Pt < It; Pt += 1)
                                  Mt.assets[Pt].layers &&
                                    Bt(Mt.assets[Pt].layers);
                              }
                            };
                          })(),
                          kt = (function () {
                            var qt = [4, 4, 18];
                            function Ft(Mt) {
                              var Pt,
                                It = Mt.length,
                                Ot,
                                Xt;
                              for (Pt = It - 1; Pt >= 0; Pt -= 1)
                                if (Mt[Pt].ty === "sh")
                                  if (Mt[Pt].ks.k.i)
                                    Mt[Pt].ks.k.c = Mt[Pt].closed;
                                  else
                                    for (
                                      Xt = Mt[Pt].ks.k.length, Ot = 0;
                                      Ot < Xt;
                                      Ot += 1
                                    )
                                      Mt[Pt].ks.k[Ot].s &&
                                        (Mt[Pt].ks.k[Ot].s[0].c =
                                          Mt[Pt].closed),
                                        Mt[Pt].ks.k[Ot].e &&
                                          (Mt[Pt].ks.k[Ot].e[0].c =
                                            Mt[Pt].closed);
                                else Mt[Pt].ty === "gr" && Ft(Mt[Pt].it);
                            }
                            function Bt(Mt) {
                              var Pt,
                                It,
                                Ot = Mt.length,
                                Xt,
                                sn,
                                Kt,
                                tn;
                              for (It = 0; It < Ot; It += 1) {
                                if (((Pt = Mt[It]), Pt.hasMask)) {
                                  var pn = Pt.masksProperties;
                                  for (sn = pn.length, Xt = 0; Xt < sn; Xt += 1)
                                    if (pn[Xt].pt.k.i)
                                      pn[Xt].pt.k.c = pn[Xt].cl;
                                    else
                                      for (
                                        tn = pn[Xt].pt.k.length, Kt = 0;
                                        Kt < tn;
                                        Kt += 1
                                      )
                                        pn[Xt].pt.k[Kt].s &&
                                          (pn[Xt].pt.k[Kt].s[0].c = pn[Xt].cl),
                                          pn[Xt].pt.k[Kt].e &&
                                            (pn[Xt].pt.k[Kt].e[0].c =
                                              pn[Xt].cl);
                                }
                                Pt.ty === 4 && Ft(Pt.shapes);
                              }
                            }
                            return function (Mt) {
                              if (St(qt, Mt.v) && (Bt(Mt.layers), Mt.assets)) {
                                var Pt,
                                  It = Mt.assets.length;
                                for (Pt = 0; Pt < It; Pt += 1)
                                  Mt.assets[Pt].layers &&
                                    Bt(Mt.assets[Pt].layers);
                              }
                            };
                          })();
                        function Dt(qt) {
                          qt.__complete ||
                            (Ct(qt),
                            wt(qt),
                            bt(qt),
                            Tt(qt),
                            kt(qt),
                            nt(qt.layers, qt.assets),
                            Be(qt.chars, qt.assets),
                            (qt.__complete = !0));
                        }
                        function Vt(qt) {
                          qt.t.a.length === 0 && "m" in qt.t.p;
                        }
                        var Ht = {};
                        return (
                          (Ht.completeData = Dt),
                          (Ht.checkColors = Ct),
                          (Ht.checkChars = bt),
                          (Ht.checkPathProperties = Tt),
                          (Ht.checkShapes = kt),
                          (Ht.completeLayers = nt),
                          Ht
                        );
                      }
                      if (
                        (o.dataManager || (o.dataManager = me()),
                        o.assetLoader ||
                          (o.assetLoader = (function () {
                            function nt(ot) {
                              var st = ot.getResponseHeader("content-type");
                              return (st &&
                                ot.responseType === "json" &&
                                st.indexOf("json") !== -1) ||
                                (ot.response &&
                                  _typeof$5(ot.response) === "object")
                                ? ot.response
                                : ot.response && typeof ot.response == "string"
                                ? JSON.parse(ot.response)
                                : ot.responseText
                                ? JSON.parse(ot.responseText)
                                : null;
                            }
                            function Be(ot, st, vt, xt) {
                              var St,
                                wt = new XMLHttpRequest();
                              try {
                                wt.responseType = "json";
                              } catch {}
                              wt.onreadystatechange = function () {
                                if (wt.readyState === 4)
                                  if (wt.status === 200) (St = nt(wt)), vt(St);
                                  else
                                    try {
                                      (St = nt(wt)), vt(St);
                                    } catch (bt) {
                                      xt && xt(bt);
                                    }
                              };
                              try {
                                wt.open(["G", "E", "T"].join(""), ot, !0);
                              } catch {
                                wt.open(
                                  ["G", "E", "T"].join(""),
                                  st + "/" + ot,
                                  !0
                                );
                              }
                              wt.send();
                            }
                            return { load: Be };
                          })()),
                        de.data.type === "loadAnimation")
                      )
                        o.assetLoader.load(
                          de.data.path,
                          de.data.fullPath,
                          function (nt) {
                            o.dataManager.completeData(nt),
                              o.postMessage({
                                id: de.data.id,
                                payload: nt,
                                status: "success",
                              });
                          },
                          function () {
                            o.postMessage({ id: de.data.id, status: "error" });
                          }
                        );
                      else if (de.data.type === "complete") {
                        var Ye = de.data.animation;
                        o.dataManager.completeData(Ye),
                          o.postMessage({
                            id: de.data.id,
                            payload: Ye,
                            status: "success",
                          });
                      } else
                        de.data.type === "loadData" &&
                          o.assetLoader.load(
                            de.data.path,
                            de.data.fullPath,
                            function (nt) {
                              o.postMessage({
                                id: de.data.id,
                                payload: nt,
                                status: "success",
                              });
                            },
                            function () {
                              o.postMessage({
                                id: de.data.id,
                                status: "error",
                              });
                            }
                          );
                    })),
                    (r.onmessage = function (P) {
                      var de = P.data,
                        me = de.id,
                        Ye = e[me];
                      (e[me] = null),
                        de.status === "success"
                          ? Ye.onComplete(de.payload)
                          : Ye.onError && Ye.onError();
                    }));
                }
                function c(P, de) {
                  n += 1;
                  var me = "processId_" + n;
                  return (e[me] = { onComplete: P, onError: de }), me;
                }
                function u(P, de, me) {
                  l();
                  var Ye = c(de, me);
                  r.postMessage({
                    type: "loadAnimation",
                    path: P,
                    fullPath: window.location.origin + window.location.pathname,
                    id: Ye,
                  });
                }
                function p(P, de, me) {
                  l();
                  var Ye = c(de, me);
                  r.postMessage({
                    type: "loadData",
                    path: P,
                    fullPath: window.location.origin + window.location.pathname,
                    id: Ye,
                  });
                }
                function N(P, de, me) {
                  l();
                  var Ye = c(de, me);
                  r.postMessage({ type: "complete", animation: P, id: Ye });
                }
                return { loadAnimation: u, loadData: p, completeAnimation: N };
              })(),
              ImagePreloader = (function () {
                var n = (function () {
                  var Be = createTag("canvas");
                  (Be.width = 1), (Be.height = 1);
                  var ot = Be.getContext("2d");
                  return (
                    (ot.fillStyle = "rgba(0,0,0,0)"),
                    ot.fillRect(0, 0, 1, 1),
                    Be
                  );
                })();
                function e() {
                  (this.loadedAssets += 1),
                    this.loadedAssets === this.totalImages &&
                      this.loadedFootagesCount === this.totalFootages &&
                      this.imagesLoadedCb &&
                      this.imagesLoadedCb(null);
                }
                function t() {
                  (this.loadedFootagesCount += 1),
                    this.loadedAssets === this.totalImages &&
                      this.loadedFootagesCount === this.totalFootages &&
                      this.imagesLoadedCb &&
                      this.imagesLoadedCb(null);
                }
                function r(Be, ot, st) {
                  var vt = "";
                  if (Be.e) vt = Be.p;
                  else if (ot) {
                    var xt = Be.p;
                    xt.indexOf("images/") !== -1 && (xt = xt.split("/")[1]),
                      (vt = ot + xt);
                  } else (vt = st), (vt += Be.u ? Be.u : ""), (vt += Be.p);
                  return vt;
                }
                function s(Be) {
                  var ot = 0,
                    st = setInterval(
                      function () {
                        var vt = Be.getBBox();
                        (vt.width || ot > 500) &&
                          (this._imageLoaded(), clearInterval(st)),
                          (ot += 1);
                      }.bind(this),
                      50
                    );
                }
                function o(Be) {
                  var ot = r(Be, this.assetsPath, this.path),
                    st = createNS("image");
                  isSafari
                    ? this.testImageLoaded(st)
                    : st.addEventListener("load", this._imageLoaded, !1),
                    st.addEventListener(
                      "error",
                      function () {
                        (vt.img = n), this._imageLoaded();
                      }.bind(this),
                      !1
                    ),
                    st.setAttributeNS(
                      "http://www.w3.org/1999/xlink",
                      "href",
                      ot
                    ),
                    this._elementHelper.append
                      ? this._elementHelper.append(st)
                      : this._elementHelper.appendChild(st);
                  var vt = { img: st, assetData: Be };
                  return vt;
                }
                function a(Be) {
                  var ot = r(Be, this.assetsPath, this.path),
                    st = createTag("img");
                  (st.crossOrigin = "anonymous"),
                    st.addEventListener("load", this._imageLoaded, !1),
                    st.addEventListener(
                      "error",
                      function () {
                        (vt.img = n), this._imageLoaded();
                      }.bind(this),
                      !1
                    ),
                    (st.src = ot);
                  var vt = { img: st, assetData: Be };
                  return vt;
                }
                function l(Be) {
                  var ot = { assetData: Be },
                    st = r(Be, this.assetsPath, this.path);
                  return (
                    dataManager.loadData(
                      st,
                      function (vt) {
                        (ot.img = vt), this._footageLoaded();
                      }.bind(this),
                      function () {
                        (ot.img = {}), this._footageLoaded();
                      }.bind(this)
                    ),
                    ot
                  );
                }
                function c(Be, ot) {
                  this.imagesLoadedCb = ot;
                  var st,
                    vt = Be.length;
                  for (st = 0; st < vt; st += 1)
                    Be[st].layers ||
                      (!Be[st].t || Be[st].t === "seq"
                        ? ((this.totalImages += 1),
                          this.images.push(this._createImageData(Be[st])))
                        : Be[st].t === 3 &&
                          ((this.totalFootages += 1),
                          this.images.push(this.createFootageData(Be[st]))));
                }
                function u(Be) {
                  this.path = Be || "";
                }
                function p(Be) {
                  this.assetsPath = Be || "";
                }
                function N(Be) {
                  for (var ot = 0, st = this.images.length; ot < st; ) {
                    if (this.images[ot].assetData === Be)
                      return this.images[ot].img;
                    ot += 1;
                  }
                  return null;
                }
                function P() {
                  (this.imagesLoadedCb = null), (this.images.length = 0);
                }
                function de() {
                  return this.totalImages === this.loadedAssets;
                }
                function me() {
                  return this.totalFootages === this.loadedFootagesCount;
                }
                function Ye(Be, ot) {
                  Be === "svg"
                    ? ((this._elementHelper = ot),
                      (this._createImageData = this.createImageData.bind(this)))
                    : (this._createImageData = this.createImgData.bind(this));
                }
                function nt() {
                  (this._imageLoaded = e.bind(this)),
                    (this._footageLoaded = t.bind(this)),
                    (this.testImageLoaded = s.bind(this)),
                    (this.createFootageData = l.bind(this)),
                    (this.assetsPath = ""),
                    (this.path = ""),
                    (this.totalImages = 0),
                    (this.totalFootages = 0),
                    (this.loadedAssets = 0),
                    (this.loadedFootagesCount = 0),
                    (this.imagesLoadedCb = null),
                    (this.images = []);
                }
                return (
                  (nt.prototype = {
                    loadAssets: c,
                    setAssetsPath: p,
                    setPath: u,
                    loadedImages: de,
                    loadedFootages: me,
                    destroy: P,
                    getAsset: N,
                    createImgData: a,
                    createImageData: o,
                    imageLoaded: e,
                    footageLoaded: t,
                    setCacheType: Ye,
                  }),
                  nt
                );
              })();
            function BaseEvent() {}
            BaseEvent.prototype = {
              triggerEvent: function (e, t) {
                if (this._cbs[e])
                  for (var r = this._cbs[e], s = 0; s < r.length; s += 1)
                    r[s](t);
              },
              addEventListener: function (e, t) {
                return (
                  this._cbs[e] || (this._cbs[e] = []),
                  this._cbs[e].push(t),
                  function () {
                    this.removeEventListener(e, t);
                  }.bind(this)
                );
              },
              removeEventListener: function (e, t) {
                if (!t) this._cbs[e] = null;
                else if (this._cbs[e]) {
                  for (var r = 0, s = this._cbs[e].length; r < s; )
                    this._cbs[e][r] === t &&
                      (this._cbs[e].splice(r, 1), (r -= 1), (s -= 1)),
                      (r += 1);
                  this._cbs[e].length || (this._cbs[e] = null);
                }
              },
            };
            var markerParser = (function () {
                function n(e) {
                  for (
                    var t = e.split(`\r
`),
                      r = {},
                      s,
                      o = 0,
                      a = 0;
                    a < t.length;
                    a += 1
                  )
                    (s = t[a].split(":")),
                      s.length === 2 && ((r[s[0]] = s[1].trim()), (o += 1));
                  if (o === 0) throw new Error();
                  return r;
                }
                return function (e) {
                  for (var t = [], r = 0; r < e.length; r += 1) {
                    var s = e[r],
                      o = { time: s.tm, duration: s.dr };
                    try {
                      o.payload = JSON.parse(e[r].cm);
                    } catch {
                      try {
                        o.payload = n(e[r].cm);
                      } catch {
                        o.payload = { name: e[r].cm };
                      }
                    }
                    t.push(o);
                  }
                  return t;
                };
              })(),
              ProjectInterface = (function () {
                function n(e) {
                  this.compositions.push(e);
                }
                return function () {
                  function e(t) {
                    for (var r = 0, s = this.compositions.length; r < s; ) {
                      if (
                        this.compositions[r].data &&
                        this.compositions[r].data.nm === t
                      )
                        return (
                          this.compositions[r].prepareFrame &&
                            this.compositions[r].data.xt &&
                            this.compositions[r].prepareFrame(
                              this.currentFrame
                            ),
                          this.compositions[r].compInterface
                        );
                      r += 1;
                    }
                    return null;
                  }
                  return (
                    (e.compositions = []),
                    (e.currentFrame = 0),
                    (e.registerComposition = n),
                    e
                  );
                };
              })(),
              renderers = {},
              registerRenderer = function (e, t) {
                renderers[e] = t;
              };
            function getRenderer(n) {
              return renderers[n];
            }
            function getRegisteredRenderer() {
              if (renderers.canvas) return "canvas";
              for (var n in renderers) if (renderers[n]) return n;
              return "";
            }
            function _typeof$4(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof$4 =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof$4(n)
              );
            }
            var AnimationItem = function () {
              (this._cbs = []),
                (this.name = ""),
                (this.path = ""),
                (this.isLoaded = !1),
                (this.currentFrame = 0),
                (this.currentRawFrame = 0),
                (this.firstFrame = 0),
                (this.totalFrames = 0),
                (this.frameRate = 0),
                (this.frameMult = 0),
                (this.playSpeed = 1),
                (this.playDirection = 1),
                (this.playCount = 0),
                (this.animationData = {}),
                (this.assets = []),
                (this.isPaused = !0),
                (this.autoplay = !1),
                (this.loop = !0),
                (this.renderer = null),
                (this.animationID = createElementID()),
                (this.assetsPath = ""),
                (this.timeCompleted = 0),
                (this.segmentPos = 0),
                (this.isSubframeEnabled = getSubframeEnabled()),
                (this.segments = []),
                (this._idle = !0),
                (this._completedLoop = !1),
                (this.projectInterface = ProjectInterface()),
                (this.imagePreloader = new ImagePreloader()),
                (this.audioController = audioControllerFactory()),
                (this.markers = []),
                (this.configAnimation = this.configAnimation.bind(this)),
                (this.onSetupError = this.onSetupError.bind(this)),
                (this.onSegmentComplete = this.onSegmentComplete.bind(this)),
                (this.drawnFrameEvent = new BMEnterFrameEvent(
                  "drawnFrame",
                  0,
                  0,
                  0
                )),
                (this.expressionsPlugin = getExpressionsPlugin());
            };
            extendPrototype([BaseEvent], AnimationItem),
              (AnimationItem.prototype.setParams = function (n) {
                (n.wrapper || n.container) &&
                  (this.wrapper = n.wrapper || n.container);
                var e = "svg";
                n.animType ? (e = n.animType) : n.renderer && (e = n.renderer);
                var t = getRenderer(e);
                (this.renderer = new t(this, n.rendererSettings)),
                  this.imagePreloader.setCacheType(
                    e,
                    this.renderer.globalData.defs
                  ),
                  this.renderer.setProjectInterface(this.projectInterface),
                  (this.animType = e),
                  n.loop === "" ||
                  n.loop === null ||
                  n.loop === void 0 ||
                  n.loop === !0
                    ? (this.loop = !0)
                    : n.loop === !1
                    ? (this.loop = !1)
                    : (this.loop = parseInt(n.loop, 10)),
                  (this.autoplay = "autoplay" in n ? n.autoplay : !0),
                  (this.name = n.name ? n.name : ""),
                  (this.autoloadSegments = Object.prototype.hasOwnProperty.call(
                    n,
                    "autoloadSegments"
                  )
                    ? n.autoloadSegments
                    : !0),
                  (this.assetsPath = n.assetsPath),
                  (this.initialSegment = n.initialSegment),
                  n.audioFactory &&
                    this.audioController.setAudioFactory(n.audioFactory),
                  n.animationData
                    ? this.setupAnimation(n.animationData)
                    : n.path &&
                      (n.path.lastIndexOf("\\") !== -1
                        ? (this.path = n.path.substr(
                            0,
                            n.path.lastIndexOf("\\") + 1
                          ))
                        : (this.path = n.path.substr(
                            0,
                            n.path.lastIndexOf("/") + 1
                          )),
                      (this.fileName = n.path.substr(
                        n.path.lastIndexOf("/") + 1
                      )),
                      (this.fileName = this.fileName.substr(
                        0,
                        this.fileName.lastIndexOf(".json")
                      )),
                      dataManager.loadAnimation(
                        n.path,
                        this.configAnimation,
                        this.onSetupError
                      ));
              }),
              (AnimationItem.prototype.onSetupError = function () {
                this.trigger("data_failed");
              }),
              (AnimationItem.prototype.setupAnimation = function (n) {
                dataManager.completeAnimation(n, this.configAnimation);
              }),
              (AnimationItem.prototype.setData = function (n, e) {
                e && _typeof$4(e) !== "object" && (e = JSON.parse(e));
                var t = { wrapper: n, animationData: e },
                  r = n.attributes;
                (t.path = r.getNamedItem("data-animation-path")
                  ? r.getNamedItem("data-animation-path").value
                  : r.getNamedItem("data-bm-path")
                  ? r.getNamedItem("data-bm-path").value
                  : r.getNamedItem("bm-path")
                  ? r.getNamedItem("bm-path").value
                  : ""),
                  (t.animType = r.getNamedItem("data-anim-type")
                    ? r.getNamedItem("data-anim-type").value
                    : r.getNamedItem("data-bm-type")
                    ? r.getNamedItem("data-bm-type").value
                    : r.getNamedItem("bm-type")
                    ? r.getNamedItem("bm-type").value
                    : r.getNamedItem("data-bm-renderer")
                    ? r.getNamedItem("data-bm-renderer").value
                    : r.getNamedItem("bm-renderer")
                    ? r.getNamedItem("bm-renderer").value
                    : getRegisteredRenderer() || "canvas");
                var s = r.getNamedItem("data-anim-loop")
                  ? r.getNamedItem("data-anim-loop").value
                  : r.getNamedItem("data-bm-loop")
                  ? r.getNamedItem("data-bm-loop").value
                  : r.getNamedItem("bm-loop")
                  ? r.getNamedItem("bm-loop").value
                  : "";
                s === "false"
                  ? (t.loop = !1)
                  : s === "true"
                  ? (t.loop = !0)
                  : s !== "" && (t.loop = parseInt(s, 10));
                var o = r.getNamedItem("data-anim-autoplay")
                  ? r.getNamedItem("data-anim-autoplay").value
                  : r.getNamedItem("data-bm-autoplay")
                  ? r.getNamedItem("data-bm-autoplay").value
                  : r.getNamedItem("bm-autoplay")
                  ? r.getNamedItem("bm-autoplay").value
                  : !0;
                (t.autoplay = o !== "false"),
                  (t.name = r.getNamedItem("data-name")
                    ? r.getNamedItem("data-name").value
                    : r.getNamedItem("data-bm-name")
                    ? r.getNamedItem("data-bm-name").value
                    : r.getNamedItem("bm-name")
                    ? r.getNamedItem("bm-name").value
                    : "");
                var a = r.getNamedItem("data-anim-prerender")
                  ? r.getNamedItem("data-anim-prerender").value
                  : r.getNamedItem("data-bm-prerender")
                  ? r.getNamedItem("data-bm-prerender").value
                  : r.getNamedItem("bm-prerender")
                  ? r.getNamedItem("bm-prerender").value
                  : "";
                a === "false" && (t.prerender = !1),
                  t.path ? this.setParams(t) : this.trigger("destroy");
              }),
              (AnimationItem.prototype.includeLayers = function (n) {
                n.op > this.animationData.op &&
                  ((this.animationData.op = n.op),
                  (this.totalFrames = Math.floor(
                    n.op - this.animationData.ip
                  )));
                var e = this.animationData.layers,
                  t,
                  r = e.length,
                  s = n.layers,
                  o,
                  a = s.length;
                for (o = 0; o < a; o += 1)
                  for (t = 0; t < r; ) {
                    if (e[t].id === s[o].id) {
                      e[t] = s[o];
                      break;
                    }
                    t += 1;
                  }
                if (
                  ((n.chars || n.fonts) &&
                    (this.renderer.globalData.fontManager.addChars(n.chars),
                    this.renderer.globalData.fontManager.addFonts(
                      n.fonts,
                      this.renderer.globalData.defs
                    )),
                  n.assets)
                )
                  for (r = n.assets.length, t = 0; t < r; t += 1)
                    this.animationData.assets.push(n.assets[t]);
                (this.animationData.__complete = !1),
                  dataManager.completeAnimation(
                    this.animationData,
                    this.onSegmentComplete
                  );
              }),
              (AnimationItem.prototype.onSegmentComplete = function (n) {
                this.animationData = n;
                var e = getExpressionsPlugin();
                e && e.initExpressions(this), this.loadNextSegment();
              }),
              (AnimationItem.prototype.loadNextSegment = function () {
                var n = this.animationData.segments;
                if (!n || n.length === 0 || !this.autoloadSegments) {
                  this.trigger("data_ready"),
                    (this.timeCompleted = this.totalFrames);
                  return;
                }
                var e = n.shift();
                this.timeCompleted = e.time * this.frameRate;
                var t =
                  this.path + this.fileName + "_" + this.segmentPos + ".json";
                (this.segmentPos += 1),
                  dataManager.loadData(
                    t,
                    this.includeLayers.bind(this),
                    function () {
                      this.trigger("data_failed");
                    }.bind(this)
                  );
              }),
              (AnimationItem.prototype.loadSegments = function () {
                var n = this.animationData.segments;
                n || (this.timeCompleted = this.totalFrames),
                  this.loadNextSegment();
              }),
              (AnimationItem.prototype.imagesLoaded = function () {
                this.trigger("loaded_images"), this.checkLoaded();
              }),
              (AnimationItem.prototype.preloadImages = function () {
                this.imagePreloader.setAssetsPath(this.assetsPath),
                  this.imagePreloader.setPath(this.path),
                  this.imagePreloader.loadAssets(
                    this.animationData.assets,
                    this.imagesLoaded.bind(this)
                  );
              }),
              (AnimationItem.prototype.configAnimation = function (n) {
                if (this.renderer)
                  try {
                    (this.animationData = n),
                      this.initialSegment
                        ? ((this.totalFrames = Math.floor(
                            this.initialSegment[1] - this.initialSegment[0]
                          )),
                          (this.firstFrame = Math.round(
                            this.initialSegment[0]
                          )))
                        : ((this.totalFrames = Math.floor(
                            this.animationData.op - this.animationData.ip
                          )),
                          (this.firstFrame = Math.round(
                            this.animationData.ip
                          ))),
                      this.renderer.configAnimation(n),
                      n.assets || (n.assets = []),
                      (this.assets = this.animationData.assets),
                      (this.frameRate = this.animationData.fr),
                      (this.frameMult = this.animationData.fr / 1e3),
                      this.renderer.searchExtraCompositions(n.assets),
                      (this.markers = markerParser(n.markers || [])),
                      this.trigger("config_ready"),
                      this.preloadImages(),
                      this.loadSegments(),
                      this.updaFrameModifier(),
                      this.waitForFontsLoaded(),
                      this.isPaused && this.audioController.pause();
                  } catch (e) {
                    this.triggerConfigError(e);
                  }
              }),
              (AnimationItem.prototype.waitForFontsLoaded = function () {
                this.renderer &&
                  (this.renderer.globalData.fontManager.isLoaded
                    ? this.checkLoaded()
                    : setTimeout(this.waitForFontsLoaded.bind(this), 20));
              }),
              (AnimationItem.prototype.checkLoaded = function () {
                if (
                  !this.isLoaded &&
                  this.renderer.globalData.fontManager.isLoaded &&
                  (this.imagePreloader.loadedImages() ||
                    this.renderer.rendererType !== "canvas") &&
                  this.imagePreloader.loadedFootages()
                ) {
                  this.isLoaded = !0;
                  var n = getExpressionsPlugin();
                  n && n.initExpressions(this),
                    this.renderer.initItems(),
                    setTimeout(
                      function () {
                        this.trigger("DOMLoaded");
                      }.bind(this),
                      0
                    ),
                    this.gotoFrame(),
                    this.autoplay && this.play();
                }
              }),
              (AnimationItem.prototype.resize = function (n, e) {
                var t = typeof n == "number" ? n : void 0,
                  r = typeof e == "number" ? e : void 0;
                this.renderer.updateContainerSize(t, r);
              }),
              (AnimationItem.prototype.setSubframe = function (n) {
                this.isSubframeEnabled = !!n;
              }),
              (AnimationItem.prototype.gotoFrame = function () {
                (this.currentFrame = this.isSubframeEnabled
                  ? this.currentRawFrame
                  : ~~this.currentRawFrame),
                  this.timeCompleted !== this.totalFrames &&
                    this.currentFrame > this.timeCompleted &&
                    (this.currentFrame = this.timeCompleted),
                  this.trigger("enterFrame"),
                  this.renderFrame(),
                  this.trigger("drawnFrame");
              }),
              (AnimationItem.prototype.renderFrame = function () {
                if (!(this.isLoaded === !1 || !this.renderer))
                  try {
                    this.expressionsPlugin &&
                      this.expressionsPlugin.resetFrame(),
                      this.renderer.renderFrame(
                        this.currentFrame + this.firstFrame
                      );
                  } catch (n) {
                    this.triggerRenderFrameError(n);
                  }
              }),
              (AnimationItem.prototype.play = function (n) {
                (n && this.name !== n) ||
                  (this.isPaused === !0 &&
                    ((this.isPaused = !1),
                    this.trigger("_play"),
                    this.audioController.resume(),
                    this._idle &&
                      ((this._idle = !1), this.trigger("_active"))));
              }),
              (AnimationItem.prototype.pause = function (n) {
                (n && this.name !== n) ||
                  (this.isPaused === !1 &&
                    ((this.isPaused = !0),
                    this.trigger("_pause"),
                    (this._idle = !0),
                    this.trigger("_idle"),
                    this.audioController.pause()));
              }),
              (AnimationItem.prototype.togglePause = function (n) {
                (n && this.name !== n) ||
                  (this.isPaused === !0 ? this.play() : this.pause());
              }),
              (AnimationItem.prototype.stop = function (n) {
                (n && this.name !== n) ||
                  (this.pause(),
                  (this.playCount = 0),
                  (this._completedLoop = !1),
                  this.setCurrentRawFrameValue(0));
              }),
              (AnimationItem.prototype.getMarkerData = function (n) {
                for (var e, t = 0; t < this.markers.length; t += 1)
                  if (
                    ((e = this.markers[t]), e.payload && e.payload.name === n)
                  )
                    return e;
                return null;
              }),
              (AnimationItem.prototype.goToAndStop = function (n, e, t) {
                if (!(t && this.name !== t)) {
                  var r = Number(n);
                  if (isNaN(r)) {
                    var s = this.getMarkerData(n);
                    s && this.goToAndStop(s.time, !0);
                  } else
                    e
                      ? this.setCurrentRawFrameValue(n)
                      : this.setCurrentRawFrameValue(n * this.frameModifier);
                  this.pause();
                }
              }),
              (AnimationItem.prototype.goToAndPlay = function (n, e, t) {
                if (!(t && this.name !== t)) {
                  var r = Number(n);
                  if (isNaN(r)) {
                    var s = this.getMarkerData(n);
                    s &&
                      (s.duration
                        ? this.playSegments([s.time, s.time + s.duration], !0)
                        : this.goToAndStop(s.time, !0));
                  } else this.goToAndStop(r, e, t);
                  this.play();
                }
              }),
              (AnimationItem.prototype.advanceTime = function (n) {
                if (!(this.isPaused === !0 || this.isLoaded === !1)) {
                  var e = this.currentRawFrame + n * this.frameModifier,
                    t = !1;
                  e >= this.totalFrames - 1 && this.frameModifier > 0
                    ? !this.loop || this.playCount === this.loop
                      ? this.checkSegments(
                          e > this.totalFrames ? e % this.totalFrames : 0
                        ) || ((t = !0), (e = this.totalFrames - 1))
                      : e >= this.totalFrames
                      ? ((this.playCount += 1),
                        this.checkSegments(e % this.totalFrames) ||
                          (this.setCurrentRawFrameValue(e % this.totalFrames),
                          (this._completedLoop = !0),
                          this.trigger("loopComplete")))
                      : this.setCurrentRawFrameValue(e)
                    : e < 0
                    ? this.checkSegments(e % this.totalFrames) ||
                      (this.loop && !(this.playCount-- <= 0 && this.loop !== !0)
                        ? (this.setCurrentRawFrameValue(
                            this.totalFrames + (e % this.totalFrames)
                          ),
                          this._completedLoop
                            ? this.trigger("loopComplete")
                            : (this._completedLoop = !0))
                        : ((t = !0), (e = 0)))
                    : this.setCurrentRawFrameValue(e),
                    t &&
                      (this.setCurrentRawFrameValue(e),
                      this.pause(),
                      this.trigger("complete"));
                }
              }),
              (AnimationItem.prototype.adjustSegment = function (n, e) {
                (this.playCount = 0),
                  n[1] < n[0]
                    ? (this.frameModifier > 0 &&
                        (this.playSpeed < 0
                          ? this.setSpeed(-this.playSpeed)
                          : this.setDirection(-1)),
                      (this.totalFrames = n[0] - n[1]),
                      (this.timeCompleted = this.totalFrames),
                      (this.firstFrame = n[1]),
                      this.setCurrentRawFrameValue(
                        this.totalFrames - 0.001 - e
                      ))
                    : n[1] > n[0] &&
                      (this.frameModifier < 0 &&
                        (this.playSpeed < 0
                          ? this.setSpeed(-this.playSpeed)
                          : this.setDirection(1)),
                      (this.totalFrames = n[1] - n[0]),
                      (this.timeCompleted = this.totalFrames),
                      (this.firstFrame = n[0]),
                      this.setCurrentRawFrameValue(0.001 + e)),
                  this.trigger("segmentStart");
              }),
              (AnimationItem.prototype.setSegment = function (n, e) {
                var t = -1;
                this.isPaused &&
                  (this.currentRawFrame + this.firstFrame < n
                    ? (t = n)
                    : this.currentRawFrame + this.firstFrame > e &&
                      (t = e - n)),
                  (this.firstFrame = n),
                  (this.totalFrames = e - n),
                  (this.timeCompleted = this.totalFrames),
                  t !== -1 && this.goToAndStop(t, !0);
              }),
              (AnimationItem.prototype.playSegments = function (n, e) {
                if (
                  (e && (this.segments.length = 0),
                  _typeof$4(n[0]) === "object")
                ) {
                  var t,
                    r = n.length;
                  for (t = 0; t < r; t += 1) this.segments.push(n[t]);
                } else this.segments.push(n);
                this.segments.length &&
                  e &&
                  this.adjustSegment(this.segments.shift(), 0),
                  this.isPaused && this.play();
              }),
              (AnimationItem.prototype.resetSegments = function (n) {
                (this.segments.length = 0),
                  this.segments.push([
                    this.animationData.ip,
                    this.animationData.op,
                  ]),
                  n && this.checkSegments(0);
              }),
              (AnimationItem.prototype.checkSegments = function (n) {
                return this.segments.length
                  ? (this.adjustSegment(this.segments.shift(), n), !0)
                  : !1;
              }),
              (AnimationItem.prototype.destroy = function (n) {
                (n && this.name !== n) ||
                  !this.renderer ||
                  (this.renderer.destroy(),
                  this.imagePreloader.destroy(),
                  this.trigger("destroy"),
                  (this._cbs = null),
                  (this.onEnterFrame = null),
                  (this.onLoopComplete = null),
                  (this.onComplete = null),
                  (this.onSegmentStart = null),
                  (this.onDestroy = null),
                  (this.renderer = null),
                  (this.expressionsPlugin = null),
                  (this.imagePreloader = null),
                  (this.projectInterface = null));
              }),
              (AnimationItem.prototype.setCurrentRawFrameValue = function (n) {
                (this.currentRawFrame = n), this.gotoFrame();
              }),
              (AnimationItem.prototype.setSpeed = function (n) {
                (this.playSpeed = n), this.updaFrameModifier();
              }),
              (AnimationItem.prototype.setDirection = function (n) {
                (this.playDirection = n < 0 ? -1 : 1), this.updaFrameModifier();
              }),
              (AnimationItem.prototype.setLoop = function (n) {
                this.loop = n;
              }),
              (AnimationItem.prototype.setVolume = function (n, e) {
                (e && this.name !== e) || this.audioController.setVolume(n);
              }),
              (AnimationItem.prototype.getVolume = function () {
                return this.audioController.getVolume();
              }),
              (AnimationItem.prototype.mute = function (n) {
                (n && this.name !== n) || this.audioController.mute();
              }),
              (AnimationItem.prototype.unmute = function (n) {
                (n && this.name !== n) || this.audioController.unmute();
              }),
              (AnimationItem.prototype.updaFrameModifier = function () {
                (this.frameModifier =
                  this.frameMult * this.playSpeed * this.playDirection),
                  this.audioController.setRate(
                    this.playSpeed * this.playDirection
                  );
              }),
              (AnimationItem.prototype.getPath = function () {
                return this.path;
              }),
              (AnimationItem.prototype.getAssetsPath = function (n) {
                var e = "";
                if (n.e) e = n.p;
                else if (this.assetsPath) {
                  var t = n.p;
                  t.indexOf("images/") !== -1 && (t = t.split("/")[1]),
                    (e = this.assetsPath + t);
                } else (e = this.path), (e += n.u ? n.u : ""), (e += n.p);
                return e;
              }),
              (AnimationItem.prototype.getAssetData = function (n) {
                for (var e = 0, t = this.assets.length; e < t; ) {
                  if (n === this.assets[e].id) return this.assets[e];
                  e += 1;
                }
                return null;
              }),
              (AnimationItem.prototype.hide = function () {
                this.renderer.hide();
              }),
              (AnimationItem.prototype.show = function () {
                this.renderer.show();
              }),
              (AnimationItem.prototype.getDuration = function (n) {
                return n ? this.totalFrames : this.totalFrames / this.frameRate;
              }),
              (AnimationItem.prototype.updateDocumentData = function (n, e, t) {
                try {
                  var r = this.renderer.getElementByPath(n);
                  r.updateDocumentData(e, t);
                } catch {}
              }),
              (AnimationItem.prototype.trigger = function (n) {
                if (this._cbs && this._cbs[n])
                  switch (n) {
                    case "enterFrame":
                      this.triggerEvent(
                        n,
                        new BMEnterFrameEvent(
                          n,
                          this.currentFrame,
                          this.totalFrames,
                          this.frameModifier
                        )
                      );
                      break;
                    case "drawnFrame":
                      (this.drawnFrameEvent.currentTime = this.currentFrame),
                        (this.drawnFrameEvent.totalTime = this.totalFrames),
                        (this.drawnFrameEvent.direction = this.frameModifier),
                        this.triggerEvent(n, this.drawnFrameEvent);
                      break;
                    case "loopComplete":
                      this.triggerEvent(
                        n,
                        new BMCompleteLoopEvent(
                          n,
                          this.loop,
                          this.playCount,
                          this.frameMult
                        )
                      );
                      break;
                    case "complete":
                      this.triggerEvent(
                        n,
                        new BMCompleteEvent(n, this.frameMult)
                      );
                      break;
                    case "segmentStart":
                      this.triggerEvent(
                        n,
                        new BMSegmentStartEvent(
                          n,
                          this.firstFrame,
                          this.totalFrames
                        )
                      );
                      break;
                    case "destroy":
                      this.triggerEvent(n, new BMDestroyEvent(n, this));
                      break;
                    default:
                      this.triggerEvent(n);
                  }
                n === "enterFrame" &&
                  this.onEnterFrame &&
                  this.onEnterFrame.call(
                    this,
                    new BMEnterFrameEvent(
                      n,
                      this.currentFrame,
                      this.totalFrames,
                      this.frameMult
                    )
                  ),
                  n === "loopComplete" &&
                    this.onLoopComplete &&
                    this.onLoopComplete.call(
                      this,
                      new BMCompleteLoopEvent(
                        n,
                        this.loop,
                        this.playCount,
                        this.frameMult
                      )
                    ),
                  n === "complete" &&
                    this.onComplete &&
                    this.onComplete.call(
                      this,
                      new BMCompleteEvent(n, this.frameMult)
                    ),
                  n === "segmentStart" &&
                    this.onSegmentStart &&
                    this.onSegmentStart.call(
                      this,
                      new BMSegmentStartEvent(
                        n,
                        this.firstFrame,
                        this.totalFrames
                      )
                    ),
                  n === "destroy" &&
                    this.onDestroy &&
                    this.onDestroy.call(this, new BMDestroyEvent(n, this));
              }),
              (AnimationItem.prototype.triggerRenderFrameError = function (n) {
                var e = new BMRenderFrameErrorEvent(n, this.currentFrame);
                this.triggerEvent("error", e),
                  this.onError && this.onError.call(this, e);
              }),
              (AnimationItem.prototype.triggerConfigError = function (n) {
                var e = new BMConfigErrorEvent(n, this.currentFrame);
                this.triggerEvent("error", e),
                  this.onError && this.onError.call(this, e);
              });
            var animationManager = (function () {
                var n = {},
                  e = [],
                  t = 0,
                  r = 0,
                  s = 0,
                  o = !0,
                  a = !1;
                function l(Ft) {
                  for (var Bt = 0, Mt = Ft.target; Bt < r; )
                    e[Bt].animation === Mt &&
                      (e.splice(Bt, 1),
                      (Bt -= 1),
                      (r -= 1),
                      Mt.isPaused || N()),
                      (Bt += 1);
                }
                function c(Ft, Bt) {
                  if (!Ft) return null;
                  for (var Mt = 0; Mt < r; ) {
                    if (e[Mt].elem === Ft && e[Mt].elem !== null)
                      return e[Mt].animation;
                    Mt += 1;
                  }
                  var Pt = new AnimationItem();
                  return P(Pt, Ft), Pt.setData(Ft, Bt), Pt;
                }
                function u() {
                  var Ft,
                    Bt = e.length,
                    Mt = [];
                  for (Ft = 0; Ft < Bt; Ft += 1) Mt.push(e[Ft].animation);
                  return Mt;
                }
                function p() {
                  (s += 1), Ct();
                }
                function N() {
                  s -= 1;
                }
                function P(Ft, Bt) {
                  Ft.addEventListener("destroy", l),
                    Ft.addEventListener("_active", p),
                    Ft.addEventListener("_idle", N),
                    e.push({ elem: Bt, animation: Ft }),
                    (r += 1);
                }
                function de(Ft) {
                  var Bt = new AnimationItem();
                  return P(Bt, null), Bt.setParams(Ft), Bt;
                }
                function me(Ft, Bt) {
                  var Mt;
                  for (Mt = 0; Mt < r; Mt += 1)
                    e[Mt].animation.setSpeed(Ft, Bt);
                }
                function Ye(Ft, Bt) {
                  var Mt;
                  for (Mt = 0; Mt < r; Mt += 1)
                    e[Mt].animation.setDirection(Ft, Bt);
                }
                function nt(Ft) {
                  var Bt;
                  for (Bt = 0; Bt < r; Bt += 1) e[Bt].animation.play(Ft);
                }
                function Be(Ft) {
                  var Bt = Ft - t,
                    Mt;
                  for (Mt = 0; Mt < r; Mt += 1) e[Mt].animation.advanceTime(Bt);
                  (t = Ft),
                    s && !a ? window.requestAnimationFrame(Be) : (o = !0);
                }
                function ot(Ft) {
                  (t = Ft), window.requestAnimationFrame(Be);
                }
                function st(Ft) {
                  var Bt;
                  for (Bt = 0; Bt < r; Bt += 1) e[Bt].animation.pause(Ft);
                }
                function vt(Ft, Bt, Mt) {
                  var Pt;
                  for (Pt = 0; Pt < r; Pt += 1)
                    e[Pt].animation.goToAndStop(Ft, Bt, Mt);
                }
                function xt(Ft) {
                  var Bt;
                  for (Bt = 0; Bt < r; Bt += 1) e[Bt].animation.stop(Ft);
                }
                function St(Ft) {
                  var Bt;
                  for (Bt = 0; Bt < r; Bt += 1) e[Bt].animation.togglePause(Ft);
                }
                function wt(Ft) {
                  var Bt;
                  for (Bt = r - 1; Bt >= 0; Bt -= 1)
                    e[Bt].animation.destroy(Ft);
                }
                function bt(Ft, Bt, Mt) {
                  var Pt = [].concat(
                      [].slice.call(document.getElementsByClassName("lottie")),
                      [].slice.call(
                        document.getElementsByClassName("bodymovin")
                      )
                    ),
                    It,
                    Ot = Pt.length;
                  for (It = 0; It < Ot; It += 1)
                    Mt && Pt[It].setAttribute("data-bm-type", Mt),
                      c(Pt[It], Ft);
                  if (Bt && Ot === 0) {
                    Mt || (Mt = "svg");
                    var Xt = document.getElementsByTagName("body")[0];
                    Xt.innerText = "";
                    var sn = createTag("div");
                    (sn.style.width = "100%"),
                      (sn.style.height = "100%"),
                      sn.setAttribute("data-bm-type", Mt),
                      Xt.appendChild(sn),
                      c(sn, Ft);
                  }
                }
                function Tt() {
                  var Ft;
                  for (Ft = 0; Ft < r; Ft += 1) e[Ft].animation.resize();
                }
                function Ct() {
                  !a && s && o && (window.requestAnimationFrame(ot), (o = !1));
                }
                function kt() {
                  a = !0;
                }
                function Dt() {
                  (a = !1), Ct();
                }
                function Vt(Ft, Bt) {
                  var Mt;
                  for (Mt = 0; Mt < r; Mt += 1)
                    e[Mt].animation.setVolume(Ft, Bt);
                }
                function Ht(Ft) {
                  var Bt;
                  for (Bt = 0; Bt < r; Bt += 1) e[Bt].animation.mute(Ft);
                }
                function qt(Ft) {
                  var Bt;
                  for (Bt = 0; Bt < r; Bt += 1) e[Bt].animation.unmute(Ft);
                }
                return (
                  (n.registerAnimation = c),
                  (n.loadAnimation = de),
                  (n.setSpeed = me),
                  (n.setDirection = Ye),
                  (n.play = nt),
                  (n.pause = st),
                  (n.stop = xt),
                  (n.togglePause = St),
                  (n.searchAnimations = bt),
                  (n.resize = Tt),
                  (n.goToAndStop = vt),
                  (n.destroy = wt),
                  (n.freeze = kt),
                  (n.unfreeze = Dt),
                  (n.setVolume = Vt),
                  (n.mute = Ht),
                  (n.unmute = qt),
                  (n.getRegisteredAnimations = u),
                  n
                );
              })(),
              BezierFactory = (function () {
                var n = {};
                n.getBezierEasing = t;
                var e = {};
                function t(ot, st, vt, xt, St) {
                  var wt =
                    St ||
                    ("bez_" + ot + "_" + st + "_" + vt + "_" + xt).replace(
                      /\./g,
                      "p"
                    );
                  if (e[wt]) return e[wt];
                  var bt = new Be([ot, st, vt, xt]);
                  return (e[wt] = bt), bt;
                }
                var r = 4,
                  s = 0.001,
                  o = 1e-7,
                  a = 10,
                  l = 11,
                  c = 1 / (l - 1),
                  u = typeof Float32Array == "function";
                function p(ot, st) {
                  return 1 - 3 * st + 3 * ot;
                }
                function N(ot, st) {
                  return 3 * st - 6 * ot;
                }
                function P(ot) {
                  return 3 * ot;
                }
                function de(ot, st, vt) {
                  return ((p(st, vt) * ot + N(st, vt)) * ot + P(st)) * ot;
                }
                function me(ot, st, vt) {
                  return 3 * p(st, vt) * ot * ot + 2 * N(st, vt) * ot + P(st);
                }
                function Ye(ot, st, vt, xt, St) {
                  var wt,
                    bt,
                    Tt = 0;
                  do
                    (bt = st + (vt - st) / 2),
                      (wt = de(bt, xt, St) - ot),
                      wt > 0 ? (vt = bt) : (st = bt);
                  while (Math.abs(wt) > o && ++Tt < a);
                  return bt;
                }
                function nt(ot, st, vt, xt) {
                  for (var St = 0; St < r; ++St) {
                    var wt = me(st, vt, xt);
                    if (wt === 0) return st;
                    var bt = de(st, vt, xt) - ot;
                    st -= bt / wt;
                  }
                  return st;
                }
                function Be(ot) {
                  (this._p = ot),
                    (this._mSampleValues = u
                      ? new Float32Array(l)
                      : new Array(l)),
                    (this._precomputed = !1),
                    (this.get = this.get.bind(this));
                }
                return (
                  (Be.prototype = {
                    get: function (st) {
                      var vt = this._p[0],
                        xt = this._p[1],
                        St = this._p[2],
                        wt = this._p[3];
                      return (
                        this._precomputed || this._precompute(),
                        vt === xt && St === wt
                          ? st
                          : st === 0
                          ? 0
                          : st === 1
                          ? 1
                          : de(this._getTForX(st), xt, wt)
                      );
                    },
                    _precompute: function () {
                      var st = this._p[0],
                        vt = this._p[1],
                        xt = this._p[2],
                        St = this._p[3];
                      (this._precomputed = !0),
                        (st !== vt || xt !== St) && this._calcSampleValues();
                    },
                    _calcSampleValues: function () {
                      for (
                        var st = this._p[0], vt = this._p[2], xt = 0;
                        xt < l;
                        ++xt
                      )
                        this._mSampleValues[xt] = de(xt * c, st, vt);
                    },
                    _getTForX: function (st) {
                      for (
                        var vt = this._p[0],
                          xt = this._p[2],
                          St = this._mSampleValues,
                          wt = 0,
                          bt = 1,
                          Tt = l - 1;
                        bt !== Tt && St[bt] <= st;
                        ++bt
                      )
                        wt += c;
                      --bt;
                      var Ct = (st - St[bt]) / (St[bt + 1] - St[bt]),
                        kt = wt + Ct * c,
                        Dt = me(kt, vt, xt);
                      return Dt >= s
                        ? nt(st, kt, vt, xt)
                        : Dt === 0
                        ? kt
                        : Ye(st, wt, wt + c, vt, xt);
                    },
                  }),
                  n
                );
              })(),
              pooling = (function () {
                function n(e) {
                  return e.concat(createSizedArray(e.length));
                }
                return { double: n };
              })(),
              poolFactory = (function () {
                return function (n, e, t) {
                  var r = 0,
                    s = n,
                    o = createSizedArray(s),
                    a = { newElement: l, release: c };
                  function l() {
                    var u;
                    return r ? ((r -= 1), (u = o[r])) : (u = e()), u;
                  }
                  function c(u) {
                    r === s && ((o = pooling.double(o)), (s *= 2)),
                      t && t(u),
                      (o[r] = u),
                      (r += 1);
                  }
                  return a;
                };
              })(),
              bezierLengthPool = (function () {
                function n() {
                  return {
                    addedLength: 0,
                    percents: createTypedArray(
                      "float32",
                      getDefaultCurveSegments()
                    ),
                    lengths: createTypedArray(
                      "float32",
                      getDefaultCurveSegments()
                    ),
                  };
                }
                return poolFactory(8, n);
              })(),
              segmentsLengthPool = (function () {
                function n() {
                  return { lengths: [], totalLength: 0 };
                }
                function e(t) {
                  var r,
                    s = t.lengths.length;
                  for (r = 0; r < s; r += 1)
                    bezierLengthPool.release(t.lengths[r]);
                  t.lengths.length = 0;
                }
                return poolFactory(8, n, e);
              })();
            function bezFunction() {
              var n = Math;
              function e(P, de, me, Ye, nt, Be) {
                var ot =
                  P * Ye + de * nt + me * Be - nt * Ye - Be * P - me * de;
                return ot > -0.001 && ot < 0.001;
              }
              function t(P, de, me, Ye, nt, Be, ot, st, vt) {
                if (me === 0 && Be === 0 && vt === 0)
                  return e(P, de, Ye, nt, ot, st);
                var xt = n.sqrt(
                    n.pow(Ye - P, 2) + n.pow(nt - de, 2) + n.pow(Be - me, 2)
                  ),
                  St = n.sqrt(
                    n.pow(ot - P, 2) + n.pow(st - de, 2) + n.pow(vt - me, 2)
                  ),
                  wt = n.sqrt(
                    n.pow(ot - Ye, 2) + n.pow(st - nt, 2) + n.pow(vt - Be, 2)
                  ),
                  bt;
                return (
                  xt > St
                    ? xt > wt
                      ? (bt = xt - St - wt)
                      : (bt = wt - St - xt)
                    : wt > St
                    ? (bt = wt - St - xt)
                    : (bt = St - xt - wt),
                  bt > -1e-4 && bt < 1e-4
                );
              }
              var r = (function () {
                return function (P, de, me, Ye) {
                  var nt = getDefaultCurveSegments(),
                    Be,
                    ot,
                    st,
                    vt,
                    xt,
                    St = 0,
                    wt,
                    bt = [],
                    Tt = [],
                    Ct = bezierLengthPool.newElement();
                  for (st = me.length, Be = 0; Be < nt; Be += 1) {
                    for (xt = Be / (nt - 1), wt = 0, ot = 0; ot < st; ot += 1)
                      (vt =
                        bmPow(1 - xt, 3) * P[ot] +
                        3 * bmPow(1 - xt, 2) * xt * me[ot] +
                        3 * (1 - xt) * bmPow(xt, 2) * Ye[ot] +
                        bmPow(xt, 3) * de[ot]),
                        (bt[ot] = vt),
                        Tt[ot] !== null && (wt += bmPow(bt[ot] - Tt[ot], 2)),
                        (Tt[ot] = bt[ot]);
                    wt && ((wt = bmSqrt(wt)), (St += wt)),
                      (Ct.percents[Be] = xt),
                      (Ct.lengths[Be] = St);
                  }
                  return (Ct.addedLength = St), Ct;
                };
              })();
              function s(P) {
                var de = segmentsLengthPool.newElement(),
                  me = P.c,
                  Ye = P.v,
                  nt = P.o,
                  Be = P.i,
                  ot,
                  st = P._length,
                  vt = de.lengths,
                  xt = 0;
                for (ot = 0; ot < st - 1; ot += 1)
                  (vt[ot] = r(Ye[ot], Ye[ot + 1], nt[ot], Be[ot + 1])),
                    (xt += vt[ot].addedLength);
                return (
                  me &&
                    st &&
                    ((vt[ot] = r(Ye[ot], Ye[0], nt[ot], Be[0])),
                    (xt += vt[ot].addedLength)),
                  (de.totalLength = xt),
                  de
                );
              }
              function o(P) {
                (this.segmentLength = 0), (this.points = new Array(P));
              }
              function a(P, de) {
                (this.partialLength = P), (this.point = de);
              }
              var l = (function () {
                var P = {};
                return function (de, me, Ye, nt) {
                  var Be = (
                    de[0] +
                    "_" +
                    de[1] +
                    "_" +
                    me[0] +
                    "_" +
                    me[1] +
                    "_" +
                    Ye[0] +
                    "_" +
                    Ye[1] +
                    "_" +
                    nt[0] +
                    "_" +
                    nt[1]
                  ).replace(/\./g, "p");
                  if (!P[Be]) {
                    var ot = getDefaultCurveSegments(),
                      st,
                      vt,
                      xt,
                      St,
                      wt,
                      bt = 0,
                      Tt,
                      Ct,
                      kt = null;
                    de.length === 2 &&
                      (de[0] !== me[0] || de[1] !== me[1]) &&
                      e(
                        de[0],
                        de[1],
                        me[0],
                        me[1],
                        de[0] + Ye[0],
                        de[1] + Ye[1]
                      ) &&
                      e(
                        de[0],
                        de[1],
                        me[0],
                        me[1],
                        me[0] + nt[0],
                        me[1] + nt[1]
                      ) &&
                      (ot = 2);
                    var Dt = new o(ot);
                    for (xt = Ye.length, st = 0; st < ot; st += 1) {
                      for (
                        Ct = createSizedArray(xt),
                          wt = st / (ot - 1),
                          Tt = 0,
                          vt = 0;
                        vt < xt;
                        vt += 1
                      )
                        (St =
                          bmPow(1 - wt, 3) * de[vt] +
                          3 * bmPow(1 - wt, 2) * wt * (de[vt] + Ye[vt]) +
                          3 * (1 - wt) * bmPow(wt, 2) * (me[vt] + nt[vt]) +
                          bmPow(wt, 3) * me[vt]),
                          (Ct[vt] = St),
                          kt !== null && (Tt += bmPow(Ct[vt] - kt[vt], 2));
                      (Tt = bmSqrt(Tt)),
                        (bt += Tt),
                        (Dt.points[st] = new a(Tt, Ct)),
                        (kt = Ct);
                    }
                    (Dt.segmentLength = bt), (P[Be] = Dt);
                  }
                  return P[Be];
                };
              })();
              function c(P, de) {
                var me = de.percents,
                  Ye = de.lengths,
                  nt = me.length,
                  Be = bmFloor((nt - 1) * P),
                  ot = P * de.addedLength,
                  st = 0;
                if (Be === nt - 1 || Be === 0 || ot === Ye[Be]) return me[Be];
                for (var vt = Ye[Be] > ot ? -1 : 1, xt = !0; xt; )
                  if (
                    (Ye[Be] <= ot && Ye[Be + 1] > ot
                      ? ((st = (ot - Ye[Be]) / (Ye[Be + 1] - Ye[Be])),
                        (xt = !1))
                      : (Be += vt),
                    Be < 0 || Be >= nt - 1)
                  ) {
                    if (Be === nt - 1) return me[Be];
                    xt = !1;
                  }
                return me[Be] + (me[Be + 1] - me[Be]) * st;
              }
              function u(P, de, me, Ye, nt, Be) {
                var ot = c(nt, Be),
                  st = 1 - ot,
                  vt =
                    n.round(
                      (st * st * st * P[0] +
                        (ot * st * st + st * ot * st + st * st * ot) * me[0] +
                        (ot * ot * st + st * ot * ot + ot * st * ot) * Ye[0] +
                        ot * ot * ot * de[0]) *
                        1e3
                    ) / 1e3,
                  xt =
                    n.round(
                      (st * st * st * P[1] +
                        (ot * st * st + st * ot * st + st * st * ot) * me[1] +
                        (ot * ot * st + st * ot * ot + ot * st * ot) * Ye[1] +
                        ot * ot * ot * de[1]) *
                        1e3
                    ) / 1e3;
                return [vt, xt];
              }
              var p = createTypedArray("float32", 8);
              function N(P, de, me, Ye, nt, Be, ot) {
                nt < 0 ? (nt = 0) : nt > 1 && (nt = 1);
                var st = c(nt, ot);
                Be = Be > 1 ? 1 : Be;
                var vt = c(Be, ot),
                  xt,
                  St = P.length,
                  wt = 1 - st,
                  bt = 1 - vt,
                  Tt = wt * wt * wt,
                  Ct = st * wt * wt * 3,
                  kt = st * st * wt * 3,
                  Dt = st * st * st,
                  Vt = wt * wt * bt,
                  Ht = st * wt * bt + wt * st * bt + wt * wt * vt,
                  qt = st * st * bt + wt * st * vt + st * wt * vt,
                  Ft = st * st * vt,
                  Bt = wt * bt * bt,
                  Mt = st * bt * bt + wt * vt * bt + wt * bt * vt,
                  Pt = st * vt * bt + wt * vt * vt + st * bt * vt,
                  It = st * vt * vt,
                  Ot = bt * bt * bt,
                  Xt = vt * bt * bt + bt * vt * bt + bt * bt * vt,
                  sn = vt * vt * bt + bt * vt * vt + vt * bt * vt,
                  Kt = vt * vt * vt;
                for (xt = 0; xt < St; xt += 1)
                  (p[xt * 4] =
                    n.round(
                      (Tt * P[xt] + Ct * me[xt] + kt * Ye[xt] + Dt * de[xt]) *
                        1e3
                    ) / 1e3),
                    (p[xt * 4 + 1] =
                      n.round(
                        (Vt * P[xt] + Ht * me[xt] + qt * Ye[xt] + Ft * de[xt]) *
                          1e3
                      ) / 1e3),
                    (p[xt * 4 + 2] =
                      n.round(
                        (Bt * P[xt] + Mt * me[xt] + Pt * Ye[xt] + It * de[xt]) *
                          1e3
                      ) / 1e3),
                    (p[xt * 4 + 3] =
                      n.round(
                        (Ot * P[xt] + Xt * me[xt] + sn * Ye[xt] + Kt * de[xt]) *
                          1e3
                      ) / 1e3);
                return p;
              }
              return {
                getSegmentsLength: s,
                getNewSegment: N,
                getPointInSegment: u,
                buildBezierData: l,
                pointOnLine2D: e,
                pointOnLine3D: t,
              };
            }
            var bez = bezFunction(),
              initFrame = initialDefaultFrame,
              mathAbs = Math.abs;
            function interpolateValue(n, e) {
              var t = this.offsetTime,
                r;
              this.propType === "multidimensional" &&
                (r = createTypedArray("float32", this.pv.length));
              for (
                var s = e.lastIndex,
                  o = s,
                  a = this.keyframes.length - 1,
                  l = !0,
                  c,
                  u,
                  p;
                l;

              ) {
                if (
                  ((c = this.keyframes[o]),
                  (u = this.keyframes[o + 1]),
                  o === a - 1 && n >= u.t - t)
                ) {
                  c.h && (c = u), (s = 0);
                  break;
                }
                if (u.t - t > n) {
                  s = o;
                  break;
                }
                o < a - 1 ? (o += 1) : ((s = 0), (l = !1));
              }
              p = this.keyframesMetadata[o] || {};
              var N,
                P,
                de,
                me,
                Ye,
                nt,
                Be = u.t - t,
                ot = c.t - t,
                st;
              if (c.to) {
                p.bezierData ||
                  (p.bezierData = bez.buildBezierData(
                    c.s,
                    u.s || c.e,
                    c.to,
                    c.ti
                  ));
                var vt = p.bezierData;
                if (n >= Be || n < ot) {
                  var xt = n >= Be ? vt.points.length - 1 : 0;
                  for (P = vt.points[xt].point.length, N = 0; N < P; N += 1)
                    r[N] = vt.points[xt].point[N];
                } else {
                  p.__fnct
                    ? (nt = p.__fnct)
                    : ((nt = BezierFactory.getBezierEasing(
                        c.o.x,
                        c.o.y,
                        c.i.x,
                        c.i.y,
                        c.n
                      ).get),
                      (p.__fnct = nt)),
                    (de = nt((n - ot) / (Be - ot)));
                  var St = vt.segmentLength * de,
                    wt,
                    bt =
                      e.lastFrame < n && e._lastKeyframeIndex === o
                        ? e._lastAddedLength
                        : 0;
                  for (
                    Ye =
                      e.lastFrame < n && e._lastKeyframeIndex === o
                        ? e._lastPoint
                        : 0,
                      l = !0,
                      me = vt.points.length;
                    l;

                  ) {
                    if (
                      ((bt += vt.points[Ye].partialLength),
                      St === 0 || de === 0 || Ye === vt.points.length - 1)
                    ) {
                      for (P = vt.points[Ye].point.length, N = 0; N < P; N += 1)
                        r[N] = vt.points[Ye].point[N];
                      break;
                    } else if (
                      St >= bt &&
                      St < bt + vt.points[Ye + 1].partialLength
                    ) {
                      for (
                        wt = (St - bt) / vt.points[Ye + 1].partialLength,
                          P = vt.points[Ye].point.length,
                          N = 0;
                        N < P;
                        N += 1
                      )
                        r[N] =
                          vt.points[Ye].point[N] +
                          (vt.points[Ye + 1].point[N] -
                            vt.points[Ye].point[N]) *
                            wt;
                      break;
                    }
                    Ye < me - 1 ? (Ye += 1) : (l = !1);
                  }
                  (e._lastPoint = Ye),
                    (e._lastAddedLength = bt - vt.points[Ye].partialLength),
                    (e._lastKeyframeIndex = o);
                }
              } else {
                var Tt, Ct, kt, Dt, Vt;
                if (((a = c.s.length), (st = u.s || c.e), this.sh && c.h !== 1))
                  if (n >= Be) (r[0] = st[0]), (r[1] = st[1]), (r[2] = st[2]);
                  else if (n <= ot)
                    (r[0] = c.s[0]), (r[1] = c.s[1]), (r[2] = c.s[2]);
                  else {
                    var Ht = createQuaternion(c.s),
                      qt = createQuaternion(st),
                      Ft = (n - ot) / (Be - ot);
                    quaternionToEuler(r, slerp(Ht, qt, Ft));
                  }
                else
                  for (o = 0; o < a; o += 1)
                    c.h !== 1 &&
                      (n >= Be
                        ? (de = 1)
                        : n < ot
                        ? (de = 0)
                        : (c.o.x.constructor === Array
                            ? (p.__fnct || (p.__fnct = []),
                              p.__fnct[o]
                                ? (nt = p.__fnct[o])
                                : ((Tt =
                                    c.o.x[o] === void 0 ? c.o.x[0] : c.o.x[o]),
                                  (Ct =
                                    c.o.y[o] === void 0 ? c.o.y[0] : c.o.y[o]),
                                  (kt =
                                    c.i.x[o] === void 0 ? c.i.x[0] : c.i.x[o]),
                                  (Dt =
                                    c.i.y[o] === void 0 ? c.i.y[0] : c.i.y[o]),
                                  (nt = BezierFactory.getBezierEasing(
                                    Tt,
                                    Ct,
                                    kt,
                                    Dt
                                  ).get),
                                  (p.__fnct[o] = nt)))
                            : p.__fnct
                            ? (nt = p.__fnct)
                            : ((Tt = c.o.x),
                              (Ct = c.o.y),
                              (kt = c.i.x),
                              (Dt = c.i.y),
                              (nt = BezierFactory.getBezierEasing(
                                Tt,
                                Ct,
                                kt,
                                Dt
                              ).get),
                              (c.keyframeMetadata = nt)),
                          (de = nt((n - ot) / (Be - ot))))),
                      (st = u.s || c.e),
                      (Vt =
                        c.h === 1 ? c.s[o] : c.s[o] + (st[o] - c.s[o]) * de),
                      this.propType === "multidimensional"
                        ? (r[o] = Vt)
                        : (r = Vt);
              }
              return (e.lastIndex = s), r;
            }
            function slerp(n, e, t) {
              var r = [],
                s = n[0],
                o = n[1],
                a = n[2],
                l = n[3],
                c = e[0],
                u = e[1],
                p = e[2],
                N = e[3],
                P,
                de,
                me,
                Ye,
                nt;
              return (
                (de = s * c + o * u + a * p + l * N),
                de < 0 && ((de = -de), (c = -c), (u = -u), (p = -p), (N = -N)),
                1 - de > 1e-6
                  ? ((P = Math.acos(de)),
                    (me = Math.sin(P)),
                    (Ye = Math.sin((1 - t) * P) / me),
                    (nt = Math.sin(t * P) / me))
                  : ((Ye = 1 - t), (nt = t)),
                (r[0] = Ye * s + nt * c),
                (r[1] = Ye * o + nt * u),
                (r[2] = Ye * a + nt * p),
                (r[3] = Ye * l + nt * N),
                r
              );
            }
            function quaternionToEuler(n, e) {
              var t = e[0],
                r = e[1],
                s = e[2],
                o = e[3],
                a = Math.atan2(
                  2 * r * o - 2 * t * s,
                  1 - 2 * r * r - 2 * s * s
                ),
                l = Math.asin(2 * t * r + 2 * s * o),
                c = Math.atan2(
                  2 * t * o - 2 * r * s,
                  1 - 2 * t * t - 2 * s * s
                );
              (n[0] = a / degToRads),
                (n[1] = l / degToRads),
                (n[2] = c / degToRads);
            }
            function createQuaternion(n) {
              var e = n[0] * degToRads,
                t = n[1] * degToRads,
                r = n[2] * degToRads,
                s = Math.cos(e / 2),
                o = Math.cos(t / 2),
                a = Math.cos(r / 2),
                l = Math.sin(e / 2),
                c = Math.sin(t / 2),
                u = Math.sin(r / 2),
                p = s * o * a - l * c * u,
                N = l * c * a + s * o * u,
                P = l * o * a + s * c * u,
                de = s * c * a - l * o * u;
              return [N, P, de, p];
            }
            function getValueAtCurrentTime() {
              var n = this.comp.renderedFrame - this.offsetTime,
                e = this.keyframes[0].t - this.offsetTime,
                t =
                  this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
              if (
                !(
                  n === this._caching.lastFrame ||
                  (this._caching.lastFrame !== initFrame &&
                    ((this._caching.lastFrame >= t && n >= t) ||
                      (this._caching.lastFrame < e && n < e)))
                )
              ) {
                this._caching.lastFrame >= n &&
                  ((this._caching._lastKeyframeIndex = -1),
                  (this._caching.lastIndex = 0));
                var r = this.interpolateValue(n, this._caching);
                this.pv = r;
              }
              return (this._caching.lastFrame = n), this.pv;
            }
            function setVValue(n) {
              var e;
              if (this.propType === "unidimensional")
                (e = n * this.mult),
                  mathAbs(this.v - e) > 1e-5 &&
                    ((this.v = e), (this._mdf = !0));
              else
                for (var t = 0, r = this.v.length; t < r; )
                  (e = n[t] * this.mult),
                    mathAbs(this.v[t] - e) > 1e-5 &&
                      ((this.v[t] = e), (this._mdf = !0)),
                    (t += 1);
            }
            function processEffectsSequence() {
              if (
                !(
                  this.elem.globalData.frameId === this.frameId ||
                  !this.effectsSequence.length
                )
              ) {
                if (this.lock) {
                  this.setVValue(this.pv);
                  return;
                }
                (this.lock = !0), (this._mdf = this._isFirstFrame);
                var n,
                  e = this.effectsSequence.length,
                  t = this.kf ? this.pv : this.data.k;
                for (n = 0; n < e; n += 1) t = this.effectsSequence[n](t);
                this.setVValue(t),
                  (this._isFirstFrame = !1),
                  (this.lock = !1),
                  (this.frameId = this.elem.globalData.frameId);
              }
            }
            function addEffect(n) {
              this.effectsSequence.push(n),
                this.container.addDynamicProperty(this);
            }
            function ValueProperty(n, e, t, r) {
              (this.propType = "unidimensional"),
                (this.mult = t || 1),
                (this.data = e),
                (this.v = t ? e.k * t : e.k),
                (this.pv = e.k),
                (this._mdf = !1),
                (this.elem = n),
                (this.container = r),
                (this.comp = n.comp),
                (this.k = !1),
                (this.kf = !1),
                (this.vel = 0),
                (this.effectsSequence = []),
                (this._isFirstFrame = !0),
                (this.getValue = processEffectsSequence),
                (this.setVValue = setVValue),
                (this.addEffect = addEffect);
            }
            function MultiDimensionalProperty(n, e, t, r) {
              (this.propType = "multidimensional"),
                (this.mult = t || 1),
                (this.data = e),
                (this._mdf = !1),
                (this.elem = n),
                (this.container = r),
                (this.comp = n.comp),
                (this.k = !1),
                (this.kf = !1),
                (this.frameId = -1);
              var s,
                o = e.k.length;
              for (
                this.v = createTypedArray("float32", o),
                  this.pv = createTypedArray("float32", o),
                  this.vel = createTypedArray("float32", o),
                  s = 0;
                s < o;
                s += 1
              )
                (this.v[s] = e.k[s] * this.mult), (this.pv[s] = e.k[s]);
              (this._isFirstFrame = !0),
                (this.effectsSequence = []),
                (this.getValue = processEffectsSequence),
                (this.setVValue = setVValue),
                (this.addEffect = addEffect);
            }
            function KeyframedValueProperty(n, e, t, r) {
              (this.propType = "unidimensional"),
                (this.keyframes = e.k),
                (this.keyframesMetadata = []),
                (this.offsetTime = n.data.st),
                (this.frameId = -1),
                (this._caching = {
                  lastFrame: initFrame,
                  lastIndex: 0,
                  value: 0,
                  _lastKeyframeIndex: -1,
                }),
                (this.k = !0),
                (this.kf = !0),
                (this.data = e),
                (this.mult = t || 1),
                (this.elem = n),
                (this.container = r),
                (this.comp = n.comp),
                (this.v = initFrame),
                (this.pv = initFrame),
                (this._isFirstFrame = !0),
                (this.getValue = processEffectsSequence),
                (this.setVValue = setVValue),
                (this.interpolateValue = interpolateValue),
                (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
                (this.addEffect = addEffect);
            }
            function KeyframedMultidimensionalProperty(n, e, t, r) {
              this.propType = "multidimensional";
              var s,
                o = e.k.length,
                a,
                l,
                c,
                u;
              for (s = 0; s < o - 1; s += 1)
                e.k[s].to &&
                  e.k[s].s &&
                  e.k[s + 1] &&
                  e.k[s + 1].s &&
                  ((a = e.k[s].s),
                  (l = e.k[s + 1].s),
                  (c = e.k[s].to),
                  (u = e.k[s].ti),
                  ((a.length === 2 &&
                    !(a[0] === l[0] && a[1] === l[1]) &&
                    bez.pointOnLine2D(
                      a[0],
                      a[1],
                      l[0],
                      l[1],
                      a[0] + c[0],
                      a[1] + c[1]
                    ) &&
                    bez.pointOnLine2D(
                      a[0],
                      a[1],
                      l[0],
                      l[1],
                      l[0] + u[0],
                      l[1] + u[1]
                    )) ||
                    (a.length === 3 &&
                      !(a[0] === l[0] && a[1] === l[1] && a[2] === l[2]) &&
                      bez.pointOnLine3D(
                        a[0],
                        a[1],
                        a[2],
                        l[0],
                        l[1],
                        l[2],
                        a[0] + c[0],
                        a[1] + c[1],
                        a[2] + c[2]
                      ) &&
                      bez.pointOnLine3D(
                        a[0],
                        a[1],
                        a[2],
                        l[0],
                        l[1],
                        l[2],
                        l[0] + u[0],
                        l[1] + u[1],
                        l[2] + u[2]
                      ))) &&
                    ((e.k[s].to = null), (e.k[s].ti = null)),
                  a[0] === l[0] &&
                    a[1] === l[1] &&
                    c[0] === 0 &&
                    c[1] === 0 &&
                    u[0] === 0 &&
                    u[1] === 0 &&
                    (a.length === 2 ||
                      (a[2] === l[2] && c[2] === 0 && u[2] === 0)) &&
                    ((e.k[s].to = null), (e.k[s].ti = null)));
              (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
                (this.data = e),
                (this.keyframes = e.k),
                (this.keyframesMetadata = []),
                (this.offsetTime = n.data.st),
                (this.k = !0),
                (this.kf = !0),
                (this._isFirstFrame = !0),
                (this.mult = t || 1),
                (this.elem = n),
                (this.container = r),
                (this.comp = n.comp),
                (this.getValue = processEffectsSequence),
                (this.setVValue = setVValue),
                (this.interpolateValue = interpolateValue),
                (this.frameId = -1);
              var p = e.k[0].s.length;
              for (
                this.v = createTypedArray("float32", p),
                  this.pv = createTypedArray("float32", p),
                  s = 0;
                s < p;
                s += 1
              )
                (this.v[s] = initFrame), (this.pv[s] = initFrame);
              (this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", p),
              }),
                (this.addEffect = addEffect);
            }
            var PropertyFactory = (function () {
              function n(t, r, s, o, a) {
                r.sid && (r = t.globalData.slotManager.getProp(r));
                var l;
                if (!r.k.length) l = new ValueProperty(t, r, o, a);
                else if (typeof r.k[0] == "number")
                  l = new MultiDimensionalProperty(t, r, o, a);
                else
                  switch (s) {
                    case 0:
                      l = new KeyframedValueProperty(t, r, o, a);
                      break;
                    case 1:
                      l = new KeyframedMultidimensionalProperty(t, r, o, a);
                      break;
                  }
                return l.effectsSequence.length && a.addDynamicProperty(l), l;
              }
              var e = { getProp: n };
              return e;
            })();
            function DynamicPropertyContainer() {}
            DynamicPropertyContainer.prototype = {
              addDynamicProperty: function (e) {
                this.dynamicProperties.indexOf(e) === -1 &&
                  (this.dynamicProperties.push(e),
                  this.container.addDynamicProperty(this),
                  (this._isAnimated = !0));
              },
              iterateDynamicProperties: function () {
                this._mdf = !1;
                var e,
                  t = this.dynamicProperties.length;
                for (e = 0; e < t; e += 1)
                  this.dynamicProperties[e].getValue(),
                    this.dynamicProperties[e]._mdf && (this._mdf = !0);
              },
              initDynamicPropertyContainer: function (e) {
                (this.container = e),
                  (this.dynamicProperties = []),
                  (this._mdf = !1),
                  (this._isAnimated = !1);
              },
            };
            var pointPool = (function () {
              function n() {
                return createTypedArray("float32", 2);
              }
              return poolFactory(8, n);
            })();
            function ShapePath() {
              (this.c = !1),
                (this._length = 0),
                (this._maxLength = 8),
                (this.v = createSizedArray(this._maxLength)),
                (this.o = createSizedArray(this._maxLength)),
                (this.i = createSizedArray(this._maxLength));
            }
            (ShapePath.prototype.setPathData = function (n, e) {
              (this.c = n), this.setLength(e);
              for (var t = 0; t < e; )
                (this.v[t] = pointPool.newElement()),
                  (this.o[t] = pointPool.newElement()),
                  (this.i[t] = pointPool.newElement()),
                  (t += 1);
            }),
              (ShapePath.prototype.setLength = function (n) {
                for (; this._maxLength < n; ) this.doubleArrayLength();
                this._length = n;
              }),
              (ShapePath.prototype.doubleArrayLength = function () {
                (this.v = this.v.concat(createSizedArray(this._maxLength))),
                  (this.i = this.i.concat(createSizedArray(this._maxLength))),
                  (this.o = this.o.concat(createSizedArray(this._maxLength))),
                  (this._maxLength *= 2);
              }),
              (ShapePath.prototype.setXYAt = function (n, e, t, r, s) {
                var o;
                switch (
                  ((this._length = Math.max(this._length, r + 1)),
                  this._length >= this._maxLength && this.doubleArrayLength(),
                  t)
                ) {
                  case "v":
                    o = this.v;
                    break;
                  case "i":
                    o = this.i;
                    break;
                  case "o":
                    o = this.o;
                    break;
                  default:
                    o = [];
                    break;
                }
                (!o[r] || (o[r] && !s)) && (o[r] = pointPool.newElement()),
                  (o[r][0] = n),
                  (o[r][1] = e);
              }),
              (ShapePath.prototype.setTripleAt = function (
                n,
                e,
                t,
                r,
                s,
                o,
                a,
                l
              ) {
                this.setXYAt(n, e, "v", a, l),
                  this.setXYAt(t, r, "o", a, l),
                  this.setXYAt(s, o, "i", a, l);
              }),
              (ShapePath.prototype.reverse = function () {
                var n = new ShapePath();
                n.setPathData(this.c, this._length);
                var e = this.v,
                  t = this.o,
                  r = this.i,
                  s = 0;
                this.c &&
                  (n.setTripleAt(
                    e[0][0],
                    e[0][1],
                    r[0][0],
                    r[0][1],
                    t[0][0],
                    t[0][1],
                    0,
                    !1
                  ),
                  (s = 1));
                var o = this._length - 1,
                  a = this._length,
                  l;
                for (l = s; l < a; l += 1)
                  n.setTripleAt(
                    e[o][0],
                    e[o][1],
                    r[o][0],
                    r[o][1],
                    t[o][0],
                    t[o][1],
                    l,
                    !1
                  ),
                    (o -= 1);
                return n;
              }),
              (ShapePath.prototype.length = function () {
                return this._length;
              });
            var shapePool = (function () {
              function n() {
                return new ShapePath();
              }
              function e(s) {
                var o = s._length,
                  a;
                for (a = 0; a < o; a += 1)
                  pointPool.release(s.v[a]),
                    pointPool.release(s.i[a]),
                    pointPool.release(s.o[a]),
                    (s.v[a] = null),
                    (s.i[a] = null),
                    (s.o[a] = null);
                (s._length = 0), (s.c = !1);
              }
              function t(s) {
                var o = r.newElement(),
                  a,
                  l = s._length === void 0 ? s.v.length : s._length;
                for (o.setLength(l), o.c = s.c, a = 0; a < l; a += 1)
                  o.setTripleAt(
                    s.v[a][0],
                    s.v[a][1],
                    s.o[a][0],
                    s.o[a][1],
                    s.i[a][0],
                    s.i[a][1],
                    a
                  );
                return o;
              }
              var r = poolFactory(4, n, e);
              return (r.clone = t), r;
            })();
            function ShapeCollection() {
              (this._length = 0),
                (this._maxLength = 4),
                (this.shapes = createSizedArray(this._maxLength));
            }
            (ShapeCollection.prototype.addShape = function (n) {
              this._length === this._maxLength &&
                ((this.shapes = this.shapes.concat(
                  createSizedArray(this._maxLength)
                )),
                (this._maxLength *= 2)),
                (this.shapes[this._length] = n),
                (this._length += 1);
            }),
              (ShapeCollection.prototype.releaseShapes = function () {
                var n;
                for (n = 0; n < this._length; n += 1)
                  shapePool.release(this.shapes[n]);
                this._length = 0;
              });
            var shapeCollectionPool = (function () {
                var n = { newShapeCollection: s, release: o },
                  e = 0,
                  t = 4,
                  r = createSizedArray(t);
                function s() {
                  var a;
                  return (
                    e ? ((e -= 1), (a = r[e])) : (a = new ShapeCollection()), a
                  );
                }
                function o(a) {
                  var l,
                    c = a._length;
                  for (l = 0; l < c; l += 1) shapePool.release(a.shapes[l]);
                  (a._length = 0),
                    e === t && ((r = pooling.double(r)), (t *= 2)),
                    (r[e] = a),
                    (e += 1);
                }
                return n;
              })(),
              ShapePropertyFactory = (function () {
                var n = -999999;
                function e(Be, ot, st) {
                  var vt = st.lastIndex,
                    xt,
                    St,
                    wt,
                    bt,
                    Tt,
                    Ct,
                    kt,
                    Dt,
                    Vt,
                    Ht = this.keyframes;
                  if (Be < Ht[0].t - this.offsetTime)
                    (xt = Ht[0].s[0]), (wt = !0), (vt = 0);
                  else if (Be >= Ht[Ht.length - 1].t - this.offsetTime)
                    (xt = Ht[Ht.length - 1].s
                      ? Ht[Ht.length - 1].s[0]
                      : Ht[Ht.length - 2].e[0]),
                      (wt = !0);
                  else {
                    for (
                      var qt = vt, Ft = Ht.length - 1, Bt = !0, Mt, Pt, It;
                      Bt &&
                      ((Mt = Ht[qt]),
                      (Pt = Ht[qt + 1]),
                      !(Pt.t - this.offsetTime > Be));

                    )
                      qt < Ft - 1 ? (qt += 1) : (Bt = !1);
                    if (
                      ((It = this.keyframesMetadata[qt] || {}),
                      (wt = Mt.h === 1),
                      (vt = qt),
                      !wt)
                    ) {
                      if (Be >= Pt.t - this.offsetTime) Dt = 1;
                      else if (Be < Mt.t - this.offsetTime) Dt = 0;
                      else {
                        var Ot;
                        It.__fnct
                          ? (Ot = It.__fnct)
                          : ((Ot = BezierFactory.getBezierEasing(
                              Mt.o.x,
                              Mt.o.y,
                              Mt.i.x,
                              Mt.i.y
                            ).get),
                            (It.__fnct = Ot)),
                          (Dt = Ot(
                            (Be - (Mt.t - this.offsetTime)) /
                              (Pt.t -
                                this.offsetTime -
                                (Mt.t - this.offsetTime))
                          ));
                      }
                      St = Pt.s ? Pt.s[0] : Mt.e[0];
                    }
                    xt = Mt.s[0];
                  }
                  for (
                    Ct = ot._length,
                      kt = xt.i[0].length,
                      st.lastIndex = vt,
                      bt = 0;
                    bt < Ct;
                    bt += 1
                  )
                    for (Tt = 0; Tt < kt; Tt += 1)
                      (Vt = wt
                        ? xt.i[bt][Tt]
                        : xt.i[bt][Tt] + (St.i[bt][Tt] - xt.i[bt][Tt]) * Dt),
                        (ot.i[bt][Tt] = Vt),
                        (Vt = wt
                          ? xt.o[bt][Tt]
                          : xt.o[bt][Tt] + (St.o[bt][Tt] - xt.o[bt][Tt]) * Dt),
                        (ot.o[bt][Tt] = Vt),
                        (Vt = wt
                          ? xt.v[bt][Tt]
                          : xt.v[bt][Tt] + (St.v[bt][Tt] - xt.v[bt][Tt]) * Dt),
                        (ot.v[bt][Tt] = Vt);
                }
                function t() {
                  var Be = this.comp.renderedFrame - this.offsetTime,
                    ot = this.keyframes[0].t - this.offsetTime,
                    st =
                      this.keyframes[this.keyframes.length - 1].t -
                      this.offsetTime,
                    vt = this._caching.lastFrame;
                  return (
                    (vt !== n &&
                      ((vt < ot && Be < ot) || (vt > st && Be > st))) ||
                      ((this._caching.lastIndex =
                        vt < Be ? this._caching.lastIndex : 0),
                      this.interpolateShape(Be, this.pv, this._caching)),
                    (this._caching.lastFrame = Be),
                    this.pv
                  );
                }
                function r() {
                  this.paths = this.localShapeCollection;
                }
                function s(Be, ot) {
                  if (Be._length !== ot._length || Be.c !== ot.c) return !1;
                  var st,
                    vt = Be._length;
                  for (st = 0; st < vt; st += 1)
                    if (
                      Be.v[st][0] !== ot.v[st][0] ||
                      Be.v[st][1] !== ot.v[st][1] ||
                      Be.o[st][0] !== ot.o[st][0] ||
                      Be.o[st][1] !== ot.o[st][1] ||
                      Be.i[st][0] !== ot.i[st][0] ||
                      Be.i[st][1] !== ot.i[st][1]
                    )
                      return !1;
                  return !0;
                }
                function o(Be) {
                  s(this.v, Be) ||
                    ((this.v = shapePool.clone(Be)),
                    this.localShapeCollection.releaseShapes(),
                    this.localShapeCollection.addShape(this.v),
                    (this._mdf = !0),
                    (this.paths = this.localShapeCollection));
                }
                function a() {
                  if (this.elem.globalData.frameId !== this.frameId) {
                    if (!this.effectsSequence.length) {
                      this._mdf = !1;
                      return;
                    }
                    if (this.lock) {
                      this.setVValue(this.pv);
                      return;
                    }
                    (this.lock = !0), (this._mdf = !1);
                    var Be;
                    this.kf
                      ? (Be = this.pv)
                      : this.data.ks
                      ? (Be = this.data.ks.k)
                      : (Be = this.data.pt.k);
                    var ot,
                      st = this.effectsSequence.length;
                    for (ot = 0; ot < st; ot += 1)
                      Be = this.effectsSequence[ot](Be);
                    this.setVValue(Be),
                      (this.lock = !1),
                      (this.frameId = this.elem.globalData.frameId);
                  }
                }
                function l(Be, ot, st) {
                  (this.propType = "shape"),
                    (this.comp = Be.comp),
                    (this.container = Be),
                    (this.elem = Be),
                    (this.data = ot),
                    (this.k = !1),
                    (this.kf = !1),
                    (this._mdf = !1);
                  var vt = st === 3 ? ot.pt.k : ot.ks.k;
                  (this.v = shapePool.clone(vt)),
                    (this.pv = shapePool.clone(this.v)),
                    (this.localShapeCollection =
                      shapeCollectionPool.newShapeCollection()),
                    (this.paths = this.localShapeCollection),
                    this.paths.addShape(this.v),
                    (this.reset = r),
                    (this.effectsSequence = []);
                }
                function c(Be) {
                  this.effectsSequence.push(Be),
                    this.container.addDynamicProperty(this);
                }
                (l.prototype.interpolateShape = e),
                  (l.prototype.getValue = a),
                  (l.prototype.setVValue = o),
                  (l.prototype.addEffect = c);
                function u(Be, ot, st) {
                  (this.propType = "shape"),
                    (this.comp = Be.comp),
                    (this.elem = Be),
                    (this.container = Be),
                    (this.offsetTime = Be.data.st),
                    (this.keyframes = st === 3 ? ot.pt.k : ot.ks.k),
                    (this.keyframesMetadata = []),
                    (this.k = !0),
                    (this.kf = !0);
                  var vt = this.keyframes[0].s[0].i.length;
                  (this.v = shapePool.newElement()),
                    this.v.setPathData(this.keyframes[0].s[0].c, vt),
                    (this.pv = shapePool.clone(this.v)),
                    (this.localShapeCollection =
                      shapeCollectionPool.newShapeCollection()),
                    (this.paths = this.localShapeCollection),
                    this.paths.addShape(this.v),
                    (this.lastFrame = n),
                    (this.reset = r),
                    (this._caching = { lastFrame: n, lastIndex: 0 }),
                    (this.effectsSequence = [t.bind(this)]);
                }
                (u.prototype.getValue = a),
                  (u.prototype.interpolateShape = e),
                  (u.prototype.setVValue = o),
                  (u.prototype.addEffect = c);
                var p = (function () {
                    var Be = roundCorner;
                    function ot(st, vt) {
                      (this.v = shapePool.newElement()),
                        this.v.setPathData(!0, 4),
                        (this.localShapeCollection =
                          shapeCollectionPool.newShapeCollection()),
                        (this.paths = this.localShapeCollection),
                        this.localShapeCollection.addShape(this.v),
                        (this.d = vt.d),
                        (this.elem = st),
                        (this.comp = st.comp),
                        (this.frameId = -1),
                        this.initDynamicPropertyContainer(st),
                        (this.p = PropertyFactory.getProp(
                          st,
                          vt.p,
                          1,
                          0,
                          this
                        )),
                        (this.s = PropertyFactory.getProp(
                          st,
                          vt.s,
                          1,
                          0,
                          this
                        )),
                        this.dynamicProperties.length
                          ? (this.k = !0)
                          : ((this.k = !1), this.convertEllToPath());
                    }
                    return (
                      (ot.prototype = {
                        reset: r,
                        getValue: function () {
                          this.elem.globalData.frameId !== this.frameId &&
                            ((this.frameId = this.elem.globalData.frameId),
                            this.iterateDynamicProperties(),
                            this._mdf && this.convertEllToPath());
                        },
                        convertEllToPath: function () {
                          var vt = this.p.v[0],
                            xt = this.p.v[1],
                            St = this.s.v[0] / 2,
                            wt = this.s.v[1] / 2,
                            bt = this.d !== 3,
                            Tt = this.v;
                          (Tt.v[0][0] = vt),
                            (Tt.v[0][1] = xt - wt),
                            (Tt.v[1][0] = bt ? vt + St : vt - St),
                            (Tt.v[1][1] = xt),
                            (Tt.v[2][0] = vt),
                            (Tt.v[2][1] = xt + wt),
                            (Tt.v[3][0] = bt ? vt - St : vt + St),
                            (Tt.v[3][1] = xt),
                            (Tt.i[0][0] = bt ? vt - St * Be : vt + St * Be),
                            (Tt.i[0][1] = xt - wt),
                            (Tt.i[1][0] = bt ? vt + St : vt - St),
                            (Tt.i[1][1] = xt - wt * Be),
                            (Tt.i[2][0] = bt ? vt + St * Be : vt - St * Be),
                            (Tt.i[2][1] = xt + wt),
                            (Tt.i[3][0] = bt ? vt - St : vt + St),
                            (Tt.i[3][1] = xt + wt * Be),
                            (Tt.o[0][0] = bt ? vt + St * Be : vt - St * Be),
                            (Tt.o[0][1] = xt - wt),
                            (Tt.o[1][0] = bt ? vt + St : vt - St),
                            (Tt.o[1][1] = xt + wt * Be),
                            (Tt.o[2][0] = bt ? vt - St * Be : vt + St * Be),
                            (Tt.o[2][1] = xt + wt),
                            (Tt.o[3][0] = bt ? vt - St : vt + St),
                            (Tt.o[3][1] = xt - wt * Be);
                        },
                      }),
                      extendPrototype([DynamicPropertyContainer], ot),
                      ot
                    );
                  })(),
                  N = (function () {
                    function Be(ot, st) {
                      (this.v = shapePool.newElement()),
                        this.v.setPathData(!0, 0),
                        (this.elem = ot),
                        (this.comp = ot.comp),
                        (this.data = st),
                        (this.frameId = -1),
                        (this.d = st.d),
                        this.initDynamicPropertyContainer(ot),
                        st.sy === 1
                          ? ((this.ir = PropertyFactory.getProp(
                              ot,
                              st.ir,
                              0,
                              0,
                              this
                            )),
                            (this.is = PropertyFactory.getProp(
                              ot,
                              st.is,
                              0,
                              0.01,
                              this
                            )),
                            (this.convertToPath = this.convertStarToPath))
                          : (this.convertToPath = this.convertPolygonToPath),
                        (this.pt = PropertyFactory.getProp(
                          ot,
                          st.pt,
                          0,
                          0,
                          this
                        )),
                        (this.p = PropertyFactory.getProp(
                          ot,
                          st.p,
                          1,
                          0,
                          this
                        )),
                        (this.r = PropertyFactory.getProp(
                          ot,
                          st.r,
                          0,
                          degToRads,
                          this
                        )),
                        (this.or = PropertyFactory.getProp(
                          ot,
                          st.or,
                          0,
                          0,
                          this
                        )),
                        (this.os = PropertyFactory.getProp(
                          ot,
                          st.os,
                          0,
                          0.01,
                          this
                        )),
                        (this.localShapeCollection =
                          shapeCollectionPool.newShapeCollection()),
                        this.localShapeCollection.addShape(this.v),
                        (this.paths = this.localShapeCollection),
                        this.dynamicProperties.length
                          ? (this.k = !0)
                          : ((this.k = !1), this.convertToPath());
                    }
                    return (
                      (Be.prototype = {
                        reset: r,
                        getValue: function () {
                          this.elem.globalData.frameId !== this.frameId &&
                            ((this.frameId = this.elem.globalData.frameId),
                            this.iterateDynamicProperties(),
                            this._mdf && this.convertToPath());
                        },
                        convertStarToPath: function () {
                          var st = Math.floor(this.pt.v) * 2,
                            vt = (Math.PI * 2) / st,
                            xt = !0,
                            St = this.or.v,
                            wt = this.ir.v,
                            bt = this.os.v,
                            Tt = this.is.v,
                            Ct = (2 * Math.PI * St) / (st * 2),
                            kt = (2 * Math.PI * wt) / (st * 2),
                            Dt,
                            Vt,
                            Ht,
                            qt,
                            Ft = -Math.PI / 2;
                          Ft += this.r.v;
                          var Bt = this.data.d === 3 ? -1 : 1;
                          for (this.v._length = 0, Dt = 0; Dt < st; Dt += 1) {
                            (Vt = xt ? St : wt),
                              (Ht = xt ? bt : Tt),
                              (qt = xt ? Ct : kt);
                            var Mt = Vt * Math.cos(Ft),
                              Pt = Vt * Math.sin(Ft),
                              It =
                                Mt === 0 && Pt === 0
                                  ? 0
                                  : Pt / Math.sqrt(Mt * Mt + Pt * Pt),
                              Ot =
                                Mt === 0 && Pt === 0
                                  ? 0
                                  : -Mt / Math.sqrt(Mt * Mt + Pt * Pt);
                            (Mt += +this.p.v[0]),
                              (Pt += +this.p.v[1]),
                              this.v.setTripleAt(
                                Mt,
                                Pt,
                                Mt - It * qt * Ht * Bt,
                                Pt - Ot * qt * Ht * Bt,
                                Mt + It * qt * Ht * Bt,
                                Pt + Ot * qt * Ht * Bt,
                                Dt,
                                !0
                              ),
                              (xt = !xt),
                              (Ft += vt * Bt);
                          }
                        },
                        convertPolygonToPath: function () {
                          var st = Math.floor(this.pt.v),
                            vt = (Math.PI * 2) / st,
                            xt = this.or.v,
                            St = this.os.v,
                            wt = (2 * Math.PI * xt) / (st * 4),
                            bt,
                            Tt = -Math.PI * 0.5,
                            Ct = this.data.d === 3 ? -1 : 1;
                          for (
                            Tt += this.r.v, this.v._length = 0, bt = 0;
                            bt < st;
                            bt += 1
                          ) {
                            var kt = xt * Math.cos(Tt),
                              Dt = xt * Math.sin(Tt),
                              Vt =
                                kt === 0 && Dt === 0
                                  ? 0
                                  : Dt / Math.sqrt(kt * kt + Dt * Dt),
                              Ht =
                                kt === 0 && Dt === 0
                                  ? 0
                                  : -kt / Math.sqrt(kt * kt + Dt * Dt);
                            (kt += +this.p.v[0]),
                              (Dt += +this.p.v[1]),
                              this.v.setTripleAt(
                                kt,
                                Dt,
                                kt - Vt * wt * St * Ct,
                                Dt - Ht * wt * St * Ct,
                                kt + Vt * wt * St * Ct,
                                Dt + Ht * wt * St * Ct,
                                bt,
                                !0
                              ),
                              (Tt += vt * Ct);
                          }
                          (this.paths.length = 0), (this.paths[0] = this.v);
                        },
                      }),
                      extendPrototype([DynamicPropertyContainer], Be),
                      Be
                    );
                  })(),
                  P = (function () {
                    function Be(ot, st) {
                      (this.v = shapePool.newElement()),
                        (this.v.c = !0),
                        (this.localShapeCollection =
                          shapeCollectionPool.newShapeCollection()),
                        this.localShapeCollection.addShape(this.v),
                        (this.paths = this.localShapeCollection),
                        (this.elem = ot),
                        (this.comp = ot.comp),
                        (this.frameId = -1),
                        (this.d = st.d),
                        this.initDynamicPropertyContainer(ot),
                        (this.p = PropertyFactory.getProp(
                          ot,
                          st.p,
                          1,
                          0,
                          this
                        )),
                        (this.s = PropertyFactory.getProp(
                          ot,
                          st.s,
                          1,
                          0,
                          this
                        )),
                        (this.r = PropertyFactory.getProp(
                          ot,
                          st.r,
                          0,
                          0,
                          this
                        )),
                        this.dynamicProperties.length
                          ? (this.k = !0)
                          : ((this.k = !1), this.convertRectToPath());
                    }
                    return (
                      (Be.prototype = {
                        convertRectToPath: function () {
                          var st = this.p.v[0],
                            vt = this.p.v[1],
                            xt = this.s.v[0] / 2,
                            St = this.s.v[1] / 2,
                            wt = bmMin(xt, St, this.r.v),
                            bt = wt * (1 - roundCorner);
                          (this.v._length = 0),
                            this.d === 2 || this.d === 1
                              ? (this.v.setTripleAt(
                                  st + xt,
                                  vt - St + wt,
                                  st + xt,
                                  vt - St + wt,
                                  st + xt,
                                  vt - St + bt,
                                  0,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  st + xt,
                                  vt + St - wt,
                                  st + xt,
                                  vt + St - bt,
                                  st + xt,
                                  vt + St - wt,
                                  1,
                                  !0
                                ),
                                wt !== 0
                                  ? (this.v.setTripleAt(
                                      st + xt - wt,
                                      vt + St,
                                      st + xt - wt,
                                      vt + St,
                                      st + xt - bt,
                                      vt + St,
                                      2,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt + wt,
                                      vt + St,
                                      st - xt + bt,
                                      vt + St,
                                      st - xt + wt,
                                      vt + St,
                                      3,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt,
                                      vt + St - wt,
                                      st - xt,
                                      vt + St - wt,
                                      st - xt,
                                      vt + St - bt,
                                      4,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt,
                                      vt - St + wt,
                                      st - xt,
                                      vt - St + bt,
                                      st - xt,
                                      vt - St + wt,
                                      5,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt + wt,
                                      vt - St,
                                      st - xt + wt,
                                      vt - St,
                                      st - xt + bt,
                                      vt - St,
                                      6,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st + xt - wt,
                                      vt - St,
                                      st + xt - bt,
                                      vt - St,
                                      st + xt - wt,
                                      vt - St,
                                      7,
                                      !0
                                    ))
                                  : (this.v.setTripleAt(
                                      st - xt,
                                      vt + St,
                                      st - xt + bt,
                                      vt + St,
                                      st - xt,
                                      vt + St,
                                      2
                                    ),
                                    this.v.setTripleAt(
                                      st - xt,
                                      vt - St,
                                      st - xt,
                                      vt - St + bt,
                                      st - xt,
                                      vt - St,
                                      3
                                    )))
                              : (this.v.setTripleAt(
                                  st + xt,
                                  vt - St + wt,
                                  st + xt,
                                  vt - St + bt,
                                  st + xt,
                                  vt - St + wt,
                                  0,
                                  !0
                                ),
                                wt !== 0
                                  ? (this.v.setTripleAt(
                                      st + xt - wt,
                                      vt - St,
                                      st + xt - wt,
                                      vt - St,
                                      st + xt - bt,
                                      vt - St,
                                      1,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt + wt,
                                      vt - St,
                                      st - xt + bt,
                                      vt - St,
                                      st - xt + wt,
                                      vt - St,
                                      2,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt,
                                      vt - St + wt,
                                      st - xt,
                                      vt - St + wt,
                                      st - xt,
                                      vt - St + bt,
                                      3,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt,
                                      vt + St - wt,
                                      st - xt,
                                      vt + St - bt,
                                      st - xt,
                                      vt + St - wt,
                                      4,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt + wt,
                                      vt + St,
                                      st - xt + wt,
                                      vt + St,
                                      st - xt + bt,
                                      vt + St,
                                      5,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st + xt - wt,
                                      vt + St,
                                      st + xt - bt,
                                      vt + St,
                                      st + xt - wt,
                                      vt + St,
                                      6,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st + xt,
                                      vt + St - wt,
                                      st + xt,
                                      vt + St - wt,
                                      st + xt,
                                      vt + St - bt,
                                      7,
                                      !0
                                    ))
                                  : (this.v.setTripleAt(
                                      st - xt,
                                      vt - St,
                                      st - xt + bt,
                                      vt - St,
                                      st - xt,
                                      vt - St,
                                      1,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st - xt,
                                      vt + St,
                                      st - xt,
                                      vt + St - bt,
                                      st - xt,
                                      vt + St,
                                      2,
                                      !0
                                    ),
                                    this.v.setTripleAt(
                                      st + xt,
                                      vt + St,
                                      st + xt - bt,
                                      vt + St,
                                      st + xt,
                                      vt + St,
                                      3,
                                      !0
                                    )));
                        },
                        getValue: function () {
                          this.elem.globalData.frameId !== this.frameId &&
                            ((this.frameId = this.elem.globalData.frameId),
                            this.iterateDynamicProperties(),
                            this._mdf && this.convertRectToPath());
                        },
                        reset: r,
                      }),
                      extendPrototype([DynamicPropertyContainer], Be),
                      Be
                    );
                  })();
                function de(Be, ot, st) {
                  var vt;
                  if (st === 3 || st === 4) {
                    var xt = st === 3 ? ot.pt : ot.ks,
                      St = xt.k;
                    St.length
                      ? (vt = new u(Be, ot, st))
                      : (vt = new l(Be, ot, st));
                  } else
                    st === 5
                      ? (vt = new P(Be, ot))
                      : st === 6
                      ? (vt = new p(Be, ot))
                      : st === 7 && (vt = new N(Be, ot));
                  return vt.k && Be.addDynamicProperty(vt), vt;
                }
                function me() {
                  return l;
                }
                function Ye() {
                  return u;
                }
                var nt = {};
                return (
                  (nt.getShapeProp = de),
                  (nt.getConstructorFunction = me),
                  (nt.getKeyframedConstructorFunction = Ye),
                  nt
                );
              })();
            /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */ var Matrix = (function () {
              var n = Math.cos,
                e = Math.sin,
                t = Math.tan,
                r = Math.round;
              function s() {
                return (
                  (this.props[0] = 1),
                  (this.props[1] = 0),
                  (this.props[2] = 0),
                  (this.props[3] = 0),
                  (this.props[4] = 0),
                  (this.props[5] = 1),
                  (this.props[6] = 0),
                  (this.props[7] = 0),
                  (this.props[8] = 0),
                  (this.props[9] = 0),
                  (this.props[10] = 1),
                  (this.props[11] = 0),
                  (this.props[12] = 0),
                  (this.props[13] = 0),
                  (this.props[14] = 0),
                  (this.props[15] = 1),
                  this
                );
              }
              function o(Mt) {
                if (Mt === 0) return this;
                var Pt = n(Mt),
                  It = e(Mt);
                return this._t(
                  Pt,
                  -It,
                  0,
                  0,
                  It,
                  Pt,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  1
                );
              }
              function a(Mt) {
                if (Mt === 0) return this;
                var Pt = n(Mt),
                  It = e(Mt);
                return this._t(
                  1,
                  0,
                  0,
                  0,
                  0,
                  Pt,
                  -It,
                  0,
                  0,
                  It,
                  Pt,
                  0,
                  0,
                  0,
                  0,
                  1
                );
              }
              function l(Mt) {
                if (Mt === 0) return this;
                var Pt = n(Mt),
                  It = e(Mt);
                return this._t(
                  Pt,
                  0,
                  It,
                  0,
                  0,
                  1,
                  0,
                  0,
                  -It,
                  0,
                  Pt,
                  0,
                  0,
                  0,
                  0,
                  1
                );
              }
              function c(Mt) {
                if (Mt === 0) return this;
                var Pt = n(Mt),
                  It = e(Mt);
                return this._t(
                  Pt,
                  -It,
                  0,
                  0,
                  It,
                  Pt,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  1
                );
              }
              function u(Mt, Pt) {
                return this._t(1, Pt, Mt, 1, 0, 0);
              }
              function p(Mt, Pt) {
                return this.shear(t(Mt), t(Pt));
              }
              function N(Mt, Pt) {
                var It = n(Pt),
                  Ot = e(Pt);
                return this._t(
                  It,
                  Ot,
                  0,
                  0,
                  -Ot,
                  It,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  1
                )
                  ._t(1, 0, 0, 0, t(Mt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                  ._t(It, -Ot, 0, 0, Ot, It, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
              }
              function P(Mt, Pt, It) {
                return (
                  !It && It !== 0 && (It = 1),
                  Mt === 1 && Pt === 1 && It === 1
                    ? this
                    : this._t(Mt, 0, 0, 0, 0, Pt, 0, 0, 0, 0, It, 0, 0, 0, 0, 1)
                );
              }
              function de(
                Mt,
                Pt,
                It,
                Ot,
                Xt,
                sn,
                Kt,
                tn,
                pn,
                _n,
                bn,
                $n,
                tr,
                ur,
                _r,
                Bn
              ) {
                return (
                  (this.props[0] = Mt),
                  (this.props[1] = Pt),
                  (this.props[2] = It),
                  (this.props[3] = Ot),
                  (this.props[4] = Xt),
                  (this.props[5] = sn),
                  (this.props[6] = Kt),
                  (this.props[7] = tn),
                  (this.props[8] = pn),
                  (this.props[9] = _n),
                  (this.props[10] = bn),
                  (this.props[11] = $n),
                  (this.props[12] = tr),
                  (this.props[13] = ur),
                  (this.props[14] = _r),
                  (this.props[15] = Bn),
                  this
                );
              }
              function me(Mt, Pt, It) {
                return (
                  (It = It || 0),
                  Mt !== 0 || Pt !== 0 || It !== 0
                    ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, Mt, Pt, It, 1)
                    : this
                );
              }
              function Ye(
                Mt,
                Pt,
                It,
                Ot,
                Xt,
                sn,
                Kt,
                tn,
                pn,
                _n,
                bn,
                $n,
                tr,
                ur,
                _r,
                Bn
              ) {
                var jt = this.props;
                if (
                  Mt === 1 &&
                  Pt === 0 &&
                  It === 0 &&
                  Ot === 0 &&
                  Xt === 0 &&
                  sn === 1 &&
                  Kt === 0 &&
                  tn === 0 &&
                  pn === 0 &&
                  _n === 0 &&
                  bn === 1 &&
                  $n === 0
                )
                  return (
                    (jt[12] = jt[12] * Mt + jt[15] * tr),
                    (jt[13] = jt[13] * sn + jt[15] * ur),
                    (jt[14] = jt[14] * bn + jt[15] * _r),
                    (jt[15] *= Bn),
                    (this._identityCalculated = !1),
                    this
                  );
                var Yn = jt[0],
                  zn = jt[1],
                  rn = jt[2],
                  In = jt[3],
                  or = jt[4],
                  Gn = jt[5],
                  Yt = jt[6],
                  Gt = jt[7],
                  hn = jt[8],
                  En = jt[9],
                  Ln = jt[10],
                  mn = jt[11],
                  Vn = jt[12],
                  Fn = jt[13],
                  nr = jt[14],
                  yr = jt[15];
                return (
                  (jt[0] = Yn * Mt + zn * Xt + rn * pn + In * tr),
                  (jt[1] = Yn * Pt + zn * sn + rn * _n + In * ur),
                  (jt[2] = Yn * It + zn * Kt + rn * bn + In * _r),
                  (jt[3] = Yn * Ot + zn * tn + rn * $n + In * Bn),
                  (jt[4] = or * Mt + Gn * Xt + Yt * pn + Gt * tr),
                  (jt[5] = or * Pt + Gn * sn + Yt * _n + Gt * ur),
                  (jt[6] = or * It + Gn * Kt + Yt * bn + Gt * _r),
                  (jt[7] = or * Ot + Gn * tn + Yt * $n + Gt * Bn),
                  (jt[8] = hn * Mt + En * Xt + Ln * pn + mn * tr),
                  (jt[9] = hn * Pt + En * sn + Ln * _n + mn * ur),
                  (jt[10] = hn * It + En * Kt + Ln * bn + mn * _r),
                  (jt[11] = hn * Ot + En * tn + Ln * $n + mn * Bn),
                  (jt[12] = Vn * Mt + Fn * Xt + nr * pn + yr * tr),
                  (jt[13] = Vn * Pt + Fn * sn + nr * _n + yr * ur),
                  (jt[14] = Vn * It + Fn * Kt + nr * bn + yr * _r),
                  (jt[15] = Vn * Ot + Fn * tn + nr * $n + yr * Bn),
                  (this._identityCalculated = !1),
                  this
                );
              }
              function nt(Mt) {
                var Pt = Mt.props;
                return this.transform(
                  Pt[0],
                  Pt[1],
                  Pt[2],
                  Pt[3],
                  Pt[4],
                  Pt[5],
                  Pt[6],
                  Pt[7],
                  Pt[8],
                  Pt[9],
                  Pt[10],
                  Pt[11],
                  Pt[12],
                  Pt[13],
                  Pt[14],
                  Pt[15]
                );
              }
              function Be() {
                return (
                  this._identityCalculated ||
                    ((this._identity = !(
                      this.props[0] !== 1 ||
                      this.props[1] !== 0 ||
                      this.props[2] !== 0 ||
                      this.props[3] !== 0 ||
                      this.props[4] !== 0 ||
                      this.props[5] !== 1 ||
                      this.props[6] !== 0 ||
                      this.props[7] !== 0 ||
                      this.props[8] !== 0 ||
                      this.props[9] !== 0 ||
                      this.props[10] !== 1 ||
                      this.props[11] !== 0 ||
                      this.props[12] !== 0 ||
                      this.props[13] !== 0 ||
                      this.props[14] !== 0 ||
                      this.props[15] !== 1
                    )),
                    (this._identityCalculated = !0)),
                  this._identity
                );
              }
              function ot(Mt) {
                for (var Pt = 0; Pt < 16; ) {
                  if (Mt.props[Pt] !== this.props[Pt]) return !1;
                  Pt += 1;
                }
                return !0;
              }
              function st(Mt) {
                var Pt;
                for (Pt = 0; Pt < 16; Pt += 1) Mt.props[Pt] = this.props[Pt];
                return Mt;
              }
              function vt(Mt) {
                var Pt;
                for (Pt = 0; Pt < 16; Pt += 1) this.props[Pt] = Mt[Pt];
              }
              function xt(Mt, Pt, It) {
                return {
                  x:
                    Mt * this.props[0] +
                    Pt * this.props[4] +
                    It * this.props[8] +
                    this.props[12],
                  y:
                    Mt * this.props[1] +
                    Pt * this.props[5] +
                    It * this.props[9] +
                    this.props[13],
                  z:
                    Mt * this.props[2] +
                    Pt * this.props[6] +
                    It * this.props[10] +
                    this.props[14],
                };
              }
              function St(Mt, Pt, It) {
                return (
                  Mt * this.props[0] +
                  Pt * this.props[4] +
                  It * this.props[8] +
                  this.props[12]
                );
              }
              function wt(Mt, Pt, It) {
                return (
                  Mt * this.props[1] +
                  Pt * this.props[5] +
                  It * this.props[9] +
                  this.props[13]
                );
              }
              function bt(Mt, Pt, It) {
                return (
                  Mt * this.props[2] +
                  Pt * this.props[6] +
                  It * this.props[10] +
                  this.props[14]
                );
              }
              function Tt() {
                var Mt =
                    this.props[0] * this.props[5] -
                    this.props[1] * this.props[4],
                  Pt = this.props[5] / Mt,
                  It = -this.props[1] / Mt,
                  Ot = -this.props[4] / Mt,
                  Xt = this.props[0] / Mt,
                  sn =
                    (this.props[4] * this.props[13] -
                      this.props[5] * this.props[12]) /
                    Mt,
                  Kt =
                    -(
                      this.props[0] * this.props[13] -
                      this.props[1] * this.props[12]
                    ) / Mt,
                  tn = new Matrix();
                return (
                  (tn.props[0] = Pt),
                  (tn.props[1] = It),
                  (tn.props[4] = Ot),
                  (tn.props[5] = Xt),
                  (tn.props[12] = sn),
                  (tn.props[13] = Kt),
                  tn
                );
              }
              function Ct(Mt) {
                var Pt = this.getInverseMatrix();
                return Pt.applyToPointArray(Mt[0], Mt[1], Mt[2] || 0);
              }
              function kt(Mt) {
                var Pt,
                  It = Mt.length,
                  Ot = [];
                for (Pt = 0; Pt < It; Pt += 1) Ot[Pt] = Ct(Mt[Pt]);
                return Ot;
              }
              function Dt(Mt, Pt, It) {
                var Ot = createTypedArray("float32", 6);
                if (this.isIdentity())
                  (Ot[0] = Mt[0]),
                    (Ot[1] = Mt[1]),
                    (Ot[2] = Pt[0]),
                    (Ot[3] = Pt[1]),
                    (Ot[4] = It[0]),
                    (Ot[5] = It[1]);
                else {
                  var Xt = this.props[0],
                    sn = this.props[1],
                    Kt = this.props[4],
                    tn = this.props[5],
                    pn = this.props[12],
                    _n = this.props[13];
                  (Ot[0] = Mt[0] * Xt + Mt[1] * Kt + pn),
                    (Ot[1] = Mt[0] * sn + Mt[1] * tn + _n),
                    (Ot[2] = Pt[0] * Xt + Pt[1] * Kt + pn),
                    (Ot[3] = Pt[0] * sn + Pt[1] * tn + _n),
                    (Ot[4] = It[0] * Xt + It[1] * Kt + pn),
                    (Ot[5] = It[0] * sn + It[1] * tn + _n);
                }
                return Ot;
              }
              function Vt(Mt, Pt, It) {
                var Ot;
                return (
                  this.isIdentity()
                    ? (Ot = [Mt, Pt, It])
                    : (Ot = [
                        Mt * this.props[0] +
                          Pt * this.props[4] +
                          It * this.props[8] +
                          this.props[12],
                        Mt * this.props[1] +
                          Pt * this.props[5] +
                          It * this.props[9] +
                          this.props[13],
                        Mt * this.props[2] +
                          Pt * this.props[6] +
                          It * this.props[10] +
                          this.props[14],
                      ]),
                  Ot
                );
              }
              function Ht(Mt, Pt) {
                if (this.isIdentity()) return Mt + "," + Pt;
                var It = this.props;
                return (
                  Math.round((Mt * It[0] + Pt * It[4] + It[12]) * 100) / 100 +
                  "," +
                  Math.round((Mt * It[1] + Pt * It[5] + It[13]) * 100) / 100
                );
              }
              function qt() {
                for (
                  var Mt = 0, Pt = this.props, It = "matrix3d(", Ot = 1e4;
                  Mt < 16;

                )
                  (It += r(Pt[Mt] * Ot) / Ot),
                    (It += Mt === 15 ? ")" : ","),
                    (Mt += 1);
                return It;
              }
              function Ft(Mt) {
                var Pt = 1e4;
                return (Mt < 1e-6 && Mt > 0) || (Mt > -1e-6 && Mt < 0)
                  ? r(Mt * Pt) / Pt
                  : Mt;
              }
              function Bt() {
                var Mt = this.props,
                  Pt = Ft(Mt[0]),
                  It = Ft(Mt[1]),
                  Ot = Ft(Mt[4]),
                  Xt = Ft(Mt[5]),
                  sn = Ft(Mt[12]),
                  Kt = Ft(Mt[13]);
                return (
                  "matrix(" +
                  Pt +
                  "," +
                  It +
                  "," +
                  Ot +
                  "," +
                  Xt +
                  "," +
                  sn +
                  "," +
                  Kt +
                  ")"
                );
              }
              return function () {
                (this.reset = s),
                  (this.rotate = o),
                  (this.rotateX = a),
                  (this.rotateY = l),
                  (this.rotateZ = c),
                  (this.skew = p),
                  (this.skewFromAxis = N),
                  (this.shear = u),
                  (this.scale = P),
                  (this.setTransform = de),
                  (this.translate = me),
                  (this.transform = Ye),
                  (this.multiply = nt),
                  (this.applyToPoint = xt),
                  (this.applyToX = St),
                  (this.applyToY = wt),
                  (this.applyToZ = bt),
                  (this.applyToPointArray = Vt),
                  (this.applyToTriplePoints = Dt),
                  (this.applyToPointStringified = Ht),
                  (this.toCSS = qt),
                  (this.to2dCSS = Bt),
                  (this.clone = st),
                  (this.cloneFromProps = vt),
                  (this.equals = ot),
                  (this.inversePoints = kt),
                  (this.inversePoint = Ct),
                  (this.getInverseMatrix = Tt),
                  (this._t = this.transform),
                  (this.isIdentity = Be),
                  (this._identity = !0),
                  (this._identityCalculated = !1),
                  (this.props = createTypedArray("float32", 16)),
                  this.reset();
              };
            })();
            function _typeof$3(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof$3 =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof$3(n)
              );
            }
            var lottie = {};
            function setLocation(n) {
              setLocationHref(n);
            }
            function searchAnimations() {
              animationManager.searchAnimations();
            }
            function setSubframeRendering(n) {
              setSubframeEnabled(n);
            }
            function setPrefix(n) {
              setIdPrefix(n);
            }
            function loadAnimation(n) {
              return animationManager.loadAnimation(n);
            }
            function setQuality(n) {
              if (typeof n == "string")
                switch (n) {
                  case "high":
                    setDefaultCurveSegments(200);
                    break;
                  default:
                  case "medium":
                    setDefaultCurveSegments(50);
                    break;
                  case "low":
                    setDefaultCurveSegments(10);
                    break;
                }
              else !isNaN(n) && n > 1 && setDefaultCurveSegments(n);
            }
            function inBrowser() {
              return typeof navigator < "u";
            }
            function installPlugin(n, e) {
              n === "expressions" && setExpressionsPlugin(e);
            }
            function getFactory(n) {
              switch (n) {
                case "propertyFactory":
                  return PropertyFactory;
                case "shapePropertyFactory":
                  return ShapePropertyFactory;
                case "matrix":
                  return Matrix;
                default:
                  return null;
              }
            }
            (lottie.play = animationManager.play),
              (lottie.pause = animationManager.pause),
              (lottie.setLocationHref = setLocation),
              (lottie.togglePause = animationManager.togglePause),
              (lottie.setSpeed = animationManager.setSpeed),
              (lottie.setDirection = animationManager.setDirection),
              (lottie.stop = animationManager.stop),
              (lottie.searchAnimations = searchAnimations),
              (lottie.registerAnimation = animationManager.registerAnimation),
              (lottie.loadAnimation = loadAnimation),
              (lottie.setSubframeRendering = setSubframeRendering),
              (lottie.resize = animationManager.resize),
              (lottie.goToAndStop = animationManager.goToAndStop),
              (lottie.destroy = animationManager.destroy),
              (lottie.setQuality = setQuality),
              (lottie.inBrowser = inBrowser),
              (lottie.installPlugin = installPlugin),
              (lottie.freeze = animationManager.freeze),
              (lottie.unfreeze = animationManager.unfreeze),
              (lottie.setVolume = animationManager.setVolume),
              (lottie.mute = animationManager.mute),
              (lottie.unmute = animationManager.unmute),
              (lottie.getRegisteredAnimations =
                animationManager.getRegisteredAnimations),
              (lottie.useWebWorker = setWebWorker),
              (lottie.setIDPrefix = setPrefix),
              (lottie.__getFactory = getFactory),
              (lottie.version = "5.13.0");
            function checkReady() {
              document.readyState === "complete" &&
                (clearInterval(readyStateCheckInterval), searchAnimations());
            }
            function getQueryVariable(n) {
              for (
                var e = queryString.split("&"), t = 0;
                t < e.length;
                t += 1
              ) {
                var r = e[t].split("=");
                if (decodeURIComponent(r[0]) == n)
                  return decodeURIComponent(r[1]);
              }
              return null;
            }
            var queryString = "";
            {
              var scripts = document.getElementsByTagName("script"),
                index = scripts.length - 1,
                myScript = scripts[index] || { src: "" };
              (queryString = myScript.src
                ? myScript.src.replace(/^[^\?]+\??/, "")
                : ""),
                getQueryVariable("renderer");
            }
            var readyStateCheckInterval = setInterval(checkReady, 100);
            try {
              _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
            } catch (n) {}
            var ShapeModifiers = (function () {
              var n = {},
                e = {};
              (n.registerModifier = t), (n.getModifier = r);
              function t(s, o) {
                e[s] || (e[s] = o);
              }
              function r(s, o, a) {
                return new e[s](o, a);
              }
              return n;
            })();
            function ShapeModifier() {}
            (ShapeModifier.prototype.initModifierProperties = function () {}),
              (ShapeModifier.prototype.addShapeToModifier = function () {}),
              (ShapeModifier.prototype.addShape = function (n) {
                if (!this.closed) {
                  n.sh.container.addDynamicProperty(n.sh);
                  var e = {
                    shape: n.sh,
                    data: n,
                    localShapeCollection:
                      shapeCollectionPool.newShapeCollection(),
                  };
                  this.shapes.push(e),
                    this.addShapeToModifier(e),
                    this._isAnimated && n.setAsAnimated();
                }
              }),
              (ShapeModifier.prototype.init = function (n, e) {
                (this.shapes = []),
                  (this.elem = n),
                  this.initDynamicPropertyContainer(n),
                  this.initModifierProperties(n, e),
                  (this.frameId = initialDefaultFrame),
                  (this.closed = !1),
                  (this.k = !1),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : this.getValue(!0);
              }),
              (ShapeModifier.prototype.processKeys = function () {
                this.elem.globalData.frameId !== this.frameId &&
                  ((this.frameId = this.elem.globalData.frameId),
                  this.iterateDynamicProperties());
              }),
              extendPrototype([DynamicPropertyContainer], ShapeModifier);
            function TrimModifier() {}
            extendPrototype([ShapeModifier], TrimModifier),
              (TrimModifier.prototype.initModifierProperties = function (n, e) {
                (this.s = PropertyFactory.getProp(n, e.s, 0, 0.01, this)),
                  (this.e = PropertyFactory.getProp(n, e.e, 0, 0.01, this)),
                  (this.o = PropertyFactory.getProp(n, e.o, 0, 0, this)),
                  (this.sValue = 0),
                  (this.eValue = 0),
                  (this.getValue = this.processKeys),
                  (this.m = e.m),
                  (this._isAnimated =
                    !!this.s.effectsSequence.length ||
                    !!this.e.effectsSequence.length ||
                    !!this.o.effectsSequence.length);
              }),
              (TrimModifier.prototype.addShapeToModifier = function (n) {
                n.pathsData = [];
              }),
              (TrimModifier.prototype.calculateShapeEdges = function (
                n,
                e,
                t,
                r,
                s
              ) {
                var o = [];
                e <= 1
                  ? o.push({ s: n, e })
                  : n >= 1
                  ? o.push({ s: n - 1, e: e - 1 })
                  : (o.push({ s: n, e: 1 }), o.push({ s: 0, e: e - 1 }));
                var a = [],
                  l,
                  c = o.length,
                  u;
                for (l = 0; l < c; l += 1)
                  if (((u = o[l]), !(u.e * s < r || u.s * s > r + t))) {
                    var p, N;
                    u.s * s <= r ? (p = 0) : (p = (u.s * s - r) / t),
                      u.e * s >= r + t ? (N = 1) : (N = (u.e * s - r) / t),
                      a.push([p, N]);
                  }
                return a.length || a.push([0, 0]), a;
              }),
              (TrimModifier.prototype.releasePathsData = function (n) {
                var e,
                  t = n.length;
                for (e = 0; e < t; e += 1) segmentsLengthPool.release(n[e]);
                return (n.length = 0), n;
              }),
              (TrimModifier.prototype.processShapes = function (n) {
                var e, t;
                if (this._mdf || n) {
                  var r = (this.o.v % 360) / 360;
                  if (
                    (r < 0 && (r += 1),
                    this.s.v > 1
                      ? (e = 1 + r)
                      : this.s.v < 0
                      ? (e = 0 + r)
                      : (e = this.s.v + r),
                    this.e.v > 1
                      ? (t = 1 + r)
                      : this.e.v < 0
                      ? (t = 0 + r)
                      : (t = this.e.v + r),
                    e > t)
                  ) {
                    var s = e;
                    (e = t), (t = s);
                  }
                  (e = Math.round(e * 1e4) * 1e-4),
                    (t = Math.round(t * 1e4) * 1e-4),
                    (this.sValue = e),
                    (this.eValue = t);
                } else (e = this.sValue), (t = this.eValue);
                var o,
                  a,
                  l = this.shapes.length,
                  c,
                  u,
                  p,
                  N,
                  P,
                  de = 0;
                if (t === e)
                  for (a = 0; a < l; a += 1)
                    this.shapes[a].localShapeCollection.releaseShapes(),
                      (this.shapes[a].shape._mdf = !0),
                      (this.shapes[a].shape.paths =
                        this.shapes[a].localShapeCollection),
                      this._mdf && (this.shapes[a].pathsData.length = 0);
                else if ((t === 1 && e === 0) || (t === 0 && e === 1)) {
                  if (this._mdf)
                    for (a = 0; a < l; a += 1)
                      (this.shapes[a].pathsData.length = 0),
                        (this.shapes[a].shape._mdf = !0);
                } else {
                  var me = [],
                    Ye,
                    nt;
                  for (a = 0; a < l; a += 1)
                    if (
                      ((Ye = this.shapes[a]),
                      !Ye.shape._mdf && !this._mdf && !n && this.m !== 2)
                    )
                      Ye.shape.paths = Ye.localShapeCollection;
                    else {
                      if (
                        ((o = Ye.shape.paths),
                        (u = o._length),
                        (P = 0),
                        !Ye.shape._mdf && Ye.pathsData.length)
                      )
                        P = Ye.totalShapeLength;
                      else {
                        for (
                          p = this.releasePathsData(Ye.pathsData), c = 0;
                          c < u;
                          c += 1
                        )
                          (N = bez.getSegmentsLength(o.shapes[c])),
                            p.push(N),
                            (P += N.totalLength);
                        (Ye.totalShapeLength = P), (Ye.pathsData = p);
                      }
                      (de += P), (Ye.shape._mdf = !0);
                    }
                  var Be = e,
                    ot = t,
                    st = 0,
                    vt;
                  for (a = l - 1; a >= 0; a -= 1)
                    if (((Ye = this.shapes[a]), Ye.shape._mdf)) {
                      for (
                        nt = Ye.localShapeCollection,
                          nt.releaseShapes(),
                          this.m === 2 && l > 1
                            ? ((vt = this.calculateShapeEdges(
                                e,
                                t,
                                Ye.totalShapeLength,
                                st,
                                de
                              )),
                              (st += Ye.totalShapeLength))
                            : (vt = [[Be, ot]]),
                          u = vt.length,
                          c = 0;
                        c < u;
                        c += 1
                      ) {
                        (Be = vt[c][0]),
                          (ot = vt[c][1]),
                          (me.length = 0),
                          ot <= 1
                            ? me.push({
                                s: Ye.totalShapeLength * Be,
                                e: Ye.totalShapeLength * ot,
                              })
                            : Be >= 1
                            ? me.push({
                                s: Ye.totalShapeLength * (Be - 1),
                                e: Ye.totalShapeLength * (ot - 1),
                              })
                            : (me.push({
                                s: Ye.totalShapeLength * Be,
                                e: Ye.totalShapeLength,
                              }),
                              me.push({
                                s: 0,
                                e: Ye.totalShapeLength * (ot - 1),
                              }));
                        var xt = this.addShapes(Ye, me[0]);
                        if (me[0].s !== me[0].e) {
                          if (me.length > 1) {
                            var St =
                              Ye.shape.paths.shapes[Ye.shape.paths._length - 1];
                            if (St.c) {
                              var wt = xt.pop();
                              this.addPaths(xt, nt),
                                (xt = this.addShapes(Ye, me[1], wt));
                            } else
                              this.addPaths(xt, nt),
                                (xt = this.addShapes(Ye, me[1]));
                          }
                          this.addPaths(xt, nt);
                        }
                      }
                      Ye.shape.paths = nt;
                    }
                }
              }),
              (TrimModifier.prototype.addPaths = function (n, e) {
                var t,
                  r = n.length;
                for (t = 0; t < r; t += 1) e.addShape(n[t]);
              }),
              (TrimModifier.prototype.addSegment = function (
                n,
                e,
                t,
                r,
                s,
                o,
                a
              ) {
                s.setXYAt(e[0], e[1], "o", o),
                  s.setXYAt(t[0], t[1], "i", o + 1),
                  a && s.setXYAt(n[0], n[1], "v", o),
                  s.setXYAt(r[0], r[1], "v", o + 1);
              }),
              (TrimModifier.prototype.addSegmentFromArray = function (
                n,
                e,
                t,
                r
              ) {
                e.setXYAt(n[1], n[5], "o", t),
                  e.setXYAt(n[2], n[6], "i", t + 1),
                  r && e.setXYAt(n[0], n[4], "v", t),
                  e.setXYAt(n[3], n[7], "v", t + 1);
              }),
              (TrimModifier.prototype.addShapes = function (n, e, t) {
                var r = n.pathsData,
                  s = n.shape.paths.shapes,
                  o,
                  a = n.shape.paths._length,
                  l,
                  c,
                  u = 0,
                  p,
                  N,
                  P,
                  de,
                  me = [],
                  Ye,
                  nt = !0;
                for (
                  t
                    ? ((N = t._length), (Ye = t._length))
                    : ((t = shapePool.newElement()), (N = 0), (Ye = 0)),
                    me.push(t),
                    o = 0;
                  o < a;
                  o += 1
                ) {
                  for (
                    P = r[o].lengths,
                      t.c = s[o].c,
                      c = s[o].c ? P.length : P.length + 1,
                      l = 1;
                    l < c;
                    l += 1
                  )
                    if (((p = P[l - 1]), u + p.addedLength < e.s))
                      (u += p.addedLength), (t.c = !1);
                    else if (u > e.e) {
                      t.c = !1;
                      break;
                    } else
                      e.s <= u && e.e >= u + p.addedLength
                        ? (this.addSegment(
                            s[o].v[l - 1],
                            s[o].o[l - 1],
                            s[o].i[l],
                            s[o].v[l],
                            t,
                            N,
                            nt
                          ),
                          (nt = !1))
                        : ((de = bez.getNewSegment(
                            s[o].v[l - 1],
                            s[o].v[l],
                            s[o].o[l - 1],
                            s[o].i[l],
                            (e.s - u) / p.addedLength,
                            (e.e - u) / p.addedLength,
                            P[l - 1]
                          )),
                          this.addSegmentFromArray(de, t, N, nt),
                          (nt = !1),
                          (t.c = !1)),
                        (u += p.addedLength),
                        (N += 1);
                  if (s[o].c && P.length) {
                    if (((p = P[l - 1]), u <= e.e)) {
                      var Be = P[l - 1].addedLength;
                      e.s <= u && e.e >= u + Be
                        ? (this.addSegment(
                            s[o].v[l - 1],
                            s[o].o[l - 1],
                            s[o].i[0],
                            s[o].v[0],
                            t,
                            N,
                            nt
                          ),
                          (nt = !1))
                        : ((de = bez.getNewSegment(
                            s[o].v[l - 1],
                            s[o].v[0],
                            s[o].o[l - 1],
                            s[o].i[0],
                            (e.s - u) / Be,
                            (e.e - u) / Be,
                            P[l - 1]
                          )),
                          this.addSegmentFromArray(de, t, N, nt),
                          (nt = !1),
                          (t.c = !1));
                    } else t.c = !1;
                    (u += p.addedLength), (N += 1);
                  }
                  if (
                    (t._length &&
                      (t.setXYAt(t.v[Ye][0], t.v[Ye][1], "i", Ye),
                      t.setXYAt(
                        t.v[t._length - 1][0],
                        t.v[t._length - 1][1],
                        "o",
                        t._length - 1
                      )),
                    u > e.e)
                  )
                    break;
                  o < a - 1 &&
                    ((t = shapePool.newElement()),
                    (nt = !0),
                    me.push(t),
                    (N = 0));
                }
                return me;
              });
            function PuckerAndBloatModifier() {}
            extendPrototype([ShapeModifier], PuckerAndBloatModifier),
              (PuckerAndBloatModifier.prototype.initModifierProperties =
                function (n, e) {
                  (this.getValue = this.processKeys),
                    (this.amount = PropertyFactory.getProp(
                      n,
                      e.a,
                      0,
                      null,
                      this
                    )),
                    (this._isAnimated = !!this.amount.effectsSequence.length);
                }),
              (PuckerAndBloatModifier.prototype.processPath = function (n, e) {
                var t = e / 100,
                  r = [0, 0],
                  s = n._length,
                  o = 0;
                for (o = 0; o < s; o += 1)
                  (r[0] += n.v[o][0]), (r[1] += n.v[o][1]);
                (r[0] /= s), (r[1] /= s);
                var a = shapePool.newElement();
                a.c = n.c;
                var l, c, u, p, N, P;
                for (o = 0; o < s; o += 1)
                  (l = n.v[o][0] + (r[0] - n.v[o][0]) * t),
                    (c = n.v[o][1] + (r[1] - n.v[o][1]) * t),
                    (u = n.o[o][0] + (r[0] - n.o[o][0]) * -t),
                    (p = n.o[o][1] + (r[1] - n.o[o][1]) * -t),
                    (N = n.i[o][0] + (r[0] - n.i[o][0]) * -t),
                    (P = n.i[o][1] + (r[1] - n.i[o][1]) * -t),
                    a.setTripleAt(l, c, u, p, N, P, o);
                return a;
              }),
              (PuckerAndBloatModifier.prototype.processShapes = function (n) {
                var e,
                  t,
                  r = this.shapes.length,
                  s,
                  o,
                  a = this.amount.v;
                if (a !== 0) {
                  var l, c;
                  for (t = 0; t < r; t += 1) {
                    if (
                      ((l = this.shapes[t]),
                      (c = l.localShapeCollection),
                      !(!l.shape._mdf && !this._mdf && !n))
                    )
                      for (
                        c.releaseShapes(),
                          l.shape._mdf = !0,
                          e = l.shape.paths.shapes,
                          o = l.shape.paths._length,
                          s = 0;
                        s < o;
                        s += 1
                      )
                        c.addShape(this.processPath(e[s], a));
                    l.shape.paths = l.localShapeCollection;
                  }
                }
                this.dynamicProperties.length || (this._mdf = !1);
              });
            var TransformPropertyFactory = (function () {
              var n = [0, 0];
              function e(c) {
                var u = this._mdf;
                this.iterateDynamicProperties(),
                  (this._mdf = this._mdf || u),
                  this.a &&
                    c.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                  this.s && c.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                  this.sk && c.skewFromAxis(-this.sk.v, this.sa.v),
                  this.r
                    ? c.rotate(-this.r.v)
                    : c
                        .rotateZ(-this.rz.v)
                        .rotateY(this.ry.v)
                        .rotateX(this.rx.v)
                        .rotateZ(-this.or.v[2])
                        .rotateY(this.or.v[1])
                        .rotateX(this.or.v[0]),
                  this.data.p.s
                    ? this.data.p.z
                      ? c.translate(this.px.v, this.py.v, -this.pz.v)
                      : c.translate(this.px.v, this.py.v, 0)
                    : c.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
              }
              function t(c) {
                if (this.elem.globalData.frameId !== this.frameId) {
                  if (
                    (this._isDirty &&
                      (this.precalculateMatrix(), (this._isDirty = !1)),
                    this.iterateDynamicProperties(),
                    this._mdf || c)
                  ) {
                    var u;
                    if (
                      (this.v.cloneFromProps(this.pre.props),
                      this.appliedTransformations < 1 &&
                        this.v.translate(
                          -this.a.v[0],
                          -this.a.v[1],
                          this.a.v[2]
                        ),
                      this.appliedTransformations < 2 &&
                        this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                      this.sk &&
                        this.appliedTransformations < 3 &&
                        this.v.skewFromAxis(-this.sk.v, this.sa.v),
                      this.r && this.appliedTransformations < 4
                        ? this.v.rotate(-this.r.v)
                        : !this.r &&
                          this.appliedTransformations < 4 &&
                          this.v
                            .rotateZ(-this.rz.v)
                            .rotateY(this.ry.v)
                            .rotateX(this.rx.v)
                            .rotateZ(-this.or.v[2])
                            .rotateY(this.or.v[1])
                            .rotateX(this.or.v[0]),
                      this.autoOriented)
                    ) {
                      var p, N;
                      if (
                        ((u = this.elem.globalData.frameRate),
                        this.p && this.p.keyframes && this.p.getValueAtTime)
                      )
                        this.p._caching.lastFrame + this.p.offsetTime <=
                        this.p.keyframes[0].t
                          ? ((p = this.p.getValueAtTime(
                              (this.p.keyframes[0].t + 0.01) / u,
                              0
                            )),
                            (N = this.p.getValueAtTime(
                              this.p.keyframes[0].t / u,
                              0
                            )))
                          : this.p._caching.lastFrame + this.p.offsetTime >=
                            this.p.keyframes[this.p.keyframes.length - 1].t
                          ? ((p = this.p.getValueAtTime(
                              this.p.keyframes[this.p.keyframes.length - 1].t /
                                u,
                              0
                            )),
                            (N = this.p.getValueAtTime(
                              (this.p.keyframes[this.p.keyframes.length - 1].t -
                                0.05) /
                                u,
                              0
                            )))
                          : ((p = this.p.pv),
                            (N = this.p.getValueAtTime(
                              (this.p._caching.lastFrame +
                                this.p.offsetTime -
                                0.01) /
                                u,
                              this.p.offsetTime
                            )));
                      else if (
                        this.px &&
                        this.px.keyframes &&
                        this.py.keyframes &&
                        this.px.getValueAtTime &&
                        this.py.getValueAtTime
                      ) {
                        (p = []), (N = []);
                        var P = this.px,
                          de = this.py;
                        P._caching.lastFrame + P.offsetTime <= P.keyframes[0].t
                          ? ((p[0] = P.getValueAtTime(
                              (P.keyframes[0].t + 0.01) / u,
                              0
                            )),
                            (p[1] = de.getValueAtTime(
                              (de.keyframes[0].t + 0.01) / u,
                              0
                            )),
                            (N[0] = P.getValueAtTime(P.keyframes[0].t / u, 0)),
                            (N[1] = de.getValueAtTime(
                              de.keyframes[0].t / u,
                              0
                            )))
                          : P._caching.lastFrame + P.offsetTime >=
                            P.keyframes[P.keyframes.length - 1].t
                          ? ((p[0] = P.getValueAtTime(
                              P.keyframes[P.keyframes.length - 1].t / u,
                              0
                            )),
                            (p[1] = de.getValueAtTime(
                              de.keyframes[de.keyframes.length - 1].t / u,
                              0
                            )),
                            (N[0] = P.getValueAtTime(
                              (P.keyframes[P.keyframes.length - 1].t - 0.01) /
                                u,
                              0
                            )),
                            (N[1] = de.getValueAtTime(
                              (de.keyframes[de.keyframes.length - 1].t - 0.01) /
                                u,
                              0
                            )))
                          : ((p = [P.pv, de.pv]),
                            (N[0] = P.getValueAtTime(
                              (P._caching.lastFrame + P.offsetTime - 0.01) / u,
                              P.offsetTime
                            )),
                            (N[1] = de.getValueAtTime(
                              (de._caching.lastFrame + de.offsetTime - 0.01) /
                                u,
                              de.offsetTime
                            )));
                      } else (N = n), (p = N);
                      this.v.rotate(-Math.atan2(p[1] - N[1], p[0] - N[0]));
                    }
                    this.data.p && this.data.p.s
                      ? this.data.p.z
                        ? this.v.translate(this.px.v, this.py.v, -this.pz.v)
                        : this.v.translate(this.px.v, this.py.v, 0)
                      : this.v.translate(
                          this.p.v[0],
                          this.p.v[1],
                          -this.p.v[2]
                        );
                  }
                  this.frameId = this.elem.globalData.frameId;
                }
              }
              function r() {
                if (
                  ((this.appliedTransformations = 0),
                  this.pre.reset(),
                  !this.a.effectsSequence.length)
                )
                  this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    (this.appliedTransformations = 1);
                else return;
                if (!this.s.effectsSequence.length)
                  this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    (this.appliedTransformations = 2);
                else return;
                if (this.sk)
                  if (
                    !this.sk.effectsSequence.length &&
                    !this.sa.effectsSequence.length
                  )
                    this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                      (this.appliedTransformations = 3);
                  else return;
                this.r
                  ? this.r.effectsSequence.length ||
                    (this.pre.rotate(-this.r.v),
                    (this.appliedTransformations = 4))
                  : !this.rz.effectsSequence.length &&
                    !this.ry.effectsSequence.length &&
                    !this.rx.effectsSequence.length &&
                    !this.or.effectsSequence.length &&
                    (this.pre
                      .rotateZ(-this.rz.v)
                      .rotateY(this.ry.v)
                      .rotateX(this.rx.v)
                      .rotateZ(-this.or.v[2])
                      .rotateY(this.or.v[1])
                      .rotateX(this.or.v[0]),
                    (this.appliedTransformations = 4));
              }
              function s() {}
              function o(c) {
                this._addDynamicProperty(c),
                  this.elem.addDynamicProperty(c),
                  (this._isDirty = !0);
              }
              function a(c, u, p) {
                if (
                  ((this.elem = c),
                  (this.frameId = -1),
                  (this.propType = "transform"),
                  (this.data = u),
                  (this.v = new Matrix()),
                  (this.pre = new Matrix()),
                  (this.appliedTransformations = 0),
                  this.initDynamicPropertyContainer(p || c),
                  u.p && u.p.s
                    ? ((this.px = PropertyFactory.getProp(
                        c,
                        u.p.x,
                        0,
                        0,
                        this
                      )),
                      (this.py = PropertyFactory.getProp(c, u.p.y, 0, 0, this)),
                      u.p.z &&
                        (this.pz = PropertyFactory.getProp(
                          c,
                          u.p.z,
                          0,
                          0,
                          this
                        )))
                    : (this.p = PropertyFactory.getProp(
                        c,
                        u.p || { k: [0, 0, 0] },
                        1,
                        0,
                        this
                      )),
                  u.rx)
                ) {
                  if (
                    ((this.rx = PropertyFactory.getProp(
                      c,
                      u.rx,
                      0,
                      degToRads,
                      this
                    )),
                    (this.ry = PropertyFactory.getProp(
                      c,
                      u.ry,
                      0,
                      degToRads,
                      this
                    )),
                    (this.rz = PropertyFactory.getProp(
                      c,
                      u.rz,
                      0,
                      degToRads,
                      this
                    )),
                    u.or.k[0].ti)
                  ) {
                    var N,
                      P = u.or.k.length;
                    for (N = 0; N < P; N += 1)
                      (u.or.k[N].to = null), (u.or.k[N].ti = null);
                  }
                  (this.or = PropertyFactory.getProp(
                    c,
                    u.or,
                    1,
                    degToRads,
                    this
                  )),
                    (this.or.sh = !0);
                } else
                  this.r = PropertyFactory.getProp(
                    c,
                    u.r || { k: 0 },
                    0,
                    degToRads,
                    this
                  );
                u.sk &&
                  ((this.sk = PropertyFactory.getProp(
                    c,
                    u.sk,
                    0,
                    degToRads,
                    this
                  )),
                  (this.sa = PropertyFactory.getProp(
                    c,
                    u.sa,
                    0,
                    degToRads,
                    this
                  ))),
                  (this.a = PropertyFactory.getProp(
                    c,
                    u.a || { k: [0, 0, 0] },
                    1,
                    0,
                    this
                  )),
                  (this.s = PropertyFactory.getProp(
                    c,
                    u.s || { k: [100, 100, 100] },
                    1,
                    0.01,
                    this
                  )),
                  u.o
                    ? (this.o = PropertyFactory.getProp(c, u.o, 0, 0.01, c))
                    : (this.o = { _mdf: !1, v: 1 }),
                  (this._isDirty = !0),
                  this.dynamicProperties.length || this.getValue(!0);
              }
              (a.prototype = {
                applyToMatrix: e,
                getValue: t,
                precalculateMatrix: r,
                autoOrient: s,
              }),
                extendPrototype([DynamicPropertyContainer], a),
                (a.prototype.addDynamicProperty = o),
                (a.prototype._addDynamicProperty =
                  DynamicPropertyContainer.prototype.addDynamicProperty);
              function l(c, u, p) {
                return new a(c, u, p);
              }
              return { getTransformProperty: l };
            })();
            function RepeaterModifier() {}
            extendPrototype([ShapeModifier], RepeaterModifier),
              (RepeaterModifier.prototype.initModifierProperties = function (
                n,
                e
              ) {
                (this.getValue = this.processKeys),
                  (this.c = PropertyFactory.getProp(n, e.c, 0, null, this)),
                  (this.o = PropertyFactory.getProp(n, e.o, 0, null, this)),
                  (this.tr = TransformPropertyFactory.getTransformProperty(
                    n,
                    e.tr,
                    this
                  )),
                  (this.so = PropertyFactory.getProp(
                    n,
                    e.tr.so,
                    0,
                    0.01,
                    this
                  )),
                  (this.eo = PropertyFactory.getProp(
                    n,
                    e.tr.eo,
                    0,
                    0.01,
                    this
                  )),
                  (this.data = e),
                  this.dynamicProperties.length || this.getValue(!0),
                  (this._isAnimated = !!this.dynamicProperties.length),
                  (this.pMatrix = new Matrix()),
                  (this.rMatrix = new Matrix()),
                  (this.sMatrix = new Matrix()),
                  (this.tMatrix = new Matrix()),
                  (this.matrix = new Matrix());
              }),
              (RepeaterModifier.prototype.applyTransforms = function (
                n,
                e,
                t,
                r,
                s,
                o
              ) {
                var a = o ? -1 : 1,
                  l = r.s.v[0] + (1 - r.s.v[0]) * (1 - s),
                  c = r.s.v[1] + (1 - r.s.v[1]) * (1 - s);
                n.translate(r.p.v[0] * a * s, r.p.v[1] * a * s, r.p.v[2]),
                  e.translate(-r.a.v[0], -r.a.v[1], r.a.v[2]),
                  e.rotate(-r.r.v * a * s),
                  e.translate(r.a.v[0], r.a.v[1], r.a.v[2]),
                  t.translate(-r.a.v[0], -r.a.v[1], r.a.v[2]),
                  t.scale(o ? 1 / l : l, o ? 1 / c : c),
                  t.translate(r.a.v[0], r.a.v[1], r.a.v[2]);
              }),
              (RepeaterModifier.prototype.init = function (n, e, t, r) {
                for (
                  this.elem = n,
                    this.arr = e,
                    this.pos = t,
                    this.elemsData = r,
                    this._currentCopies = 0,
                    this._elements = [],
                    this._groups = [],
                    this.frameId = -1,
                    this.initDynamicPropertyContainer(n),
                    this.initModifierProperties(n, e[t]);
                  t > 0;

                )
                  (t -= 1), this._elements.unshift(e[t]);
                this.dynamicProperties.length
                  ? (this.k = !0)
                  : this.getValue(!0);
              }),
              (RepeaterModifier.prototype.resetElements = function (n) {
                var e,
                  t = n.length;
                for (e = 0; e < t; e += 1)
                  (n[e]._processed = !1),
                    n[e].ty === "gr" && this.resetElements(n[e].it);
              }),
              (RepeaterModifier.prototype.cloneElements = function (n) {
                var e = JSON.parse(JSON.stringify(n));
                return this.resetElements(e), e;
              }),
              (RepeaterModifier.prototype.changeGroupRender = function (n, e) {
                var t,
                  r = n.length;
                for (t = 0; t < r; t += 1)
                  (n[t]._render = e),
                    n[t].ty === "gr" && this.changeGroupRender(n[t].it, e);
              }),
              (RepeaterModifier.prototype.processShapes = function (n) {
                var e,
                  t,
                  r,
                  s,
                  o,
                  a = !1;
                if (this._mdf || n) {
                  var l = Math.ceil(this.c.v);
                  if (this._groups.length < l) {
                    for (; this._groups.length < l; ) {
                      var c = {
                        it: this.cloneElements(this._elements),
                        ty: "gr",
                      };
                      c.it.push({
                        a: { a: 0, ix: 1, k: [0, 0] },
                        nm: "Transform",
                        o: { a: 0, ix: 7, k: 100 },
                        p: { a: 0, ix: 2, k: [0, 0] },
                        r: {
                          a: 1,
                          ix: 6,
                          k: [
                            { s: 0, e: 0, t: 0 },
                            { s: 0, e: 0, t: 1 },
                          ],
                        },
                        s: { a: 0, ix: 3, k: [100, 100] },
                        sa: { a: 0, ix: 5, k: 0 },
                        sk: { a: 0, ix: 4, k: 0 },
                        ty: "tr",
                      }),
                        this.arr.splice(0, 0, c),
                        this._groups.splice(0, 0, c),
                        (this._currentCopies += 1);
                    }
                    this.elem.reloadShapes(), (a = !0);
                  }
                  o = 0;
                  var u;
                  for (r = 0; r <= this._groups.length - 1; r += 1) {
                    if (
                      ((u = o < l),
                      (this._groups[r]._render = u),
                      this.changeGroupRender(this._groups[r].it, u),
                      !u)
                    ) {
                      var p = this.elemsData[r].it,
                        N = p[p.length - 1];
                      N.transform.op.v !== 0
                        ? ((N.transform.op._mdf = !0), (N.transform.op.v = 0))
                        : (N.transform.op._mdf = !1);
                    }
                    o += 1;
                  }
                  this._currentCopies = l;
                  var P = this.o.v,
                    de = P % 1,
                    me = P > 0 ? Math.floor(P) : Math.ceil(P),
                    Ye = this.pMatrix.props,
                    nt = this.rMatrix.props,
                    Be = this.sMatrix.props;
                  this.pMatrix.reset(),
                    this.rMatrix.reset(),
                    this.sMatrix.reset(),
                    this.tMatrix.reset(),
                    this.matrix.reset();
                  var ot = 0;
                  if (P > 0) {
                    for (; ot < me; )
                      this.applyTransforms(
                        this.pMatrix,
                        this.rMatrix,
                        this.sMatrix,
                        this.tr,
                        1,
                        !1
                      ),
                        (ot += 1);
                    de &&
                      (this.applyTransforms(
                        this.pMatrix,
                        this.rMatrix,
                        this.sMatrix,
                        this.tr,
                        de,
                        !1
                      ),
                      (ot += de));
                  } else if (P < 0) {
                    for (; ot > me; )
                      this.applyTransforms(
                        this.pMatrix,
                        this.rMatrix,
                        this.sMatrix,
                        this.tr,
                        1,
                        !0
                      ),
                        (ot -= 1);
                    de &&
                      (this.applyTransforms(
                        this.pMatrix,
                        this.rMatrix,
                        this.sMatrix,
                        this.tr,
                        -de,
                        !0
                      ),
                      (ot -= de));
                  }
                  (r = this.data.m === 1 ? 0 : this._currentCopies - 1),
                    (s = this.data.m === 1 ? 1 : -1),
                    (o = this._currentCopies);
                  for (var st, vt; o; ) {
                    if (
                      ((e = this.elemsData[r].it),
                      (t = e[e.length - 1].transform.mProps.v.props),
                      (vt = t.length),
                      (e[e.length - 1].transform.mProps._mdf = !0),
                      (e[e.length - 1].transform.op._mdf = !0),
                      (e[e.length - 1].transform.op.v =
                        this._currentCopies === 1
                          ? this.so.v
                          : this.so.v +
                            (this.eo.v - this.so.v) *
                              (r / (this._currentCopies - 1))),
                      ot !== 0)
                    ) {
                      for (
                        ((r !== 0 && s === 1) ||
                          (r !== this._currentCopies - 1 && s === -1)) &&
                          this.applyTransforms(
                            this.pMatrix,
                            this.rMatrix,
                            this.sMatrix,
                            this.tr,
                            1,
                            !1
                          ),
                          this.matrix.transform(
                            nt[0],
                            nt[1],
                            nt[2],
                            nt[3],
                            nt[4],
                            nt[5],
                            nt[6],
                            nt[7],
                            nt[8],
                            nt[9],
                            nt[10],
                            nt[11],
                            nt[12],
                            nt[13],
                            nt[14],
                            nt[15]
                          ),
                          this.matrix.transform(
                            Be[0],
                            Be[1],
                            Be[2],
                            Be[3],
                            Be[4],
                            Be[5],
                            Be[6],
                            Be[7],
                            Be[8],
                            Be[9],
                            Be[10],
                            Be[11],
                            Be[12],
                            Be[13],
                            Be[14],
                            Be[15]
                          ),
                          this.matrix.transform(
                            Ye[0],
                            Ye[1],
                            Ye[2],
                            Ye[3],
                            Ye[4],
                            Ye[5],
                            Ye[6],
                            Ye[7],
                            Ye[8],
                            Ye[9],
                            Ye[10],
                            Ye[11],
                            Ye[12],
                            Ye[13],
                            Ye[14],
                            Ye[15]
                          ),
                          st = 0;
                        st < vt;
                        st += 1
                      )
                        t[st] = this.matrix.props[st];
                      this.matrix.reset();
                    } else
                      for (this.matrix.reset(), st = 0; st < vt; st += 1)
                        t[st] = this.matrix.props[st];
                    (ot += 1), (o -= 1), (r += s);
                  }
                } else
                  for (o = this._currentCopies, r = 0, s = 1; o; )
                    (e = this.elemsData[r].it),
                      (t = e[e.length - 1].transform.mProps.v.props),
                      (e[e.length - 1].transform.mProps._mdf = !1),
                      (e[e.length - 1].transform.op._mdf = !1),
                      (o -= 1),
                      (r += s);
                return a;
              }),
              (RepeaterModifier.prototype.addShape = function () {});
            function RoundCornersModifier() {}
            extendPrototype([ShapeModifier], RoundCornersModifier),
              (RoundCornersModifier.prototype.initModifierProperties =
                function (n, e) {
                  (this.getValue = this.processKeys),
                    (this.rd = PropertyFactory.getProp(n, e.r, 0, null, this)),
                    (this._isAnimated = !!this.rd.effectsSequence.length);
                }),
              (RoundCornersModifier.prototype.processPath = function (n, e) {
                var t = shapePool.newElement();
                t.c = n.c;
                var r,
                  s = n._length,
                  o,
                  a,
                  l,
                  c,
                  u,
                  p,
                  N = 0,
                  P,
                  de,
                  me,
                  Ye,
                  nt,
                  Be;
                for (r = 0; r < s; r += 1)
                  (o = n.v[r]),
                    (l = n.o[r]),
                    (a = n.i[r]),
                    o[0] === l[0] &&
                    o[1] === l[1] &&
                    o[0] === a[0] &&
                    o[1] === a[1]
                      ? (r === 0 || r === s - 1) && !n.c
                        ? (t.setTripleAt(o[0], o[1], l[0], l[1], a[0], a[1], N),
                          (N += 1))
                        : (r === 0 ? (c = n.v[s - 1]) : (c = n.v[r - 1]),
                          (u = Math.sqrt(
                            Math.pow(o[0] - c[0], 2) + Math.pow(o[1] - c[1], 2)
                          )),
                          (p = u ? Math.min(u / 2, e) / u : 0),
                          (nt = o[0] + (c[0] - o[0]) * p),
                          (P = nt),
                          (Be = o[1] - (o[1] - c[1]) * p),
                          (de = Be),
                          (me = P - (P - o[0]) * roundCorner),
                          (Ye = de - (de - o[1]) * roundCorner),
                          t.setTripleAt(P, de, me, Ye, nt, Be, N),
                          (N += 1),
                          r === s - 1 ? (c = n.v[0]) : (c = n.v[r + 1]),
                          (u = Math.sqrt(
                            Math.pow(o[0] - c[0], 2) + Math.pow(o[1] - c[1], 2)
                          )),
                          (p = u ? Math.min(u / 2, e) / u : 0),
                          (me = o[0] + (c[0] - o[0]) * p),
                          (P = me),
                          (Ye = o[1] + (c[1] - o[1]) * p),
                          (de = Ye),
                          (nt = P - (P - o[0]) * roundCorner),
                          (Be = de - (de - o[1]) * roundCorner),
                          t.setTripleAt(P, de, me, Ye, nt, Be, N),
                          (N += 1))
                      : (t.setTripleAt(
                          n.v[r][0],
                          n.v[r][1],
                          n.o[r][0],
                          n.o[r][1],
                          n.i[r][0],
                          n.i[r][1],
                          N
                        ),
                        (N += 1));
                return t;
              }),
              (RoundCornersModifier.prototype.processShapes = function (n) {
                var e,
                  t,
                  r = this.shapes.length,
                  s,
                  o,
                  a = this.rd.v;
                if (a !== 0) {
                  var l, c;
                  for (t = 0; t < r; t += 1) {
                    if (
                      ((l = this.shapes[t]),
                      (c = l.localShapeCollection),
                      !(!l.shape._mdf && !this._mdf && !n))
                    )
                      for (
                        c.releaseShapes(),
                          l.shape._mdf = !0,
                          e = l.shape.paths.shapes,
                          o = l.shape.paths._length,
                          s = 0;
                        s < o;
                        s += 1
                      )
                        c.addShape(this.processPath(e[s], a));
                    l.shape.paths = l.localShapeCollection;
                  }
                }
                this.dynamicProperties.length || (this._mdf = !1);
              });
            function floatEqual(n, e) {
              return (
                Math.abs(n - e) * 1e5 <= Math.min(Math.abs(n), Math.abs(e))
              );
            }
            function floatZero(n) {
              return Math.abs(n) <= 1e-5;
            }
            function lerp(n, e, t) {
              return n * (1 - t) + e * t;
            }
            function lerpPoint(n, e, t) {
              return [lerp(n[0], e[0], t), lerp(n[1], e[1], t)];
            }
            function quadRoots(n, e, t) {
              if (n === 0) return [];
              var r = e * e - 4 * n * t;
              if (r < 0) return [];
              var s = -e / (2 * n);
              if (r === 0) return [s];
              var o = Math.sqrt(r) / (2 * n);
              return [s - o, s + o];
            }
            function polynomialCoefficients(n, e, t, r) {
              return [
                -n + 3 * e - 3 * t + r,
                3 * n - 6 * e + 3 * t,
                -3 * n + 3 * e,
                n,
              ];
            }
            function singlePoint(n) {
              return new PolynomialBezier(n, n, n, n, !1);
            }
            function PolynomialBezier(n, e, t, r, s) {
              s && pointEqual(n, e) && (e = lerpPoint(n, r, 1 / 3)),
                s && pointEqual(t, r) && (t = lerpPoint(n, r, 2 / 3));
              var o = polynomialCoefficients(n[0], e[0], t[0], r[0]),
                a = polynomialCoefficients(n[1], e[1], t[1], r[1]);
              (this.a = [o[0], a[0]]),
                (this.b = [o[1], a[1]]),
                (this.c = [o[2], a[2]]),
                (this.d = [o[3], a[3]]),
                (this.points = [n, e, t, r]);
            }
            (PolynomialBezier.prototype.point = function (n) {
              return [
                ((this.a[0] * n + this.b[0]) * n + this.c[0]) * n + this.d[0],
                ((this.a[1] * n + this.b[1]) * n + this.c[1]) * n + this.d[1],
              ];
            }),
              (PolynomialBezier.prototype.derivative = function (n) {
                return [
                  (3 * n * this.a[0] + 2 * this.b[0]) * n + this.c[0],
                  (3 * n * this.a[1] + 2 * this.b[1]) * n + this.c[1],
                ];
              }),
              (PolynomialBezier.prototype.tangentAngle = function (n) {
                var e = this.derivative(n);
                return Math.atan2(e[1], e[0]);
              }),
              (PolynomialBezier.prototype.normalAngle = function (n) {
                var e = this.derivative(n);
                return Math.atan2(e[0], e[1]);
              }),
              (PolynomialBezier.prototype.inflectionPoints = function () {
                var n = this.a[1] * this.b[0] - this.a[0] * this.b[1];
                if (floatZero(n)) return [];
                var e =
                    (-0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1])) /
                    n,
                  t =
                    e * e -
                    ((1 / 3) *
                      (this.b[1] * this.c[0] - this.b[0] * this.c[1])) /
                      n;
                if (t < 0) return [];
                var r = Math.sqrt(t);
                return floatZero(r)
                  ? r > 0 && r < 1
                    ? [e]
                    : []
                  : [e - r, e + r].filter(function (s) {
                      return s > 0 && s < 1;
                    });
              }),
              (PolynomialBezier.prototype.split = function (n) {
                if (n <= 0) return [singlePoint(this.points[0]), this];
                if (n >= 1)
                  return [
                    this,
                    singlePoint(this.points[this.points.length - 1]),
                  ];
                var e = lerpPoint(this.points[0], this.points[1], n),
                  t = lerpPoint(this.points[1], this.points[2], n),
                  r = lerpPoint(this.points[2], this.points[3], n),
                  s = lerpPoint(e, t, n),
                  o = lerpPoint(t, r, n),
                  a = lerpPoint(s, o, n);
                return [
                  new PolynomialBezier(this.points[0], e, s, a, !0),
                  new PolynomialBezier(a, o, r, this.points[3], !0),
                ];
              });
            function extrema(n, e) {
              var t = n.points[0][e],
                r = n.points[n.points.length - 1][e];
              if (t > r) {
                var s = r;
                (r = t), (t = s);
              }
              for (
                var o = quadRoots(3 * n.a[e], 2 * n.b[e], n.c[e]), a = 0;
                a < o.length;
                a += 1
              )
                if (o[a] > 0 && o[a] < 1) {
                  var l = n.point(o[a])[e];
                  l < t ? (t = l) : l > r && (r = l);
                }
              return { min: t, max: r };
            }
            (PolynomialBezier.prototype.bounds = function () {
              return { x: extrema(this, 0), y: extrema(this, 1) };
            }),
              (PolynomialBezier.prototype.boundingBox = function () {
                var n = this.bounds();
                return {
                  left: n.x.min,
                  right: n.x.max,
                  top: n.y.min,
                  bottom: n.y.max,
                  width: n.x.max - n.x.min,
                  height: n.y.max - n.y.min,
                  cx: (n.x.max + n.x.min) / 2,
                  cy: (n.y.max + n.y.min) / 2,
                };
              });
            function intersectData(n, e, t) {
              var r = n.boundingBox();
              return {
                cx: r.cx,
                cy: r.cy,
                width: r.width,
                height: r.height,
                bez: n,
                t: (e + t) / 2,
                t1: e,
                t2: t,
              };
            }
            function splitData(n) {
              var e = n.bez.split(0.5);
              return [
                intersectData(e[0], n.t1, n.t),
                intersectData(e[1], n.t, n.t2),
              ];
            }
            function boxIntersect(n, e) {
              return (
                Math.abs(n.cx - e.cx) * 2 < n.width + e.width &&
                Math.abs(n.cy - e.cy) * 2 < n.height + e.height
              );
            }
            function intersectsImpl(n, e, t, r, s, o) {
              if (boxIntersect(n, e)) {
                if (
                  t >= o ||
                  (n.width <= r &&
                    n.height <= r &&
                    e.width <= r &&
                    e.height <= r)
                ) {
                  s.push([n.t, e.t]);
                  return;
                }
                var a = splitData(n),
                  l = splitData(e);
                intersectsImpl(a[0], l[0], t + 1, r, s, o),
                  intersectsImpl(a[0], l[1], t + 1, r, s, o),
                  intersectsImpl(a[1], l[0], t + 1, r, s, o),
                  intersectsImpl(a[1], l[1], t + 1, r, s, o);
              }
            }
            (PolynomialBezier.prototype.intersections = function (n, e, t) {
              e === void 0 && (e = 2), t === void 0 && (t = 7);
              var r = [];
              return (
                intersectsImpl(
                  intersectData(this, 0, 1),
                  intersectData(n, 0, 1),
                  0,
                  e,
                  r,
                  t
                ),
                r
              );
            }),
              (PolynomialBezier.shapeSegment = function (n, e) {
                var t = (e + 1) % n.length();
                return new PolynomialBezier(n.v[e], n.o[e], n.i[t], n.v[t], !0);
              }),
              (PolynomialBezier.shapeSegmentInverted = function (n, e) {
                var t = (e + 1) % n.length();
                return new PolynomialBezier(n.v[t], n.i[t], n.o[e], n.v[e], !0);
              });
            function crossProduct(n, e) {
              return [
                n[1] * e[2] - n[2] * e[1],
                n[2] * e[0] - n[0] * e[2],
                n[0] * e[1] - n[1] * e[0],
              ];
            }
            function lineIntersection(n, e, t, r) {
              var s = [n[0], n[1], 1],
                o = [e[0], e[1], 1],
                a = [t[0], t[1], 1],
                l = [r[0], r[1], 1],
                c = crossProduct(crossProduct(s, o), crossProduct(a, l));
              return floatZero(c[2]) ? null : [c[0] / c[2], c[1] / c[2]];
            }
            function polarOffset(n, e, t) {
              return [n[0] + Math.cos(e) * t, n[1] - Math.sin(e) * t];
            }
            function pointDistance(n, e) {
              return Math.hypot(n[0] - e[0], n[1] - e[1]);
            }
            function pointEqual(n, e) {
              return floatEqual(n[0], e[0]) && floatEqual(n[1], e[1]);
            }
            function ZigZagModifier() {}
            extendPrototype([ShapeModifier], ZigZagModifier),
              (ZigZagModifier.prototype.initModifierProperties = function (
                n,
                e
              ) {
                (this.getValue = this.processKeys),
                  (this.amplitude = PropertyFactory.getProp(
                    n,
                    e.s,
                    0,
                    null,
                    this
                  )),
                  (this.frequency = PropertyFactory.getProp(
                    n,
                    e.r,
                    0,
                    null,
                    this
                  )),
                  (this.pointsType = PropertyFactory.getProp(
                    n,
                    e.pt,
                    0,
                    null,
                    this
                  )),
                  (this._isAnimated =
                    this.amplitude.effectsSequence.length !== 0 ||
                    this.frequency.effectsSequence.length !== 0 ||
                    this.pointsType.effectsSequence.length !== 0);
              });
            function setPoint(n, e, t, r, s, o, a) {
              var l = t - Math.PI / 2,
                c = t + Math.PI / 2,
                u = e[0] + Math.cos(t) * r * s,
                p = e[1] - Math.sin(t) * r * s;
              n.setTripleAt(
                u,
                p,
                u + Math.cos(l) * o,
                p - Math.sin(l) * o,
                u + Math.cos(c) * a,
                p - Math.sin(c) * a,
                n.length()
              );
            }
            function getPerpendicularVector(n, e) {
              var t = [e[0] - n[0], e[1] - n[1]],
                r = -Math.PI * 0.5,
                s = [
                  Math.cos(r) * t[0] - Math.sin(r) * t[1],
                  Math.sin(r) * t[0] + Math.cos(r) * t[1],
                ];
              return s;
            }
            function getProjectingAngle(n, e) {
              var t = e === 0 ? n.length() - 1 : e - 1,
                r = (e + 1) % n.length(),
                s = n.v[t],
                o = n.v[r],
                a = getPerpendicularVector(s, o);
              return Math.atan2(0, 1) - Math.atan2(a[1], a[0]);
            }
            function zigZagCorner(n, e, t, r, s, o, a) {
              var l = getProjectingAngle(e, t),
                c = e.v[t % e._length],
                u = e.v[t === 0 ? e._length - 1 : t - 1],
                p = e.v[(t + 1) % e._length],
                N =
                  o === 2
                    ? Math.sqrt(
                        Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2)
                      )
                    : 0,
                P =
                  o === 2
                    ? Math.sqrt(
                        Math.pow(c[0] - p[0], 2) + Math.pow(c[1] - p[1], 2)
                      )
                    : 0;
              setPoint(
                n,
                e.v[t % e._length],
                l,
                a,
                r,
                P / ((s + 1) * 2),
                N / ((s + 1) * 2)
              );
            }
            function zigZagSegment(n, e, t, r, s, o) {
              for (var a = 0; a < r; a += 1) {
                var l = (a + 1) / (r + 1),
                  c =
                    s === 2
                      ? Math.sqrt(
                          Math.pow(e.points[3][0] - e.points[0][0], 2) +
                            Math.pow(e.points[3][1] - e.points[0][1], 2)
                        )
                      : 0,
                  u = e.normalAngle(l),
                  p = e.point(l);
                setPoint(n, p, u, o, t, c / ((r + 1) * 2), c / ((r + 1) * 2)),
                  (o = -o);
              }
              return o;
            }
            (ZigZagModifier.prototype.processPath = function (n, e, t, r) {
              var s = n._length,
                o = shapePool.newElement();
              if (((o.c = n.c), n.c || (s -= 1), s === 0)) return o;
              var a = -1,
                l = PolynomialBezier.shapeSegment(n, 0);
              zigZagCorner(o, n, 0, e, t, r, a);
              for (var c = 0; c < s; c += 1)
                (a = zigZagSegment(o, l, e, t, r, -a)),
                  c === s - 1 && !n.c
                    ? (l = null)
                    : (l = PolynomialBezier.shapeSegment(n, (c + 1) % s)),
                  zigZagCorner(o, n, c + 1, e, t, r, a);
              return o;
            }),
              (ZigZagModifier.prototype.processShapes = function (n) {
                var e,
                  t,
                  r = this.shapes.length,
                  s,
                  o,
                  a = this.amplitude.v,
                  l = Math.max(0, Math.round(this.frequency.v)),
                  c = this.pointsType.v;
                if (a !== 0) {
                  var u, p;
                  for (t = 0; t < r; t += 1) {
                    if (
                      ((u = this.shapes[t]),
                      (p = u.localShapeCollection),
                      !(!u.shape._mdf && !this._mdf && !n))
                    )
                      for (
                        p.releaseShapes(),
                          u.shape._mdf = !0,
                          e = u.shape.paths.shapes,
                          o = u.shape.paths._length,
                          s = 0;
                        s < o;
                        s += 1
                      )
                        p.addShape(this.processPath(e[s], a, l, c));
                    u.shape.paths = u.localShapeCollection;
                  }
                }
                this.dynamicProperties.length || (this._mdf = !1);
              });
            function linearOffset(n, e, t) {
              var r = Math.atan2(e[0] - n[0], e[1] - n[1]);
              return [polarOffset(n, r, t), polarOffset(e, r, t)];
            }
            function offsetSegment(n, e) {
              var t, r, s, o, a, l, c;
              (c = linearOffset(n.points[0], n.points[1], e)),
                (t = c[0]),
                (r = c[1]),
                (c = linearOffset(n.points[1], n.points[2], e)),
                (s = c[0]),
                (o = c[1]),
                (c = linearOffset(n.points[2], n.points[3], e)),
                (a = c[0]),
                (l = c[1]);
              var u = lineIntersection(t, r, s, o);
              u === null && (u = r);
              var p = lineIntersection(a, l, s, o);
              return p === null && (p = a), new PolynomialBezier(t, u, p, l);
            }
            function joinLines(n, e, t, r, s) {
              var o = e.points[3],
                a = t.points[0];
              if (r === 3 || pointEqual(o, a)) return o;
              if (r === 2) {
                var l = -e.tangentAngle(1),
                  c = -t.tangentAngle(0) + Math.PI,
                  u = lineIntersection(
                    o,
                    polarOffset(o, l + Math.PI / 2, 100),
                    a,
                    polarOffset(a, l + Math.PI / 2, 100)
                  ),
                  p = u ? pointDistance(u, o) : pointDistance(o, a) / 2,
                  N = polarOffset(o, l, 2 * p * roundCorner);
                return (
                  n.setXYAt(N[0], N[1], "o", n.length() - 1),
                  (N = polarOffset(a, c, 2 * p * roundCorner)),
                  n.setTripleAt(a[0], a[1], a[0], a[1], N[0], N[1], n.length()),
                  a
                );
              }
              var P = pointEqual(o, e.points[2]) ? e.points[0] : e.points[2],
                de = pointEqual(a, t.points[1]) ? t.points[3] : t.points[1],
                me = lineIntersection(P, o, a, de);
              return me && pointDistance(me, o) < s
                ? (n.setTripleAt(
                    me[0],
                    me[1],
                    me[0],
                    me[1],
                    me[0],
                    me[1],
                    n.length()
                  ),
                  me)
                : o;
            }
            function getIntersection(n, e) {
              var t = n.intersections(e);
              return (
                t.length && floatEqual(t[0][0], 1) && t.shift(),
                t.length ? t[0] : null
              );
            }
            function pruneSegmentIntersection(n, e) {
              var t = n.slice(),
                r = e.slice(),
                s = getIntersection(n[n.length - 1], e[0]);
              return (
                s &&
                  ((t[n.length - 1] = n[n.length - 1].split(s[0])[0]),
                  (r[0] = e[0].split(s[1])[1])),
                n.length > 1 &&
                e.length > 1 &&
                ((s = getIntersection(n[0], e[e.length - 1])), s)
                  ? [[n[0].split(s[0])[0]], [e[e.length - 1].split(s[1])[1]]]
                  : [t, r]
              );
            }
            function pruneIntersections(n) {
              for (var e, t = 1; t < n.length; t += 1)
                (e = pruneSegmentIntersection(n[t - 1], n[t])),
                  (n[t - 1] = e[0]),
                  (n[t] = e[1]);
              return (
                n.length > 1 &&
                  ((e = pruneSegmentIntersection(n[n.length - 1], n[0])),
                  (n[n.length - 1] = e[0]),
                  (n[0] = e[1])),
                n
              );
            }
            function offsetSegmentSplit(n, e) {
              var t = n.inflectionPoints(),
                r,
                s,
                o,
                a;
              if (t.length === 0) return [offsetSegment(n, e)];
              if (t.length === 1 || floatEqual(t[1], 1))
                return (
                  (o = n.split(t[0])),
                  (r = o[0]),
                  (s = o[1]),
                  [offsetSegment(r, e), offsetSegment(s, e)]
                );
              (o = n.split(t[0])), (r = o[0]);
              var l = (t[1] - t[0]) / (1 - t[0]);
              return (
                (o = o[1].split(l)),
                (a = o[0]),
                (s = o[1]),
                [offsetSegment(r, e), offsetSegment(a, e), offsetSegment(s, e)]
              );
            }
            function OffsetPathModifier() {}
            extendPrototype([ShapeModifier], OffsetPathModifier),
              (OffsetPathModifier.prototype.initModifierProperties = function (
                n,
                e
              ) {
                (this.getValue = this.processKeys),
                  (this.amount = PropertyFactory.getProp(
                    n,
                    e.a,
                    0,
                    null,
                    this
                  )),
                  (this.miterLimit = PropertyFactory.getProp(
                    n,
                    e.ml,
                    0,
                    null,
                    this
                  )),
                  (this.lineJoin = e.lj),
                  (this._isAnimated = this.amount.effectsSequence.length !== 0);
              }),
              (OffsetPathModifier.prototype.processPath = function (
                n,
                e,
                t,
                r
              ) {
                var s = shapePool.newElement();
                s.c = n.c;
                var o = n.length();
                n.c || (o -= 1);
                var a,
                  l,
                  c,
                  u = [];
                for (a = 0; a < o; a += 1)
                  (c = PolynomialBezier.shapeSegment(n, a)),
                    u.push(offsetSegmentSplit(c, e));
                if (!n.c)
                  for (a = o - 1; a >= 0; a -= 1)
                    (c = PolynomialBezier.shapeSegmentInverted(n, a)),
                      u.push(offsetSegmentSplit(c, e));
                u = pruneIntersections(u);
                var p = null,
                  N = null;
                for (a = 0; a < u.length; a += 1) {
                  var P = u[a];
                  for (
                    N && (p = joinLines(s, N, P[0], t, r)),
                      N = P[P.length - 1],
                      l = 0;
                    l < P.length;
                    l += 1
                  )
                    (c = P[l]),
                      p && pointEqual(c.points[0], p)
                        ? s.setXYAt(
                            c.points[1][0],
                            c.points[1][1],
                            "o",
                            s.length() - 1
                          )
                        : s.setTripleAt(
                            c.points[0][0],
                            c.points[0][1],
                            c.points[1][0],
                            c.points[1][1],
                            c.points[0][0],
                            c.points[0][1],
                            s.length()
                          ),
                      s.setTripleAt(
                        c.points[3][0],
                        c.points[3][1],
                        c.points[3][0],
                        c.points[3][1],
                        c.points[2][0],
                        c.points[2][1],
                        s.length()
                      ),
                      (p = c.points[3]);
                }
                return u.length && joinLines(s, N, u[0][0], t, r), s;
              }),
              (OffsetPathModifier.prototype.processShapes = function (n) {
                var e,
                  t,
                  r = this.shapes.length,
                  s,
                  o,
                  a = this.amount.v,
                  l = this.miterLimit.v,
                  c = this.lineJoin;
                if (a !== 0) {
                  var u, p;
                  for (t = 0; t < r; t += 1) {
                    if (
                      ((u = this.shapes[t]),
                      (p = u.localShapeCollection),
                      !(!u.shape._mdf && !this._mdf && !n))
                    )
                      for (
                        p.releaseShapes(),
                          u.shape._mdf = !0,
                          e = u.shape.paths.shapes,
                          o = u.shape.paths._length,
                          s = 0;
                        s < o;
                        s += 1
                      )
                        p.addShape(this.processPath(e[s], a, c, l));
                    u.shape.paths = u.localShapeCollection;
                  }
                }
                this.dynamicProperties.length || (this._mdf = !1);
              });
            function getFontProperties(n) {
              for (
                var e = n.fStyle ? n.fStyle.split(" ") : [],
                  t = "normal",
                  r = "normal",
                  s = e.length,
                  o,
                  a = 0;
                a < s;
                a += 1
              )
                switch (((o = e[a].toLowerCase()), o)) {
                  case "italic":
                    r = "italic";
                    break;
                  case "bold":
                    t = "700";
                    break;
                  case "black":
                    t = "900";
                    break;
                  case "medium":
                    t = "500";
                    break;
                  case "regular":
                  case "normal":
                    t = "400";
                    break;
                  case "light":
                  case "thin":
                    t = "200";
                    break;
                }
              return { style: r, weight: n.fWeight || t };
            }
            var FontManager = (function () {
              var n = 5e3,
                e = { w: 0, size: 0, shapes: [], data: { shapes: [] } },
                t = [];
              t = t.concat([
                2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367,
                2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377,
                2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390,
                2391, 2402, 2403,
              ]);
              var r = 127988,
                s = 917631,
                o = 917601,
                a = 917626,
                l = 65039,
                c = 8205,
                u = 127462,
                p = 127487,
                N = [
                  "d83cdffb",
                  "d83cdffc",
                  "d83cdffd",
                  "d83cdffe",
                  "d83cdfff",
                ];
              function P(Ft) {
                var Bt = Ft.split(","),
                  Mt,
                  Pt = Bt.length,
                  It = [];
                for (Mt = 0; Mt < Pt; Mt += 1)
                  Bt[Mt] !== "sans-serif" &&
                    Bt[Mt] !== "monospace" &&
                    It.push(Bt[Mt]);
                return It.join(",");
              }
              function de(Ft, Bt) {
                var Mt = createTag("span");
                Mt.setAttribute("aria-hidden", !0), (Mt.style.fontFamily = Bt);
                var Pt = createTag("span");
                (Pt.innerText = "giItT1WQy@!-/#"),
                  (Mt.style.position = "absolute"),
                  (Mt.style.left = "-10000px"),
                  (Mt.style.top = "-10000px"),
                  (Mt.style.fontSize = "300px"),
                  (Mt.style.fontVariant = "normal"),
                  (Mt.style.fontStyle = "normal"),
                  (Mt.style.fontWeight = "normal"),
                  (Mt.style.letterSpacing = "0"),
                  Mt.appendChild(Pt),
                  document.body.appendChild(Mt);
                var It = Pt.offsetWidth;
                return (
                  (Pt.style.fontFamily = P(Ft) + ", " + Bt),
                  { node: Pt, w: It, parent: Mt }
                );
              }
              function me() {
                var Ft,
                  Bt = this.fonts.length,
                  Mt,
                  Pt,
                  It = Bt;
                for (Ft = 0; Ft < Bt; Ft += 1)
                  this.fonts[Ft].loaded
                    ? (It -= 1)
                    : this.fonts[Ft].fOrigin === "n" ||
                      this.fonts[Ft].origin === 0
                    ? (this.fonts[Ft].loaded = !0)
                    : ((Mt = this.fonts[Ft].monoCase.node),
                      (Pt = this.fonts[Ft].monoCase.w),
                      Mt.offsetWidth !== Pt
                        ? ((It -= 1), (this.fonts[Ft].loaded = !0))
                        : ((Mt = this.fonts[Ft].sansCase.node),
                          (Pt = this.fonts[Ft].sansCase.w),
                          Mt.offsetWidth !== Pt &&
                            ((It -= 1), (this.fonts[Ft].loaded = !0))),
                      this.fonts[Ft].loaded &&
                        (this.fonts[Ft].sansCase.parent.parentNode.removeChild(
                          this.fonts[Ft].sansCase.parent
                        ),
                        this.fonts[Ft].monoCase.parent.parentNode.removeChild(
                          this.fonts[Ft].monoCase.parent
                        )));
                It !== 0 && Date.now() - this.initTime < n
                  ? setTimeout(this.checkLoadedFontsBinded, 20)
                  : setTimeout(this.setIsLoadedBinded, 10);
              }
              function Ye(Ft, Bt) {
                var Mt = document.body && Bt ? "svg" : "canvas",
                  Pt,
                  It = getFontProperties(Ft);
                if (Mt === "svg") {
                  var Ot = createNS("text");
                  (Ot.style.fontSize = "100px"),
                    Ot.setAttribute("font-family", Ft.fFamily),
                    Ot.setAttribute("font-style", It.style),
                    Ot.setAttribute("font-weight", It.weight),
                    (Ot.textContent = "1"),
                    Ft.fClass
                      ? ((Ot.style.fontFamily = "inherit"),
                        Ot.setAttribute("class", Ft.fClass))
                      : (Ot.style.fontFamily = Ft.fFamily),
                    Bt.appendChild(Ot),
                    (Pt = Ot);
                } else {
                  var Xt = new OffscreenCanvas(500, 500).getContext("2d");
                  (Xt.font =
                    It.style + " " + It.weight + " 100px " + Ft.fFamily),
                    (Pt = Xt);
                }
                function sn(Kt) {
                  return Mt === "svg"
                    ? ((Pt.textContent = Kt), Pt.getComputedTextLength())
                    : Pt.measureText(Kt).width;
                }
                return { measureText: sn };
              }
              function nt(Ft, Bt) {
                if (!Ft) {
                  this.isLoaded = !0;
                  return;
                }
                if (this.chars) {
                  (this.isLoaded = !0), (this.fonts = Ft.list);
                  return;
                }
                if (!document.body) {
                  (this.isLoaded = !0),
                    Ft.list.forEach(function (bn) {
                      (bn.helper = Ye(bn)), (bn.cache = {});
                    }),
                    (this.fonts = Ft.list);
                  return;
                }
                var Mt = Ft.list,
                  Pt,
                  It = Mt.length,
                  Ot = It;
                for (Pt = 0; Pt < It; Pt += 1) {
                  var Xt = !0,
                    sn,
                    Kt;
                  if (
                    ((Mt[Pt].loaded = !1),
                    (Mt[Pt].monoCase = de(Mt[Pt].fFamily, "monospace")),
                    (Mt[Pt].sansCase = de(Mt[Pt].fFamily, "sans-serif")),
                    !Mt[Pt].fPath)
                  )
                    (Mt[Pt].loaded = !0), (Ot -= 1);
                  else if (Mt[Pt].fOrigin === "p" || Mt[Pt].origin === 3) {
                    if (
                      ((sn = document.querySelectorAll(
                        'style[f-forigin="p"][f-family="' +
                          Mt[Pt].fFamily +
                          '"], style[f-origin="3"][f-family="' +
                          Mt[Pt].fFamily +
                          '"]'
                      )),
                      sn.length > 0 && (Xt = !1),
                      Xt)
                    ) {
                      var tn = createTag("style");
                      tn.setAttribute("f-forigin", Mt[Pt].fOrigin),
                        tn.setAttribute("f-origin", Mt[Pt].origin),
                        tn.setAttribute("f-family", Mt[Pt].fFamily),
                        (tn.type = "text/css"),
                        (tn.innerText =
                          "@font-face {font-family: " +
                          Mt[Pt].fFamily +
                          "; font-style: normal; src: url('" +
                          Mt[Pt].fPath +
                          "');}"),
                        Bt.appendChild(tn);
                    }
                  } else if (Mt[Pt].fOrigin === "g" || Mt[Pt].origin === 1) {
                    for (
                      sn = document.querySelectorAll(
                        'link[f-forigin="g"], link[f-origin="1"]'
                      ),
                        Kt = 0;
                      Kt < sn.length;
                      Kt += 1
                    )
                      sn[Kt].href.indexOf(Mt[Pt].fPath) !== -1 && (Xt = !1);
                    if (Xt) {
                      var pn = createTag("link");
                      pn.setAttribute("f-forigin", Mt[Pt].fOrigin),
                        pn.setAttribute("f-origin", Mt[Pt].origin),
                        (pn.type = "text/css"),
                        (pn.rel = "stylesheet"),
                        (pn.href = Mt[Pt].fPath),
                        document.body.appendChild(pn);
                    }
                  } else if (Mt[Pt].fOrigin === "t" || Mt[Pt].origin === 2) {
                    for (
                      sn = document.querySelectorAll(
                        'script[f-forigin="t"], script[f-origin="2"]'
                      ),
                        Kt = 0;
                      Kt < sn.length;
                      Kt += 1
                    )
                      Mt[Pt].fPath === sn[Kt].src && (Xt = !1);
                    if (Xt) {
                      var _n = createTag("link");
                      _n.setAttribute("f-forigin", Mt[Pt].fOrigin),
                        _n.setAttribute("f-origin", Mt[Pt].origin),
                        _n.setAttribute("rel", "stylesheet"),
                        _n.setAttribute("href", Mt[Pt].fPath),
                        Bt.appendChild(_n);
                    }
                  }
                  (Mt[Pt].helper = Ye(Mt[Pt], Bt)),
                    (Mt[Pt].cache = {}),
                    this.fonts.push(Mt[Pt]);
                }
                Ot === 0
                  ? (this.isLoaded = !0)
                  : setTimeout(this.checkLoadedFonts.bind(this), 100);
              }
              function Be(Ft) {
                if (Ft) {
                  this.chars || (this.chars = []);
                  var Bt,
                    Mt = Ft.length,
                    Pt,
                    It = this.chars.length,
                    Ot;
                  for (Bt = 0; Bt < Mt; Bt += 1) {
                    for (Pt = 0, Ot = !1; Pt < It; )
                      this.chars[Pt].style === Ft[Bt].style &&
                        this.chars[Pt].fFamily === Ft[Bt].fFamily &&
                        this.chars[Pt].ch === Ft[Bt].ch &&
                        (Ot = !0),
                        (Pt += 1);
                    Ot || (this.chars.push(Ft[Bt]), (It += 1));
                  }
                }
              }
              function ot(Ft, Bt, Mt) {
                for (var Pt = 0, It = this.chars.length; Pt < It; ) {
                  if (
                    this.chars[Pt].ch === Ft &&
                    this.chars[Pt].style === Bt &&
                    this.chars[Pt].fFamily === Mt
                  )
                    return this.chars[Pt];
                  Pt += 1;
                }
                return (
                  ((typeof Ft == "string" && Ft.charCodeAt(0) !== 13) || !Ft) &&
                    console &&
                    console.warn &&
                    !this._warned &&
                    ((this._warned = !0),
                    console.warn(
                      "Missing character from exported characters list: ",
                      Ft,
                      Bt,
                      Mt
                    )),
                  e
                );
              }
              function st(Ft, Bt, Mt) {
                var Pt = this.getFontByName(Bt),
                  It = Ft;
                if (!Pt.cache[It]) {
                  var Ot = Pt.helper;
                  if (Ft === " ") {
                    var Xt = Ot.measureText("|" + Ft + "|"),
                      sn = Ot.measureText("||");
                    Pt.cache[It] = (Xt - sn) / 100;
                  } else Pt.cache[It] = Ot.measureText(Ft) / 100;
                }
                return Pt.cache[It] * Mt;
              }
              function vt(Ft) {
                for (var Bt = 0, Mt = this.fonts.length; Bt < Mt; ) {
                  if (this.fonts[Bt].fName === Ft) return this.fonts[Bt];
                  Bt += 1;
                }
                return this.fonts[0];
              }
              function xt(Ft) {
                var Bt = 0,
                  Mt = Ft.charCodeAt(0);
                if (Mt >= 55296 && Mt <= 56319) {
                  var Pt = Ft.charCodeAt(1);
                  Pt >= 56320 &&
                    Pt <= 57343 &&
                    (Bt = (Mt - 55296) * 1024 + Pt - 56320 + 65536);
                }
                return Bt;
              }
              function St(Ft, Bt) {
                var Mt = Ft.toString(16) + Bt.toString(16);
                return N.indexOf(Mt) !== -1;
              }
              function wt(Ft) {
                return Ft === c;
              }
              function bt(Ft) {
                return Ft === l;
              }
              function Tt(Ft) {
                var Bt = xt(Ft);
                return Bt >= u && Bt <= p;
              }
              function Ct(Ft) {
                return Tt(Ft.substr(0, 2)) && Tt(Ft.substr(2, 2));
              }
              function kt(Ft) {
                return t.indexOf(Ft) !== -1;
              }
              function Dt(Ft, Bt) {
                var Mt = xt(Ft.substr(Bt, 2));
                if (Mt !== r) return !1;
                var Pt = 0;
                for (Bt += 2; Pt < 5; ) {
                  if (((Mt = xt(Ft.substr(Bt, 2))), Mt < o || Mt > a))
                    return !1;
                  (Pt += 1), (Bt += 2);
                }
                return xt(Ft.substr(Bt, 2)) === s;
              }
              function Vt() {
                this.isLoaded = !0;
              }
              var Ht = function () {
                (this.fonts = []),
                  (this.chars = null),
                  (this.typekitLoaded = 0),
                  (this.isLoaded = !1),
                  (this._warned = !1),
                  (this.initTime = Date.now()),
                  (this.setIsLoadedBinded = this.setIsLoaded.bind(this)),
                  (this.checkLoadedFontsBinded =
                    this.checkLoadedFonts.bind(this));
              };
              (Ht.isModifier = St),
                (Ht.isZeroWidthJoiner = wt),
                (Ht.isFlagEmoji = Ct),
                (Ht.isRegionalCode = Tt),
                (Ht.isCombinedCharacter = kt),
                (Ht.isRegionalFlag = Dt),
                (Ht.isVariationSelector = bt),
                (Ht.BLACK_FLAG_CODE_POINT = r);
              var qt = {
                addChars: Be,
                addFonts: nt,
                getCharData: ot,
                getFontByName: vt,
                measureText: st,
                checkLoadedFonts: me,
                setIsLoaded: Vt,
              };
              return (Ht.prototype = qt), Ht;
            })();
            function SlotManager(n) {
              this.animationData = n;
            }
            SlotManager.prototype.getProp = function (n) {
              return this.animationData.slots && this.animationData.slots[n.sid]
                ? Object.assign(n, this.animationData.slots[n.sid].p)
                : n;
            };
            function slotFactory(n) {
              return new SlotManager(n);
            }
            function RenderableElement() {}
            RenderableElement.prototype = {
              initRenderable: function () {
                (this.isInRange = !1),
                  (this.hidden = !1),
                  (this.isTransparent = !1),
                  (this.renderableComponents = []);
              },
              addRenderableComponent: function (e) {
                this.renderableComponents.indexOf(e) === -1 &&
                  this.renderableComponents.push(e);
              },
              removeRenderableComponent: function (e) {
                this.renderableComponents.indexOf(e) !== -1 &&
                  this.renderableComponents.splice(
                    this.renderableComponents.indexOf(e),
                    1
                  );
              },
              prepareRenderableFrame: function (e) {
                this.checkLayerLimits(e);
              },
              checkTransparency: function () {
                this.finalTransform.mProp.o.v <= 0
                  ? !this.isTransparent &&
                    this.globalData.renderConfig.hideOnTransparent &&
                    ((this.isTransparent = !0), this.hide())
                  : this.isTransparent &&
                    ((this.isTransparent = !1), this.show());
              },
              checkLayerLimits: function (e) {
                this.data.ip - this.data.st <= e &&
                this.data.op - this.data.st > e
                  ? this.isInRange !== !0 &&
                    ((this.globalData._mdf = !0),
                    (this._mdf = !0),
                    (this.isInRange = !0),
                    this.show())
                  : this.isInRange !== !1 &&
                    ((this.globalData._mdf = !0),
                    (this.isInRange = !1),
                    this.hide());
              },
              renderRenderable: function () {
                var e,
                  t = this.renderableComponents.length;
                for (e = 0; e < t; e += 1)
                  this.renderableComponents[e].renderFrame(this._isFirstFrame);
              },
              sourceRectAtTime: function () {
                return { top: 0, left: 0, width: 100, height: 100 };
              },
              getLayerSize: function () {
                return this.data.ty === 5
                  ? {
                      w: this.data.textData.width,
                      h: this.data.textData.height,
                    }
                  : { w: this.data.width, h: this.data.height };
              },
            };
            var getBlendMode = (function () {
              var n = {
                0: "source-over",
                1: "multiply",
                2: "screen",
                3: "overlay",
                4: "darken",
                5: "lighten",
                6: "color-dodge",
                7: "color-burn",
                8: "hard-light",
                9: "soft-light",
                10: "difference",
                11: "exclusion",
                12: "hue",
                13: "saturation",
                14: "color",
                15: "luminosity",
              };
              return function (e) {
                return n[e] || "";
              };
            })();
            function SliderEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 0, 0, t);
            }
            function AngleEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 0, 0, t);
            }
            function ColorEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 1, 0, t);
            }
            function PointEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 1, 0, t);
            }
            function LayerIndexEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 0, 0, t);
            }
            function MaskIndexEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 0, 0, t);
            }
            function CheckboxEffect(n, e, t) {
              this.p = PropertyFactory.getProp(e, n.v, 0, 0, t);
            }
            function NoValueEffect() {
              this.p = {};
            }
            function EffectsManager(n, e) {
              var t = n.ef || [];
              this.effectElements = [];
              var r,
                s = t.length,
                o;
              for (r = 0; r < s; r += 1)
                (o = new GroupEffect(t[r], e)), this.effectElements.push(o);
            }
            function GroupEffect(n, e) {
              this.init(n, e);
            }
            extendPrototype([DynamicPropertyContainer], GroupEffect),
              (GroupEffect.prototype.getValue =
                GroupEffect.prototype.iterateDynamicProperties),
              (GroupEffect.prototype.init = function (n, e) {
                (this.data = n),
                  (this.effectElements = []),
                  this.initDynamicPropertyContainer(e);
                var t,
                  r = this.data.ef.length,
                  s,
                  o = this.data.ef;
                for (t = 0; t < r; t += 1) {
                  switch (((s = null), o[t].ty)) {
                    case 0:
                      s = new SliderEffect(o[t], e, this);
                      break;
                    case 1:
                      s = new AngleEffect(o[t], e, this);
                      break;
                    case 2:
                      s = new ColorEffect(o[t], e, this);
                      break;
                    case 3:
                      s = new PointEffect(o[t], e, this);
                      break;
                    case 4:
                    case 7:
                      s = new CheckboxEffect(o[t], e, this);
                      break;
                    case 10:
                      s = new LayerIndexEffect(o[t], e, this);
                      break;
                    case 11:
                      s = new MaskIndexEffect(o[t], e, this);
                      break;
                    case 5:
                      s = new EffectsManager(o[t], e);
                      break;
                    default:
                      s = new NoValueEffect(o[t]);
                      break;
                  }
                  s && this.effectElements.push(s);
                }
              });
            function BaseElement() {}
            BaseElement.prototype = {
              checkMasks: function () {
                if (!this.data.hasMask) return !1;
                for (var e = 0, t = this.data.masksProperties.length; e < t; ) {
                  if (
                    this.data.masksProperties[e].mode !== "n" &&
                    this.data.masksProperties[e].cl !== !1
                  )
                    return !0;
                  e += 1;
                }
                return !1;
              },
              initExpressions: function () {
                var e = getExpressionInterfaces();
                if (e) {
                  var t = e("layer"),
                    r = e("effects"),
                    s = e("shape"),
                    o = e("text"),
                    a = e("comp");
                  (this.layerInterface = t(this)),
                    this.data.hasMask &&
                      this.maskManager &&
                      this.layerInterface.registerMaskInterface(
                        this.maskManager
                      );
                  var l = r.createEffectsInterface(this, this.layerInterface);
                  this.layerInterface.registerEffectsInterface(l),
                    this.data.ty === 0 || this.data.xt
                      ? (this.compInterface = a(this))
                      : this.data.ty === 4
                      ? ((this.layerInterface.shapeInterface = s(
                          this.shapesData,
                          this.itemsData,
                          this.layerInterface
                        )),
                        (this.layerInterface.content =
                          this.layerInterface.shapeInterface))
                      : this.data.ty === 5 &&
                        ((this.layerInterface.textInterface = o(this)),
                        (this.layerInterface.text =
                          this.layerInterface.textInterface));
                }
              },
              setBlendMode: function () {
                var e = getBlendMode(this.data.bm),
                  t = this.baseElement || this.layerElement;
                t.style["mix-blend-mode"] = e;
              },
              initBaseData: function (e, t, r) {
                (this.globalData = t),
                  (this.comp = r),
                  (this.data = e),
                  (this.layerId = createElementID()),
                  this.data.sr || (this.data.sr = 1),
                  (this.effectsManager = new EffectsManager(
                    this.data,
                    this,
                    this.dynamicProperties
                  ));
              },
              getType: function () {
                return this.type;
              },
              sourceRectAtTime: function () {},
            };
            function FrameElement() {}
            FrameElement.prototype = {
              initFrame: function () {
                (this._isFirstFrame = !1),
                  (this.dynamicProperties = []),
                  (this._mdf = !1);
              },
              prepareProperties: function (e, t) {
                var r,
                  s = this.dynamicProperties.length;
                for (r = 0; r < s; r += 1)
                  (t ||
                    (this._isParent &&
                      this.dynamicProperties[r].propType === "transform")) &&
                    (this.dynamicProperties[r].getValue(),
                    this.dynamicProperties[r]._mdf &&
                      ((this.globalData._mdf = !0), (this._mdf = !0)));
              },
              addDynamicProperty: function (e) {
                this.dynamicProperties.indexOf(e) === -1 &&
                  this.dynamicProperties.push(e);
              },
            };
            function FootageElement(n, e, t) {
              this.initFrame(),
                this.initRenderable(),
                (this.assetData = e.getAssetData(n.refId)),
                (this.footageData = e.imageLoader.getAsset(this.assetData)),
                this.initBaseData(n, e, t);
            }
            (FootageElement.prototype.prepareFrame = function () {}),
              extendPrototype(
                [RenderableElement, BaseElement, FrameElement],
                FootageElement
              ),
              (FootageElement.prototype.getBaseElement = function () {
                return null;
              }),
              (FootageElement.prototype.renderFrame = function () {}),
              (FootageElement.prototype.destroy = function () {}),
              (FootageElement.prototype.initExpressions = function () {
                var n = getExpressionInterfaces();
                if (n) {
                  var e = n("footage");
                  this.layerInterface = e(this);
                }
              }),
              (FootageElement.prototype.getFootageData = function () {
                return this.footageData;
              });
            function AudioElement(n, e, t) {
              this.initFrame(),
                this.initRenderable(),
                (this.assetData = e.getAssetData(n.refId)),
                this.initBaseData(n, e, t),
                (this._isPlaying = !1),
                (this._canPlay = !1);
              var r = this.globalData.getAssetsPath(this.assetData);
              (this.audio = this.globalData.audioController.createAudio(r)),
                (this._currentTime = 0),
                this.globalData.audioController.addAudio(this),
                (this._volumeMultiplier = 1),
                (this._volume = 1),
                (this._previousVolume = null),
                (this.tm = n.tm
                  ? PropertyFactory.getProp(this, n.tm, 0, e.frameRate, this)
                  : { _placeholder: !0 }),
                (this.lv = PropertyFactory.getProp(
                  this,
                  n.au && n.au.lv ? n.au.lv : { k: [100] },
                  1,
                  0.01,
                  this
                ));
            }
            (AudioElement.prototype.prepareFrame = function (n) {
              if (
                (this.prepareRenderableFrame(n, !0),
                this.prepareProperties(n, !0),
                this.tm._placeholder)
              )
                this._currentTime = n / this.data.sr;
              else {
                var e = this.tm.v;
                this._currentTime = e;
              }
              this._volume = this.lv.v[0];
              var t = this._volume * this._volumeMultiplier;
              this._previousVolume !== t &&
                ((this._previousVolume = t), this.audio.volume(t));
            }),
              extendPrototype(
                [RenderableElement, BaseElement, FrameElement],
                AudioElement
              ),
              (AudioElement.prototype.renderFrame = function () {
                this.isInRange &&
                  this._canPlay &&
                  (this._isPlaying
                    ? (!this.audio.playing() ||
                        Math.abs(
                          this._currentTime / this.globalData.frameRate -
                            this.audio.seek()
                        ) > 0.1) &&
                      this.audio.seek(
                        this._currentTime / this.globalData.frameRate
                      )
                    : (this.audio.play(),
                      this.audio.seek(
                        this._currentTime / this.globalData.frameRate
                      ),
                      (this._isPlaying = !0)));
              }),
              (AudioElement.prototype.show = function () {}),
              (AudioElement.prototype.hide = function () {
                this.audio.pause(), (this._isPlaying = !1);
              }),
              (AudioElement.prototype.pause = function () {
                this.audio.pause(),
                  (this._isPlaying = !1),
                  (this._canPlay = !1);
              }),
              (AudioElement.prototype.resume = function () {
                this._canPlay = !0;
              }),
              (AudioElement.prototype.setRate = function (n) {
                this.audio.rate(n);
              }),
              (AudioElement.prototype.volume = function (n) {
                (this._volumeMultiplier = n),
                  (this._previousVolume = n * this._volume),
                  this.audio.volume(this._previousVolume);
              }),
              (AudioElement.prototype.getBaseElement = function () {
                return null;
              }),
              (AudioElement.prototype.destroy = function () {}),
              (AudioElement.prototype.sourceRectAtTime = function () {}),
              (AudioElement.prototype.initExpressions = function () {});
            function BaseRenderer() {}
            (BaseRenderer.prototype.checkLayers = function (n) {
              var e,
                t = this.layers.length,
                r;
              for (this.completeLayers = !0, e = t - 1; e >= 0; e -= 1)
                this.elements[e] ||
                  ((r = this.layers[e]),
                  r.ip - r.st <= n - this.layers[e].st &&
                    r.op - r.st > n - this.layers[e].st &&
                    this.buildItem(e)),
                  (this.completeLayers = this.elements[e]
                    ? this.completeLayers
                    : !1);
              this.checkPendingElements();
            }),
              (BaseRenderer.prototype.createItem = function (n) {
                switch (n.ty) {
                  case 2:
                    return this.createImage(n);
                  case 0:
                    return this.createComp(n);
                  case 1:
                    return this.createSolid(n);
                  case 3:
                    return this.createNull(n);
                  case 4:
                    return this.createShape(n);
                  case 5:
                    return this.createText(n);
                  case 6:
                    return this.createAudio(n);
                  case 13:
                    return this.createCamera(n);
                  case 15:
                    return this.createFootage(n);
                  default:
                    return this.createNull(n);
                }
              }),
              (BaseRenderer.prototype.createCamera = function () {
                throw new Error(
                  "You're using a 3d camera. Try the html renderer."
                );
              }),
              (BaseRenderer.prototype.createAudio = function (n) {
                return new AudioElement(n, this.globalData, this);
              }),
              (BaseRenderer.prototype.createFootage = function (n) {
                return new FootageElement(n, this.globalData, this);
              }),
              (BaseRenderer.prototype.buildAllItems = function () {
                var n,
                  e = this.layers.length;
                for (n = 0; n < e; n += 1) this.buildItem(n);
                this.checkPendingElements();
              }),
              (BaseRenderer.prototype.includeLayers = function (n) {
                this.completeLayers = !1;
                var e,
                  t = n.length,
                  r,
                  s = this.layers.length;
                for (e = 0; e < t; e += 1)
                  for (r = 0; r < s; ) {
                    if (this.layers[r].id === n[e].id) {
                      this.layers[r] = n[e];
                      break;
                    }
                    r += 1;
                  }
              }),
              (BaseRenderer.prototype.setProjectInterface = function (n) {
                this.globalData.projectInterface = n;
              }),
              (BaseRenderer.prototype.initItems = function () {
                this.globalData.progressiveLoad || this.buildAllItems();
              }),
              (BaseRenderer.prototype.buildElementParenting = function (
                n,
                e,
                t
              ) {
                for (
                  var r = this.elements, s = this.layers, o = 0, a = s.length;
                  o < a;

                )
                  s[o].ind == e &&
                    (!r[o] || r[o] === !0
                      ? (this.buildItem(o), this.addPendingElement(n))
                      : (t.push(r[o]),
                        r[o].setAsParent(),
                        s[o].parent !== void 0
                          ? this.buildElementParenting(n, s[o].parent, t)
                          : n.setHierarchy(t))),
                    (o += 1);
              }),
              (BaseRenderer.prototype.addPendingElement = function (n) {
                this.pendingElements.push(n);
              }),
              (BaseRenderer.prototype.searchExtraCompositions = function (n) {
                var e,
                  t = n.length;
                for (e = 0; e < t; e += 1)
                  if (n[e].xt) {
                    var r = this.createComp(n[e]);
                    r.initExpressions(),
                      this.globalData.projectInterface.registerComposition(r);
                  }
              }),
              (BaseRenderer.prototype.getElementById = function (n) {
                var e,
                  t = this.elements.length;
                for (e = 0; e < t; e += 1)
                  if (this.elements[e].data.ind === n) return this.elements[e];
                return null;
              }),
              (BaseRenderer.prototype.getElementByPath = function (n) {
                var e = n.shift(),
                  t;
                if (typeof e == "number") t = this.elements[e];
                else {
                  var r,
                    s = this.elements.length;
                  for (r = 0; r < s; r += 1)
                    if (this.elements[r].data.nm === e) {
                      t = this.elements[r];
                      break;
                    }
                }
                return n.length === 0 ? t : t.getElementByPath(n);
              }),
              (BaseRenderer.prototype.setupGlobalData = function (n, e) {
                (this.globalData.fontManager = new FontManager()),
                  (this.globalData.slotManager = slotFactory(n)),
                  this.globalData.fontManager.addChars(n.chars),
                  this.globalData.fontManager.addFonts(n.fonts, e),
                  (this.globalData.getAssetData =
                    this.animationItem.getAssetData.bind(this.animationItem)),
                  (this.globalData.getAssetsPath =
                    this.animationItem.getAssetsPath.bind(this.animationItem)),
                  (this.globalData.imageLoader =
                    this.animationItem.imagePreloader),
                  (this.globalData.audioController =
                    this.animationItem.audioController),
                  (this.globalData.frameId = 0),
                  (this.globalData.frameRate = n.fr),
                  (this.globalData.nm = n.nm),
                  (this.globalData.compSize = { w: n.w, h: n.h });
              });
            var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" };
            function TransformElement() {}
            TransformElement.prototype = {
              initTransform: function () {
                var e = new Matrix();
                (this.finalTransform = {
                  mProp: this.data.ks
                    ? TransformPropertyFactory.getTransformProperty(
                        this,
                        this.data.ks,
                        this
                      )
                    : { o: 0 },
                  _matMdf: !1,
                  _localMatMdf: !1,
                  _opMdf: !1,
                  mat: e,
                  localMat: e,
                  localOpacity: 1,
                }),
                  this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                  this.data.ty;
              },
              renderTransform: function () {
                if (
                  ((this.finalTransform._opMdf =
                    this.finalTransform.mProp.o._mdf || this._isFirstFrame),
                  (this.finalTransform._matMdf =
                    this.finalTransform.mProp._mdf || this._isFirstFrame),
                  this.hierarchy)
                ) {
                  var e,
                    t = this.finalTransform.mat,
                    r = 0,
                    s = this.hierarchy.length;
                  if (!this.finalTransform._matMdf)
                    for (; r < s; ) {
                      if (this.hierarchy[r].finalTransform.mProp._mdf) {
                        this.finalTransform._matMdf = !0;
                        break;
                      }
                      r += 1;
                    }
                  if (this.finalTransform._matMdf)
                    for (
                      e = this.finalTransform.mProp.v.props,
                        t.cloneFromProps(e),
                        r = 0;
                      r < s;
                      r += 1
                    )
                      t.multiply(this.hierarchy[r].finalTransform.mProp.v);
                }
                (!this.localTransforms || this.finalTransform._matMdf) &&
                  (this.finalTransform._localMatMdf =
                    this.finalTransform._matMdf),
                  this.finalTransform._opMdf &&
                    (this.finalTransform.localOpacity =
                      this.finalTransform.mProp.o.v);
              },
              renderLocalTransform: function () {
                if (this.localTransforms) {
                  var e = 0,
                    t = this.localTransforms.length;
                  if (
                    ((this.finalTransform._localMatMdf =
                      this.finalTransform._matMdf),
                    !this.finalTransform._localMatMdf ||
                      !this.finalTransform._opMdf)
                  )
                    for (; e < t; )
                      this.localTransforms[e]._mdf &&
                        (this.finalTransform._localMatMdf = !0),
                        this.localTransforms[e]._opMdf &&
                          !this.finalTransform._opMdf &&
                          ((this.finalTransform.localOpacity =
                            this.finalTransform.mProp.o.v),
                          (this.finalTransform._opMdf = !0)),
                        (e += 1);
                  if (this.finalTransform._localMatMdf) {
                    var r = this.finalTransform.localMat;
                    for (
                      this.localTransforms[0].matrix.clone(r), e = 1;
                      e < t;
                      e += 1
                    ) {
                      var s = this.localTransforms[e].matrix;
                      r.multiply(s);
                    }
                    r.multiply(this.finalTransform.mat);
                  }
                  if (this.finalTransform._opMdf) {
                    var o = this.finalTransform.localOpacity;
                    for (e = 0; e < t; e += 1)
                      o *= this.localTransforms[e].opacity * 0.01;
                    this.finalTransform.localOpacity = o;
                  }
                }
              },
              searchEffectTransforms: function () {
                if (this.renderableEffectsManager) {
                  var e = this.renderableEffectsManager.getEffects(
                    effectTypes.TRANSFORM_EFFECT
                  );
                  if (e.length) {
                    (this.localTransforms = []),
                      (this.finalTransform.localMat = new Matrix());
                    var t = 0,
                      r = e.length;
                    for (t = 0; t < r; t += 1) this.localTransforms.push(e[t]);
                  }
                }
              },
              globalToLocal: function (e) {
                var t = [];
                t.push(this.finalTransform);
                for (var r = !0, s = this.comp; r; )
                  s.finalTransform
                    ? (s.data.hasMask && t.splice(0, 0, s.finalTransform),
                      (s = s.comp))
                    : (r = !1);
                var o,
                  a = t.length,
                  l;
                for (o = 0; o < a; o += 1)
                  (l = t[o].mat.applyToPointArray(0, 0, 0)),
                    (e = [e[0] - l[0], e[1] - l[1], 0]);
                return e;
              },
              mHelper: new Matrix(),
            };
            function MaskElement(n, e, t) {
              (this.data = n),
                (this.element = e),
                (this.globalData = t),
                (this.storedData = []),
                (this.masksProperties = this.data.masksProperties || []),
                (this.maskElement = null);
              var r = this.globalData.defs,
                s,
                o = this.masksProperties ? this.masksProperties.length : 0;
              (this.viewData = createSizedArray(o)), (this.solidPath = "");
              var a,
                l = this.masksProperties,
                c = 0,
                u = [],
                p,
                N,
                P = createElementID(),
                de,
                me,
                Ye,
                nt,
                Be = "clipPath",
                ot = "clip-path";
              for (s = 0; s < o; s += 1)
                if (
                  (((l[s].mode !== "a" && l[s].mode !== "n") ||
                    l[s].inv ||
                    l[s].o.k !== 100 ||
                    l[s].o.x) &&
                    ((Be = "mask"), (ot = "mask")),
                  (l[s].mode === "s" || l[s].mode === "i") && c === 0
                    ? ((de = createNS("rect")),
                      de.setAttribute("fill", "#ffffff"),
                      de.setAttribute("width", this.element.comp.data.w || 0),
                      de.setAttribute("height", this.element.comp.data.h || 0),
                      u.push(de))
                    : (de = null),
                  (a = createNS("path")),
                  l[s].mode === "n")
                )
                  (this.viewData[s] = {
                    op: PropertyFactory.getProp(
                      this.element,
                      l[s].o,
                      0,
                      0.01,
                      this.element
                    ),
                    prop: ShapePropertyFactory.getShapeProp(
                      this.element,
                      l[s],
                      3
                    ),
                    elem: a,
                    lastPath: "",
                  }),
                    r.appendChild(a);
                else {
                  (c += 1),
                    a.setAttribute(
                      "fill",
                      l[s].mode === "s" ? "#000000" : "#ffffff"
                    ),
                    a.setAttribute("clip-rule", "nonzero");
                  var st;
                  if (
                    (l[s].x.k !== 0
                      ? ((Be = "mask"),
                        (ot = "mask"),
                        (nt = PropertyFactory.getProp(
                          this.element,
                          l[s].x,
                          0,
                          null,
                          this.element
                        )),
                        (st = createElementID()),
                        (me = createNS("filter")),
                        me.setAttribute("id", st),
                        (Ye = createNS("feMorphology")),
                        Ye.setAttribute("operator", "erode"),
                        Ye.setAttribute("in", "SourceGraphic"),
                        Ye.setAttribute("radius", "0"),
                        me.appendChild(Ye),
                        r.appendChild(me),
                        a.setAttribute(
                          "stroke",
                          l[s].mode === "s" ? "#000000" : "#ffffff"
                        ))
                      : ((Ye = null), (nt = null)),
                    (this.storedData[s] = {
                      elem: a,
                      x: nt,
                      expan: Ye,
                      lastPath: "",
                      lastOperator: "",
                      filterId: st,
                      lastRadius: 0,
                    }),
                    l[s].mode === "i")
                  ) {
                    N = u.length;
                    var vt = createNS("g");
                    for (p = 0; p < N; p += 1) vt.appendChild(u[p]);
                    var xt = createNS("mask");
                    xt.setAttribute("mask-type", "alpha"),
                      xt.setAttribute("id", P + "_" + c),
                      xt.appendChild(a),
                      r.appendChild(xt),
                      vt.setAttribute(
                        "mask",
                        "url(" + getLocationHref() + "#" + P + "_" + c + ")"
                      ),
                      (u.length = 0),
                      u.push(vt);
                  } else u.push(a);
                  l[s].inv &&
                    !this.solidPath &&
                    (this.solidPath = this.createLayerSolidPath()),
                    (this.viewData[s] = {
                      elem: a,
                      lastPath: "",
                      op: PropertyFactory.getProp(
                        this.element,
                        l[s].o,
                        0,
                        0.01,
                        this.element
                      ),
                      prop: ShapePropertyFactory.getShapeProp(
                        this.element,
                        l[s],
                        3
                      ),
                      invRect: de,
                    }),
                    this.viewData[s].prop.k ||
                      this.drawPath(
                        l[s],
                        this.viewData[s].prop.v,
                        this.viewData[s]
                      );
                }
              for (
                this.maskElement = createNS(Be), o = u.length, s = 0;
                s < o;
                s += 1
              )
                this.maskElement.appendChild(u[s]);
              c > 0 &&
                (this.maskElement.setAttribute("id", P),
                this.element.maskedElement.setAttribute(
                  ot,
                  "url(" + getLocationHref() + "#" + P + ")"
                ),
                r.appendChild(this.maskElement)),
                this.viewData.length &&
                  this.element.addRenderableComponent(this);
            }
            (MaskElement.prototype.getMaskProperty = function (n) {
              return this.viewData[n].prop;
            }),
              (MaskElement.prototype.renderFrame = function (n) {
                var e = this.element.finalTransform.mat,
                  t,
                  r = this.masksProperties.length;
                for (t = 0; t < r; t += 1)
                  if (
                    ((this.viewData[t].prop._mdf || n) &&
                      this.drawPath(
                        this.masksProperties[t],
                        this.viewData[t].prop.v,
                        this.viewData[t]
                      ),
                    (this.viewData[t].op._mdf || n) &&
                      this.viewData[t].elem.setAttribute(
                        "fill-opacity",
                        this.viewData[t].op.v
                      ),
                    this.masksProperties[t].mode !== "n" &&
                      (this.viewData[t].invRect &&
                        (this.element.finalTransform.mProp._mdf || n) &&
                        this.viewData[t].invRect.setAttribute(
                          "transform",
                          e.getInverseMatrix().to2dCSS()
                        ),
                      this.storedData[t].x && (this.storedData[t].x._mdf || n)))
                  ) {
                    var s = this.storedData[t].expan;
                    this.storedData[t].x.v < 0
                      ? (this.storedData[t].lastOperator !== "erode" &&
                          ((this.storedData[t].lastOperator = "erode"),
                          this.storedData[t].elem.setAttribute(
                            "filter",
                            "url(" +
                              getLocationHref() +
                              "#" +
                              this.storedData[t].filterId +
                              ")"
                          )),
                        s.setAttribute("radius", -this.storedData[t].x.v))
                      : (this.storedData[t].lastOperator !== "dilate" &&
                          ((this.storedData[t].lastOperator = "dilate"),
                          this.storedData[t].elem.setAttribute("filter", null)),
                        this.storedData[t].elem.setAttribute(
                          "stroke-width",
                          this.storedData[t].x.v * 2
                        ));
                  }
              }),
              (MaskElement.prototype.getMaskelement = function () {
                return this.maskElement;
              }),
              (MaskElement.prototype.createLayerSolidPath = function () {
                var n = "M0,0 ";
                return (
                  (n += " h" + this.globalData.compSize.w),
                  (n += " v" + this.globalData.compSize.h),
                  (n += " h-" + this.globalData.compSize.w),
                  (n += " v-" + this.globalData.compSize.h + " "),
                  n
                );
              }),
              (MaskElement.prototype.drawPath = function (n, e, t) {
                var r = " M" + e.v[0][0] + "," + e.v[0][1],
                  s,
                  o;
                for (o = e._length, s = 1; s < o; s += 1)
                  r +=
                    " C" +
                    e.o[s - 1][0] +
                    "," +
                    e.o[s - 1][1] +
                    " " +
                    e.i[s][0] +
                    "," +
                    e.i[s][1] +
                    " " +
                    e.v[s][0] +
                    "," +
                    e.v[s][1];
                if (
                  (e.c &&
                    o > 1 &&
                    (r +=
                      " C" +
                      e.o[s - 1][0] +
                      "," +
                      e.o[s - 1][1] +
                      " " +
                      e.i[0][0] +
                      "," +
                      e.i[0][1] +
                      " " +
                      e.v[0][0] +
                      "," +
                      e.v[0][1]),
                  t.lastPath !== r)
                ) {
                  var a = "";
                  t.elem &&
                    (e.c && (a = n.inv ? this.solidPath + r : r),
                    t.elem.setAttribute("d", a)),
                    (t.lastPath = r);
                }
              }),
              (MaskElement.prototype.destroy = function () {
                (this.element = null),
                  (this.globalData = null),
                  (this.maskElement = null),
                  (this.data = null),
                  (this.masksProperties = null);
              });
            var filtersFactory = (function () {
                var n = {};
                (n.createFilter = e), (n.createAlphaToLuminanceFilter = t);
                function e(r, s) {
                  var o = createNS("filter");
                  return (
                    o.setAttribute("id", r),
                    s !== !0 &&
                      (o.setAttribute("filterUnits", "objectBoundingBox"),
                      o.setAttribute("x", "0%"),
                      o.setAttribute("y", "0%"),
                      o.setAttribute("width", "100%"),
                      o.setAttribute("height", "100%")),
                    o
                  );
                }
                function t() {
                  var r = createNS("feColorMatrix");
                  return (
                    r.setAttribute("type", "matrix"),
                    r.setAttribute("color-interpolation-filters", "sRGB"),
                    r.setAttribute(
                      "values",
                      "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"
                    ),
                    r
                  );
                }
                return n;
              })(),
              featureSupport = (function () {
                var n = {
                  maskType: !0,
                  svgLumaHidden: !0,
                  offscreenCanvas: typeof OffscreenCanvas < "u",
                };
                return (
                  (/MSIE 10/i.test(navigator.userAgent) ||
                    /MSIE 9/i.test(navigator.userAgent) ||
                    /rv:11.0/i.test(navigator.userAgent) ||
                    /Edge\/\d./i.test(navigator.userAgent)) &&
                    (n.maskType = !1),
                  /firefox/i.test(navigator.userAgent) &&
                    (n.svgLumaHidden = !1),
                  n
                );
              })(),
              registeredEffects$1 = {},
              idPrefix = "filter_result_";
            function SVGEffects(n) {
              var e,
                t = "SourceGraphic",
                r = n.data.ef ? n.data.ef.length : 0,
                s = createElementID(),
                o = filtersFactory.createFilter(s, !0),
                a = 0;
              this.filters = [];
              var l;
              for (e = 0; e < r; e += 1) {
                l = null;
                var c = n.data.ef[e].ty;
                if (registeredEffects$1[c]) {
                  var u = registeredEffects$1[c].effect;
                  (l = new u(
                    o,
                    n.effectsManager.effectElements[e],
                    n,
                    idPrefix + a,
                    t
                  )),
                    (t = idPrefix + a),
                    registeredEffects$1[c].countsAsEffect && (a += 1);
                }
                l && this.filters.push(l);
              }
              a &&
                (n.globalData.defs.appendChild(o),
                n.layerElement.setAttribute(
                  "filter",
                  "url(" + getLocationHref() + "#" + s + ")"
                )),
                this.filters.length && n.addRenderableComponent(this);
            }
            (SVGEffects.prototype.renderFrame = function (n) {
              var e,
                t = this.filters.length;
              for (e = 0; e < t; e += 1) this.filters[e].renderFrame(n);
            }),
              (SVGEffects.prototype.getEffects = function (n) {
                var e,
                  t = this.filters.length,
                  r = [];
                for (e = 0; e < t; e += 1)
                  this.filters[e].type === n && r.push(this.filters[e]);
                return r;
              });
            function registerEffect$1(n, e, t) {
              registeredEffects$1[n] = { effect: e, countsAsEffect: t };
            }
            function SVGBaseElement() {}
            SVGBaseElement.prototype = {
              initRendererElement: function () {
                this.layerElement = createNS("g");
              },
              createContainerElements: function () {
                (this.matteElement = createNS("g")),
                  (this.transformedElement = this.layerElement),
                  (this.maskedElement = this.layerElement),
                  (this._sizeChanged = !1);
                var e = null;
                if (this.data.td) {
                  this.matteMasks = {};
                  var t = createNS("g");
                  t.setAttribute("id", this.layerId),
                    t.appendChild(this.layerElement),
                    (e = t),
                    this.globalData.defs.appendChild(t);
                } else
                  this.data.tt
                    ? (this.matteElement.appendChild(this.layerElement),
                      (e = this.matteElement),
                      (this.baseElement = this.matteElement))
                    : (this.baseElement = this.layerElement);
                if (
                  (this.data.ln &&
                    this.layerElement.setAttribute("id", this.data.ln),
                  this.data.cl &&
                    this.layerElement.setAttribute("class", this.data.cl),
                  this.data.ty === 0 && !this.data.hd)
                ) {
                  var r = createNS("clipPath"),
                    s = createNS("path");
                  s.setAttribute(
                    "d",
                    "M0,0 L" +
                      this.data.w +
                      ",0 L" +
                      this.data.w +
                      "," +
                      this.data.h +
                      " L0," +
                      this.data.h +
                      "z"
                  );
                  var o = createElementID();
                  if (
                    (r.setAttribute("id", o),
                    r.appendChild(s),
                    this.globalData.defs.appendChild(r),
                    this.checkMasks())
                  ) {
                    var a = createNS("g");
                    a.setAttribute(
                      "clip-path",
                      "url(" + getLocationHref() + "#" + o + ")"
                    ),
                      a.appendChild(this.layerElement),
                      (this.transformedElement = a),
                      e
                        ? e.appendChild(this.transformedElement)
                        : (this.baseElement = this.transformedElement);
                  } else
                    this.layerElement.setAttribute(
                      "clip-path",
                      "url(" + getLocationHref() + "#" + o + ")"
                    );
                }
                this.data.bm !== 0 && this.setBlendMode();
              },
              renderElement: function () {
                this.finalTransform._localMatMdf &&
                  this.transformedElement.setAttribute(
                    "transform",
                    this.finalTransform.localMat.to2dCSS()
                  ),
                  this.finalTransform._opMdf &&
                    this.transformedElement.setAttribute(
                      "opacity",
                      this.finalTransform.localOpacity
                    );
              },
              destroyBaseElement: function () {
                (this.layerElement = null),
                  (this.matteElement = null),
                  this.maskManager.destroy();
              },
              getBaseElement: function () {
                return this.data.hd ? null : this.baseElement;
              },
              createRenderableComponents: function () {
                (this.maskManager = new MaskElement(
                  this.data,
                  this,
                  this.globalData
                )),
                  (this.renderableEffectsManager = new SVGEffects(this)),
                  this.searchEffectTransforms();
              },
              getMatte: function (e) {
                if (
                  (this.matteMasks || (this.matteMasks = {}),
                  !this.matteMasks[e])
                ) {
                  var t = this.layerId + "_" + e,
                    r,
                    s,
                    o,
                    a;
                  if (e === 1 || e === 3) {
                    var l = createNS("mask");
                    l.setAttribute("id", t),
                      l.setAttribute(
                        "mask-type",
                        e === 3 ? "luminance" : "alpha"
                      ),
                      (o = createNS("use")),
                      o.setAttributeNS(
                        "http://www.w3.org/1999/xlink",
                        "href",
                        "#" + this.layerId
                      ),
                      l.appendChild(o),
                      this.globalData.defs.appendChild(l),
                      !featureSupport.maskType &&
                        e === 1 &&
                        (l.setAttribute("mask-type", "luminance"),
                        (r = createElementID()),
                        (s = filtersFactory.createFilter(r)),
                        this.globalData.defs.appendChild(s),
                        s.appendChild(
                          filtersFactory.createAlphaToLuminanceFilter()
                        ),
                        (a = createNS("g")),
                        a.appendChild(o),
                        l.appendChild(a),
                        a.setAttribute(
                          "filter",
                          "url(" + getLocationHref() + "#" + r + ")"
                        ));
                  } else if (e === 2) {
                    var c = createNS("mask");
                    c.setAttribute("id", t),
                      c.setAttribute("mask-type", "alpha");
                    var u = createNS("g");
                    c.appendChild(u),
                      (r = createElementID()),
                      (s = filtersFactory.createFilter(r));
                    var p = createNS("feComponentTransfer");
                    p.setAttribute("in", "SourceGraphic"), s.appendChild(p);
                    var N = createNS("feFuncA");
                    N.setAttribute("type", "table"),
                      N.setAttribute("tableValues", "1.0 0.0"),
                      p.appendChild(N),
                      this.globalData.defs.appendChild(s);
                    var P = createNS("rect");
                    P.setAttribute("width", this.comp.data.w),
                      P.setAttribute("height", this.comp.data.h),
                      P.setAttribute("x", "0"),
                      P.setAttribute("y", "0"),
                      P.setAttribute("fill", "#ffffff"),
                      P.setAttribute("opacity", "0"),
                      u.setAttribute(
                        "filter",
                        "url(" + getLocationHref() + "#" + r + ")"
                      ),
                      u.appendChild(P),
                      (o = createNS("use")),
                      o.setAttributeNS(
                        "http://www.w3.org/1999/xlink",
                        "href",
                        "#" + this.layerId
                      ),
                      u.appendChild(o),
                      featureSupport.maskType ||
                        (c.setAttribute("mask-type", "luminance"),
                        s.appendChild(
                          filtersFactory.createAlphaToLuminanceFilter()
                        ),
                        (a = createNS("g")),
                        u.appendChild(P),
                        a.appendChild(this.layerElement),
                        u.appendChild(a)),
                      this.globalData.defs.appendChild(c);
                  }
                  this.matteMasks[e] = t;
                }
                return this.matteMasks[e];
              },
              setMatte: function (e) {
                this.matteElement &&
                  this.matteElement.setAttribute(
                    "mask",
                    "url(" + getLocationHref() + "#" + e + ")"
                  );
              },
            };
            function HierarchyElement() {}
            HierarchyElement.prototype = {
              initHierarchy: function () {
                (this.hierarchy = []),
                  (this._isParent = !1),
                  this.checkParenting();
              },
              setHierarchy: function (e) {
                this.hierarchy = e;
              },
              setAsParent: function () {
                this._isParent = !0;
              },
              checkParenting: function () {
                this.data.parent !== void 0 &&
                  this.comp.buildElementParenting(this, this.data.parent, []);
              },
            };
            function RenderableDOMElement() {}
            (function () {
              var n = {
                initElement: function (t, r, s) {
                  this.initFrame(),
                    this.initBaseData(t, r, s),
                    this.initTransform(t, r, s),
                    this.initHierarchy(),
                    this.initRenderable(),
                    this.initRendererElement(),
                    this.createContainerElements(),
                    this.createRenderableComponents(),
                    this.createContent(),
                    this.hide();
                },
                hide: function () {
                  if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                    var t = this.baseElement || this.layerElement;
                    (t.style.display = "none"), (this.hidden = !0);
                  }
                },
                show: function () {
                  if (this.isInRange && !this.isTransparent) {
                    if (!this.data.hd) {
                      var t = this.baseElement || this.layerElement;
                      t.style.display = "block";
                    }
                    (this.hidden = !1), (this._isFirstFrame = !0);
                  }
                },
                renderFrame: function () {
                  this.data.hd ||
                    this.hidden ||
                    (this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.renderElement(),
                    this.renderInnerContent(),
                    this._isFirstFrame && (this._isFirstFrame = !1));
                },
                renderInnerContent: function () {},
                prepareFrame: function (t) {
                  (this._mdf = !1),
                    this.prepareRenderableFrame(t),
                    this.prepareProperties(t, this.isInRange),
                    this.checkTransparency();
                },
                destroy: function () {
                  (this.innerElem = null), this.destroyBaseElement();
                },
              };
              extendPrototype(
                [RenderableElement, createProxyFunction(n)],
                RenderableDOMElement
              );
            })();
            function IImageElement(n, e, t) {
              (this.assetData = e.getAssetData(n.refId)),
                this.assetData &&
                  this.assetData.sid &&
                  (this.assetData = e.slotManager.getProp(this.assetData)),
                this.initElement(n, e, t),
                (this.sourceRect = {
                  top: 0,
                  left: 0,
                  width: this.assetData.w,
                  height: this.assetData.h,
                });
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                SVGBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableDOMElement,
              ],
              IImageElement
            ),
              (IImageElement.prototype.createContent = function () {
                var n = this.globalData.getAssetsPath(this.assetData);
                (this.innerElem = createNS("image")),
                  this.innerElem.setAttribute("width", this.assetData.w + "px"),
                  this.innerElem.setAttribute(
                    "height",
                    this.assetData.h + "px"
                  ),
                  this.innerElem.setAttribute(
                    "preserveAspectRatio",
                    this.assetData.pr ||
                      this.globalData.renderConfig.imagePreserveAspectRatio
                  ),
                  this.innerElem.setAttributeNS(
                    "http://www.w3.org/1999/xlink",
                    "href",
                    n
                  ),
                  this.layerElement.appendChild(this.innerElem);
              }),
              (IImageElement.prototype.sourceRectAtTime = function () {
                return this.sourceRect;
              });
            function ProcessedElement(n, e) {
              (this.elem = n), (this.pos = e);
            }
            function IShapeElement() {}
            IShapeElement.prototype = {
              addShapeToModifiers: function (e) {
                var t,
                  r = this.shapeModifiers.length;
                for (t = 0; t < r; t += 1) this.shapeModifiers[t].addShape(e);
              },
              isShapeInAnimatedModifiers: function (e) {
                for (var t = 0, r = this.shapeModifiers.length; t < r; )
                  if (this.shapeModifiers[t].isAnimatedWithShape(e)) return !0;
                return !1;
              },
              renderModifiers: function () {
                if (this.shapeModifiers.length) {
                  var e,
                    t = this.shapes.length;
                  for (e = 0; e < t; e += 1) this.shapes[e].sh.reset();
                  t = this.shapeModifiers.length;
                  var r;
                  for (
                    e = t - 1;
                    e >= 0 &&
                    ((r = this.shapeModifiers[e].processShapes(
                      this._isFirstFrame
                    )),
                    !r);
                    e -= 1
                  );
                }
              },
              searchProcessedElement: function (e) {
                for (
                  var t = this.processedElements, r = 0, s = t.length;
                  r < s;

                ) {
                  if (t[r].elem === e) return t[r].pos;
                  r += 1;
                }
                return 0;
              },
              addProcessedElement: function (e, t) {
                for (var r = this.processedElements, s = r.length; s; )
                  if (((s -= 1), r[s].elem === e)) {
                    r[s].pos = t;
                    return;
                  }
                r.push(new ProcessedElement(e, t));
              },
              prepareFrame: function (e) {
                this.prepareRenderableFrame(e),
                  this.prepareProperties(e, this.isInRange);
              },
            };
            var lineCapEnum = { 1: "butt", 2: "round", 3: "square" },
              lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" };
            function SVGShapeData(n, e, t) {
              (this.caches = []),
                (this.styles = []),
                (this.transformers = n),
                (this.lStr = ""),
                (this.sh = t),
                (this.lvl = e),
                (this._isAnimated = !!t.k);
              for (var r = 0, s = n.length; r < s; ) {
                if (n[r].mProps.dynamicProperties.length) {
                  this._isAnimated = !0;
                  break;
                }
                r += 1;
              }
            }
            SVGShapeData.prototype.setAsAnimated = function () {
              this._isAnimated = !0;
            };
            function SVGStyleData(n, e) {
              (this.data = n),
                (this.type = n.ty),
                (this.d = ""),
                (this.lvl = e),
                (this._mdf = !1),
                (this.closed = n.hd === !0),
                (this.pElem = createNS("path")),
                (this.msElem = null);
            }
            SVGStyleData.prototype.reset = function () {
              (this.d = ""), (this._mdf = !1);
            };
            function DashProperty(n, e, t, r) {
              (this.elem = n),
                (this.frameId = -1),
                (this.dataProps = createSizedArray(e.length)),
                (this.renderer = t),
                (this.k = !1),
                (this.dashStr = ""),
                (this.dashArray = createTypedArray(
                  "float32",
                  e.length ? e.length - 1 : 0
                )),
                (this.dashoffset = createTypedArray("float32", 1)),
                this.initDynamicPropertyContainer(r);
              var s,
                o = e.length || 0,
                a;
              for (s = 0; s < o; s += 1)
                (a = PropertyFactory.getProp(n, e[s].v, 0, 0, this)),
                  (this.k = a.k || this.k),
                  (this.dataProps[s] = { n: e[s].n, p: a });
              this.k || this.getValue(!0), (this._isAnimated = this.k);
            }
            (DashProperty.prototype.getValue = function (n) {
              if (
                !(this.elem.globalData.frameId === this.frameId && !n) &&
                ((this.frameId = this.elem.globalData.frameId),
                this.iterateDynamicProperties(),
                (this._mdf = this._mdf || n),
                this._mdf)
              ) {
                var e = 0,
                  t = this.dataProps.length;
                for (
                  this.renderer === "svg" && (this.dashStr = ""), e = 0;
                  e < t;
                  e += 1
                )
                  this.dataProps[e].n !== "o"
                    ? this.renderer === "svg"
                      ? (this.dashStr += " " + this.dataProps[e].p.v)
                      : (this.dashArray[e] = this.dataProps[e].p.v)
                    : (this.dashoffset[0] = this.dataProps[e].p.v);
              }
            }),
              extendPrototype([DynamicPropertyContainer], DashProperty);
            function SVGStrokeStyleData(n, e, t) {
              this.initDynamicPropertyContainer(n),
                (this.getValue = this.iterateDynamicProperties),
                (this.o = PropertyFactory.getProp(n, e.o, 0, 0.01, this)),
                (this.w = PropertyFactory.getProp(n, e.w, 0, null, this)),
                (this.d = new DashProperty(n, e.d || {}, "svg", this)),
                (this.c = PropertyFactory.getProp(n, e.c, 1, 255, this)),
                (this.style = t),
                (this._isAnimated = !!this._isAnimated);
            }
            extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
            function SVGFillStyleData(n, e, t) {
              this.initDynamicPropertyContainer(n),
                (this.getValue = this.iterateDynamicProperties),
                (this.o = PropertyFactory.getProp(n, e.o, 0, 0.01, this)),
                (this.c = PropertyFactory.getProp(n, e.c, 1, 255, this)),
                (this.style = t);
            }
            extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
            function SVGNoStyleData(n, e, t) {
              this.initDynamicPropertyContainer(n),
                (this.getValue = this.iterateDynamicProperties),
                (this.style = t);
            }
            extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
            function GradientProperty(n, e, t) {
              (this.data = e), (this.c = createTypedArray("uint8c", e.p * 4));
              var r = e.k.k[0].s
                ? e.k.k[0].s.length - e.p * 4
                : e.k.k.length - e.p * 4;
              (this.o = createTypedArray("float32", r)),
                (this._cmdf = !1),
                (this._omdf = !1),
                (this._collapsable = this.checkCollapsable()),
                (this._hasOpacity = r),
                this.initDynamicPropertyContainer(t),
                (this.prop = PropertyFactory.getProp(n, e.k, 1, null, this)),
                (this.k = this.prop.k),
                this.getValue(!0);
            }
            (GradientProperty.prototype.comparePoints = function (n, e) {
              for (var t = 0, r = this.o.length / 2, s; t < r; ) {
                if (((s = Math.abs(n[t * 4] - n[e * 4 + t * 2])), s > 0.01))
                  return !1;
                t += 1;
              }
              return !0;
            }),
              (GradientProperty.prototype.checkCollapsable = function () {
                if (this.o.length / 2 !== this.c.length / 4) return !1;
                if (this.data.k.k[0].s)
                  for (var n = 0, e = this.data.k.k.length; n < e; ) {
                    if (!this.comparePoints(this.data.k.k[n].s, this.data.p))
                      return !1;
                    n += 1;
                  }
                else if (!this.comparePoints(this.data.k.k, this.data.p))
                  return !1;
                return !0;
              }),
              (GradientProperty.prototype.getValue = function (n) {
                if (
                  (this.prop.getValue(),
                  (this._mdf = !1),
                  (this._cmdf = !1),
                  (this._omdf = !1),
                  this.prop._mdf || n)
                ) {
                  var e,
                    t = this.data.p * 4,
                    r,
                    s;
                  for (e = 0; e < t; e += 1)
                    (r = e % 4 === 0 ? 100 : 255),
                      (s = Math.round(this.prop.v[e] * r)),
                      this.c[e] !== s && ((this.c[e] = s), (this._cmdf = !n));
                  if (this.o.length)
                    for (
                      t = this.prop.v.length, e = this.data.p * 4;
                      e < t;
                      e += 1
                    )
                      (r = e % 2 === 0 ? 100 : 1),
                        (s =
                          e % 2 === 0
                            ? Math.round(this.prop.v[e] * 100)
                            : this.prop.v[e]),
                        this.o[e - this.data.p * 4] !== s &&
                          ((this.o[e - this.data.p * 4] = s),
                          (this._omdf = !n));
                  this._mdf = !n;
                }
              }),
              extendPrototype([DynamicPropertyContainer], GradientProperty);
            function SVGGradientFillStyleData(n, e, t) {
              this.initDynamicPropertyContainer(n),
                (this.getValue = this.iterateDynamicProperties),
                this.initGradientData(n, e, t);
            }
            (SVGGradientFillStyleData.prototype.initGradientData = function (
              n,
              e,
              t
            ) {
              (this.o = PropertyFactory.getProp(n, e.o, 0, 0.01, this)),
                (this.s = PropertyFactory.getProp(n, e.s, 1, null, this)),
                (this.e = PropertyFactory.getProp(n, e.e, 1, null, this)),
                (this.h = PropertyFactory.getProp(
                  n,
                  e.h || { k: 0 },
                  0,
                  0.01,
                  this
                )),
                (this.a = PropertyFactory.getProp(
                  n,
                  e.a || { k: 0 },
                  0,
                  degToRads,
                  this
                )),
                (this.g = new GradientProperty(n, e.g, this)),
                (this.style = t),
                (this.stops = []),
                this.setGradientData(t.pElem, e),
                this.setGradientOpacity(e, t),
                (this._isAnimated = !!this._isAnimated);
            }),
              (SVGGradientFillStyleData.prototype.setGradientData = function (
                n,
                e
              ) {
                var t = createElementID(),
                  r = createNS(e.t === 1 ? "linearGradient" : "radialGradient");
                r.setAttribute("id", t),
                  r.setAttribute("spreadMethod", "pad"),
                  r.setAttribute("gradientUnits", "userSpaceOnUse");
                var s = [],
                  o,
                  a,
                  l;
                for (l = e.g.p * 4, a = 0; a < l; a += 4)
                  (o = createNS("stop")), r.appendChild(o), s.push(o);
                n.setAttribute(
                  e.ty === "gf" ? "fill" : "stroke",
                  "url(" + getLocationHref() + "#" + t + ")"
                ),
                  (this.gf = r),
                  (this.cst = s);
              }),
              (SVGGradientFillStyleData.prototype.setGradientOpacity =
                function (n, e) {
                  if (this.g._hasOpacity && !this.g._collapsable) {
                    var t,
                      r,
                      s,
                      o = createNS("mask"),
                      a = createNS("path");
                    o.appendChild(a);
                    var l = createElementID(),
                      c = createElementID();
                    o.setAttribute("id", c);
                    var u = createNS(
                      n.t === 1 ? "linearGradient" : "radialGradient"
                    );
                    u.setAttribute("id", l),
                      u.setAttribute("spreadMethod", "pad"),
                      u.setAttribute("gradientUnits", "userSpaceOnUse"),
                      (s = n.g.k.k[0].s ? n.g.k.k[0].s.length : n.g.k.k.length);
                    var p = this.stops;
                    for (r = n.g.p * 4; r < s; r += 2)
                      (t = createNS("stop")),
                        t.setAttribute("stop-color", "rgb(255,255,255)"),
                        u.appendChild(t),
                        p.push(t);
                    a.setAttribute(
                      n.ty === "gf" ? "fill" : "stroke",
                      "url(" + getLocationHref() + "#" + l + ")"
                    ),
                      n.ty === "gs" &&
                        (a.setAttribute(
                          "stroke-linecap",
                          lineCapEnum[n.lc || 2]
                        ),
                        a.setAttribute(
                          "stroke-linejoin",
                          lineJoinEnum[n.lj || 2]
                        ),
                        n.lj === 1 &&
                          a.setAttribute("stroke-miterlimit", n.ml)),
                      (this.of = u),
                      (this.ms = o),
                      (this.ost = p),
                      (this.maskId = c),
                      (e.msElem = a);
                  }
                }),
              extendPrototype(
                [DynamicPropertyContainer],
                SVGGradientFillStyleData
              );
            function SVGGradientStrokeStyleData(n, e, t) {
              this.initDynamicPropertyContainer(n),
                (this.getValue = this.iterateDynamicProperties),
                (this.w = PropertyFactory.getProp(n, e.w, 0, null, this)),
                (this.d = new DashProperty(n, e.d || {}, "svg", this)),
                this.initGradientData(n, e, t),
                (this._isAnimated = !!this._isAnimated);
            }
            extendPrototype(
              [SVGGradientFillStyleData, DynamicPropertyContainer],
              SVGGradientStrokeStyleData
            );
            function ShapeGroupData() {
              (this.it = []),
                (this.prevViewData = []),
                (this.gr = createNS("g"));
            }
            function SVGTransformData(n, e, t) {
              (this.transform = { mProps: n, op: e, container: t }),
                (this.elements = []),
                (this._isAnimated =
                  this.transform.mProps.dynamicProperties.length ||
                  this.transform.op.effectsSequence.length);
            }
            var buildShapeString = function (e, t, r, s) {
                if (t === 0) return "";
                var o = e.o,
                  a = e.i,
                  l = e.v,
                  c,
                  u = " M" + s.applyToPointStringified(l[0][0], l[0][1]);
                for (c = 1; c < t; c += 1)
                  u +=
                    " C" +
                    s.applyToPointStringified(o[c - 1][0], o[c - 1][1]) +
                    " " +
                    s.applyToPointStringified(a[c][0], a[c][1]) +
                    " " +
                    s.applyToPointStringified(l[c][0], l[c][1]);
                return (
                  r &&
                    t &&
                    ((u +=
                      " C" +
                      s.applyToPointStringified(o[c - 1][0], o[c - 1][1]) +
                      " " +
                      s.applyToPointStringified(a[0][0], a[0][1]) +
                      " " +
                      s.applyToPointStringified(l[0][0], l[0][1])),
                    (u += "z")),
                  u
                );
              },
              SVGElementsRenderer = (function () {
                var n = new Matrix(),
                  e = new Matrix(),
                  t = { createRenderFunction: r };
                function r(N) {
                  switch (N.ty) {
                    case "fl":
                      return l;
                    case "gf":
                      return u;
                    case "gs":
                      return c;
                    case "st":
                      return p;
                    case "sh":
                    case "el":
                    case "rc":
                    case "sr":
                      return a;
                    case "tr":
                      return s;
                    case "no":
                      return o;
                    default:
                      return null;
                  }
                }
                function s(N, P, de) {
                  (de || P.transform.op._mdf) &&
                    P.transform.container.setAttribute(
                      "opacity",
                      P.transform.op.v
                    ),
                    (de || P.transform.mProps._mdf) &&
                      P.transform.container.setAttribute(
                        "transform",
                        P.transform.mProps.v.to2dCSS()
                      );
                }
                function o() {}
                function a(N, P, de) {
                  var me,
                    Ye,
                    nt,
                    Be,
                    ot,
                    st,
                    vt = P.styles.length,
                    xt = P.lvl,
                    St,
                    wt,
                    bt,
                    Tt;
                  for (st = 0; st < vt; st += 1) {
                    if (((Be = P.sh._mdf || de), P.styles[st].lvl < xt)) {
                      for (
                        wt = e.reset(),
                          bt = xt - P.styles[st].lvl,
                          Tt = P.transformers.length - 1;
                        !Be && bt > 0;

                      )
                        (Be = P.transformers[Tt].mProps._mdf || Be),
                          (bt -= 1),
                          (Tt -= 1);
                      if (Be)
                        for (
                          bt = xt - P.styles[st].lvl,
                            Tt = P.transformers.length - 1;
                          bt > 0;

                        )
                          wt.multiply(P.transformers[Tt].mProps.v),
                            (bt -= 1),
                            (Tt -= 1);
                    } else wt = n;
                    if (((St = P.sh.paths), (Ye = St._length), Be)) {
                      for (nt = "", me = 0; me < Ye; me += 1)
                        (ot = St.shapes[me]),
                          ot &&
                            ot._length &&
                            (nt += buildShapeString(ot, ot._length, ot.c, wt));
                      P.caches[st] = nt;
                    } else nt = P.caches[st];
                    (P.styles[st].d += N.hd === !0 ? "" : nt),
                      (P.styles[st]._mdf = Be || P.styles[st]._mdf);
                  }
                }
                function l(N, P, de) {
                  var me = P.style;
                  (P.c._mdf || de) &&
                    me.pElem.setAttribute(
                      "fill",
                      "rgb(" +
                        bmFloor(P.c.v[0]) +
                        "," +
                        bmFloor(P.c.v[1]) +
                        "," +
                        bmFloor(P.c.v[2]) +
                        ")"
                    ),
                    (P.o._mdf || de) &&
                      me.pElem.setAttribute("fill-opacity", P.o.v);
                }
                function c(N, P, de) {
                  u(N, P, de), p(N, P, de);
                }
                function u(N, P, de) {
                  var me = P.gf,
                    Ye = P.g._hasOpacity,
                    nt = P.s.v,
                    Be = P.e.v;
                  if (P.o._mdf || de) {
                    var ot = N.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                    P.style.pElem.setAttribute(ot, P.o.v);
                  }
                  if (P.s._mdf || de) {
                    var st = N.t === 1 ? "x1" : "cx",
                      vt = st === "x1" ? "y1" : "cy";
                    me.setAttribute(st, nt[0]),
                      me.setAttribute(vt, nt[1]),
                      Ye &&
                        !P.g._collapsable &&
                        (P.of.setAttribute(st, nt[0]),
                        P.of.setAttribute(vt, nt[1]));
                  }
                  var xt, St, wt, bt;
                  if (P.g._cmdf || de) {
                    xt = P.cst;
                    var Tt = P.g.c;
                    for (wt = xt.length, St = 0; St < wt; St += 1)
                      (bt = xt[St]),
                        bt.setAttribute("offset", Tt[St * 4] + "%"),
                        bt.setAttribute(
                          "stop-color",
                          "rgb(" +
                            Tt[St * 4 + 1] +
                            "," +
                            Tt[St * 4 + 2] +
                            "," +
                            Tt[St * 4 + 3] +
                            ")"
                        );
                  }
                  if (Ye && (P.g._omdf || de)) {
                    var Ct = P.g.o;
                    for (
                      P.g._collapsable ? (xt = P.cst) : (xt = P.ost),
                        wt = xt.length,
                        St = 0;
                      St < wt;
                      St += 1
                    )
                      (bt = xt[St]),
                        P.g._collapsable ||
                          bt.setAttribute("offset", Ct[St * 2] + "%"),
                        bt.setAttribute("stop-opacity", Ct[St * 2 + 1]);
                  }
                  if (N.t === 1)
                    (P.e._mdf || de) &&
                      (me.setAttribute("x2", Be[0]),
                      me.setAttribute("y2", Be[1]),
                      Ye &&
                        !P.g._collapsable &&
                        (P.of.setAttribute("x2", Be[0]),
                        P.of.setAttribute("y2", Be[1])));
                  else {
                    var kt;
                    if (
                      ((P.s._mdf || P.e._mdf || de) &&
                        ((kt = Math.sqrt(
                          Math.pow(nt[0] - Be[0], 2) +
                            Math.pow(nt[1] - Be[1], 2)
                        )),
                        me.setAttribute("r", kt),
                        Ye && !P.g._collapsable && P.of.setAttribute("r", kt)),
                      P.s._mdf || P.e._mdf || P.h._mdf || P.a._mdf || de)
                    ) {
                      kt ||
                        (kt = Math.sqrt(
                          Math.pow(nt[0] - Be[0], 2) +
                            Math.pow(nt[1] - Be[1], 2)
                        ));
                      var Dt = Math.atan2(Be[1] - nt[1], Be[0] - nt[0]),
                        Vt = P.h.v;
                      Vt >= 1 ? (Vt = 0.99) : Vt <= -1 && (Vt = -0.99);
                      var Ht = kt * Vt,
                        qt = Math.cos(Dt + P.a.v) * Ht + nt[0],
                        Ft = Math.sin(Dt + P.a.v) * Ht + nt[1];
                      me.setAttribute("fx", qt),
                        me.setAttribute("fy", Ft),
                        Ye &&
                          !P.g._collapsable &&
                          (P.of.setAttribute("fx", qt),
                          P.of.setAttribute("fy", Ft));
                    }
                  }
                }
                function p(N, P, de) {
                  var me = P.style,
                    Ye = P.d;
                  Ye &&
                    (Ye._mdf || de) &&
                    Ye.dashStr &&
                    (me.pElem.setAttribute("stroke-dasharray", Ye.dashStr),
                    me.pElem.setAttribute(
                      "stroke-dashoffset",
                      Ye.dashoffset[0]
                    )),
                    P.c &&
                      (P.c._mdf || de) &&
                      me.pElem.setAttribute(
                        "stroke",
                        "rgb(" +
                          bmFloor(P.c.v[0]) +
                          "," +
                          bmFloor(P.c.v[1]) +
                          "," +
                          bmFloor(P.c.v[2]) +
                          ")"
                      ),
                    (P.o._mdf || de) &&
                      me.pElem.setAttribute("stroke-opacity", P.o.v),
                    (P.w._mdf || de) &&
                      (me.pElem.setAttribute("stroke-width", P.w.v),
                      me.msElem &&
                        me.msElem.setAttribute("stroke-width", P.w.v));
                }
                return t;
              })();
            function SVGShapeElement(n, e, t) {
              (this.shapes = []),
                (this.shapesData = n.shapes),
                (this.stylesList = []),
                (this.shapeModifiers = []),
                (this.itemsData = []),
                (this.processedElements = []),
                (this.animatedContents = []),
                this.initElement(n, e, t),
                (this.prevViewData = []);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                SVGBaseElement,
                IShapeElement,
                HierarchyElement,
                FrameElement,
                RenderableDOMElement,
              ],
              SVGShapeElement
            ),
              (SVGShapeElement.prototype.initSecondaryElement = function () {}),
              (SVGShapeElement.prototype.identityMatrix = new Matrix()),
              (SVGShapeElement.prototype.buildExpressionInterface =
                function () {}),
              (SVGShapeElement.prototype.createContent = function () {
                this.searchShapes(
                  this.shapesData,
                  this.itemsData,
                  this.prevViewData,
                  this.layerElement,
                  0,
                  [],
                  !0
                ),
                  this.filterUniqueShapes();
              }),
              (SVGShapeElement.prototype.filterUniqueShapes = function () {
                var n,
                  e = this.shapes.length,
                  t,
                  r,
                  s = this.stylesList.length,
                  o,
                  a = [],
                  l = !1;
                for (r = 0; r < s; r += 1) {
                  for (
                    o = this.stylesList[r], l = !1, a.length = 0, n = 0;
                    n < e;
                    n += 1
                  )
                    (t = this.shapes[n]),
                      t.styles.indexOf(o) !== -1 &&
                        (a.push(t), (l = t._isAnimated || l));
                  a.length > 1 && l && this.setShapesAsAnimated(a);
                }
              }),
              (SVGShapeElement.prototype.setShapesAsAnimated = function (n) {
                var e,
                  t = n.length;
                for (e = 0; e < t; e += 1) n[e].setAsAnimated();
              }),
              (SVGShapeElement.prototype.createStyleElement = function (n, e) {
                var t,
                  r = new SVGStyleData(n, e),
                  s = r.pElem;
                if (n.ty === "st") t = new SVGStrokeStyleData(this, n, r);
                else if (n.ty === "fl") t = new SVGFillStyleData(this, n, r);
                else if (n.ty === "gf" || n.ty === "gs") {
                  var o =
                    n.ty === "gf"
                      ? SVGGradientFillStyleData
                      : SVGGradientStrokeStyleData;
                  (t = new o(this, n, r)),
                    this.globalData.defs.appendChild(t.gf),
                    t.maskId &&
                      (this.globalData.defs.appendChild(t.ms),
                      this.globalData.defs.appendChild(t.of),
                      s.setAttribute(
                        "mask",
                        "url(" + getLocationHref() + "#" + t.maskId + ")"
                      ));
                } else n.ty === "no" && (t = new SVGNoStyleData(this, n, r));
                return (
                  (n.ty === "st" || n.ty === "gs") &&
                    (s.setAttribute("stroke-linecap", lineCapEnum[n.lc || 2]),
                    s.setAttribute("stroke-linejoin", lineJoinEnum[n.lj || 2]),
                    s.setAttribute("fill-opacity", "0"),
                    n.lj === 1 && s.setAttribute("stroke-miterlimit", n.ml)),
                  n.r === 2 && s.setAttribute("fill-rule", "evenodd"),
                  n.ln && s.setAttribute("id", n.ln),
                  n.cl && s.setAttribute("class", n.cl),
                  n.bm && (s.style["mix-blend-mode"] = getBlendMode(n.bm)),
                  this.stylesList.push(r),
                  this.addToAnimatedContents(n, t),
                  t
                );
              }),
              (SVGShapeElement.prototype.createGroupElement = function (n) {
                var e = new ShapeGroupData();
                return (
                  n.ln && e.gr.setAttribute("id", n.ln),
                  n.cl && e.gr.setAttribute("class", n.cl),
                  n.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(n.bm)),
                  e
                );
              }),
              (SVGShapeElement.prototype.createTransformElement = function (
                n,
                e
              ) {
                var t = TransformPropertyFactory.getTransformProperty(
                    this,
                    n,
                    this
                  ),
                  r = new SVGTransformData(t, t.o, e);
                return this.addToAnimatedContents(n, r), r;
              }),
              (SVGShapeElement.prototype.createShapeElement = function (
                n,
                e,
                t
              ) {
                var r = 4;
                n.ty === "rc"
                  ? (r = 5)
                  : n.ty === "el"
                  ? (r = 6)
                  : n.ty === "sr" && (r = 7);
                var s = ShapePropertyFactory.getShapeProp(this, n, r, this),
                  o = new SVGShapeData(e, t, s);
                return (
                  this.shapes.push(o),
                  this.addShapeToModifiers(o),
                  this.addToAnimatedContents(n, o),
                  o
                );
              }),
              (SVGShapeElement.prototype.addToAnimatedContents = function (
                n,
                e
              ) {
                for (var t = 0, r = this.animatedContents.length; t < r; ) {
                  if (this.animatedContents[t].element === e) return;
                  t += 1;
                }
                this.animatedContents.push({
                  fn: SVGElementsRenderer.createRenderFunction(n),
                  element: e,
                  data: n,
                });
              }),
              (SVGShapeElement.prototype.setElementStyles = function (n) {
                var e = n.styles,
                  t,
                  r = this.stylesList.length;
                for (t = 0; t < r; t += 1)
                  e.indexOf(this.stylesList[t]) === -1 &&
                    !this.stylesList[t].closed &&
                    e.push(this.stylesList[t]);
              }),
              (SVGShapeElement.prototype.reloadShapes = function () {
                this._isFirstFrame = !0;
                var n,
                  e = this.itemsData.length;
                for (n = 0; n < e; n += 1)
                  this.prevViewData[n] = this.itemsData[n];
                for (
                  this.searchShapes(
                    this.shapesData,
                    this.itemsData,
                    this.prevViewData,
                    this.layerElement,
                    0,
                    [],
                    !0
                  ),
                    this.filterUniqueShapes(),
                    e = this.dynamicProperties.length,
                    n = 0;
                  n < e;
                  n += 1
                )
                  this.dynamicProperties[n].getValue();
                this.renderModifiers();
              }),
              (SVGShapeElement.prototype.searchShapes = function (
                n,
                e,
                t,
                r,
                s,
                o,
                a
              ) {
                var l = [].concat(o),
                  c,
                  u = n.length - 1,
                  p,
                  N,
                  P = [],
                  de = [],
                  me,
                  Ye,
                  nt;
                for (c = u; c >= 0; c -= 1) {
                  if (
                    ((nt = this.searchProcessedElement(n[c])),
                    nt ? (e[c] = t[nt - 1]) : (n[c]._render = a),
                    n[c].ty === "fl" ||
                      n[c].ty === "st" ||
                      n[c].ty === "gf" ||
                      n[c].ty === "gs" ||
                      n[c].ty === "no")
                  )
                    nt
                      ? (e[c].style.closed = n[c].hd)
                      : (e[c] = this.createStyleElement(n[c], s)),
                      n[c]._render &&
                        e[c].style.pElem.parentNode !== r &&
                        r.appendChild(e[c].style.pElem),
                      P.push(e[c].style);
                  else if (n[c].ty === "gr") {
                    if (!nt) e[c] = this.createGroupElement(n[c]);
                    else
                      for (N = e[c].it.length, p = 0; p < N; p += 1)
                        e[c].prevViewData[p] = e[c].it[p];
                    this.searchShapes(
                      n[c].it,
                      e[c].it,
                      e[c].prevViewData,
                      e[c].gr,
                      s + 1,
                      l,
                      a
                    ),
                      n[c]._render &&
                        e[c].gr.parentNode !== r &&
                        r.appendChild(e[c].gr);
                  } else
                    n[c].ty === "tr"
                      ? (nt || (e[c] = this.createTransformElement(n[c], r)),
                        (me = e[c].transform),
                        l.push(me))
                      : n[c].ty === "sh" ||
                        n[c].ty === "rc" ||
                        n[c].ty === "el" ||
                        n[c].ty === "sr"
                      ? (nt || (e[c] = this.createShapeElement(n[c], l, s)),
                        this.setElementStyles(e[c]))
                      : n[c].ty === "tm" ||
                        n[c].ty === "rd" ||
                        n[c].ty === "ms" ||
                        n[c].ty === "pb" ||
                        n[c].ty === "zz" ||
                        n[c].ty === "op"
                      ? (nt
                          ? ((Ye = e[c]), (Ye.closed = !1))
                          : ((Ye = ShapeModifiers.getModifier(n[c].ty)),
                            Ye.init(this, n[c]),
                            (e[c] = Ye),
                            this.shapeModifiers.push(Ye)),
                        de.push(Ye))
                      : n[c].ty === "rp" &&
                        (nt
                          ? ((Ye = e[c]), (Ye.closed = !0))
                          : ((Ye = ShapeModifiers.getModifier(n[c].ty)),
                            (e[c] = Ye),
                            Ye.init(this, n, c, e),
                            this.shapeModifiers.push(Ye),
                            (a = !1)),
                        de.push(Ye));
                  this.addProcessedElement(n[c], c + 1);
                }
                for (u = P.length, c = 0; c < u; c += 1) P[c].closed = !0;
                for (u = de.length, c = 0; c < u; c += 1) de[c].closed = !0;
              }),
              (SVGShapeElement.prototype.renderInnerContent = function () {
                this.renderModifiers();
                var n,
                  e = this.stylesList.length;
                for (n = 0; n < e; n += 1) this.stylesList[n].reset();
                for (this.renderShape(), n = 0; n < e; n += 1)
                  (this.stylesList[n]._mdf || this._isFirstFrame) &&
                    (this.stylesList[n].msElem &&
                      (this.stylesList[n].msElem.setAttribute(
                        "d",
                        this.stylesList[n].d
                      ),
                      (this.stylesList[n].d = "M0 0" + this.stylesList[n].d)),
                    this.stylesList[n].pElem.setAttribute(
                      "d",
                      this.stylesList[n].d || "M0 0"
                    ));
              }),
              (SVGShapeElement.prototype.renderShape = function () {
                var n,
                  e = this.animatedContents.length,
                  t;
                for (n = 0; n < e; n += 1)
                  (t = this.animatedContents[n]),
                    (this._isFirstFrame || t.element._isAnimated) &&
                      t.data !== !0 &&
                      t.fn(t.data, t.element, this._isFirstFrame);
              }),
              (SVGShapeElement.prototype.destroy = function () {
                this.destroyBaseElement(),
                  (this.shapesData = null),
                  (this.itemsData = null);
              });
            function LetterProps(n, e, t, r, s, o) {
              (this.o = n),
                (this.sw = e),
                (this.sc = t),
                (this.fc = r),
                (this.m = s),
                (this.p = o),
                (this._mdf = {
                  o: !0,
                  sw: !!e,
                  sc: !!t,
                  fc: !!r,
                  m: !0,
                  p: !0,
                });
            }
            LetterProps.prototype.update = function (n, e, t, r, s, o) {
              (this._mdf.o = !1),
                (this._mdf.sw = !1),
                (this._mdf.sc = !1),
                (this._mdf.fc = !1),
                (this._mdf.m = !1),
                (this._mdf.p = !1);
              var a = !1;
              return (
                this.o !== n && ((this.o = n), (this._mdf.o = !0), (a = !0)),
                this.sw !== e && ((this.sw = e), (this._mdf.sw = !0), (a = !0)),
                this.sc !== t && ((this.sc = t), (this._mdf.sc = !0), (a = !0)),
                this.fc !== r && ((this.fc = r), (this._mdf.fc = !0), (a = !0)),
                this.m !== s && ((this.m = s), (this._mdf.m = !0), (a = !0)),
                o.length &&
                  (this.p[0] !== o[0] ||
                    this.p[1] !== o[1] ||
                    this.p[4] !== o[4] ||
                    this.p[5] !== o[5] ||
                    this.p[12] !== o[12] ||
                    this.p[13] !== o[13]) &&
                  ((this.p = o), (this._mdf.p = !0), (a = !0)),
                a
              );
            };
            function TextProperty(n, e) {
              (this._frameId = initialDefaultFrame),
                (this.pv = ""),
                (this.v = ""),
                (this.kf = !1),
                (this._isFirstFrame = !0),
                (this._mdf = !1),
                e.d && e.d.sid && (e.d = n.globalData.slotManager.getProp(e.d)),
                (this.data = e),
                (this.elem = n),
                (this.comp = this.elem.comp),
                (this.keysIndex = 0),
                (this.canResize = !1),
                (this.minimumFontSize = 1),
                (this.effectsSequence = []),
                (this.currentData = {
                  ascent: 0,
                  boxWidth: this.defaultBoxWidth,
                  f: "",
                  fStyle: "",
                  fWeight: "",
                  fc: "",
                  j: "",
                  justifyOffset: "",
                  l: [],
                  lh: 0,
                  lineWidths: [],
                  ls: "",
                  of: "",
                  s: "",
                  sc: "",
                  sw: 0,
                  t: 0,
                  tr: 0,
                  sz: 0,
                  ps: null,
                  fillColorAnim: !1,
                  strokeColorAnim: !1,
                  strokeWidthAnim: !1,
                  yOffset: 0,
                  finalSize: 0,
                  finalText: [],
                  finalLineHeight: 0,
                  __complete: !1,
                }),
                this.copyData(this.currentData, this.data.d.k[0].s),
                this.searchProperty() ||
                  this.completeTextData(this.currentData);
            }
            (TextProperty.prototype.defaultBoxWidth = [0, 0]),
              (TextProperty.prototype.copyData = function (n, e) {
                for (var t in e)
                  Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]);
                return n;
              }),
              (TextProperty.prototype.setCurrentData = function (n) {
                n.__complete || this.completeTextData(n),
                  (this.currentData = n),
                  (this.currentData.boxWidth =
                    this.currentData.boxWidth || this.defaultBoxWidth),
                  (this._mdf = !0);
              }),
              (TextProperty.prototype.searchProperty = function () {
                return this.searchKeyframes();
              }),
              (TextProperty.prototype.searchKeyframes = function () {
                return (
                  (this.kf = this.data.d.k.length > 1),
                  this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
                  this.kf
                );
              }),
              (TextProperty.prototype.addEffect = function (n) {
                this.effectsSequence.push(n),
                  this.elem.addDynamicProperty(this);
              }),
              (TextProperty.prototype.getValue = function (n) {
                if (
                  !(
                    (this.elem.globalData.frameId === this.frameId ||
                      !this.effectsSequence.length) &&
                    !n
                  )
                ) {
                  this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                  var e = this.currentData,
                    t = this.keysIndex;
                  if (this.lock) {
                    this.setCurrentData(this.currentData);
                    return;
                  }
                  (this.lock = !0), (this._mdf = !1);
                  var r,
                    s = this.effectsSequence.length,
                    o = n || this.data.d.k[this.keysIndex].s;
                  for (r = 0; r < s; r += 1)
                    t !== this.keysIndex
                      ? (o = this.effectsSequence[r](o, o.t))
                      : (o = this.effectsSequence[r](this.currentData, o.t));
                  e !== o && this.setCurrentData(o),
                    (this.v = this.currentData),
                    (this.pv = this.v),
                    (this.lock = !1),
                    (this.frameId = this.elem.globalData.frameId);
                }
              }),
              (TextProperty.prototype.getKeyframeValue = function () {
                for (
                  var n = this.data.d.k,
                    e = this.elem.comp.renderedFrame,
                    t = 0,
                    r = n.length;
                  t <= r - 1 && !(t === r - 1 || n[t + 1].t > e);

                )
                  t += 1;
                return (
                  this.keysIndex !== t && (this.keysIndex = t),
                  this.data.d.k[this.keysIndex].s
                );
              }),
              (TextProperty.prototype.buildFinalText = function (n) {
                for (
                  var e = [], t = 0, r = n.length, s, o, a = !1, l = !1, c = "";
                  t < r;

                )
                  (a = l),
                    (l = !1),
                    (s = n.charCodeAt(t)),
                    (c = n.charAt(t)),
                    FontManager.isCombinedCharacter(s)
                      ? (a = !0)
                      : s >= 55296 && s <= 56319
                      ? FontManager.isRegionalFlag(n, t)
                        ? (c = n.substr(t, 14))
                        : ((o = n.charCodeAt(t + 1)),
                          o >= 56320 &&
                            o <= 57343 &&
                            (FontManager.isModifier(s, o)
                              ? ((c = n.substr(t, 2)), (a = !0))
                              : FontManager.isFlagEmoji(n.substr(t, 4))
                              ? (c = n.substr(t, 4))
                              : (c = n.substr(t, 2))))
                      : s > 56319
                      ? ((o = n.charCodeAt(t + 1)),
                        FontManager.isVariationSelector(s) && (a = !0))
                      : FontManager.isZeroWidthJoiner(s) &&
                        ((a = !0), (l = !0)),
                    a ? ((e[e.length - 1] += c), (a = !1)) : e.push(c),
                    (t += c.length);
                return e;
              }),
              (TextProperty.prototype.completeTextData = function (n) {
                n.__complete = !0;
                var e = this.elem.globalData.fontManager,
                  t = this.data,
                  r = [],
                  s,
                  o,
                  a,
                  l = 0,
                  c,
                  u = t.m.g,
                  p = 0,
                  N = 0,
                  P = 0,
                  de = [],
                  me = 0,
                  Ye = 0,
                  nt,
                  Be,
                  ot = e.getFontByName(n.f),
                  st,
                  vt = 0,
                  xt = getFontProperties(ot);
                (n.fWeight = xt.weight),
                  (n.fStyle = xt.style),
                  (n.finalSize = n.s),
                  (n.finalText = this.buildFinalText(n.t)),
                  (o = n.finalText.length),
                  (n.finalLineHeight = n.lh);
                var St = (n.tr / 1e3) * n.finalSize,
                  wt;
                if (n.sz)
                  for (var bt = !0, Tt = n.sz[0], Ct = n.sz[1], kt, Dt; bt; ) {
                    (Dt = this.buildFinalText(n.t)),
                      (kt = 0),
                      (me = 0),
                      (o = Dt.length),
                      (St = (n.tr / 1e3) * n.finalSize);
                    var Vt = -1;
                    for (s = 0; s < o; s += 1)
                      (wt = Dt[s].charCodeAt(0)),
                        (a = !1),
                        Dt[s] === " "
                          ? (Vt = s)
                          : (wt === 13 || wt === 3) &&
                            ((me = 0),
                            (a = !0),
                            (kt += n.finalLineHeight || n.finalSize * 1.2)),
                        e.chars
                          ? ((st = e.getCharData(Dt[s], ot.fStyle, ot.fFamily)),
                            (vt = a ? 0 : (st.w * n.finalSize) / 100))
                          : (vt = e.measureText(Dt[s], n.f, n.finalSize)),
                        me + vt > Tt && Dt[s] !== " "
                          ? (Vt === -1 ? (o += 1) : (s = Vt),
                            (kt += n.finalLineHeight || n.finalSize * 1.2),
                            Dt.splice(s, Vt === s ? 1 : 0, "\r"),
                            (Vt = -1),
                            (me = 0))
                          : ((me += vt), (me += St));
                    (kt += (ot.ascent * n.finalSize) / 100),
                      this.canResize &&
                      n.finalSize > this.minimumFontSize &&
                      Ct < kt
                        ? ((n.finalSize -= 1),
                          (n.finalLineHeight = (n.finalSize * n.lh) / n.s))
                        : ((n.finalText = Dt),
                          (o = n.finalText.length),
                          (bt = !1));
                  }
                (me = -St), (vt = 0);
                var Ht = 0,
                  qt;
                for (s = 0; s < o; s += 1)
                  if (
                    ((a = !1),
                    (qt = n.finalText[s]),
                    (wt = qt.charCodeAt(0)),
                    wt === 13 || wt === 3
                      ? ((Ht = 0),
                        de.push(me),
                        (Ye = me > Ye ? me : Ye),
                        (me = -2 * St),
                        (c = ""),
                        (a = !0),
                        (P += 1))
                      : (c = qt),
                    e.chars
                      ? ((st = e.getCharData(
                          qt,
                          ot.fStyle,
                          e.getFontByName(n.f).fFamily
                        )),
                        (vt = a ? 0 : (st.w * n.finalSize) / 100))
                      : (vt = e.measureText(c, n.f, n.finalSize)),
                    qt === " "
                      ? (Ht += vt + St)
                      : ((me += vt + St + Ht), (Ht = 0)),
                    r.push({
                      l: vt,
                      an: vt,
                      add: p,
                      n: a,
                      anIndexes: [],
                      val: c,
                      line: P,
                      animatorJustifyOffset: 0,
                    }),
                    u == 2)
                  ) {
                    if (((p += vt), c === "" || c === " " || s === o - 1)) {
                      for ((c === "" || c === " ") && (p -= vt); N <= s; )
                        (r[N].an = p),
                          (r[N].ind = l),
                          (r[N].extra = vt),
                          (N += 1);
                      (l += 1), (p = 0);
                    }
                  } else if (u == 3) {
                    if (((p += vt), c === "" || s === o - 1)) {
                      for (c === "" && (p -= vt); N <= s; )
                        (r[N].an = p),
                          (r[N].ind = l),
                          (r[N].extra = vt),
                          (N += 1);
                      (p = 0), (l += 1);
                    }
                  } else (r[l].ind = l), (r[l].extra = 0), (l += 1);
                if (((n.l = r), (Ye = me > Ye ? me : Ye), de.push(me), n.sz))
                  (n.boxWidth = n.sz[0]), (n.justifyOffset = 0);
                else
                  switch (((n.boxWidth = Ye), n.j)) {
                    case 1:
                      n.justifyOffset = -n.boxWidth;
                      break;
                    case 2:
                      n.justifyOffset = -n.boxWidth / 2;
                      break;
                    default:
                      n.justifyOffset = 0;
                  }
                n.lineWidths = de;
                var Ft = t.a,
                  Bt,
                  Mt;
                Be = Ft.length;
                var Pt,
                  It,
                  Ot = [];
                for (nt = 0; nt < Be; nt += 1) {
                  for (
                    Bt = Ft[nt],
                      Bt.a.sc && (n.strokeColorAnim = !0),
                      Bt.a.sw && (n.strokeWidthAnim = !0),
                      (Bt.a.fc || Bt.a.fh || Bt.a.fs || Bt.a.fb) &&
                        (n.fillColorAnim = !0),
                      It = 0,
                      Pt = Bt.s.b,
                      s = 0;
                    s < o;
                    s += 1
                  )
                    (Mt = r[s]),
                      (Mt.anIndexes[nt] = It),
                      ((Pt == 1 && Mt.val !== "") ||
                        (Pt == 2 && Mt.val !== "" && Mt.val !== " ") ||
                        (Pt == 3 && (Mt.n || Mt.val == " " || s == o - 1)) ||
                        (Pt == 4 && (Mt.n || s == o - 1))) &&
                        (Bt.s.rn === 1 && Ot.push(It), (It += 1));
                  t.a[nt].s.totalChars = It;
                  var Xt = -1,
                    sn;
                  if (Bt.s.rn === 1)
                    for (s = 0; s < o; s += 1)
                      (Mt = r[s]),
                        Xt != Mt.anIndexes[nt] &&
                          ((Xt = Mt.anIndexes[nt]),
                          (sn = Ot.splice(
                            Math.floor(Math.random() * Ot.length),
                            1
                          )[0])),
                        (Mt.anIndexes[nt] = sn);
                }
                (n.yOffset = n.finalLineHeight || n.finalSize * 1.2),
                  (n.ls = n.ls || 0),
                  (n.ascent = (ot.ascent * n.finalSize) / 100);
              }),
              (TextProperty.prototype.updateDocumentData = function (n, e) {
                e = e === void 0 ? this.keysIndex : e;
                var t = this.copyData({}, this.data.d.k[e].s);
                (t = this.copyData(t, n)),
                  (this.data.d.k[e].s = t),
                  this.recalculate(e),
                  this.setCurrentData(t),
                  this.elem.addDynamicProperty(this);
              }),
              (TextProperty.prototype.recalculate = function (n) {
                var e = this.data.d.k[n].s;
                (e.__complete = !1),
                  (this.keysIndex = 0),
                  (this._isFirstFrame = !0),
                  this.getValue(e);
              }),
              (TextProperty.prototype.canResizeFont = function (n) {
                (this.canResize = n),
                  this.recalculate(this.keysIndex),
                  this.elem.addDynamicProperty(this);
              }),
              (TextProperty.prototype.setMinimumFontSize = function (n) {
                (this.minimumFontSize = Math.floor(n) || 1),
                  this.recalculate(this.keysIndex),
                  this.elem.addDynamicProperty(this);
              });
            var TextSelectorProp = (function () {
              var n = Math.max,
                e = Math.min,
                t = Math.floor;
              function r(o, a) {
                (this._currentTextLength = -1),
                  (this.k = !1),
                  (this.data = a),
                  (this.elem = o),
                  (this.comp = o.comp),
                  (this.finalS = 0),
                  (this.finalE = 0),
                  this.initDynamicPropertyContainer(o),
                  (this.s = PropertyFactory.getProp(
                    o,
                    a.s || { k: 0 },
                    0,
                    0,
                    this
                  )),
                  "e" in a
                    ? (this.e = PropertyFactory.getProp(o, a.e, 0, 0, this))
                    : (this.e = { v: 100 }),
                  (this.o = PropertyFactory.getProp(
                    o,
                    a.o || { k: 0 },
                    0,
                    0,
                    this
                  )),
                  (this.xe = PropertyFactory.getProp(
                    o,
                    a.xe || { k: 0 },
                    0,
                    0,
                    this
                  )),
                  (this.ne = PropertyFactory.getProp(
                    o,
                    a.ne || { k: 0 },
                    0,
                    0,
                    this
                  )),
                  (this.sm = PropertyFactory.getProp(
                    o,
                    a.sm || { k: 100 },
                    0,
                    0,
                    this
                  )),
                  (this.a = PropertyFactory.getProp(o, a.a, 0, 0.01, this)),
                  this.dynamicProperties.length || this.getValue();
              }
              (r.prototype = {
                getMult: function (a) {
                  this._currentTextLength !==
                    this.elem.textProperty.currentData.l.length &&
                    this.getValue();
                  var l = 0,
                    c = 0,
                    u = 1,
                    p = 1;
                  this.ne.v > 0
                    ? (l = this.ne.v / 100)
                    : (c = -this.ne.v / 100),
                    this.xe.v > 0
                      ? (u = 1 - this.xe.v / 100)
                      : (p = 1 + this.xe.v / 100);
                  var N = BezierFactory.getBezierEasing(l, c, u, p).get,
                    P = 0,
                    de = this.finalS,
                    me = this.finalE,
                    Ye = this.data.sh;
                  if (Ye === 2)
                    me === de
                      ? (P = a >= me ? 1 : 0)
                      : (P = n(
                          0,
                          e(0.5 / (me - de) + (a - de) / (me - de), 1)
                        )),
                      (P = N(P));
                  else if (Ye === 3)
                    me === de
                      ? (P = a >= me ? 0 : 1)
                      : (P =
                          1 -
                          n(0, e(0.5 / (me - de) + (a - de) / (me - de), 1))),
                      (P = N(P));
                  else if (Ye === 4)
                    me === de
                      ? (P = 0)
                      : ((P = n(
                          0,
                          e(0.5 / (me - de) + (a - de) / (me - de), 1)
                        )),
                        P < 0.5 ? (P *= 2) : (P = 1 - 2 * (P - 0.5))),
                      (P = N(P));
                  else if (Ye === 5) {
                    if (me === de) P = 0;
                    else {
                      var nt = me - de;
                      a = e(n(0, a + 0.5 - de), me - de);
                      var Be = -nt / 2 + a,
                        ot = nt / 2;
                      P = Math.sqrt(1 - (Be * Be) / (ot * ot));
                    }
                    P = N(P);
                  } else
                    Ye === 6
                      ? (me === de
                          ? (P = 0)
                          : ((a = e(n(0, a + 0.5 - de), me - de)),
                            (P =
                              (1 +
                                Math.cos(
                                  Math.PI + (Math.PI * 2 * a) / (me - de)
                                )) /
                              2)),
                        (P = N(P)))
                      : (a >= t(de) &&
                          (a - de < 0
                            ? (P = n(0, e(e(me, 1) - (de - a), 1)))
                            : (P = n(0, e(me - a, 1)))),
                        (P = N(P)));
                  if (this.sm.v !== 100) {
                    var st = this.sm.v * 0.01;
                    st === 0 && (st = 1e-8);
                    var vt = 0.5 - st * 0.5;
                    P < vt ? (P = 0) : ((P = (P - vt) / st), P > 1 && (P = 1));
                  }
                  return P * this.a.v;
                },
                getValue: function (a) {
                  this.iterateDynamicProperties(),
                    (this._mdf = a || this._mdf),
                    (this._currentTextLength =
                      this.elem.textProperty.currentData.l.length || 0),
                    a &&
                      this.data.r === 2 &&
                      (this.e.v = this._currentTextLength);
                  var l = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
                    c = this.o.v / l,
                    u = this.s.v / l + c,
                    p = this.e.v / l + c;
                  if (u > p) {
                    var N = u;
                    (u = p), (p = N);
                  }
                  (this.finalS = u), (this.finalE = p);
                },
              }),
                extendPrototype([DynamicPropertyContainer], r);
              function s(o, a, l) {
                return new r(o, a);
              }
              return { getTextSelectorProp: s };
            })();
            function TextAnimatorDataProperty(n, e, t) {
              var r = { propType: !1 },
                s = PropertyFactory.getProp,
                o = e.a;
              (this.a = {
                r: o.r ? s(n, o.r, 0, degToRads, t) : r,
                rx: o.rx ? s(n, o.rx, 0, degToRads, t) : r,
                ry: o.ry ? s(n, o.ry, 0, degToRads, t) : r,
                sk: o.sk ? s(n, o.sk, 0, degToRads, t) : r,
                sa: o.sa ? s(n, o.sa, 0, degToRads, t) : r,
                s: o.s ? s(n, o.s, 1, 0.01, t) : r,
                a: o.a ? s(n, o.a, 1, 0, t) : r,
                o: o.o ? s(n, o.o, 0, 0.01, t) : r,
                p: o.p ? s(n, o.p, 1, 0, t) : r,
                sw: o.sw ? s(n, o.sw, 0, 0, t) : r,
                sc: o.sc ? s(n, o.sc, 1, 0, t) : r,
                fc: o.fc ? s(n, o.fc, 1, 0, t) : r,
                fh: o.fh ? s(n, o.fh, 0, 0, t) : r,
                fs: o.fs ? s(n, o.fs, 0, 0.01, t) : r,
                fb: o.fb ? s(n, o.fb, 0, 0.01, t) : r,
                t: o.t ? s(n, o.t, 0, 0, t) : r,
              }),
                (this.s = TextSelectorProp.getTextSelectorProp(n, e.s, t)),
                (this.s.t = e.s.t);
            }
            function TextAnimatorProperty(n, e, t) {
              (this._isFirstFrame = !0),
                (this._hasMaskedPath = !1),
                (this._frameId = -1),
                (this._textData = n),
                (this._renderType = e),
                (this._elem = t),
                (this._animatorsData = createSizedArray(
                  this._textData.a.length
                )),
                (this._pathData = {}),
                (this._moreOptions = { alignment: {} }),
                (this.renderedLetters = []),
                (this.lettersChangedFlag = !1),
                this.initDynamicPropertyContainer(t);
            }
            (TextAnimatorProperty.prototype.searchProperties = function () {
              var n,
                e = this._textData.a.length,
                t,
                r = PropertyFactory.getProp;
              for (n = 0; n < e; n += 1)
                (t = this._textData.a[n]),
                  (this._animatorsData[n] = new TextAnimatorDataProperty(
                    this._elem,
                    t,
                    this
                  ));
              this._textData.p && "m" in this._textData.p
                ? ((this._pathData = {
                    a: r(this._elem, this._textData.p.a, 0, 0, this),
                    f: r(this._elem, this._textData.p.f, 0, 0, this),
                    l: r(this._elem, this._textData.p.l, 0, 0, this),
                    r: r(this._elem, this._textData.p.r, 0, 0, this),
                    p: r(this._elem, this._textData.p.p, 0, 0, this),
                    m: this._elem.maskManager.getMaskProperty(
                      this._textData.p.m
                    ),
                  }),
                  (this._hasMaskedPath = !0))
                : (this._hasMaskedPath = !1),
                (this._moreOptions.alignment = r(
                  this._elem,
                  this._textData.m.a,
                  1,
                  0,
                  this
                ));
            }),
              (TextAnimatorProperty.prototype.getMeasures = function (n, e) {
                if (
                  ((this.lettersChangedFlag = e),
                  !(
                    !this._mdf &&
                    !this._isFirstFrame &&
                    !e &&
                    (!this._hasMaskedPath || !this._pathData.m._mdf)
                  ))
                ) {
                  this._isFirstFrame = !1;
                  var t = this._moreOptions.alignment.v,
                    r = this._animatorsData,
                    s = this._textData,
                    o = this.mHelper,
                    a = this._renderType,
                    l = this.renderedLetters.length,
                    c,
                    u,
                    p,
                    N,
                    P = n.l,
                    de,
                    me,
                    Ye,
                    nt,
                    Be,
                    ot,
                    st,
                    vt,
                    xt,
                    St,
                    wt,
                    bt,
                    Tt,
                    Ct,
                    kt;
                  if (this._hasMaskedPath) {
                    if (
                      ((kt = this._pathData.m),
                      !this._pathData.n || this._pathData._mdf)
                    ) {
                      var Dt = kt.v;
                      this._pathData.r.v && (Dt = Dt.reverse()),
                        (de = { tLength: 0, segments: [] }),
                        (N = Dt._length - 1);
                      var Vt;
                      for (bt = 0, p = 0; p < N; p += 1)
                        (Vt = bez.buildBezierData(
                          Dt.v[p],
                          Dt.v[p + 1],
                          [Dt.o[p][0] - Dt.v[p][0], Dt.o[p][1] - Dt.v[p][1]],
                          [
                            Dt.i[p + 1][0] - Dt.v[p + 1][0],
                            Dt.i[p + 1][1] - Dt.v[p + 1][1],
                          ]
                        )),
                          (de.tLength += Vt.segmentLength),
                          de.segments.push(Vt),
                          (bt += Vt.segmentLength);
                      (p = N),
                        kt.v.c &&
                          ((Vt = bez.buildBezierData(
                            Dt.v[p],
                            Dt.v[0],
                            [Dt.o[p][0] - Dt.v[p][0], Dt.o[p][1] - Dt.v[p][1]],
                            [Dt.i[0][0] - Dt.v[0][0], Dt.i[0][1] - Dt.v[0][1]]
                          )),
                          (de.tLength += Vt.segmentLength),
                          de.segments.push(Vt),
                          (bt += Vt.segmentLength)),
                        (this._pathData.pi = de);
                    }
                    if (
                      ((de = this._pathData.pi),
                      (me = this._pathData.f.v),
                      (st = 0),
                      (ot = 1),
                      (nt = 0),
                      (Be = !0),
                      (St = de.segments),
                      me < 0 && kt.v.c)
                    )
                      for (
                        de.tLength < Math.abs(me) &&
                          (me = -Math.abs(me) % de.tLength),
                          st = St.length - 1,
                          xt = St[st].points,
                          ot = xt.length - 1;
                        me < 0;

                      )
                        (me += xt[ot].partialLength),
                          (ot -= 1),
                          ot < 0 &&
                            ((st -= 1),
                            (xt = St[st].points),
                            (ot = xt.length - 1));
                    (xt = St[st].points),
                      (vt = xt[ot - 1]),
                      (Ye = xt[ot]),
                      (wt = Ye.partialLength);
                  }
                  (N = P.length), (c = 0), (u = 0);
                  var Ht = n.finalSize * 1.2 * 0.714,
                    qt = !0,
                    Ft,
                    Bt,
                    Mt,
                    Pt,
                    It;
                  Pt = r.length;
                  var Ot,
                    Xt = -1,
                    sn,
                    Kt,
                    tn,
                    pn = me,
                    _n = st,
                    bn = ot,
                    $n = -1,
                    tr,
                    ur,
                    _r,
                    Bn,
                    jt,
                    Yn,
                    zn,
                    rn,
                    In = "",
                    or = this.defaultPropsArray,
                    Gn;
                  if (n.j === 2 || n.j === 1) {
                    var Yt = 0,
                      Gt = 0,
                      hn = n.j === 2 ? -0.5 : -1,
                      En = 0,
                      Ln = !0;
                    for (p = 0; p < N; p += 1)
                      if (P[p].n) {
                        for (Yt && (Yt += Gt); En < p; )
                          (P[En].animatorJustifyOffset = Yt), (En += 1);
                        (Yt = 0), (Ln = !0);
                      } else {
                        for (Mt = 0; Mt < Pt; Mt += 1)
                          (Ft = r[Mt].a),
                            Ft.t.propType &&
                              (Ln && n.j === 2 && (Gt += Ft.t.v * hn),
                              (Bt = r[Mt].s),
                              (Ot = Bt.getMult(
                                P[p].anIndexes[Mt],
                                s.a[Mt].s.totalChars
                              )),
                              Ot.length
                                ? (Yt += Ft.t.v * Ot[0] * hn)
                                : (Yt += Ft.t.v * Ot * hn));
                        Ln = !1;
                      }
                    for (Yt && (Yt += Gt); En < p; )
                      (P[En].animatorJustifyOffset = Yt), (En += 1);
                  }
                  for (p = 0; p < N; p += 1) {
                    if ((o.reset(), (tr = 1), P[p].n))
                      (c = 0),
                        (u += n.yOffset),
                        (u += qt ? 1 : 0),
                        (me = pn),
                        (qt = !1),
                        this._hasMaskedPath &&
                          ((st = _n),
                          (ot = bn),
                          (xt = St[st].points),
                          (vt = xt[ot - 1]),
                          (Ye = xt[ot]),
                          (wt = Ye.partialLength),
                          (nt = 0)),
                        (In = ""),
                        (rn = ""),
                        (Yn = ""),
                        (Gn = ""),
                        (or = this.defaultPropsArray);
                    else {
                      if (this._hasMaskedPath) {
                        if ($n !== P[p].line) {
                          switch (n.j) {
                            case 1:
                              me += bt - n.lineWidths[P[p].line];
                              break;
                            case 2:
                              me += (bt - n.lineWidths[P[p].line]) / 2;
                              break;
                          }
                          $n = P[p].line;
                        }
                        Xt !== P[p].ind &&
                          (P[Xt] && (me += P[Xt].extra),
                          (me += P[p].an / 2),
                          (Xt = P[p].ind)),
                          (me += t[0] * P[p].an * 0.005);
                        var mn = 0;
                        for (Mt = 0; Mt < Pt; Mt += 1)
                          (Ft = r[Mt].a),
                            Ft.p.propType &&
                              ((Bt = r[Mt].s),
                              (Ot = Bt.getMult(
                                P[p].anIndexes[Mt],
                                s.a[Mt].s.totalChars
                              )),
                              Ot.length
                                ? (mn += Ft.p.v[0] * Ot[0])
                                : (mn += Ft.p.v[0] * Ot)),
                            Ft.a.propType &&
                              ((Bt = r[Mt].s),
                              (Ot = Bt.getMult(
                                P[p].anIndexes[Mt],
                                s.a[Mt].s.totalChars
                              )),
                              Ot.length
                                ? (mn += Ft.a.v[0] * Ot[0])
                                : (mn += Ft.a.v[0] * Ot));
                        for (
                          Be = !0,
                            this._pathData.a.v &&
                              ((me =
                                P[0].an * 0.5 +
                                ((bt -
                                  this._pathData.f.v -
                                  P[0].an * 0.5 -
                                  P[P.length - 1].an * 0.5) *
                                  Xt) /
                                  (N - 1)),
                              (me += this._pathData.f.v));
                          Be;

                        )
                          nt + wt >= me + mn || !xt
                            ? ((Tt = (me + mn - nt) / Ye.partialLength),
                              (Kt =
                                vt.point[0] + (Ye.point[0] - vt.point[0]) * Tt),
                              (tn =
                                vt.point[1] + (Ye.point[1] - vt.point[1]) * Tt),
                              o.translate(
                                -t[0] * P[p].an * 0.005,
                                -(t[1] * Ht) * 0.01
                              ),
                              (Be = !1))
                            : xt &&
                              ((nt += Ye.partialLength),
                              (ot += 1),
                              ot >= xt.length &&
                                ((ot = 0),
                                (st += 1),
                                St[st]
                                  ? (xt = St[st].points)
                                  : kt.v.c
                                  ? ((ot = 0), (st = 0), (xt = St[st].points))
                                  : ((nt -= Ye.partialLength), (xt = null))),
                              xt &&
                                ((vt = Ye),
                                (Ye = xt[ot]),
                                (wt = Ye.partialLength)));
                        (sn = P[p].an / 2 - P[p].add), o.translate(-sn, 0, 0);
                      } else
                        (sn = P[p].an / 2 - P[p].add),
                          o.translate(-sn, 0, 0),
                          o.translate(
                            -t[0] * P[p].an * 0.005,
                            -t[1] * Ht * 0.01,
                            0
                          );
                      for (Mt = 0; Mt < Pt; Mt += 1)
                        (Ft = r[Mt].a),
                          Ft.t.propType &&
                            ((Bt = r[Mt].s),
                            (Ot = Bt.getMult(
                              P[p].anIndexes[Mt],
                              s.a[Mt].s.totalChars
                            )),
                            (c !== 0 || n.j !== 0) &&
                              (this._hasMaskedPath
                                ? Ot.length
                                  ? (me += Ft.t.v * Ot[0])
                                  : (me += Ft.t.v * Ot)
                                : Ot.length
                                ? (c += Ft.t.v * Ot[0])
                                : (c += Ft.t.v * Ot)));
                      for (
                        n.strokeWidthAnim && (_r = n.sw || 0),
                          n.strokeColorAnim &&
                            (n.sc
                              ? (ur = [n.sc[0], n.sc[1], n.sc[2]])
                              : (ur = [0, 0, 0])),
                          n.fillColorAnim &&
                            n.fc &&
                            (Bn = [n.fc[0], n.fc[1], n.fc[2]]),
                          Mt = 0;
                        Mt < Pt;
                        Mt += 1
                      )
                        (Ft = r[Mt].a),
                          Ft.a.propType &&
                            ((Bt = r[Mt].s),
                            (Ot = Bt.getMult(
                              P[p].anIndexes[Mt],
                              s.a[Mt].s.totalChars
                            )),
                            Ot.length
                              ? o.translate(
                                  -Ft.a.v[0] * Ot[0],
                                  -Ft.a.v[1] * Ot[1],
                                  Ft.a.v[2] * Ot[2]
                                )
                              : o.translate(
                                  -Ft.a.v[0] * Ot,
                                  -Ft.a.v[1] * Ot,
                                  Ft.a.v[2] * Ot
                                ));
                      for (Mt = 0; Mt < Pt; Mt += 1)
                        (Ft = r[Mt].a),
                          Ft.s.propType &&
                            ((Bt = r[Mt].s),
                            (Ot = Bt.getMult(
                              P[p].anIndexes[Mt],
                              s.a[Mt].s.totalChars
                            )),
                            Ot.length
                              ? o.scale(
                                  1 + (Ft.s.v[0] - 1) * Ot[0],
                                  1 + (Ft.s.v[1] - 1) * Ot[1],
                                  1
                                )
                              : o.scale(
                                  1 + (Ft.s.v[0] - 1) * Ot,
                                  1 + (Ft.s.v[1] - 1) * Ot,
                                  1
                                ));
                      for (Mt = 0; Mt < Pt; Mt += 1) {
                        if (
                          ((Ft = r[Mt].a),
                          (Bt = r[Mt].s),
                          (Ot = Bt.getMult(
                            P[p].anIndexes[Mt],
                            s.a[Mt].s.totalChars
                          )),
                          Ft.sk.propType &&
                            (Ot.length
                              ? o.skewFromAxis(
                                  -Ft.sk.v * Ot[0],
                                  Ft.sa.v * Ot[1]
                                )
                              : o.skewFromAxis(-Ft.sk.v * Ot, Ft.sa.v * Ot)),
                          Ft.r.propType &&
                            (Ot.length
                              ? o.rotateZ(-Ft.r.v * Ot[2])
                              : o.rotateZ(-Ft.r.v * Ot)),
                          Ft.ry.propType &&
                            (Ot.length
                              ? o.rotateY(Ft.ry.v * Ot[1])
                              : o.rotateY(Ft.ry.v * Ot)),
                          Ft.rx.propType &&
                            (Ot.length
                              ? o.rotateX(Ft.rx.v * Ot[0])
                              : o.rotateX(Ft.rx.v * Ot)),
                          Ft.o.propType &&
                            (Ot.length
                              ? (tr += (Ft.o.v * Ot[0] - tr) * Ot[0])
                              : (tr += (Ft.o.v * Ot - tr) * Ot)),
                          n.strokeWidthAnim &&
                            Ft.sw.propType &&
                            (Ot.length
                              ? (_r += Ft.sw.v * Ot[0])
                              : (_r += Ft.sw.v * Ot)),
                          n.strokeColorAnim && Ft.sc.propType)
                        )
                          for (jt = 0; jt < 3; jt += 1)
                            Ot.length
                              ? (ur[jt] += (Ft.sc.v[jt] - ur[jt]) * Ot[0])
                              : (ur[jt] += (Ft.sc.v[jt] - ur[jt]) * Ot);
                        if (n.fillColorAnim && n.fc) {
                          if (Ft.fc.propType)
                            for (jt = 0; jt < 3; jt += 1)
                              Ot.length
                                ? (Bn[jt] += (Ft.fc.v[jt] - Bn[jt]) * Ot[0])
                                : (Bn[jt] += (Ft.fc.v[jt] - Bn[jt]) * Ot);
                          Ft.fh.propType &&
                            (Ot.length
                              ? (Bn = addHueToRGB(Bn, Ft.fh.v * Ot[0]))
                              : (Bn = addHueToRGB(Bn, Ft.fh.v * Ot))),
                            Ft.fs.propType &&
                              (Ot.length
                                ? (Bn = addSaturationToRGB(Bn, Ft.fs.v * Ot[0]))
                                : (Bn = addSaturationToRGB(Bn, Ft.fs.v * Ot))),
                            Ft.fb.propType &&
                              (Ot.length
                                ? (Bn = addBrightnessToRGB(Bn, Ft.fb.v * Ot[0]))
                                : (Bn = addBrightnessToRGB(Bn, Ft.fb.v * Ot)));
                        }
                      }
                      for (Mt = 0; Mt < Pt; Mt += 1)
                        (Ft = r[Mt].a),
                          Ft.p.propType &&
                            ((Bt = r[Mt].s),
                            (Ot = Bt.getMult(
                              P[p].anIndexes[Mt],
                              s.a[Mt].s.totalChars
                            )),
                            this._hasMaskedPath
                              ? Ot.length
                                ? o.translate(
                                    0,
                                    Ft.p.v[1] * Ot[0],
                                    -Ft.p.v[2] * Ot[1]
                                  )
                                : o.translate(
                                    0,
                                    Ft.p.v[1] * Ot,
                                    -Ft.p.v[2] * Ot
                                  )
                              : Ot.length
                              ? o.translate(
                                  Ft.p.v[0] * Ot[0],
                                  Ft.p.v[1] * Ot[1],
                                  -Ft.p.v[2] * Ot[2]
                                )
                              : o.translate(
                                  Ft.p.v[0] * Ot,
                                  Ft.p.v[1] * Ot,
                                  -Ft.p.v[2] * Ot
                                ));
                      if (
                        (n.strokeWidthAnim && (Yn = _r < 0 ? 0 : _r),
                        n.strokeColorAnim &&
                          (zn =
                            "rgb(" +
                            Math.round(ur[0] * 255) +
                            "," +
                            Math.round(ur[1] * 255) +
                            "," +
                            Math.round(ur[2] * 255) +
                            ")"),
                        n.fillColorAnim &&
                          n.fc &&
                          (rn =
                            "rgb(" +
                            Math.round(Bn[0] * 255) +
                            "," +
                            Math.round(Bn[1] * 255) +
                            "," +
                            Math.round(Bn[2] * 255) +
                            ")"),
                        this._hasMaskedPath)
                      ) {
                        if (
                          (o.translate(0, -n.ls),
                          o.translate(0, t[1] * Ht * 0.01 + u, 0),
                          this._pathData.p.v)
                        ) {
                          Ct =
                            (Ye.point[1] - vt.point[1]) /
                            (Ye.point[0] - vt.point[0]);
                          var Vn = (Math.atan(Ct) * 180) / Math.PI;
                          Ye.point[0] < vt.point[0] && (Vn += 180),
                            o.rotate((-Vn * Math.PI) / 180);
                        }
                        o.translate(Kt, tn, 0),
                          (me -= t[0] * P[p].an * 0.005),
                          P[p + 1] &&
                            Xt !== P[p + 1].ind &&
                            ((me += P[p].an / 2),
                            (me += n.tr * 0.001 * n.finalSize));
                      } else {
                        switch (
                          (o.translate(c, u, 0),
                          n.ps && o.translate(n.ps[0], n.ps[1] + n.ascent, 0),
                          n.j)
                        ) {
                          case 1:
                            o.translate(
                              P[p].animatorJustifyOffset +
                                n.justifyOffset +
                                (n.boxWidth - n.lineWidths[P[p].line]),
                              0,
                              0
                            );
                            break;
                          case 2:
                            o.translate(
                              P[p].animatorJustifyOffset +
                                n.justifyOffset +
                                (n.boxWidth - n.lineWidths[P[p].line]) / 2,
                              0,
                              0
                            );
                            break;
                        }
                        o.translate(0, -n.ls),
                          o.translate(sn, 0, 0),
                          o.translate(
                            t[0] * P[p].an * 0.005,
                            t[1] * Ht * 0.01,
                            0
                          ),
                          (c += P[p].l + n.tr * 0.001 * n.finalSize);
                      }
                      a === "html"
                        ? (In = o.toCSS())
                        : a === "svg"
                        ? (In = o.to2dCSS())
                        : (or = [
                            o.props[0],
                            o.props[1],
                            o.props[2],
                            o.props[3],
                            o.props[4],
                            o.props[5],
                            o.props[6],
                            o.props[7],
                            o.props[8],
                            o.props[9],
                            o.props[10],
                            o.props[11],
                            o.props[12],
                            o.props[13],
                            o.props[14],
                            o.props[15],
                          ]),
                        (Gn = tr);
                    }
                    l <= p
                      ? ((It = new LetterProps(Gn, Yn, zn, rn, In, or)),
                        this.renderedLetters.push(It),
                        (l += 1),
                        (this.lettersChangedFlag = !0))
                      : ((It = this.renderedLetters[p]),
                        (this.lettersChangedFlag =
                          It.update(Gn, Yn, zn, rn, In, or) ||
                          this.lettersChangedFlag));
                  }
                }
              }),
              (TextAnimatorProperty.prototype.getValue = function () {
                this._elem.globalData.frameId !== this._frameId &&
                  ((this._frameId = this._elem.globalData.frameId),
                  this.iterateDynamicProperties());
              }),
              (TextAnimatorProperty.prototype.mHelper = new Matrix()),
              (TextAnimatorProperty.prototype.defaultPropsArray = []),
              extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
            function ITextElement() {}
            (ITextElement.prototype.initElement = function (n, e, t) {
              (this.lettersChangedFlag = !0),
                this.initFrame(),
                this.initBaseData(n, e, t),
                (this.textProperty = new TextProperty(
                  this,
                  n.t,
                  this.dynamicProperties
                )),
                (this.textAnimator = new TextAnimatorProperty(
                  n.t,
                  this.renderType,
                  this
                )),
                this.initTransform(n, e, t),
                this.initHierarchy(),
                this.initRenderable(),
                this.initRendererElement(),
                this.createContainerElements(),
                this.createRenderableComponents(),
                this.createContent(),
                this.hide(),
                this.textAnimator.searchProperties(this.dynamicProperties);
            }),
              (ITextElement.prototype.prepareFrame = function (n) {
                (this._mdf = !1),
                  this.prepareRenderableFrame(n),
                  this.prepareProperties(n, this.isInRange);
              }),
              (ITextElement.prototype.createPathShape = function (n, e) {
                var t,
                  r = e.length,
                  s,
                  o = "";
                for (t = 0; t < r; t += 1)
                  e[t].ty === "sh" &&
                    ((s = e[t].ks.k),
                    (o += buildShapeString(s, s.i.length, !0, n)));
                return o;
              }),
              (ITextElement.prototype.updateDocumentData = function (n, e) {
                this.textProperty.updateDocumentData(n, e);
              }),
              (ITextElement.prototype.canResizeFont = function (n) {
                this.textProperty.canResizeFont(n);
              }),
              (ITextElement.prototype.setMinimumFontSize = function (n) {
                this.textProperty.setMinimumFontSize(n);
              }),
              (ITextElement.prototype.applyTextPropertiesToMatrix = function (
                n,
                e,
                t,
                r,
                s
              ) {
                switch (
                  (n.ps && e.translate(n.ps[0], n.ps[1] + n.ascent, 0),
                  e.translate(0, -n.ls, 0),
                  n.j)
                ) {
                  case 1:
                    e.translate(
                      n.justifyOffset + (n.boxWidth - n.lineWidths[t]),
                      0,
                      0
                    );
                    break;
                  case 2:
                    e.translate(
                      n.justifyOffset + (n.boxWidth - n.lineWidths[t]) / 2,
                      0,
                      0
                    );
                    break;
                }
                e.translate(r, s, 0);
              }),
              (ITextElement.prototype.buildColor = function (n) {
                return (
                  "rgb(" +
                  Math.round(n[0] * 255) +
                  "," +
                  Math.round(n[1] * 255) +
                  "," +
                  Math.round(n[2] * 255) +
                  ")"
                );
              }),
              (ITextElement.prototype.emptyProp = new LetterProps()),
              (ITextElement.prototype.destroy = function () {}),
              (ITextElement.prototype.validateText = function () {
                (this.textProperty._mdf || this.textProperty._isFirstFrame) &&
                  (this.buildNewText(),
                  (this.textProperty._isFirstFrame = !1),
                  (this.textProperty._mdf = !1));
              });
            var emptyShapeData = { shapes: [] };
            function SVGTextLottieElement(n, e, t) {
              (this.textSpans = []),
                (this.renderType = "svg"),
                this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                SVGBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableDOMElement,
                ITextElement,
              ],
              SVGTextLottieElement
            ),
              (SVGTextLottieElement.prototype.createContent = function () {
                this.data.singleShape &&
                  !this.globalData.fontManager.chars &&
                  (this.textContainer = createNS("text"));
              }),
              (SVGTextLottieElement.prototype.buildTextContents = function (n) {
                for (var e = 0, t = n.length, r = [], s = ""; e < t; )
                  n[e] === "\r" || n[e] === ""
                    ? (r.push(s), (s = ""))
                    : (s += n[e]),
                    (e += 1);
                return r.push(s), r;
              }),
              (SVGTextLottieElement.prototype.buildShapeData = function (n, e) {
                if (n.shapes && n.shapes.length) {
                  var t = n.shapes[0];
                  if (t.it) {
                    var r = t.it[t.it.length - 1];
                    r.s && ((r.s.k[0] = e), (r.s.k[1] = e));
                  }
                }
                return n;
              }),
              (SVGTextLottieElement.prototype.buildNewText = function () {
                this.addDynamicProperty(this);
                var n,
                  e,
                  t = this.textProperty.currentData;
                (this.renderedLetters = createSizedArray(t ? t.l.length : 0)),
                  t.fc
                    ? this.layerElement.setAttribute(
                        "fill",
                        this.buildColor(t.fc)
                      )
                    : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
                  t.sc &&
                    (this.layerElement.setAttribute(
                      "stroke",
                      this.buildColor(t.sc)
                    ),
                    this.layerElement.setAttribute("stroke-width", t.sw)),
                  this.layerElement.setAttribute("font-size", t.finalSize);
                var r = this.globalData.fontManager.getFontByName(t.f);
                if (r.fClass) this.layerElement.setAttribute("class", r.fClass);
                else {
                  this.layerElement.setAttribute("font-family", r.fFamily);
                  var s = t.fWeight,
                    o = t.fStyle;
                  this.layerElement.setAttribute("font-style", o),
                    this.layerElement.setAttribute("font-weight", s);
                }
                this.layerElement.setAttribute("aria-label", t.t);
                var a = t.l || [],
                  l = !!this.globalData.fontManager.chars;
                e = a.length;
                var c,
                  u = this.mHelper,
                  p = "",
                  N = this.data.singleShape,
                  P = 0,
                  de = 0,
                  me = !0,
                  Ye = t.tr * 0.001 * t.finalSize;
                if (N && !l && !t.sz) {
                  var nt = this.textContainer,
                    Be = "start";
                  switch (t.j) {
                    case 1:
                      Be = "end";
                      break;
                    case 2:
                      Be = "middle";
                      break;
                    default:
                      Be = "start";
                      break;
                  }
                  nt.setAttribute("text-anchor", Be),
                    nt.setAttribute("letter-spacing", Ye);
                  var ot = this.buildTextContents(t.finalText);
                  for (
                    e = ot.length, de = t.ps ? t.ps[1] + t.ascent : 0, n = 0;
                    n < e;
                    n += 1
                  )
                    (c = this.textSpans[n].span || createNS("tspan")),
                      (c.textContent = ot[n]),
                      c.setAttribute("x", 0),
                      c.setAttribute("y", de),
                      (c.style.display = "inherit"),
                      nt.appendChild(c),
                      this.textSpans[n] ||
                        (this.textSpans[n] = { span: null, glyph: null }),
                      (this.textSpans[n].span = c),
                      (de += t.finalLineHeight);
                  this.layerElement.appendChild(nt);
                } else {
                  var st = this.textSpans.length,
                    vt;
                  for (n = 0; n < e; n += 1) {
                    if (
                      (this.textSpans[n] ||
                        (this.textSpans[n] = {
                          span: null,
                          childSpan: null,
                          glyph: null,
                        }),
                      !l || !N || n === 0)
                    ) {
                      if (
                        ((c =
                          st > n
                            ? this.textSpans[n].span
                            : createNS(l ? "g" : "text")),
                        st <= n)
                      ) {
                        if (
                          (c.setAttribute("stroke-linecap", "butt"),
                          c.setAttribute("stroke-linejoin", "round"),
                          c.setAttribute("stroke-miterlimit", "4"),
                          (this.textSpans[n].span = c),
                          l)
                        ) {
                          var xt = createNS("g");
                          c.appendChild(xt), (this.textSpans[n].childSpan = xt);
                        }
                        (this.textSpans[n].span = c),
                          this.layerElement.appendChild(c);
                      }
                      c.style.display = "inherit";
                    }
                    if (
                      (u.reset(),
                      N &&
                        (a[n].n &&
                          ((P = -Ye),
                          (de += t.yOffset),
                          (de += me ? 1 : 0),
                          (me = !1)),
                        this.applyTextPropertiesToMatrix(
                          t,
                          u,
                          a[n].line,
                          P,
                          de
                        ),
                        (P += a[n].l || 0),
                        (P += Ye)),
                      l)
                    ) {
                      vt = this.globalData.fontManager.getCharData(
                        t.finalText[n],
                        r.fStyle,
                        this.globalData.fontManager.getFontByName(t.f).fFamily
                      );
                      var St;
                      if (vt.t === 1)
                        St = new SVGCompElement(vt.data, this.globalData, this);
                      else {
                        var wt = emptyShapeData;
                        vt.data &&
                          vt.data.shapes &&
                          (wt = this.buildShapeData(vt.data, t.finalSize)),
                          (St = new SVGShapeElement(wt, this.globalData, this));
                      }
                      if (this.textSpans[n].glyph) {
                        var bt = this.textSpans[n].glyph;
                        this.textSpans[n].childSpan.removeChild(
                          bt.layerElement
                        ),
                          bt.destroy();
                      }
                      (this.textSpans[n].glyph = St),
                        (St._debug = !0),
                        St.prepareFrame(0),
                        St.renderFrame(),
                        this.textSpans[n].childSpan.appendChild(
                          St.layerElement
                        ),
                        vt.t === 1 &&
                          this.textSpans[n].childSpan.setAttribute(
                            "transform",
                            "scale(" +
                              t.finalSize / 100 +
                              "," +
                              t.finalSize / 100 +
                              ")"
                          );
                    } else
                      N &&
                        c.setAttribute(
                          "transform",
                          "translate(" + u.props[12] + "," + u.props[13] + ")"
                        ),
                        (c.textContent = a[n].val),
                        c.setAttributeNS(
                          "http://www.w3.org/XML/1998/namespace",
                          "xml:space",
                          "preserve"
                        );
                  }
                  N && c && c.setAttribute("d", p);
                }
                for (; n < this.textSpans.length; )
                  (this.textSpans[n].span.style.display = "none"), (n += 1);
                this._sizeChanged = !0;
              }),
              (SVGTextLottieElement.prototype.sourceRectAtTime = function () {
                if (
                  (this.prepareFrame(this.comp.renderedFrame - this.data.st),
                  this.renderInnerContent(),
                  this._sizeChanged)
                ) {
                  this._sizeChanged = !1;
                  var n = this.layerElement.getBBox();
                  this.bbox = {
                    top: n.y,
                    left: n.x,
                    width: n.width,
                    height: n.height,
                  };
                }
                return this.bbox;
              }),
              (SVGTextLottieElement.prototype.getValue = function () {
                var n,
                  e = this.textSpans.length,
                  t;
                for (
                  this.renderedFrame = this.comp.renderedFrame, n = 0;
                  n < e;
                  n += 1
                )
                  (t = this.textSpans[n].glyph),
                    t &&
                      (t.prepareFrame(this.comp.renderedFrame - this.data.st),
                      t._mdf && (this._mdf = !0));
              }),
              (SVGTextLottieElement.prototype.renderInnerContent = function () {
                if (
                  (this.validateText(),
                  (!this.data.singleShape || this._mdf) &&
                    (this.textAnimator.getMeasures(
                      this.textProperty.currentData,
                      this.lettersChangedFlag
                    ),
                    this.lettersChangedFlag ||
                      this.textAnimator.lettersChangedFlag))
                ) {
                  this._sizeChanged = !0;
                  var n,
                    e,
                    t = this.textAnimator.renderedLetters,
                    r = this.textProperty.currentData.l;
                  e = r.length;
                  var s, o, a;
                  for (n = 0; n < e; n += 1)
                    r[n].n ||
                      ((s = t[n]),
                      (o = this.textSpans[n].span),
                      (a = this.textSpans[n].glyph),
                      a && a.renderFrame(),
                      s._mdf.m && o.setAttribute("transform", s.m),
                      s._mdf.o && o.setAttribute("opacity", s.o),
                      s._mdf.sw && o.setAttribute("stroke-width", s.sw),
                      s._mdf.sc && o.setAttribute("stroke", s.sc),
                      s._mdf.fc && o.setAttribute("fill", s.fc));
                }
              });
            function ISolidElement(n, e, t) {
              this.initElement(n, e, t);
            }
            extendPrototype([IImageElement], ISolidElement),
              (ISolidElement.prototype.createContent = function () {
                var n = createNS("rect");
                n.setAttribute("width", this.data.sw),
                  n.setAttribute("height", this.data.sh),
                  n.setAttribute("fill", this.data.sc),
                  this.layerElement.appendChild(n);
              });
            function NullElement(n, e, t) {
              this.initFrame(),
                this.initBaseData(n, e, t),
                this.initFrame(),
                this.initTransform(n, e, t),
                this.initHierarchy();
            }
            (NullElement.prototype.prepareFrame = function (n) {
              this.prepareProperties(n, !0);
            }),
              (NullElement.prototype.renderFrame = function () {}),
              (NullElement.prototype.getBaseElement = function () {
                return null;
              }),
              (NullElement.prototype.destroy = function () {}),
              (NullElement.prototype.sourceRectAtTime = function () {}),
              (NullElement.prototype.hide = function () {}),
              extendPrototype(
                [BaseElement, TransformElement, HierarchyElement, FrameElement],
                NullElement
              );
            function SVGRendererBase() {}
            extendPrototype([BaseRenderer], SVGRendererBase),
              (SVGRendererBase.prototype.createNull = function (n) {
                return new NullElement(n, this.globalData, this);
              }),
              (SVGRendererBase.prototype.createShape = function (n) {
                return new SVGShapeElement(n, this.globalData, this);
              }),
              (SVGRendererBase.prototype.createText = function (n) {
                return new SVGTextLottieElement(n, this.globalData, this);
              }),
              (SVGRendererBase.prototype.createImage = function (n) {
                return new IImageElement(n, this.globalData, this);
              }),
              (SVGRendererBase.prototype.createSolid = function (n) {
                return new ISolidElement(n, this.globalData, this);
              }),
              (SVGRendererBase.prototype.configAnimation = function (n) {
                this.svgElement.setAttribute(
                  "xmlns",
                  "http://www.w3.org/2000/svg"
                ),
                  this.svgElement.setAttribute(
                    "xmlns:xlink",
                    "http://www.w3.org/1999/xlink"
                  ),
                  this.renderConfig.viewBoxSize
                    ? this.svgElement.setAttribute(
                        "viewBox",
                        this.renderConfig.viewBoxSize
                      )
                    : this.svgElement.setAttribute(
                        "viewBox",
                        "0 0 " + n.w + " " + n.h
                      ),
                  this.renderConfig.viewBoxOnly ||
                    (this.svgElement.setAttribute("width", n.w),
                    this.svgElement.setAttribute("height", n.h),
                    (this.svgElement.style.width = "100%"),
                    (this.svgElement.style.height = "100%"),
                    (this.svgElement.style.transform = "translate3d(0,0,0)"),
                    (this.svgElement.style.contentVisibility =
                      this.renderConfig.contentVisibility)),
                  this.renderConfig.width &&
                    this.svgElement.setAttribute(
                      "width",
                      this.renderConfig.width
                    ),
                  this.renderConfig.height &&
                    this.svgElement.setAttribute(
                      "height",
                      this.renderConfig.height
                    ),
                  this.renderConfig.className &&
                    this.svgElement.setAttribute(
                      "class",
                      this.renderConfig.className
                    ),
                  this.renderConfig.id &&
                    this.svgElement.setAttribute("id", this.renderConfig.id),
                  this.renderConfig.focusable !== void 0 &&
                    this.svgElement.setAttribute(
                      "focusable",
                      this.renderConfig.focusable
                    ),
                  this.svgElement.setAttribute(
                    "preserveAspectRatio",
                    this.renderConfig.preserveAspectRatio
                  ),
                  this.animationItem.wrapper.appendChild(this.svgElement);
                var e = this.globalData.defs;
                this.setupGlobalData(n, e),
                  (this.globalData.progressiveLoad =
                    this.renderConfig.progressiveLoad),
                  (this.data = n);
                var t = createNS("clipPath"),
                  r = createNS("rect");
                r.setAttribute("width", n.w),
                  r.setAttribute("height", n.h),
                  r.setAttribute("x", 0),
                  r.setAttribute("y", 0);
                var s = createElementID();
                t.setAttribute("id", s),
                  t.appendChild(r),
                  this.layerElement.setAttribute(
                    "clip-path",
                    "url(" + getLocationHref() + "#" + s + ")"
                  ),
                  e.appendChild(t),
                  (this.layers = n.layers),
                  (this.elements = createSizedArray(n.layers.length));
              }),
              (SVGRendererBase.prototype.destroy = function () {
                this.animationItem.wrapper &&
                  (this.animationItem.wrapper.innerText = ""),
                  (this.layerElement = null),
                  (this.globalData.defs = null);
                var n,
                  e = this.layers ? this.layers.length : 0;
                for (n = 0; n < e; n += 1)
                  this.elements[n] &&
                    this.elements[n].destroy &&
                    this.elements[n].destroy();
                (this.elements.length = 0),
                  (this.destroyed = !0),
                  (this.animationItem = null);
              }),
              (SVGRendererBase.prototype.updateContainerSize = function () {}),
              (SVGRendererBase.prototype.findIndexByInd = function (n) {
                var e = 0,
                  t = this.layers.length;
                for (e = 0; e < t; e += 1)
                  if (this.layers[e].ind === n) return e;
                return -1;
              }),
              (SVGRendererBase.prototype.buildItem = function (n) {
                var e = this.elements;
                if (!(e[n] || this.layers[n].ty === 99)) {
                  e[n] = !0;
                  var t = this.createItem(this.layers[n]);
                  if (
                    ((e[n] = t),
                    getExpressionsPlugin() &&
                      (this.layers[n].ty === 0 &&
                        this.globalData.projectInterface.registerComposition(t),
                      t.initExpressions()),
                    this.appendElementInPos(t, n),
                    this.layers[n].tt)
                  ) {
                    var r =
                      "tp" in this.layers[n]
                        ? this.findIndexByInd(this.layers[n].tp)
                        : n - 1;
                    if (r === -1) return;
                    if (!this.elements[r] || this.elements[r] === !0)
                      this.buildItem(r), this.addPendingElement(t);
                    else {
                      var s = e[r],
                        o = s.getMatte(this.layers[n].tt);
                      t.setMatte(o);
                    }
                  }
                }
              }),
              (SVGRendererBase.prototype.checkPendingElements = function () {
                for (; this.pendingElements.length; ) {
                  var n = this.pendingElements.pop();
                  if ((n.checkParenting(), n.data.tt))
                    for (var e = 0, t = this.elements.length; e < t; ) {
                      if (this.elements[e] === n) {
                        var r =
                            "tp" in n.data
                              ? this.findIndexByInd(n.data.tp)
                              : e - 1,
                          s = this.elements[r],
                          o = s.getMatte(this.layers[e].tt);
                        n.setMatte(o);
                        break;
                      }
                      e += 1;
                    }
                }
              }),
              (SVGRendererBase.prototype.renderFrame = function (n) {
                if (!(this.renderedFrame === n || this.destroyed)) {
                  n === null
                    ? (n = this.renderedFrame)
                    : (this.renderedFrame = n),
                    (this.globalData.frameNum = n),
                    (this.globalData.frameId += 1),
                    (this.globalData.projectInterface.currentFrame = n),
                    (this.globalData._mdf = !1);
                  var e,
                    t = this.layers.length;
                  for (
                    this.completeLayers || this.checkLayers(n), e = t - 1;
                    e >= 0;
                    e -= 1
                  )
                    (this.completeLayers || this.elements[e]) &&
                      this.elements[e].prepareFrame(n - this.layers[e].st);
                  if (this.globalData._mdf)
                    for (e = 0; e < t; e += 1)
                      (this.completeLayers || this.elements[e]) &&
                        this.elements[e].renderFrame();
                }
              }),
              (SVGRendererBase.prototype.appendElementInPos = function (n, e) {
                var t = n.getBaseElement();
                if (t) {
                  for (var r = 0, s; r < e; )
                    this.elements[r] &&
                      this.elements[r] !== !0 &&
                      this.elements[r].getBaseElement() &&
                      (s = this.elements[r].getBaseElement()),
                      (r += 1);
                  s
                    ? this.layerElement.insertBefore(t, s)
                    : this.layerElement.appendChild(t);
                }
              }),
              (SVGRendererBase.prototype.hide = function () {
                this.layerElement.style.display = "none";
              }),
              (SVGRendererBase.prototype.show = function () {
                this.layerElement.style.display = "block";
              });
            function ICompElement() {}
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                HierarchyElement,
                FrameElement,
                RenderableDOMElement,
              ],
              ICompElement
            ),
              (ICompElement.prototype.initElement = function (n, e, t) {
                this.initFrame(),
                  this.initBaseData(n, e, t),
                  this.initTransform(n, e, t),
                  this.initRenderable(),
                  this.initHierarchy(),
                  this.initRendererElement(),
                  this.createContainerElements(),
                  this.createRenderableComponents(),
                  (this.data.xt || !e.progressiveLoad) && this.buildAllItems(),
                  this.hide();
              }),
              (ICompElement.prototype.prepareFrame = function (n) {
                if (
                  ((this._mdf = !1),
                  this.prepareRenderableFrame(n),
                  this.prepareProperties(n, this.isInRange),
                  !(!this.isInRange && !this.data.xt))
                ) {
                  if (this.tm._placeholder)
                    this.renderedFrame = n / this.data.sr;
                  else {
                    var e = this.tm.v;
                    e === this.data.op && (e = this.data.op - 1),
                      (this.renderedFrame = e);
                  }
                  var t,
                    r = this.elements.length;
                  for (
                    this.completeLayers || this.checkLayers(this.renderedFrame),
                      t = r - 1;
                    t >= 0;
                    t -= 1
                  )
                    (this.completeLayers || this.elements[t]) &&
                      (this.elements[t].prepareFrame(
                        this.renderedFrame - this.layers[t].st
                      ),
                      this.elements[t]._mdf && (this._mdf = !0));
                }
              }),
              (ICompElement.prototype.renderInnerContent = function () {
                var n,
                  e = this.layers.length;
                for (n = 0; n < e; n += 1)
                  (this.completeLayers || this.elements[n]) &&
                    this.elements[n].renderFrame();
              }),
              (ICompElement.prototype.setElements = function (n) {
                this.elements = n;
              }),
              (ICompElement.prototype.getElements = function () {
                return this.elements;
              }),
              (ICompElement.prototype.destroyElements = function () {
                var n,
                  e = this.layers.length;
                for (n = 0; n < e; n += 1)
                  this.elements[n] && this.elements[n].destroy();
              }),
              (ICompElement.prototype.destroy = function () {
                this.destroyElements(), this.destroyBaseElement();
              });
            function SVGCompElement(n, e, t) {
              (this.layers = n.layers),
                (this.supports3d = !0),
                (this.completeLayers = !1),
                (this.pendingElements = []),
                (this.elements = this.layers
                  ? createSizedArray(this.layers.length)
                  : []),
                this.initElement(n, e, t),
                (this.tm = n.tm
                  ? PropertyFactory.getProp(this, n.tm, 0, e.frameRate, this)
                  : { _placeholder: !0 });
            }
            extendPrototype(
              [SVGRendererBase, ICompElement, SVGBaseElement],
              SVGCompElement
            ),
              (SVGCompElement.prototype.createComp = function (n) {
                return new SVGCompElement(n, this.globalData, this);
              });
            function SVGRenderer(n, e) {
              (this.animationItem = n),
                (this.layers = null),
                (this.renderedFrame = -1),
                (this.svgElement = createNS("svg"));
              var t = "";
              if (e && e.title) {
                var r = createNS("title"),
                  s = createElementID();
                r.setAttribute("id", s),
                  (r.textContent = e.title),
                  this.svgElement.appendChild(r),
                  (t += s);
              }
              if (e && e.description) {
                var o = createNS("desc"),
                  a = createElementID();
                o.setAttribute("id", a),
                  (o.textContent = e.description),
                  this.svgElement.appendChild(o),
                  (t += " " + a);
              }
              t && this.svgElement.setAttribute("aria-labelledby", t);
              var l = createNS("defs");
              this.svgElement.appendChild(l);
              var c = createNS("g");
              this.svgElement.appendChild(c),
                (this.layerElement = c),
                (this.renderConfig = {
                  preserveAspectRatio:
                    (e && e.preserveAspectRatio) || "xMidYMid meet",
                  imagePreserveAspectRatio:
                    (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
                  contentVisibility: (e && e.contentVisibility) || "visible",
                  progressiveLoad: (e && e.progressiveLoad) || !1,
                  hideOnTransparent: !(e && e.hideOnTransparent === !1),
                  viewBoxOnly: (e && e.viewBoxOnly) || !1,
                  viewBoxSize: (e && e.viewBoxSize) || !1,
                  className: (e && e.className) || "",
                  id: (e && e.id) || "",
                  focusable: e && e.focusable,
                  filterSize: {
                    width: (e && e.filterSize && e.filterSize.width) || "100%",
                    height:
                      (e && e.filterSize && e.filterSize.height) || "100%",
                    x: (e && e.filterSize && e.filterSize.x) || "0%",
                    y: (e && e.filterSize && e.filterSize.y) || "0%",
                  },
                  width: e && e.width,
                  height: e && e.height,
                  runExpressions:
                    !e || e.runExpressions === void 0 || e.runExpressions,
                }),
                (this.globalData = {
                  _mdf: !1,
                  frameNum: -1,
                  defs: l,
                  renderConfig: this.renderConfig,
                }),
                (this.elements = []),
                (this.pendingElements = []),
                (this.destroyed = !1),
                (this.rendererType = "svg");
            }
            extendPrototype([SVGRendererBase], SVGRenderer),
              (SVGRenderer.prototype.createComp = function (n) {
                return new SVGCompElement(n, this.globalData, this);
              });
            function ShapeTransformManager() {
              (this.sequences = {}),
                (this.sequenceList = []),
                (this.transform_key_count = 0);
            }
            ShapeTransformManager.prototype = {
              addTransformSequence: function (e) {
                var t,
                  r = e.length,
                  s = "_";
                for (t = 0; t < r; t += 1) s += e[t].transform.key + "_";
                var o = this.sequences[s];
                return (
                  o ||
                    ((o = {
                      transforms: [].concat(e),
                      finalTransform: new Matrix(),
                      _mdf: !1,
                    }),
                    (this.sequences[s] = o),
                    this.sequenceList.push(o)),
                  o
                );
              },
              processSequence: function (e, t) {
                for (var r = 0, s = e.transforms.length, o = t; r < s && !t; ) {
                  if (e.transforms[r].transform.mProps._mdf) {
                    o = !0;
                    break;
                  }
                  r += 1;
                }
                if (o)
                  for (e.finalTransform.reset(), r = s - 1; r >= 0; r -= 1)
                    e.finalTransform.multiply(
                      e.transforms[r].transform.mProps.v
                    );
                e._mdf = o;
              },
              processSequences: function (e) {
                var t,
                  r = this.sequenceList.length;
                for (t = 0; t < r; t += 1)
                  this.processSequence(this.sequenceList[t], e);
              },
              getNewKey: function () {
                return (
                  (this.transform_key_count += 1),
                  "_" + this.transform_key_count
                );
              },
            };
            var lumaLoader = function () {
              var e = "__lottie_element_luma_buffer",
                t = null,
                r = null,
                s = null;
              function o() {
                var c = createNS("svg"),
                  u = createNS("filter"),
                  p = createNS("feColorMatrix");
                return (
                  u.setAttribute("id", e),
                  p.setAttribute("type", "matrix"),
                  p.setAttribute("color-interpolation-filters", "sRGB"),
                  p.setAttribute(
                    "values",
                    "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"
                  ),
                  u.appendChild(p),
                  c.appendChild(u),
                  c.setAttribute("id", e + "_svg"),
                  featureSupport.svgLumaHidden && (c.style.display = "none"),
                  c
                );
              }
              function a() {
                t ||
                  ((s = o()),
                  document.body.appendChild(s),
                  (t = createTag("canvas")),
                  (r = t.getContext("2d")),
                  (r.filter = "url(#" + e + ")"),
                  (r.fillStyle = "rgba(0,0,0,0)"),
                  r.fillRect(0, 0, 1, 1));
              }
              function l(c) {
                return (
                  t || a(),
                  (t.width = c.width),
                  (t.height = c.height),
                  (r.filter = "url(#" + e + ")"),
                  t
                );
              }
              return { load: a, get: l };
            };
            function createCanvas(n, e) {
              if (featureSupport.offscreenCanvas)
                return new OffscreenCanvas(n, e);
              var t = createTag("canvas");
              return (t.width = n), (t.height = e), t;
            }
            var assetLoader = (function () {
                return {
                  loadLumaCanvas: lumaLoader.load,
                  getLumaCanvas: lumaLoader.get,
                  createCanvas,
                };
              })(),
              registeredEffects = {};
            function CVEffects(n) {
              var e,
                t = n.data.ef ? n.data.ef.length : 0;
              this.filters = [];
              var r;
              for (e = 0; e < t; e += 1) {
                r = null;
                var s = n.data.ef[e].ty;
                if (registeredEffects[s]) {
                  var o = registeredEffects[s].effect;
                  r = new o(n.effectsManager.effectElements[e], n);
                }
                r && this.filters.push(r);
              }
              this.filters.length && n.addRenderableComponent(this);
            }
            (CVEffects.prototype.renderFrame = function (n) {
              var e,
                t = this.filters.length;
              for (e = 0; e < t; e += 1) this.filters[e].renderFrame(n);
            }),
              (CVEffects.prototype.getEffects = function (n) {
                var e,
                  t = this.filters.length,
                  r = [];
                for (e = 0; e < t; e += 1)
                  this.filters[e].type === n && r.push(this.filters[e]);
                return r;
              });
            function registerEffect(n, e) {
              registeredEffects[n] = { effect: e };
            }
            function CVMaskElement(n, e) {
              (this.data = n),
                (this.element = e),
                (this.masksProperties = this.data.masksProperties || []),
                (this.viewData = createSizedArray(this.masksProperties.length));
              var t,
                r = this.masksProperties.length,
                s = !1;
              for (t = 0; t < r; t += 1)
                this.masksProperties[t].mode !== "n" && (s = !0),
                  (this.viewData[t] = ShapePropertyFactory.getShapeProp(
                    this.element,
                    this.masksProperties[t],
                    3
                  ));
              (this.hasMasks = s),
                s && this.element.addRenderableComponent(this);
            }
            (CVMaskElement.prototype.renderFrame = function () {
              if (this.hasMasks) {
                var n = this.element.finalTransform.mat,
                  e = this.element.canvasContext,
                  t,
                  r = this.masksProperties.length,
                  s,
                  o,
                  a;
                for (e.beginPath(), t = 0; t < r; t += 1)
                  if (this.masksProperties[t].mode !== "n") {
                    this.masksProperties[t].inv &&
                      (e.moveTo(0, 0),
                      e.lineTo(this.element.globalData.compSize.w, 0),
                      e.lineTo(
                        this.element.globalData.compSize.w,
                        this.element.globalData.compSize.h
                      ),
                      e.lineTo(0, this.element.globalData.compSize.h),
                      e.lineTo(0, 0)),
                      (a = this.viewData[t].v),
                      (s = n.applyToPointArray(a.v[0][0], a.v[0][1], 0)),
                      e.moveTo(s[0], s[1]);
                    var l,
                      c = a._length;
                    for (l = 1; l < c; l += 1)
                      (o = n.applyToTriplePoints(a.o[l - 1], a.i[l], a.v[l])),
                        e.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
                    (o = n.applyToTriplePoints(a.o[l - 1], a.i[0], a.v[0])),
                      e.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
                  }
                this.element.globalData.renderer.save(!0), e.clip();
              }
            }),
              (CVMaskElement.prototype.getMaskProperty =
                MaskElement.prototype.getMaskProperty),
              (CVMaskElement.prototype.destroy = function () {
                this.element = null;
              });
            function CVBaseElement() {}
            var operationsMap = {
              1: "source-in",
              2: "source-out",
              3: "source-in",
              4: "source-out",
            };
            (CVBaseElement.prototype = {
              createElements: function () {},
              initRendererElement: function () {},
              createContainerElements: function () {
                if (this.data.tt >= 1) {
                  this.buffers = [];
                  var e = this.globalData.canvasContext,
                    t = assetLoader.createCanvas(
                      e.canvas.width,
                      e.canvas.height
                    );
                  this.buffers.push(t);
                  var r = assetLoader.createCanvas(
                    e.canvas.width,
                    e.canvas.height
                  );
                  this.buffers.push(r),
                    this.data.tt >= 3 &&
                      !document._isProxy &&
                      assetLoader.loadLumaCanvas();
                }
                (this.canvasContext = this.globalData.canvasContext),
                  (this.transformCanvas = this.globalData.transformCanvas),
                  (this.renderableEffectsManager = new CVEffects(this)),
                  this.searchEffectTransforms();
              },
              createContent: function () {},
              setBlendMode: function () {
                var e = this.globalData;
                if (e.blendMode !== this.data.bm) {
                  e.blendMode = this.data.bm;
                  var t = getBlendMode(this.data.bm);
                  e.canvasContext.globalCompositeOperation = t;
                }
              },
              createRenderableComponents: function () {
                (this.maskManager = new CVMaskElement(this.data, this)),
                  (this.transformEffects =
                    this.renderableEffectsManager.getEffects(
                      effectTypes.TRANSFORM_EFFECT
                    ));
              },
              hideElement: function () {
                !this.hidden &&
                  (!this.isInRange || this.isTransparent) &&
                  (this.hidden = !0);
              },
              showElement: function () {
                this.isInRange &&
                  !this.isTransparent &&
                  ((this.hidden = !1),
                  (this._isFirstFrame = !0),
                  (this.maskManager._isFirstFrame = !0));
              },
              clearCanvas: function (e) {
                e.clearRect(
                  this.transformCanvas.tx,
                  this.transformCanvas.ty,
                  this.transformCanvas.w * this.transformCanvas.sx,
                  this.transformCanvas.h * this.transformCanvas.sy
                );
              },
              prepareLayer: function () {
                if (this.data.tt >= 1) {
                  var e = this.buffers[0],
                    t = e.getContext("2d");
                  this.clearCanvas(t),
                    t.drawImage(this.canvasContext.canvas, 0, 0),
                    (this.currentTransform = this.canvasContext.getTransform()),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform);
                }
              },
              exitLayer: function () {
                if (this.data.tt >= 1) {
                  var e = this.buffers[1],
                    t = e.getContext("2d");
                  this.clearCanvas(t),
                    t.drawImage(this.canvasContext.canvas, 0, 0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform);
                  var r = this.comp.getElementById(
                    "tp" in this.data ? this.data.tp : this.data.ind - 1
                  );
                  if (
                    (r.renderFrame(!0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.data.tt >= 3 && !document._isProxy)
                  ) {
                    var s = assetLoader.getLumaCanvas(
                        this.canvasContext.canvas
                      ),
                      o = s.getContext("2d");
                    o.drawImage(this.canvasContext.canvas, 0, 0),
                      this.clearCanvas(this.canvasContext),
                      this.canvasContext.drawImage(s, 0, 0);
                  }
                  (this.canvasContext.globalCompositeOperation =
                    operationsMap[this.data.tt]),
                    this.canvasContext.drawImage(e, 0, 0),
                    (this.canvasContext.globalCompositeOperation =
                      "destination-over"),
                    this.canvasContext.drawImage(this.buffers[0], 0, 0),
                    this.canvasContext.setTransform(this.currentTransform),
                    (this.canvasContext.globalCompositeOperation =
                      "source-over");
                }
              },
              renderFrame: function (e) {
                if (
                  !(this.hidden || this.data.hd) &&
                  !(this.data.td === 1 && !e)
                ) {
                  this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.setBlendMode();
                  var t = this.data.ty === 0;
                  this.prepareLayer(),
                    this.globalData.renderer.save(t),
                    this.globalData.renderer.ctxTransform(
                      this.finalTransform.localMat.props
                    ),
                    this.globalData.renderer.ctxOpacity(
                      this.finalTransform.localOpacity
                    ),
                    this.renderInnerContent(),
                    this.globalData.renderer.restore(t),
                    this.exitLayer(),
                    this.maskManager.hasMasks &&
                      this.globalData.renderer.restore(!0),
                    this._isFirstFrame && (this._isFirstFrame = !1);
                }
              },
              destroy: function () {
                (this.canvasContext = null),
                  (this.data = null),
                  (this.globalData = null),
                  this.maskManager.destroy();
              },
              mHelper: new Matrix(),
            }),
              (CVBaseElement.prototype.hide =
                CVBaseElement.prototype.hideElement),
              (CVBaseElement.prototype.show =
                CVBaseElement.prototype.showElement);
            function CVShapeData(n, e, t, r) {
              (this.styledShapes = []), (this.tr = [0, 0, 0, 0, 0, 0]);
              var s = 4;
              e.ty === "rc"
                ? (s = 5)
                : e.ty === "el"
                ? (s = 6)
                : e.ty === "sr" && (s = 7),
                (this.sh = ShapePropertyFactory.getShapeProp(n, e, s, n));
              var o,
                a = t.length,
                l;
              for (o = 0; o < a; o += 1)
                t[o].closed ||
                  ((l = {
                    transforms: r.addTransformSequence(t[o].transforms),
                    trNodes: [],
                  }),
                  this.styledShapes.push(l),
                  t[o].elements.push(l));
            }
            CVShapeData.prototype.setAsAnimated =
              SVGShapeData.prototype.setAsAnimated;
            function CVShapeElement(n, e, t) {
              (this.shapes = []),
                (this.shapesData = n.shapes),
                (this.stylesList = []),
                (this.itemsData = []),
                (this.prevViewData = []),
                (this.shapeModifiers = []),
                (this.processedElements = []),
                (this.transformsManager = new ShapeTransformManager()),
                this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                CVBaseElement,
                IShapeElement,
                HierarchyElement,
                FrameElement,
                RenderableElement,
              ],
              CVShapeElement
            ),
              (CVShapeElement.prototype.initElement =
                RenderableDOMElement.prototype.initElement),
              (CVShapeElement.prototype.transformHelper = {
                opacity: 1,
                _opMdf: !1,
              }),
              (CVShapeElement.prototype.dashResetter = []),
              (CVShapeElement.prototype.createContent = function () {
                this.searchShapes(
                  this.shapesData,
                  this.itemsData,
                  this.prevViewData,
                  !0,
                  []
                );
              }),
              (CVShapeElement.prototype.createStyleElement = function (n, e) {
                var t = {
                    data: n,
                    type: n.ty,
                    preTransforms:
                      this.transformsManager.addTransformSequence(e),
                    transforms: [],
                    elements: [],
                    closed: n.hd === !0,
                  },
                  r = {};
                if (
                  (n.ty === "fl" || n.ty === "st"
                    ? ((r.c = PropertyFactory.getProp(this, n.c, 1, 255, this)),
                      r.c.k ||
                        (t.co =
                          "rgb(" +
                          bmFloor(r.c.v[0]) +
                          "," +
                          bmFloor(r.c.v[1]) +
                          "," +
                          bmFloor(r.c.v[2]) +
                          ")"))
                    : (n.ty === "gf" || n.ty === "gs") &&
                      ((r.s = PropertyFactory.getProp(
                        this,
                        n.s,
                        1,
                        null,
                        this
                      )),
                      (r.e = PropertyFactory.getProp(this, n.e, 1, null, this)),
                      (r.h = PropertyFactory.getProp(
                        this,
                        n.h || { k: 0 },
                        0,
                        0.01,
                        this
                      )),
                      (r.a = PropertyFactory.getProp(
                        this,
                        n.a || { k: 0 },
                        0,
                        degToRads,
                        this
                      )),
                      (r.g = new GradientProperty(this, n.g, this))),
                  (r.o = PropertyFactory.getProp(this, n.o, 0, 0.01, this)),
                  n.ty === "st" || n.ty === "gs")
                ) {
                  if (
                    ((t.lc = lineCapEnum[n.lc || 2]),
                    (t.lj = lineJoinEnum[n.lj || 2]),
                    n.lj == 1 && (t.ml = n.ml),
                    (r.w = PropertyFactory.getProp(this, n.w, 0, null, this)),
                    r.w.k || (t.wi = r.w.v),
                    n.d)
                  ) {
                    var s = new DashProperty(this, n.d, "canvas", this);
                    (r.d = s),
                      r.d.k ||
                        ((t.da = r.d.dashArray), (t.do = r.d.dashoffset[0]));
                  }
                } else t.r = n.r === 2 ? "evenodd" : "nonzero";
                return this.stylesList.push(t), (r.style = t), r;
              }),
              (CVShapeElement.prototype.createGroupElement = function () {
                var n = { it: [], prevViewData: [] };
                return n;
              }),
              (CVShapeElement.prototype.createTransformElement = function (n) {
                var e = {
                  transform: {
                    opacity: 1,
                    _opMdf: !1,
                    key: this.transformsManager.getNewKey(),
                    op: PropertyFactory.getProp(this, n.o, 0, 0.01, this),
                    mProps: TransformPropertyFactory.getTransformProperty(
                      this,
                      n,
                      this
                    ),
                  },
                };
                return e;
              }),
              (CVShapeElement.prototype.createShapeElement = function (n) {
                var e = new CVShapeData(
                  this,
                  n,
                  this.stylesList,
                  this.transformsManager
                );
                return this.shapes.push(e), this.addShapeToModifiers(e), e;
              }),
              (CVShapeElement.prototype.reloadShapes = function () {
                this._isFirstFrame = !0;
                var n,
                  e = this.itemsData.length;
                for (n = 0; n < e; n += 1)
                  this.prevViewData[n] = this.itemsData[n];
                for (
                  this.searchShapes(
                    this.shapesData,
                    this.itemsData,
                    this.prevViewData,
                    !0,
                    []
                  ),
                    e = this.dynamicProperties.length,
                    n = 0;
                  n < e;
                  n += 1
                )
                  this.dynamicProperties[n].getValue();
                this.renderModifiers(),
                  this.transformsManager.processSequences(this._isFirstFrame);
              }),
              (CVShapeElement.prototype.addTransformToStyleList = function (n) {
                var e,
                  t = this.stylesList.length;
                for (e = 0; e < t; e += 1)
                  this.stylesList[e].closed ||
                    this.stylesList[e].transforms.push(n);
              }),
              (CVShapeElement.prototype.removeTransformFromStyleList =
                function () {
                  var n,
                    e = this.stylesList.length;
                  for (n = 0; n < e; n += 1)
                    this.stylesList[n].closed ||
                      this.stylesList[n].transforms.pop();
                }),
              (CVShapeElement.prototype.closeStyles = function (n) {
                var e,
                  t = n.length;
                for (e = 0; e < t; e += 1) n[e].closed = !0;
              }),
              (CVShapeElement.prototype.searchShapes = function (
                n,
                e,
                t,
                r,
                s
              ) {
                var o,
                  a = n.length - 1,
                  l,
                  c,
                  u = [],
                  p = [],
                  N,
                  P,
                  de,
                  me = [].concat(s);
                for (o = a; o >= 0; o -= 1) {
                  if (
                    ((N = this.searchProcessedElement(n[o])),
                    N ? (e[o] = t[N - 1]) : (n[o]._shouldRender = r),
                    n[o].ty === "fl" ||
                      n[o].ty === "st" ||
                      n[o].ty === "gf" ||
                      n[o].ty === "gs")
                  )
                    N
                      ? (e[o].style.closed = !1)
                      : (e[o] = this.createStyleElement(n[o], me)),
                      u.push(e[o].style);
                  else if (n[o].ty === "gr") {
                    if (!N) e[o] = this.createGroupElement(n[o]);
                    else
                      for (c = e[o].it.length, l = 0; l < c; l += 1)
                        e[o].prevViewData[l] = e[o].it[l];
                    this.searchShapes(
                      n[o].it,
                      e[o].it,
                      e[o].prevViewData,
                      r,
                      me
                    );
                  } else
                    n[o].ty === "tr"
                      ? (N ||
                          ((de = this.createTransformElement(n[o])),
                          (e[o] = de)),
                        me.push(e[o]),
                        this.addTransformToStyleList(e[o]))
                      : n[o].ty === "sh" ||
                        n[o].ty === "rc" ||
                        n[o].ty === "el" ||
                        n[o].ty === "sr"
                      ? N || (e[o] = this.createShapeElement(n[o]))
                      : n[o].ty === "tm" ||
                        n[o].ty === "rd" ||
                        n[o].ty === "pb" ||
                        n[o].ty === "zz" ||
                        n[o].ty === "op"
                      ? (N
                          ? ((P = e[o]), (P.closed = !1))
                          : ((P = ShapeModifiers.getModifier(n[o].ty)),
                            P.init(this, n[o]),
                            (e[o] = P),
                            this.shapeModifiers.push(P)),
                        p.push(P))
                      : n[o].ty === "rp" &&
                        (N
                          ? ((P = e[o]), (P.closed = !0))
                          : ((P = ShapeModifiers.getModifier(n[o].ty)),
                            (e[o] = P),
                            P.init(this, n, o, e),
                            this.shapeModifiers.push(P),
                            (r = !1)),
                        p.push(P));
                  this.addProcessedElement(n[o], o + 1);
                }
                for (
                  this.removeTransformFromStyleList(),
                    this.closeStyles(u),
                    a = p.length,
                    o = 0;
                  o < a;
                  o += 1
                )
                  p[o].closed = !0;
              }),
              (CVShapeElement.prototype.renderInnerContent = function () {
                (this.transformHelper.opacity = 1),
                  (this.transformHelper._opMdf = !1),
                  this.renderModifiers(),
                  this.transformsManager.processSequences(this._isFirstFrame),
                  this.renderShape(
                    this.transformHelper,
                    this.shapesData,
                    this.itemsData,
                    !0
                  );
              }),
              (CVShapeElement.prototype.renderShapeTransform = function (n, e) {
                (n._opMdf || e.op._mdf || this._isFirstFrame) &&
                  ((e.opacity = n.opacity),
                  (e.opacity *= e.op.v),
                  (e._opMdf = !0));
              }),
              (CVShapeElement.prototype.drawLayer = function () {
                var n,
                  e = this.stylesList.length,
                  t,
                  r,
                  s,
                  o,
                  a,
                  l,
                  c = this.globalData.renderer,
                  u = this.globalData.canvasContext,
                  p,
                  N;
                for (n = 0; n < e; n += 1)
                  if (
                    ((N = this.stylesList[n]),
                    (p = N.type),
                    !(
                      ((p === "st" || p === "gs") && N.wi === 0) ||
                      !N.data._shouldRender ||
                      N.coOp === 0 ||
                      this.globalData.currentGlobalAlpha === 0
                    ))
                  ) {
                    for (
                      c.save(),
                        a = N.elements,
                        p === "st" || p === "gs"
                          ? (c.ctxStrokeStyle(p === "st" ? N.co : N.grd),
                            c.ctxLineWidth(N.wi),
                            c.ctxLineCap(N.lc),
                            c.ctxLineJoin(N.lj),
                            c.ctxMiterLimit(N.ml || 0))
                          : c.ctxFillStyle(p === "fl" ? N.co : N.grd),
                        c.ctxOpacity(N.coOp),
                        p !== "st" && p !== "gs" && u.beginPath(),
                        c.ctxTransform(N.preTransforms.finalTransform.props),
                        r = a.length,
                        t = 0;
                      t < r;
                      t += 1
                    ) {
                      for (
                        (p === "st" || p === "gs") &&
                          (u.beginPath(),
                          N.da &&
                            (u.setLineDash(N.da), (u.lineDashOffset = N.do))),
                          l = a[t].trNodes,
                          o = l.length,
                          s = 0;
                        s < o;
                        s += 1
                      )
                        l[s].t === "m"
                          ? u.moveTo(l[s].p[0], l[s].p[1])
                          : l[s].t === "c"
                          ? u.bezierCurveTo(
                              l[s].pts[0],
                              l[s].pts[1],
                              l[s].pts[2],
                              l[s].pts[3],
                              l[s].pts[4],
                              l[s].pts[5]
                            )
                          : u.closePath();
                      (p === "st" || p === "gs") &&
                        (c.ctxStroke(),
                        N.da && u.setLineDash(this.dashResetter));
                    }
                    p !== "st" &&
                      p !== "gs" &&
                      this.globalData.renderer.ctxFill(N.r),
                      c.restore();
                  }
              }),
              (CVShapeElement.prototype.renderShape = function (n, e, t, r) {
                var s,
                  o = e.length - 1,
                  a;
                for (a = n, s = o; s >= 0; s -= 1)
                  e[s].ty === "tr"
                    ? ((a = t[s].transform), this.renderShapeTransform(n, a))
                    : e[s].ty === "sh" ||
                      e[s].ty === "el" ||
                      e[s].ty === "rc" ||
                      e[s].ty === "sr"
                    ? this.renderPath(e[s], t[s])
                    : e[s].ty === "fl"
                    ? this.renderFill(e[s], t[s], a)
                    : e[s].ty === "st"
                    ? this.renderStroke(e[s], t[s], a)
                    : e[s].ty === "gf" || e[s].ty === "gs"
                    ? this.renderGradientFill(e[s], t[s], a)
                    : e[s].ty === "gr"
                    ? this.renderShape(a, e[s].it, t[s].it)
                    : e[s].ty;
                r && this.drawLayer();
              }),
              (CVShapeElement.prototype.renderStyledShape = function (n, e) {
                if (this._isFirstFrame || e._mdf || n.transforms._mdf) {
                  var t = n.trNodes,
                    r = e.paths,
                    s,
                    o,
                    a,
                    l = r._length;
                  t.length = 0;
                  var c = n.transforms.finalTransform;
                  for (a = 0; a < l; a += 1) {
                    var u = r.shapes[a];
                    if (u && u.v) {
                      for (o = u._length, s = 1; s < o; s += 1)
                        s === 1 &&
                          t.push({
                            t: "m",
                            p: c.applyToPointArray(u.v[0][0], u.v[0][1], 0),
                          }),
                          t.push({
                            t: "c",
                            pts: c.applyToTriplePoints(
                              u.o[s - 1],
                              u.i[s],
                              u.v[s]
                            ),
                          });
                      o === 1 &&
                        t.push({
                          t: "m",
                          p: c.applyToPointArray(u.v[0][0], u.v[0][1], 0),
                        }),
                        u.c &&
                          o &&
                          (t.push({
                            t: "c",
                            pts: c.applyToTriplePoints(
                              u.o[s - 1],
                              u.i[0],
                              u.v[0]
                            ),
                          }),
                          t.push({ t: "z" }));
                    }
                  }
                  n.trNodes = t;
                }
              }),
              (CVShapeElement.prototype.renderPath = function (n, e) {
                if (n.hd !== !0 && n._shouldRender) {
                  var t,
                    r = e.styledShapes.length;
                  for (t = 0; t < r; t += 1)
                    this.renderStyledShape(e.styledShapes[t], e.sh);
                }
              }),
              (CVShapeElement.prototype.renderFill = function (n, e, t) {
                var r = e.style;
                (e.c._mdf || this._isFirstFrame) &&
                  (r.co =
                    "rgb(" +
                    bmFloor(e.c.v[0]) +
                    "," +
                    bmFloor(e.c.v[1]) +
                    "," +
                    bmFloor(e.c.v[2]) +
                    ")"),
                  (e.o._mdf || t._opMdf || this._isFirstFrame) &&
                    (r.coOp = e.o.v * t.opacity);
              }),
              (CVShapeElement.prototype.renderGradientFill = function (
                n,
                e,
                t
              ) {
                var r = e.style,
                  s;
                if (
                  !r.grd ||
                  e.g._mdf ||
                  e.s._mdf ||
                  e.e._mdf ||
                  (n.t !== 1 && (e.h._mdf || e.a._mdf))
                ) {
                  var o = this.globalData.canvasContext,
                    a = e.s.v,
                    l = e.e.v;
                  if (n.t === 1)
                    s = o.createLinearGradient(a[0], a[1], l[0], l[1]);
                  else {
                    var c = Math.sqrt(
                        Math.pow(a[0] - l[0], 2) + Math.pow(a[1] - l[1], 2)
                      ),
                      u = Math.atan2(l[1] - a[1], l[0] - a[0]),
                      p = e.h.v;
                    p >= 1 ? (p = 0.99) : p <= -1 && (p = -0.99);
                    var N = c * p,
                      P = Math.cos(u + e.a.v) * N + a[0],
                      de = Math.sin(u + e.a.v) * N + a[1];
                    s = o.createRadialGradient(P, de, 0, a[0], a[1], c);
                  }
                  var me,
                    Ye = n.g.p,
                    nt = e.g.c,
                    Be = 1;
                  for (me = 0; me < Ye; me += 1)
                    e.g._hasOpacity &&
                      e.g._collapsable &&
                      (Be = e.g.o[me * 2 + 1]),
                      s.addColorStop(
                        nt[me * 4] / 100,
                        "rgba(" +
                          nt[me * 4 + 1] +
                          "," +
                          nt[me * 4 + 2] +
                          "," +
                          nt[me * 4 + 3] +
                          "," +
                          Be +
                          ")"
                      );
                  r.grd = s;
                }
                r.coOp = e.o.v * t.opacity;
              }),
              (CVShapeElement.prototype.renderStroke = function (n, e, t) {
                var r = e.style,
                  s = e.d;
                s &&
                  (s._mdf || this._isFirstFrame) &&
                  ((r.da = s.dashArray), (r.do = s.dashoffset[0])),
                  (e.c._mdf || this._isFirstFrame) &&
                    (r.co =
                      "rgb(" +
                      bmFloor(e.c.v[0]) +
                      "," +
                      bmFloor(e.c.v[1]) +
                      "," +
                      bmFloor(e.c.v[2]) +
                      ")"),
                  (e.o._mdf || t._opMdf || this._isFirstFrame) &&
                    (r.coOp = e.o.v * t.opacity),
                  (e.w._mdf || this._isFirstFrame) && (r.wi = e.w.v);
              }),
              (CVShapeElement.prototype.destroy = function () {
                (this.shapesData = null),
                  (this.globalData = null),
                  (this.canvasContext = null),
                  (this.stylesList.length = 0),
                  (this.itemsData.length = 0);
              });
            function CVTextElement(n, e, t) {
              (this.textSpans = []),
                (this.yOffset = 0),
                (this.fillColorAnim = !1),
                (this.strokeColorAnim = !1),
                (this.strokeWidthAnim = !1),
                (this.stroke = !1),
                (this.fill = !1),
                (this.justifyOffset = 0),
                (this.currentRender = null),
                (this.renderType = "canvas"),
                (this.values = {
                  fill: "rgba(0,0,0,0)",
                  stroke: "rgba(0,0,0,0)",
                  sWidth: 0,
                  fValue: "",
                }),
                this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                CVBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableElement,
                ITextElement,
              ],
              CVTextElement
            ),
              (CVTextElement.prototype.tHelper =
                createTag("canvas").getContext("2d")),
              (CVTextElement.prototype.buildNewText = function () {
                var n = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(n.l ? n.l.length : 0);
                var e = !1;
                n.fc
                  ? ((e = !0), (this.values.fill = this.buildColor(n.fc)))
                  : (this.values.fill = "rgba(0,0,0,0)"),
                  (this.fill = e);
                var t = !1;
                n.sc &&
                  ((t = !0),
                  (this.values.stroke = this.buildColor(n.sc)),
                  (this.values.sWidth = n.sw));
                var r = this.globalData.fontManager.getFontByName(n.f),
                  s,
                  o,
                  a = n.l,
                  l = this.mHelper;
                (this.stroke = t),
                  (this.values.fValue =
                    n.finalSize +
                    "px " +
                    this.globalData.fontManager.getFontByName(n.f).fFamily),
                  (o = n.finalText.length);
                var c,
                  u,
                  p,
                  N,
                  P,
                  de,
                  me,
                  Ye,
                  nt,
                  Be,
                  ot = this.data.singleShape,
                  st = n.tr * 0.001 * n.finalSize,
                  vt = 0,
                  xt = 0,
                  St = !0,
                  wt = 0;
                for (s = 0; s < o; s += 1) {
                  (c = this.globalData.fontManager.getCharData(
                    n.finalText[s],
                    r.fStyle,
                    this.globalData.fontManager.getFontByName(n.f).fFamily
                  )),
                    (u = (c && c.data) || {}),
                    l.reset(),
                    ot &&
                      a[s].n &&
                      ((vt = -st),
                      (xt += n.yOffset),
                      (xt += St ? 1 : 0),
                      (St = !1)),
                    (P = u.shapes ? u.shapes[0].it : []),
                    (me = P.length),
                    l.scale(n.finalSize / 100, n.finalSize / 100),
                    ot &&
                      this.applyTextPropertiesToMatrix(n, l, a[s].line, vt, xt),
                    (nt = createSizedArray(me - 1));
                  var bt = 0;
                  for (de = 0; de < me; de += 1)
                    if (P[de].ty === "sh") {
                      for (
                        N = P[de].ks.k.i.length,
                          Ye = P[de].ks.k,
                          Be = [],
                          p = 1;
                        p < N;
                        p += 1
                      )
                        p === 1 &&
                          Be.push(
                            l.applyToX(Ye.v[0][0], Ye.v[0][1], 0),
                            l.applyToY(Ye.v[0][0], Ye.v[0][1], 0)
                          ),
                          Be.push(
                            l.applyToX(Ye.o[p - 1][0], Ye.o[p - 1][1], 0),
                            l.applyToY(Ye.o[p - 1][0], Ye.o[p - 1][1], 0),
                            l.applyToX(Ye.i[p][0], Ye.i[p][1], 0),
                            l.applyToY(Ye.i[p][0], Ye.i[p][1], 0),
                            l.applyToX(Ye.v[p][0], Ye.v[p][1], 0),
                            l.applyToY(Ye.v[p][0], Ye.v[p][1], 0)
                          );
                      Be.push(
                        l.applyToX(Ye.o[p - 1][0], Ye.o[p - 1][1], 0),
                        l.applyToY(Ye.o[p - 1][0], Ye.o[p - 1][1], 0),
                        l.applyToX(Ye.i[0][0], Ye.i[0][1], 0),
                        l.applyToY(Ye.i[0][0], Ye.i[0][1], 0),
                        l.applyToX(Ye.v[0][0], Ye.v[0][1], 0),
                        l.applyToY(Ye.v[0][0], Ye.v[0][1], 0)
                      ),
                        (nt[bt] = Be),
                        (bt += 1);
                    }
                  ot && ((vt += a[s].l), (vt += st)),
                    this.textSpans[wt]
                      ? (this.textSpans[wt].elem = nt)
                      : (this.textSpans[wt] = { elem: nt }),
                    (wt += 1);
                }
              }),
              (CVTextElement.prototype.renderInnerContent = function () {
                this.validateText();
                var n = this.canvasContext;
                (n.font = this.values.fValue),
                  this.globalData.renderer.ctxLineCap("butt"),
                  this.globalData.renderer.ctxLineJoin("miter"),
                  this.globalData.renderer.ctxMiterLimit(4),
                  this.data.singleShape ||
                    this.textAnimator.getMeasures(
                      this.textProperty.currentData,
                      this.lettersChangedFlag
                    );
                var e,
                  t,
                  r,
                  s,
                  o,
                  a,
                  l = this.textAnimator.renderedLetters,
                  c = this.textProperty.currentData.l;
                t = c.length;
                var u,
                  p = null,
                  N = null,
                  P = null,
                  de,
                  me,
                  Ye = this.globalData.renderer;
                for (e = 0; e < t; e += 1)
                  if (!c[e].n) {
                    if (
                      ((u = l[e]),
                      u &&
                        (Ye.save(), Ye.ctxTransform(u.p), Ye.ctxOpacity(u.o)),
                      this.fill)
                    ) {
                      for (
                        u && u.fc
                          ? p !== u.fc && (Ye.ctxFillStyle(u.fc), (p = u.fc))
                          : p !== this.values.fill &&
                            ((p = this.values.fill),
                            Ye.ctxFillStyle(this.values.fill)),
                          de = this.textSpans[e].elem,
                          s = de.length,
                          this.globalData.canvasContext.beginPath(),
                          r = 0;
                        r < s;
                        r += 1
                      )
                        for (
                          me = de[r],
                            a = me.length,
                            this.globalData.canvasContext.moveTo(me[0], me[1]),
                            o = 2;
                          o < a;
                          o += 6
                        )
                          this.globalData.canvasContext.bezierCurveTo(
                            me[o],
                            me[o + 1],
                            me[o + 2],
                            me[o + 3],
                            me[o + 4],
                            me[o + 5]
                          );
                      this.globalData.canvasContext.closePath(), Ye.ctxFill();
                    }
                    if (this.stroke) {
                      for (
                        u && u.sw
                          ? P !== u.sw && ((P = u.sw), Ye.ctxLineWidth(u.sw))
                          : P !== this.values.sWidth &&
                            ((P = this.values.sWidth),
                            Ye.ctxLineWidth(this.values.sWidth)),
                          u && u.sc
                            ? N !== u.sc &&
                              ((N = u.sc), Ye.ctxStrokeStyle(u.sc))
                            : N !== this.values.stroke &&
                              ((N = this.values.stroke),
                              Ye.ctxStrokeStyle(this.values.stroke)),
                          de = this.textSpans[e].elem,
                          s = de.length,
                          this.globalData.canvasContext.beginPath(),
                          r = 0;
                        r < s;
                        r += 1
                      )
                        for (
                          me = de[r],
                            a = me.length,
                            this.globalData.canvasContext.moveTo(me[0], me[1]),
                            o = 2;
                          o < a;
                          o += 6
                        )
                          this.globalData.canvasContext.bezierCurveTo(
                            me[o],
                            me[o + 1],
                            me[o + 2],
                            me[o + 3],
                            me[o + 4],
                            me[o + 5]
                          );
                      this.globalData.canvasContext.closePath(), Ye.ctxStroke();
                    }
                    u && this.globalData.renderer.restore();
                  }
              });
            function CVImageElement(n, e, t) {
              (this.assetData = e.getAssetData(n.refId)),
                (this.img = e.imageLoader.getAsset(this.assetData)),
                this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                CVBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableElement,
              ],
              CVImageElement
            ),
              (CVImageElement.prototype.initElement =
                SVGShapeElement.prototype.initElement),
              (CVImageElement.prototype.prepareFrame =
                IImageElement.prototype.prepareFrame),
              (CVImageElement.prototype.createContent = function () {
                if (
                  this.img.width &&
                  (this.assetData.w !== this.img.width ||
                    this.assetData.h !== this.img.height)
                ) {
                  var n = createTag("canvas");
                  (n.width = this.assetData.w), (n.height = this.assetData.h);
                  var e = n.getContext("2d"),
                    t = this.img.width,
                    r = this.img.height,
                    s = t / r,
                    o = this.assetData.w / this.assetData.h,
                    a,
                    l,
                    c =
                      this.assetData.pr ||
                      this.globalData.renderConfig.imagePreserveAspectRatio;
                  (s > o && c === "xMidYMid slice") ||
                  (s < o && c !== "xMidYMid slice")
                    ? ((l = r), (a = l * o))
                    : ((a = t), (l = a / o)),
                    e.drawImage(
                      this.img,
                      (t - a) / 2,
                      (r - l) / 2,
                      a,
                      l,
                      0,
                      0,
                      this.assetData.w,
                      this.assetData.h
                    ),
                    (this.img = n);
                }
              }),
              (CVImageElement.prototype.renderInnerContent = function () {
                this.canvasContext.drawImage(this.img, 0, 0);
              }),
              (CVImageElement.prototype.destroy = function () {
                this.img = null;
              });
            function CVSolidElement(n, e, t) {
              this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                CVBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableElement,
              ],
              CVSolidElement
            ),
              (CVSolidElement.prototype.initElement =
                SVGShapeElement.prototype.initElement),
              (CVSolidElement.prototype.prepareFrame =
                IImageElement.prototype.prepareFrame),
              (CVSolidElement.prototype.renderInnerContent = function () {
                this.globalData.renderer.ctxFillStyle(this.data.sc),
                  this.globalData.renderer.ctxFillRect(
                    0,
                    0,
                    this.data.sw,
                    this.data.sh
                  );
              });
            function CanvasRendererBase() {}
            extendPrototype([BaseRenderer], CanvasRendererBase),
              (CanvasRendererBase.prototype.createShape = function (n) {
                return new CVShapeElement(n, this.globalData, this);
              }),
              (CanvasRendererBase.prototype.createText = function (n) {
                return new CVTextElement(n, this.globalData, this);
              }),
              (CanvasRendererBase.prototype.createImage = function (n) {
                return new CVImageElement(n, this.globalData, this);
              }),
              (CanvasRendererBase.prototype.createSolid = function (n) {
                return new CVSolidElement(n, this.globalData, this);
              }),
              (CanvasRendererBase.prototype.createNull =
                SVGRenderer.prototype.createNull),
              (CanvasRendererBase.prototype.ctxTransform = function (n) {
                (n[0] === 1 &&
                  n[1] === 0 &&
                  n[4] === 0 &&
                  n[5] === 1 &&
                  n[12] === 0 &&
                  n[13] === 0) ||
                  this.canvasContext.transform(
                    n[0],
                    n[1],
                    n[4],
                    n[5],
                    n[12],
                    n[13]
                  );
              }),
              (CanvasRendererBase.prototype.ctxOpacity = function (n) {
                this.canvasContext.globalAlpha *= n < 0 ? 0 : n;
              }),
              (CanvasRendererBase.prototype.ctxFillStyle = function (n) {
                this.canvasContext.fillStyle = n;
              }),
              (CanvasRendererBase.prototype.ctxStrokeStyle = function (n) {
                this.canvasContext.strokeStyle = n;
              }),
              (CanvasRendererBase.prototype.ctxLineWidth = function (n) {
                this.canvasContext.lineWidth = n;
              }),
              (CanvasRendererBase.prototype.ctxLineCap = function (n) {
                this.canvasContext.lineCap = n;
              }),
              (CanvasRendererBase.prototype.ctxLineJoin = function (n) {
                this.canvasContext.lineJoin = n;
              }),
              (CanvasRendererBase.prototype.ctxMiterLimit = function (n) {
                this.canvasContext.miterLimit = n;
              }),
              (CanvasRendererBase.prototype.ctxFill = function (n) {
                this.canvasContext.fill(n);
              }),
              (CanvasRendererBase.prototype.ctxFillRect = function (
                n,
                e,
                t,
                r
              ) {
                this.canvasContext.fillRect(n, e, t, r);
              }),
              (CanvasRendererBase.prototype.ctxStroke = function () {
                this.canvasContext.stroke();
              }),
              (CanvasRendererBase.prototype.reset = function () {
                if (!this.renderConfig.clearCanvas) {
                  this.canvasContext.restore();
                  return;
                }
                this.contextData.reset();
              }),
              (CanvasRendererBase.prototype.save = function () {
                this.canvasContext.save();
              }),
              (CanvasRendererBase.prototype.restore = function (n) {
                if (!this.renderConfig.clearCanvas) {
                  this.canvasContext.restore();
                  return;
                }
                n && (this.globalData.blendMode = "source-over"),
                  this.contextData.restore(n);
              }),
              (CanvasRendererBase.prototype.configAnimation = function (n) {
                if (this.animationItem.wrapper) {
                  this.animationItem.container = createTag("canvas");
                  var e = this.animationItem.container.style;
                  (e.width = "100%"), (e.height = "100%");
                  var t = "0px 0px 0px";
                  (e.transformOrigin = t),
                    (e.mozTransformOrigin = t),
                    (e.webkitTransformOrigin = t),
                    (e["-webkit-transform"] = t),
                    (e.contentVisibility = this.renderConfig.contentVisibility),
                    this.animationItem.wrapper.appendChild(
                      this.animationItem.container
                    ),
                    (this.canvasContext =
                      this.animationItem.container.getContext("2d")),
                    this.renderConfig.className &&
                      this.animationItem.container.setAttribute(
                        "class",
                        this.renderConfig.className
                      ),
                    this.renderConfig.id &&
                      this.animationItem.container.setAttribute(
                        "id",
                        this.renderConfig.id
                      );
                } else this.canvasContext = this.renderConfig.context;
                this.contextData.setContext(this.canvasContext),
                  (this.data = n),
                  (this.layers = n.layers),
                  (this.transformCanvas = {
                    w: n.w,
                    h: n.h,
                    sx: 0,
                    sy: 0,
                    tx: 0,
                    ty: 0,
                  }),
                  this.setupGlobalData(n, document.body),
                  (this.globalData.canvasContext = this.canvasContext),
                  (this.globalData.renderer = this),
                  (this.globalData.isDashed = !1),
                  (this.globalData.progressiveLoad =
                    this.renderConfig.progressiveLoad),
                  (this.globalData.transformCanvas = this.transformCanvas),
                  (this.elements = createSizedArray(n.layers.length)),
                  this.updateContainerSize();
              }),
              (CanvasRendererBase.prototype.updateContainerSize = function (
                n,
                e
              ) {
                this.reset();
                var t, r;
                n
                  ? ((t = n),
                    (r = e),
                    (this.canvasContext.canvas.width = t),
                    (this.canvasContext.canvas.height = r))
                  : (this.animationItem.wrapper && this.animationItem.container
                      ? ((t = this.animationItem.wrapper.offsetWidth),
                        (r = this.animationItem.wrapper.offsetHeight))
                      : ((t = this.canvasContext.canvas.width),
                        (r = this.canvasContext.canvas.height)),
                    (this.canvasContext.canvas.width =
                      t * this.renderConfig.dpr),
                    (this.canvasContext.canvas.height =
                      r * this.renderConfig.dpr));
                var s, o;
                if (
                  this.renderConfig.preserveAspectRatio.indexOf("meet") !==
                    -1 ||
                  this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1
                ) {
                  var a = this.renderConfig.preserveAspectRatio.split(" "),
                    l = a[1] || "meet",
                    c = a[0] || "xMidYMid",
                    u = c.substr(0, 4),
                    p = c.substr(4);
                  (s = t / r),
                    (o = this.transformCanvas.w / this.transformCanvas.h),
                    (o > s && l === "meet") || (o < s && l === "slice")
                      ? ((this.transformCanvas.sx =
                          t / (this.transformCanvas.w / this.renderConfig.dpr)),
                        (this.transformCanvas.sy =
                          t / (this.transformCanvas.w / this.renderConfig.dpr)))
                      : ((this.transformCanvas.sx =
                          r / (this.transformCanvas.h / this.renderConfig.dpr)),
                        (this.transformCanvas.sy =
                          r /
                          (this.transformCanvas.h / this.renderConfig.dpr))),
                    u === "xMid" &&
                    ((o < s && l === "meet") || (o > s && l === "slice"))
                      ? (this.transformCanvas.tx =
                          ((t -
                            this.transformCanvas.w *
                              (r / this.transformCanvas.h)) /
                            2) *
                          this.renderConfig.dpr)
                      : u === "xMax" &&
                        ((o < s && l === "meet") || (o > s && l === "slice"))
                      ? (this.transformCanvas.tx =
                          (t -
                            this.transformCanvas.w *
                              (r / this.transformCanvas.h)) *
                          this.renderConfig.dpr)
                      : (this.transformCanvas.tx = 0),
                    p === "YMid" &&
                    ((o > s && l === "meet") || (o < s && l === "slice"))
                      ? (this.transformCanvas.ty =
                          ((r -
                            this.transformCanvas.h *
                              (t / this.transformCanvas.w)) /
                            2) *
                          this.renderConfig.dpr)
                      : p === "YMax" &&
                        ((o > s && l === "meet") || (o < s && l === "slice"))
                      ? (this.transformCanvas.ty =
                          (r -
                            this.transformCanvas.h *
                              (t / this.transformCanvas.w)) *
                          this.renderConfig.dpr)
                      : (this.transformCanvas.ty = 0);
                } else
                  this.renderConfig.preserveAspectRatio === "none"
                    ? ((this.transformCanvas.sx =
                        t / (this.transformCanvas.w / this.renderConfig.dpr)),
                      (this.transformCanvas.sy =
                        r / (this.transformCanvas.h / this.renderConfig.dpr)),
                      (this.transformCanvas.tx = 0),
                      (this.transformCanvas.ty = 0))
                    : ((this.transformCanvas.sx = this.renderConfig.dpr),
                      (this.transformCanvas.sy = this.renderConfig.dpr),
                      (this.transformCanvas.tx = 0),
                      (this.transformCanvas.ty = 0));
                (this.transformCanvas.props = [
                  this.transformCanvas.sx,
                  0,
                  0,
                  0,
                  0,
                  this.transformCanvas.sy,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  this.transformCanvas.tx,
                  this.transformCanvas.ty,
                  0,
                  1,
                ]),
                  this.ctxTransform(this.transformCanvas.props),
                  this.canvasContext.beginPath(),
                  this.canvasContext.rect(
                    0,
                    0,
                    this.transformCanvas.w,
                    this.transformCanvas.h
                  ),
                  this.canvasContext.closePath(),
                  this.canvasContext.clip(),
                  this.renderFrame(this.renderedFrame, !0);
              }),
              (CanvasRendererBase.prototype.destroy = function () {
                this.renderConfig.clearCanvas &&
                  this.animationItem.wrapper &&
                  (this.animationItem.wrapper.innerText = "");
                var n,
                  e = this.layers ? this.layers.length : 0;
                for (n = e - 1; n >= 0; n -= 1)
                  this.elements[n] &&
                    this.elements[n].destroy &&
                    this.elements[n].destroy();
                (this.elements.length = 0),
                  (this.globalData.canvasContext = null),
                  (this.animationItem.container = null),
                  (this.destroyed = !0);
              }),
              (CanvasRendererBase.prototype.renderFrame = function (n, e) {
                if (
                  !(
                    (this.renderedFrame === n &&
                      this.renderConfig.clearCanvas === !0 &&
                      !e) ||
                    this.destroyed ||
                    n === -1
                  )
                ) {
                  (this.renderedFrame = n),
                    (this.globalData.frameNum =
                      n - this.animationItem._isFirstFrame),
                    (this.globalData.frameId += 1),
                    (this.globalData._mdf =
                      !this.renderConfig.clearCanvas || e),
                    (this.globalData.projectInterface.currentFrame = n);
                  var t,
                    r = this.layers.length;
                  for (
                    this.completeLayers || this.checkLayers(n), t = r - 1;
                    t >= 0;
                    t -= 1
                  )
                    (this.completeLayers || this.elements[t]) &&
                      this.elements[t].prepareFrame(n - this.layers[t].st);
                  if (this.globalData._mdf) {
                    for (
                      this.renderConfig.clearCanvas === !0
                        ? this.canvasContext.clearRect(
                            0,
                            0,
                            this.transformCanvas.w,
                            this.transformCanvas.h
                          )
                        : this.save(),
                        t = r - 1;
                      t >= 0;
                      t -= 1
                    )
                      (this.completeLayers || this.elements[t]) &&
                        this.elements[t].renderFrame();
                    this.renderConfig.clearCanvas !== !0 && this.restore();
                  }
                }
              }),
              (CanvasRendererBase.prototype.buildItem = function (n) {
                var e = this.elements;
                if (!(e[n] || this.layers[n].ty === 99)) {
                  var t = this.createItem(
                    this.layers[n],
                    this,
                    this.globalData
                  );
                  (e[n] = t), t.initExpressions();
                }
              }),
              (CanvasRendererBase.prototype.checkPendingElements = function () {
                for (; this.pendingElements.length; ) {
                  var n = this.pendingElements.pop();
                  n.checkParenting();
                }
              }),
              (CanvasRendererBase.prototype.hide = function () {
                this.animationItem.container.style.display = "none";
              }),
              (CanvasRendererBase.prototype.show = function () {
                this.animationItem.container.style.display = "block";
              });
            function CanvasContext() {
              (this.opacity = -1),
                (this.transform = createTypedArray("float32", 16)),
                (this.fillStyle = ""),
                (this.strokeStyle = ""),
                (this.lineWidth = ""),
                (this.lineCap = ""),
                (this.lineJoin = ""),
                (this.miterLimit = ""),
                (this.id = Math.random());
            }
            function CVContextData() {
              (this.stack = []), (this.cArrPos = 0), (this.cTr = new Matrix());
              var n,
                e = 15;
              for (n = 0; n < e; n += 1) {
                var t = new CanvasContext();
                this.stack[n] = t;
              }
              (this._length = e),
                (this.nativeContext = null),
                (this.transformMat = new Matrix()),
                (this.currentOpacity = 1),
                (this.currentFillStyle = ""),
                (this.appliedFillStyle = ""),
                (this.currentStrokeStyle = ""),
                (this.appliedStrokeStyle = ""),
                (this.currentLineWidth = ""),
                (this.appliedLineWidth = ""),
                (this.currentLineCap = ""),
                (this.appliedLineCap = ""),
                (this.currentLineJoin = ""),
                (this.appliedLineJoin = ""),
                (this.appliedMiterLimit = ""),
                (this.currentMiterLimit = "");
            }
            (CVContextData.prototype.duplicate = function () {
              var n = this._length * 2,
                e = 0;
              for (e = this._length; e < n; e += 1)
                this.stack[e] = new CanvasContext();
              this._length = n;
            }),
              (CVContextData.prototype.reset = function () {
                (this.cArrPos = 0),
                  this.cTr.reset(),
                  (this.stack[this.cArrPos].opacity = 1);
              }),
              (CVContextData.prototype.restore = function (n) {
                this.cArrPos -= 1;
                var e = this.stack[this.cArrPos],
                  t = e.transform,
                  r,
                  s = this.cTr.props;
                for (r = 0; r < 16; r += 1) s[r] = t[r];
                if (n) {
                  this.nativeContext.restore();
                  var o = this.stack[this.cArrPos + 1];
                  (this.appliedFillStyle = o.fillStyle),
                    (this.appliedStrokeStyle = o.strokeStyle),
                    (this.appliedLineWidth = o.lineWidth),
                    (this.appliedLineCap = o.lineCap),
                    (this.appliedLineJoin = o.lineJoin),
                    (this.appliedMiterLimit = o.miterLimit);
                }
                this.nativeContext.setTransform(
                  t[0],
                  t[1],
                  t[4],
                  t[5],
                  t[12],
                  t[13]
                ),
                  (n ||
                    (e.opacity !== -1 && this.currentOpacity !== e.opacity)) &&
                    ((this.nativeContext.globalAlpha = e.opacity),
                    (this.currentOpacity = e.opacity)),
                  (this.currentFillStyle = e.fillStyle),
                  (this.currentStrokeStyle = e.strokeStyle),
                  (this.currentLineWidth = e.lineWidth),
                  (this.currentLineCap = e.lineCap),
                  (this.currentLineJoin = e.lineJoin),
                  (this.currentMiterLimit = e.miterLimit);
              }),
              (CVContextData.prototype.save = function (n) {
                n && this.nativeContext.save();
                var e = this.cTr.props;
                this._length <= this.cArrPos && this.duplicate();
                var t = this.stack[this.cArrPos],
                  r;
                for (r = 0; r < 16; r += 1) t.transform[r] = e[r];
                this.cArrPos += 1;
                var s = this.stack[this.cArrPos];
                (s.opacity = t.opacity),
                  (s.fillStyle = t.fillStyle),
                  (s.strokeStyle = t.strokeStyle),
                  (s.lineWidth = t.lineWidth),
                  (s.lineCap = t.lineCap),
                  (s.lineJoin = t.lineJoin),
                  (s.miterLimit = t.miterLimit);
              }),
              (CVContextData.prototype.setOpacity = function (n) {
                this.stack[this.cArrPos].opacity = n;
              }),
              (CVContextData.prototype.setContext = function (n) {
                this.nativeContext = n;
              }),
              (CVContextData.prototype.fillStyle = function (n) {
                this.stack[this.cArrPos].fillStyle !== n &&
                  ((this.currentFillStyle = n),
                  (this.stack[this.cArrPos].fillStyle = n));
              }),
              (CVContextData.prototype.strokeStyle = function (n) {
                this.stack[this.cArrPos].strokeStyle !== n &&
                  ((this.currentStrokeStyle = n),
                  (this.stack[this.cArrPos].strokeStyle = n));
              }),
              (CVContextData.prototype.lineWidth = function (n) {
                this.stack[this.cArrPos].lineWidth !== n &&
                  ((this.currentLineWidth = n),
                  (this.stack[this.cArrPos].lineWidth = n));
              }),
              (CVContextData.prototype.lineCap = function (n) {
                this.stack[this.cArrPos].lineCap !== n &&
                  ((this.currentLineCap = n),
                  (this.stack[this.cArrPos].lineCap = n));
              }),
              (CVContextData.prototype.lineJoin = function (n) {
                this.stack[this.cArrPos].lineJoin !== n &&
                  ((this.currentLineJoin = n),
                  (this.stack[this.cArrPos].lineJoin = n));
              }),
              (CVContextData.prototype.miterLimit = function (n) {
                this.stack[this.cArrPos].miterLimit !== n &&
                  ((this.currentMiterLimit = n),
                  (this.stack[this.cArrPos].miterLimit = n));
              }),
              (CVContextData.prototype.transform = function (n) {
                this.transformMat.cloneFromProps(n);
                var e = this.cTr;
                this.transformMat.multiply(e),
                  e.cloneFromProps(this.transformMat.props);
                var t = e.props;
                this.nativeContext.setTransform(
                  t[0],
                  t[1],
                  t[4],
                  t[5],
                  t[12],
                  t[13]
                );
              }),
              (CVContextData.prototype.opacity = function (n) {
                var e = this.stack[this.cArrPos].opacity;
                (e *= n < 0 ? 0 : n),
                  this.stack[this.cArrPos].opacity !== e &&
                    (this.currentOpacity !== n &&
                      ((this.nativeContext.globalAlpha = n),
                      (this.currentOpacity = n)),
                    (this.stack[this.cArrPos].opacity = e));
              }),
              (CVContextData.prototype.fill = function (n) {
                this.appliedFillStyle !== this.currentFillStyle &&
                  ((this.appliedFillStyle = this.currentFillStyle),
                  (this.nativeContext.fillStyle = this.appliedFillStyle)),
                  this.nativeContext.fill(n);
              }),
              (CVContextData.prototype.fillRect = function (n, e, t, r) {
                this.appliedFillStyle !== this.currentFillStyle &&
                  ((this.appliedFillStyle = this.currentFillStyle),
                  (this.nativeContext.fillStyle = this.appliedFillStyle)),
                  this.nativeContext.fillRect(n, e, t, r);
              }),
              (CVContextData.prototype.stroke = function () {
                this.appliedStrokeStyle !== this.currentStrokeStyle &&
                  ((this.appliedStrokeStyle = this.currentStrokeStyle),
                  (this.nativeContext.strokeStyle = this.appliedStrokeStyle)),
                  this.appliedLineWidth !== this.currentLineWidth &&
                    ((this.appliedLineWidth = this.currentLineWidth),
                    (this.nativeContext.lineWidth = this.appliedLineWidth)),
                  this.appliedLineCap !== this.currentLineCap &&
                    ((this.appliedLineCap = this.currentLineCap),
                    (this.nativeContext.lineCap = this.appliedLineCap)),
                  this.appliedLineJoin !== this.currentLineJoin &&
                    ((this.appliedLineJoin = this.currentLineJoin),
                    (this.nativeContext.lineJoin = this.appliedLineJoin)),
                  this.appliedMiterLimit !== this.currentMiterLimit &&
                    ((this.appliedMiterLimit = this.currentMiterLimit),
                    (this.nativeContext.miterLimit = this.appliedMiterLimit)),
                  this.nativeContext.stroke();
              });
            function CVCompElement(n, e, t) {
              (this.completeLayers = !1),
                (this.layers = n.layers),
                (this.pendingElements = []),
                (this.elements = createSizedArray(this.layers.length)),
                this.initElement(n, e, t),
                (this.tm = n.tm
                  ? PropertyFactory.getProp(this, n.tm, 0, e.frameRate, this)
                  : { _placeholder: !0 });
            }
            extendPrototype(
              [CanvasRendererBase, ICompElement, CVBaseElement],
              CVCompElement
            ),
              (CVCompElement.prototype.renderInnerContent = function () {
                var n = this.canvasContext;
                n.beginPath(),
                  n.moveTo(0, 0),
                  n.lineTo(this.data.w, 0),
                  n.lineTo(this.data.w, this.data.h),
                  n.lineTo(0, this.data.h),
                  n.lineTo(0, 0),
                  n.clip();
                var e,
                  t = this.layers.length;
                for (e = t - 1; e >= 0; e -= 1)
                  (this.completeLayers || this.elements[e]) &&
                    this.elements[e].renderFrame();
              }),
              (CVCompElement.prototype.destroy = function () {
                var n,
                  e = this.layers.length;
                for (n = e - 1; n >= 0; n -= 1)
                  this.elements[n] && this.elements[n].destroy();
                (this.layers = null), (this.elements = null);
              }),
              (CVCompElement.prototype.createComp = function (n) {
                return new CVCompElement(n, this.globalData, this);
              });
            function CanvasRenderer(n, e) {
              (this.animationItem = n),
                (this.renderConfig = {
                  clearCanvas:
                    e && e.clearCanvas !== void 0 ? e.clearCanvas : !0,
                  context: (e && e.context) || null,
                  progressiveLoad: (e && e.progressiveLoad) || !1,
                  preserveAspectRatio:
                    (e && e.preserveAspectRatio) || "xMidYMid meet",
                  imagePreserveAspectRatio:
                    (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
                  contentVisibility: (e && e.contentVisibility) || "visible",
                  className: (e && e.className) || "",
                  id: (e && e.id) || "",
                  runExpressions:
                    !e || e.runExpressions === void 0 || e.runExpressions,
                }),
                (this.renderConfig.dpr = (e && e.dpr) || 1),
                this.animationItem.wrapper &&
                  (this.renderConfig.dpr =
                    (e && e.dpr) || window.devicePixelRatio || 1),
                (this.renderedFrame = -1),
                (this.globalData = {
                  frameNum: -1,
                  _mdf: !1,
                  renderConfig: this.renderConfig,
                  currentGlobalAlpha: -1,
                }),
                (this.contextData = new CVContextData()),
                (this.elements = []),
                (this.pendingElements = []),
                (this.transformMat = new Matrix()),
                (this.completeLayers = !1),
                (this.rendererType = "canvas"),
                this.renderConfig.clearCanvas &&
                  ((this.ctxTransform = this.contextData.transform.bind(
                    this.contextData
                  )),
                  (this.ctxOpacity = this.contextData.opacity.bind(
                    this.contextData
                  )),
                  (this.ctxFillStyle = this.contextData.fillStyle.bind(
                    this.contextData
                  )),
                  (this.ctxStrokeStyle = this.contextData.strokeStyle.bind(
                    this.contextData
                  )),
                  (this.ctxLineWidth = this.contextData.lineWidth.bind(
                    this.contextData
                  )),
                  (this.ctxLineCap = this.contextData.lineCap.bind(
                    this.contextData
                  )),
                  (this.ctxLineJoin = this.contextData.lineJoin.bind(
                    this.contextData
                  )),
                  (this.ctxMiterLimit = this.contextData.miterLimit.bind(
                    this.contextData
                  )),
                  (this.ctxFill = this.contextData.fill.bind(this.contextData)),
                  (this.ctxFillRect = this.contextData.fillRect.bind(
                    this.contextData
                  )),
                  (this.ctxStroke = this.contextData.stroke.bind(
                    this.contextData
                  )),
                  (this.save = this.contextData.save.bind(this.contextData)));
            }
            extendPrototype([CanvasRendererBase], CanvasRenderer),
              (CanvasRenderer.prototype.createComp = function (n) {
                return new CVCompElement(n, this.globalData, this);
              });
            function HBaseElement() {}
            (HBaseElement.prototype = {
              checkBlendMode: function () {},
              initRendererElement: function () {
                (this.baseElement = createTag(this.data.tg || "div")),
                  this.data.hasMask
                    ? ((this.svgElement = createNS("svg")),
                      (this.layerElement = createNS("g")),
                      (this.maskedElement = this.layerElement),
                      this.svgElement.appendChild(this.layerElement),
                      this.baseElement.appendChild(this.svgElement))
                    : (this.layerElement = this.baseElement),
                  styleDiv(this.baseElement);
              },
              createContainerElements: function () {
                (this.renderableEffectsManager = new CVEffects(this)),
                  (this.transformedElement = this.baseElement),
                  (this.maskedElement = this.layerElement),
                  this.data.ln &&
                    this.layerElement.setAttribute("id", this.data.ln),
                  this.data.cl &&
                    this.layerElement.setAttribute("class", this.data.cl),
                  this.data.bm !== 0 && this.setBlendMode();
              },
              renderElement: function () {
                var e = this.transformedElement
                  ? this.transformedElement.style
                  : {};
                if (this.finalTransform._matMdf) {
                  var t = this.finalTransform.mat.toCSS();
                  (e.transform = t), (e.webkitTransform = t);
                }
                this.finalTransform._opMdf &&
                  (e.opacity = this.finalTransform.mProp.o.v);
              },
              renderFrame: function () {
                this.data.hd ||
                  this.hidden ||
                  (this.renderTransform(),
                  this.renderRenderable(),
                  this.renderElement(),
                  this.renderInnerContent(),
                  this._isFirstFrame && (this._isFirstFrame = !1));
              },
              destroy: function () {
                (this.layerElement = null),
                  (this.transformedElement = null),
                  this.matteElement && (this.matteElement = null),
                  this.maskManager &&
                    (this.maskManager.destroy(), (this.maskManager = null));
              },
              createRenderableComponents: function () {
                this.maskManager = new MaskElement(
                  this.data,
                  this,
                  this.globalData
                );
              },
              addEffects: function () {},
              setMatte: function () {},
            }),
              (HBaseElement.prototype.getBaseElement =
                SVGBaseElement.prototype.getBaseElement),
              (HBaseElement.prototype.destroyBaseElement =
                HBaseElement.prototype.destroy),
              (HBaseElement.prototype.buildElementParenting =
                BaseRenderer.prototype.buildElementParenting);
            function HSolidElement(n, e, t) {
              this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                HBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableDOMElement,
              ],
              HSolidElement
            ),
              (HSolidElement.prototype.createContent = function () {
                var n;
                this.data.hasMask
                  ? ((n = createNS("rect")),
                    n.setAttribute("width", this.data.sw),
                    n.setAttribute("height", this.data.sh),
                    n.setAttribute("fill", this.data.sc),
                    this.svgElement.setAttribute("width", this.data.sw),
                    this.svgElement.setAttribute("height", this.data.sh))
                  : ((n = createTag("div")),
                    (n.style.width = this.data.sw + "px"),
                    (n.style.height = this.data.sh + "px"),
                    (n.style.backgroundColor = this.data.sc)),
                  this.layerElement.appendChild(n);
              });
            function HShapeElement(n, e, t) {
              (this.shapes = []),
                (this.shapesData = n.shapes),
                (this.stylesList = []),
                (this.shapeModifiers = []),
                (this.itemsData = []),
                (this.processedElements = []),
                (this.animatedContents = []),
                (this.shapesContainer = createNS("g")),
                this.initElement(n, e, t),
                (this.prevViewData = []),
                (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 });
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                HSolidElement,
                SVGShapeElement,
                HBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableElement,
              ],
              HShapeElement
            ),
              (HShapeElement.prototype._renderShapeFrame =
                HShapeElement.prototype.renderInnerContent),
              (HShapeElement.prototype.createContent = function () {
                var n;
                if (((this.baseElement.style.fontSize = 0), this.data.hasMask))
                  this.layerElement.appendChild(this.shapesContainer),
                    (n = this.svgElement);
                else {
                  n = createNS("svg");
                  var e = this.comp.data
                    ? this.comp.data
                    : this.globalData.compSize;
                  n.setAttribute("width", e.w),
                    n.setAttribute("height", e.h),
                    n.appendChild(this.shapesContainer),
                    this.layerElement.appendChild(n);
                }
                this.searchShapes(
                  this.shapesData,
                  this.itemsData,
                  this.prevViewData,
                  this.shapesContainer,
                  0,
                  [],
                  !0
                ),
                  this.filterUniqueShapes(),
                  (this.shapeCont = n);
              }),
              (HShapeElement.prototype.getTransformedPoint = function (n, e) {
                var t,
                  r = n.length;
                for (t = 0; t < r; t += 1)
                  e = n[t].mProps.v.applyToPointArray(e[0], e[1], 0);
                return e;
              }),
              (HShapeElement.prototype.calculateShapeBoundingBox = function (
                n,
                e
              ) {
                var t = n.sh.v,
                  r = n.transformers,
                  s,
                  o = t._length,
                  a,
                  l,
                  c,
                  u;
                if (!(o <= 1)) {
                  for (s = 0; s < o - 1; s += 1)
                    (a = this.getTransformedPoint(r, t.v[s])),
                      (l = this.getTransformedPoint(r, t.o[s])),
                      (c = this.getTransformedPoint(r, t.i[s + 1])),
                      (u = this.getTransformedPoint(r, t.v[s + 1])),
                      this.checkBounds(a, l, c, u, e);
                  t.c &&
                    ((a = this.getTransformedPoint(r, t.v[s])),
                    (l = this.getTransformedPoint(r, t.o[s])),
                    (c = this.getTransformedPoint(r, t.i[0])),
                    (u = this.getTransformedPoint(r, t.v[0])),
                    this.checkBounds(a, l, c, u, e));
                }
              }),
              (HShapeElement.prototype.checkBounds = function (n, e, t, r, s) {
                this.getBoundsOfCurve(n, e, t, r);
                var o = this.shapeBoundingBox;
                (s.x = bmMin(o.left, s.x)),
                  (s.xMax = bmMax(o.right, s.xMax)),
                  (s.y = bmMin(o.top, s.y)),
                  (s.yMax = bmMax(o.bottom, s.yMax));
              }),
              (HShapeElement.prototype.shapeBoundingBox = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
              }),
              (HShapeElement.prototype.tempBoundingBox = {
                x: 0,
                xMax: 0,
                y: 0,
                yMax: 0,
                width: 0,
                height: 0,
              }),
              (HShapeElement.prototype.getBoundsOfCurve = function (
                n,
                e,
                t,
                r
              ) {
                for (
                  var s = [
                      [n[0], r[0]],
                      [n[1], r[1]],
                    ],
                    o,
                    a,
                    l,
                    c,
                    u,
                    p,
                    N,
                    P = 0;
                  P < 2;
                  ++P
                )
                  (a = 6 * n[P] - 12 * e[P] + 6 * t[P]),
                    (o = -3 * n[P] + 9 * e[P] - 9 * t[P] + 3 * r[P]),
                    (l = 3 * e[P] - 3 * n[P]),
                    (a |= 0),
                    (o |= 0),
                    (l |= 0),
                    (o === 0 && a === 0) ||
                      (o === 0
                        ? ((c = -l / a),
                          c > 0 &&
                            c < 1 &&
                            s[P].push(this.calculateF(c, n, e, t, r, P)))
                        : ((u = a * a - 4 * l * o),
                          u >= 0 &&
                            ((p = (-a + bmSqrt(u)) / (2 * o)),
                            p > 0 &&
                              p < 1 &&
                              s[P].push(this.calculateF(p, n, e, t, r, P)),
                            (N = (-a - bmSqrt(u)) / (2 * o)),
                            N > 0 &&
                              N < 1 &&
                              s[P].push(this.calculateF(N, n, e, t, r, P)))));
                (this.shapeBoundingBox.left = bmMin.apply(null, s[0])),
                  (this.shapeBoundingBox.top = bmMin.apply(null, s[1])),
                  (this.shapeBoundingBox.right = bmMax.apply(null, s[0])),
                  (this.shapeBoundingBox.bottom = bmMax.apply(null, s[1]));
              }),
              (HShapeElement.prototype.calculateF = function (
                n,
                e,
                t,
                r,
                s,
                o
              ) {
                return (
                  bmPow(1 - n, 3) * e[o] +
                  3 * bmPow(1 - n, 2) * n * t[o] +
                  3 * (1 - n) * bmPow(n, 2) * r[o] +
                  bmPow(n, 3) * s[o]
                );
              }),
              (HShapeElement.prototype.calculateBoundingBox = function (n, e) {
                var t,
                  r = n.length;
                for (t = 0; t < r; t += 1)
                  n[t] && n[t].sh
                    ? this.calculateShapeBoundingBox(n[t], e)
                    : n[t] && n[t].it
                    ? this.calculateBoundingBox(n[t].it, e)
                    : n[t] &&
                      n[t].style &&
                      n[t].w &&
                      this.expandStrokeBoundingBox(n[t].w, e);
              }),
              (HShapeElement.prototype.expandStrokeBoundingBox = function (
                n,
                e
              ) {
                var t = 0;
                if (n.keyframes) {
                  for (var r = 0; r < n.keyframes.length; r += 1) {
                    var s = n.keyframes[r].s;
                    s > t && (t = s);
                  }
                  t *= n.mult;
                } else t = n.v * n.mult;
                (e.x -= t), (e.xMax += t), (e.y -= t), (e.yMax += t);
              }),
              (HShapeElement.prototype.currentBoxContains = function (n) {
                return (
                  this.currentBBox.x <= n.x &&
                  this.currentBBox.y <= n.y &&
                  this.currentBBox.width + this.currentBBox.x >=
                    n.x + n.width &&
                  this.currentBBox.height + this.currentBBox.y >= n.y + n.height
                );
              }),
              (HShapeElement.prototype.renderInnerContent = function () {
                if (
                  (this._renderShapeFrame(),
                  !this.hidden && (this._isFirstFrame || this._mdf))
                ) {
                  var n = this.tempBoundingBox,
                    e = 999999;
                  if (
                    ((n.x = e),
                    (n.xMax = -e),
                    (n.y = e),
                    (n.yMax = -e),
                    this.calculateBoundingBox(this.itemsData, n),
                    (n.width = n.xMax < n.x ? 0 : n.xMax - n.x),
                    (n.height = n.yMax < n.y ? 0 : n.yMax - n.y),
                    this.currentBoxContains(n))
                  )
                    return;
                  var t = !1;
                  if (
                    (this.currentBBox.w !== n.width &&
                      ((this.currentBBox.w = n.width),
                      this.shapeCont.setAttribute("width", n.width),
                      (t = !0)),
                    this.currentBBox.h !== n.height &&
                      ((this.currentBBox.h = n.height),
                      this.shapeCont.setAttribute("height", n.height),
                      (t = !0)),
                    t ||
                      this.currentBBox.x !== n.x ||
                      this.currentBBox.y !== n.y)
                  ) {
                    (this.currentBBox.w = n.width),
                      (this.currentBBox.h = n.height),
                      (this.currentBBox.x = n.x),
                      (this.currentBBox.y = n.y),
                      this.shapeCont.setAttribute(
                        "viewBox",
                        this.currentBBox.x +
                          " " +
                          this.currentBBox.y +
                          " " +
                          this.currentBBox.w +
                          " " +
                          this.currentBBox.h
                      );
                    var r = this.shapeCont.style,
                      s =
                        "translate(" +
                        this.currentBBox.x +
                        "px," +
                        this.currentBBox.y +
                        "px)";
                    (r.transform = s), (r.webkitTransform = s);
                  }
                }
              });
            function HTextElement(n, e, t) {
              (this.textSpans = []),
                (this.textPaths = []),
                (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }),
                (this.renderType = "svg"),
                (this.isMasked = !1),
                this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                HBaseElement,
                HierarchyElement,
                FrameElement,
                RenderableDOMElement,
                ITextElement,
              ],
              HTextElement
            ),
              (HTextElement.prototype.createContent = function () {
                if (((this.isMasked = this.checkMasks()), this.isMasked)) {
                  (this.renderType = "svg"),
                    (this.compW = this.comp.data.w),
                    (this.compH = this.comp.data.h),
                    this.svgElement.setAttribute("width", this.compW),
                    this.svgElement.setAttribute("height", this.compH);
                  var n = createNS("g");
                  this.maskedElement.appendChild(n), (this.innerElem = n);
                } else
                  (this.renderType = "html"),
                    (this.innerElem = this.layerElement);
                this.checkParenting();
              }),
              (HTextElement.prototype.buildNewText = function () {
                var n = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(n.l ? n.l.length : 0);
                var e = this.innerElem.style,
                  t = n.fc ? this.buildColor(n.fc) : "rgba(0,0,0,0)";
                (e.fill = t),
                  (e.color = t),
                  n.sc &&
                    ((e.stroke = this.buildColor(n.sc)),
                    (e.strokeWidth = n.sw + "px"));
                var r = this.globalData.fontManager.getFontByName(n.f);
                if (!this.globalData.fontManager.chars)
                  if (
                    ((e.fontSize = n.finalSize + "px"),
                    (e.lineHeight = n.finalSize + "px"),
                    r.fClass)
                  )
                    this.innerElem.className = r.fClass;
                  else {
                    e.fontFamily = r.fFamily;
                    var s = n.fWeight,
                      o = n.fStyle;
                    (e.fontStyle = o), (e.fontWeight = s);
                  }
                var a,
                  l,
                  c = n.l;
                l = c.length;
                var u,
                  p,
                  N,
                  P = this.mHelper,
                  de,
                  me = "",
                  Ye = 0;
                for (a = 0; a < l; a += 1) {
                  if (
                    (this.globalData.fontManager.chars
                      ? (this.textPaths[Ye]
                          ? (u = this.textPaths[Ye])
                          : ((u = createNS("path")),
                            u.setAttribute("stroke-linecap", lineCapEnum[1]),
                            u.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                            u.setAttribute("stroke-miterlimit", "4")),
                        this.isMasked ||
                          (this.textSpans[Ye]
                            ? ((p = this.textSpans[Ye]), (N = p.children[0]))
                            : ((p = createTag("div")),
                              (p.style.lineHeight = 0),
                              (N = createNS("svg")),
                              N.appendChild(u),
                              styleDiv(p))))
                      : this.isMasked
                      ? (u = this.textPaths[Ye]
                          ? this.textPaths[Ye]
                          : createNS("text"))
                      : this.textSpans[Ye]
                      ? ((p = this.textSpans[Ye]), (u = this.textPaths[Ye]))
                      : ((p = createTag("span")),
                        styleDiv(p),
                        (u = createTag("span")),
                        styleDiv(u),
                        p.appendChild(u)),
                    this.globalData.fontManager.chars)
                  ) {
                    var nt = this.globalData.fontManager.getCharData(
                        n.finalText[a],
                        r.fStyle,
                        this.globalData.fontManager.getFontByName(n.f).fFamily
                      ),
                      Be;
                    if (
                      (nt ? (Be = nt.data) : (Be = null),
                      P.reset(),
                      Be &&
                        Be.shapes &&
                        Be.shapes.length &&
                        ((de = Be.shapes[0].it),
                        P.scale(n.finalSize / 100, n.finalSize / 100),
                        (me = this.createPathShape(P, de)),
                        u.setAttribute("d", me)),
                      this.isMasked)
                    )
                      this.innerElem.appendChild(u);
                    else {
                      if ((this.innerElem.appendChild(p), Be && Be.shapes)) {
                        document.body.appendChild(N);
                        var ot = N.getBBox();
                        N.setAttribute("width", ot.width + 2),
                          N.setAttribute("height", ot.height + 2),
                          N.setAttribute(
                            "viewBox",
                            ot.x -
                              1 +
                              " " +
                              (ot.y - 1) +
                              " " +
                              (ot.width + 2) +
                              " " +
                              (ot.height + 2)
                          );
                        var st = N.style,
                          vt =
                            "translate(" +
                            (ot.x - 1) +
                            "px," +
                            (ot.y - 1) +
                            "px)";
                        (st.transform = vt),
                          (st.webkitTransform = vt),
                          (c[a].yOffset = ot.y - 1);
                      } else
                        N.setAttribute("width", 1), N.setAttribute("height", 1);
                      p.appendChild(N);
                    }
                  } else if (
                    ((u.textContent = c[a].val),
                    u.setAttributeNS(
                      "http://www.w3.org/XML/1998/namespace",
                      "xml:space",
                      "preserve"
                    ),
                    this.isMasked)
                  )
                    this.innerElem.appendChild(u);
                  else {
                    this.innerElem.appendChild(p);
                    var xt = u.style,
                      St = "translate3d(0," + -n.finalSize / 1.2 + "px,0)";
                    (xt.transform = St), (xt.webkitTransform = St);
                  }
                  this.isMasked
                    ? (this.textSpans[Ye] = u)
                    : (this.textSpans[Ye] = p),
                    (this.textSpans[Ye].style.display = "block"),
                    (this.textPaths[Ye] = u),
                    (Ye += 1);
                }
                for (; Ye < this.textSpans.length; )
                  (this.textSpans[Ye].style.display = "none"), (Ye += 1);
              }),
              (HTextElement.prototype.renderInnerContent = function () {
                this.validateText();
                var n;
                if (this.data.singleShape) {
                  if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                  if (this.isMasked && this.finalTransform._matMdf) {
                    this.svgElement.setAttribute(
                      "viewBox",
                      -this.finalTransform.mProp.p.v[0] +
                        " " +
                        -this.finalTransform.mProp.p.v[1] +
                        " " +
                        this.compW +
                        " " +
                        this.compH
                    ),
                      (n = this.svgElement.style);
                    var e =
                      "translate(" +
                      -this.finalTransform.mProp.p.v[0] +
                      "px," +
                      -this.finalTransform.mProp.p.v[1] +
                      "px)";
                    (n.transform = e), (n.webkitTransform = e);
                  }
                }
                if (
                  (this.textAnimator.getMeasures(
                    this.textProperty.currentData,
                    this.lettersChangedFlag
                  ),
                  !(
                    !this.lettersChangedFlag &&
                    !this.textAnimator.lettersChangedFlag
                  ))
                ) {
                  var t,
                    r,
                    s = 0,
                    o = this.textAnimator.renderedLetters,
                    a = this.textProperty.currentData.l;
                  r = a.length;
                  var l, c, u;
                  for (t = 0; t < r; t += 1)
                    a[t].n
                      ? (s += 1)
                      : ((c = this.textSpans[t]),
                        (u = this.textPaths[t]),
                        (l = o[s]),
                        (s += 1),
                        l._mdf.m &&
                          (this.isMasked
                            ? c.setAttribute("transform", l.m)
                            : ((c.style.webkitTransform = l.m),
                              (c.style.transform = l.m))),
                        (c.style.opacity = l.o),
                        l.sw &&
                          l._mdf.sw &&
                          u.setAttribute("stroke-width", l.sw),
                        l.sc && l._mdf.sc && u.setAttribute("stroke", l.sc),
                        l.fc &&
                          l._mdf.fc &&
                          (u.setAttribute("fill", l.fc),
                          (u.style.color = l.fc)));
                  if (
                    this.innerElem.getBBox &&
                    !this.hidden &&
                    (this._isFirstFrame || this._mdf)
                  ) {
                    var p = this.innerElem.getBBox();
                    this.currentBBox.w !== p.width &&
                      ((this.currentBBox.w = p.width),
                      this.svgElement.setAttribute("width", p.width)),
                      this.currentBBox.h !== p.height &&
                        ((this.currentBBox.h = p.height),
                        this.svgElement.setAttribute("height", p.height));
                    var N = 1;
                    if (
                      this.currentBBox.w !== p.width + N * 2 ||
                      this.currentBBox.h !== p.height + N * 2 ||
                      this.currentBBox.x !== p.x - N ||
                      this.currentBBox.y !== p.y - N
                    ) {
                      (this.currentBBox.w = p.width + N * 2),
                        (this.currentBBox.h = p.height + N * 2),
                        (this.currentBBox.x = p.x - N),
                        (this.currentBBox.y = p.y - N),
                        this.svgElement.setAttribute(
                          "viewBox",
                          this.currentBBox.x +
                            " " +
                            this.currentBBox.y +
                            " " +
                            this.currentBBox.w +
                            " " +
                            this.currentBBox.h
                        ),
                        (n = this.svgElement.style);
                      var P =
                        "translate(" +
                        this.currentBBox.x +
                        "px," +
                        this.currentBBox.y +
                        "px)";
                      (n.transform = P), (n.webkitTransform = P);
                    }
                  }
                }
              });
            function HCameraElement(n, e, t) {
              this.initFrame(),
                this.initBaseData(n, e, t),
                this.initHierarchy();
              var r = PropertyFactory.getProp;
              if (
                ((this.pe = r(this, n.pe, 0, 0, this)),
                n.ks.p.s
                  ? ((this.px = r(this, n.ks.p.x, 1, 0, this)),
                    (this.py = r(this, n.ks.p.y, 1, 0, this)),
                    (this.pz = r(this, n.ks.p.z, 1, 0, this)))
                  : (this.p = r(this, n.ks.p, 1, 0, this)),
                n.ks.a && (this.a = r(this, n.ks.a, 1, 0, this)),
                n.ks.or.k.length && n.ks.or.k[0].to)
              ) {
                var s,
                  o = n.ks.or.k.length;
                for (s = 0; s < o; s += 1)
                  (n.ks.or.k[s].to = null), (n.ks.or.k[s].ti = null);
              }
              (this.or = r(this, n.ks.or, 1, degToRads, this)),
                (this.or.sh = !0),
                (this.rx = r(this, n.ks.rx, 0, degToRads, this)),
                (this.ry = r(this, n.ks.ry, 0, degToRads, this)),
                (this.rz = r(this, n.ks.rz, 0, degToRads, this)),
                (this.mat = new Matrix()),
                (this._prevMat = new Matrix()),
                (this._isFirstFrame = !0),
                (this.finalTransform = { mProp: this });
            }
            extendPrototype(
              [BaseElement, FrameElement, HierarchyElement],
              HCameraElement
            ),
              (HCameraElement.prototype.setup = function () {
                var n,
                  e = this.comp.threeDElements.length,
                  t,
                  r,
                  s;
                for (n = 0; n < e; n += 1)
                  if (((t = this.comp.threeDElements[n]), t.type === "3d")) {
                    (r = t.perspectiveElem.style), (s = t.container.style);
                    var o = this.pe.v + "px",
                      a = "0px 0px 0px",
                      l = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    (r.perspective = o),
                      (r.webkitPerspective = o),
                      (s.transformOrigin = a),
                      (s.mozTransformOrigin = a),
                      (s.webkitTransformOrigin = a),
                      (r.transform = l),
                      (r.webkitTransform = l);
                  }
              }),
              (HCameraElement.prototype.createElements = function () {}),
              (HCameraElement.prototype.hide = function () {}),
              (HCameraElement.prototype.renderFrame = function () {
                var n = this._isFirstFrame,
                  e,
                  t;
                if (this.hierarchy)
                  for (t = this.hierarchy.length, e = 0; e < t; e += 1)
                    n = this.hierarchy[e].finalTransform.mProp._mdf || n;
                if (
                  n ||
                  this.pe._mdf ||
                  (this.p && this.p._mdf) ||
                  (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
                  this.rx._mdf ||
                  this.ry._mdf ||
                  this.rz._mdf ||
                  this.or._mdf ||
                  (this.a && this.a._mdf)
                ) {
                  if ((this.mat.reset(), this.hierarchy))
                    for (t = this.hierarchy.length - 1, e = t; e >= 0; e -= 1) {
                      var r = this.hierarchy[e].finalTransform.mProp;
                      this.mat.translate(-r.p.v[0], -r.p.v[1], r.p.v[2]),
                        this.mat
                          .rotateX(-r.or.v[0])
                          .rotateY(-r.or.v[1])
                          .rotateZ(r.or.v[2]),
                        this.mat
                          .rotateX(-r.rx.v)
                          .rotateY(-r.ry.v)
                          .rotateZ(r.rz.v),
                        this.mat.scale(
                          1 / r.s.v[0],
                          1 / r.s.v[1],
                          1 / r.s.v[2]
                        ),
                        this.mat.translate(r.a.v[0], r.a.v[1], r.a.v[2]);
                    }
                  if (
                    (this.p
                      ? this.mat.translate(
                          -this.p.v[0],
                          -this.p.v[1],
                          this.p.v[2]
                        )
                      : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                    this.a)
                  ) {
                    var s;
                    this.p
                      ? (s = [
                          this.p.v[0] - this.a.v[0],
                          this.p.v[1] - this.a.v[1],
                          this.p.v[2] - this.a.v[2],
                        ])
                      : (s = [
                          this.px.v - this.a.v[0],
                          this.py.v - this.a.v[1],
                          this.pz.v - this.a.v[2],
                        ]);
                    var o = Math.sqrt(
                        Math.pow(s[0], 2) +
                          Math.pow(s[1], 2) +
                          Math.pow(s[2], 2)
                      ),
                      a = [s[0] / o, s[1] / o, s[2] / o],
                      l = Math.sqrt(a[2] * a[2] + a[0] * a[0]),
                      c = Math.atan2(a[1], l),
                      u = Math.atan2(a[0], -a[2]);
                    this.mat.rotateY(u).rotateX(-c);
                  }
                  this.mat
                    .rotateX(-this.rx.v)
                    .rotateY(-this.ry.v)
                    .rotateZ(this.rz.v),
                    this.mat
                      .rotateX(-this.or.v[0])
                      .rotateY(-this.or.v[1])
                      .rotateZ(this.or.v[2]),
                    this.mat.translate(
                      this.globalData.compSize.w / 2,
                      this.globalData.compSize.h / 2,
                      0
                    ),
                    this.mat.translate(0, 0, this.pe.v);
                  var p = !this._prevMat.equals(this.mat);
                  if ((p || this.pe._mdf) && this.comp.threeDElements) {
                    t = this.comp.threeDElements.length;
                    var N, P, de;
                    for (e = 0; e < t; e += 1)
                      if (
                        ((N = this.comp.threeDElements[e]), N.type === "3d")
                      ) {
                        if (p) {
                          var me = this.mat.toCSS();
                          (de = N.container.style),
                            (de.transform = me),
                            (de.webkitTransform = me);
                        }
                        this.pe._mdf &&
                          ((P = N.perspectiveElem.style),
                          (P.perspective = this.pe.v + "px"),
                          (P.webkitPerspective = this.pe.v + "px"));
                      }
                    this.mat.clone(this._prevMat);
                  }
                }
                this._isFirstFrame = !1;
              }),
              (HCameraElement.prototype.prepareFrame = function (n) {
                this.prepareProperties(n, !0);
              }),
              (HCameraElement.prototype.destroy = function () {}),
              (HCameraElement.prototype.getBaseElement = function () {
                return null;
              });
            function HImageElement(n, e, t) {
              (this.assetData = e.getAssetData(n.refId)),
                this.initElement(n, e, t);
            }
            extendPrototype(
              [
                BaseElement,
                TransformElement,
                HBaseElement,
                HSolidElement,
                HierarchyElement,
                FrameElement,
                RenderableElement,
              ],
              HImageElement
            ),
              (HImageElement.prototype.createContent = function () {
                var n = this.globalData.getAssetsPath(this.assetData),
                  e = new Image();
                this.data.hasMask
                  ? ((this.imageElem = createNS("image")),
                    this.imageElem.setAttribute(
                      "width",
                      this.assetData.w + "px"
                    ),
                    this.imageElem.setAttribute(
                      "height",
                      this.assetData.h + "px"
                    ),
                    this.imageElem.setAttributeNS(
                      "http://www.w3.org/1999/xlink",
                      "href",
                      n
                    ),
                    this.layerElement.appendChild(this.imageElem),
                    this.baseElement.setAttribute("width", this.assetData.w),
                    this.baseElement.setAttribute("height", this.assetData.h))
                  : this.layerElement.appendChild(e),
                  (e.crossOrigin = "anonymous"),
                  (e.src = n),
                  this.data.ln &&
                    this.baseElement.setAttribute("id", this.data.ln);
              });
            function HybridRendererBase(n, e) {
              (this.animationItem = n),
                (this.layers = null),
                (this.renderedFrame = -1),
                (this.renderConfig = {
                  className: (e && e.className) || "",
                  imagePreserveAspectRatio:
                    (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
                  hideOnTransparent: !(e && e.hideOnTransparent === !1),
                  filterSize: {
                    width: (e && e.filterSize && e.filterSize.width) || "400%",
                    height:
                      (e && e.filterSize && e.filterSize.height) || "400%",
                    x: (e && e.filterSize && e.filterSize.x) || "-100%",
                    y: (e && e.filterSize && e.filterSize.y) || "-100%",
                  },
                }),
                (this.globalData = {
                  _mdf: !1,
                  frameNum: -1,
                  renderConfig: this.renderConfig,
                }),
                (this.pendingElements = []),
                (this.elements = []),
                (this.threeDElements = []),
                (this.destroyed = !1),
                (this.camera = null),
                (this.supports3d = !0),
                (this.rendererType = "html");
            }
            extendPrototype([BaseRenderer], HybridRendererBase),
              (HybridRendererBase.prototype.buildItem =
                SVGRenderer.prototype.buildItem),
              (HybridRendererBase.prototype.checkPendingElements = function () {
                for (; this.pendingElements.length; ) {
                  var n = this.pendingElements.pop();
                  n.checkParenting();
                }
              }),
              (HybridRendererBase.prototype.appendElementInPos = function (
                n,
                e
              ) {
                var t = n.getBaseElement();
                if (t) {
                  var r = this.layers[e];
                  if (!r.ddd || !this.supports3d)
                    if (this.threeDElements) this.addTo3dContainer(t, e);
                    else {
                      for (var s = 0, o, a, l; s < e; )
                        this.elements[s] &&
                          this.elements[s] !== !0 &&
                          this.elements[s].getBaseElement &&
                          ((a = this.elements[s]),
                          (l = this.layers[s].ddd
                            ? this.getThreeDContainerByPos(s)
                            : a.getBaseElement()),
                          (o = l || o)),
                          (s += 1);
                      o
                        ? (!r.ddd || !this.supports3d) &&
                          this.layerElement.insertBefore(t, o)
                        : (!r.ddd || !this.supports3d) &&
                          this.layerElement.appendChild(t);
                    }
                  else this.addTo3dContainer(t, e);
                }
              }),
              (HybridRendererBase.prototype.createShape = function (n) {
                return this.supports3d
                  ? new HShapeElement(n, this.globalData, this)
                  : new SVGShapeElement(n, this.globalData, this);
              }),
              (HybridRendererBase.prototype.createText = function (n) {
                return this.supports3d
                  ? new HTextElement(n, this.globalData, this)
                  : new SVGTextLottieElement(n, this.globalData, this);
              }),
              (HybridRendererBase.prototype.createCamera = function (n) {
                return (
                  (this.camera = new HCameraElement(n, this.globalData, this)),
                  this.camera
                );
              }),
              (HybridRendererBase.prototype.createImage = function (n) {
                return this.supports3d
                  ? new HImageElement(n, this.globalData, this)
                  : new IImageElement(n, this.globalData, this);
              }),
              (HybridRendererBase.prototype.createSolid = function (n) {
                return this.supports3d
                  ? new HSolidElement(n, this.globalData, this)
                  : new ISolidElement(n, this.globalData, this);
              }),
              (HybridRendererBase.prototype.createNull =
                SVGRenderer.prototype.createNull),
              (HybridRendererBase.prototype.getThreeDContainerByPos = function (
                n
              ) {
                for (var e = 0, t = this.threeDElements.length; e < t; ) {
                  if (
                    this.threeDElements[e].startPos <= n &&
                    this.threeDElements[e].endPos >= n
                  )
                    return this.threeDElements[e].perspectiveElem;
                  e += 1;
                }
                return null;
              }),
              (HybridRendererBase.prototype.createThreeDContainer = function (
                n,
                e
              ) {
                var t = createTag("div"),
                  r,
                  s;
                styleDiv(t);
                var o = createTag("div");
                if ((styleDiv(o), e === "3d")) {
                  (r = t.style),
                    (r.width = this.globalData.compSize.w + "px"),
                    (r.height = this.globalData.compSize.h + "px");
                  var a = "50% 50%";
                  (r.webkitTransformOrigin = a),
                    (r.mozTransformOrigin = a),
                    (r.transformOrigin = a),
                    (s = o.style);
                  var l = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                  (s.transform = l), (s.webkitTransform = l);
                }
                t.appendChild(o);
                var c = {
                  container: o,
                  perspectiveElem: t,
                  startPos: n,
                  endPos: n,
                  type: e,
                };
                return this.threeDElements.push(c), c;
              }),
              (HybridRendererBase.prototype.build3dContainers = function () {
                var n,
                  e = this.layers.length,
                  t,
                  r = "";
                for (n = 0; n < e; n += 1)
                  this.layers[n].ddd && this.layers[n].ty !== 3
                    ? (r !== "3d" &&
                        ((r = "3d"), (t = this.createThreeDContainer(n, "3d"))),
                      (t.endPos = Math.max(t.endPos, n)))
                    : (r !== "2d" &&
                        ((r = "2d"), (t = this.createThreeDContainer(n, "2d"))),
                      (t.endPos = Math.max(t.endPos, n)));
                for (e = this.threeDElements.length, n = e - 1; n >= 0; n -= 1)
                  this.resizerElem.appendChild(
                    this.threeDElements[n].perspectiveElem
                  );
              }),
              (HybridRendererBase.prototype.addTo3dContainer = function (n, e) {
                for (var t = 0, r = this.threeDElements.length; t < r; ) {
                  if (e <= this.threeDElements[t].endPos) {
                    for (var s = this.threeDElements[t].startPos, o; s < e; )
                      this.elements[s] &&
                        this.elements[s].getBaseElement &&
                        (o = this.elements[s].getBaseElement()),
                        (s += 1);
                    o
                      ? this.threeDElements[t].container.insertBefore(n, o)
                      : this.threeDElements[t].container.appendChild(n);
                    break;
                  }
                  t += 1;
                }
              }),
              (HybridRendererBase.prototype.configAnimation = function (n) {
                var e = createTag("div"),
                  t = this.animationItem.wrapper,
                  r = e.style;
                (r.width = n.w + "px"),
                  (r.height = n.h + "px"),
                  (this.resizerElem = e),
                  styleDiv(e),
                  (r.transformStyle = "flat"),
                  (r.mozTransformStyle = "flat"),
                  (r.webkitTransformStyle = "flat"),
                  this.renderConfig.className &&
                    e.setAttribute("class", this.renderConfig.className),
                  t.appendChild(e),
                  (r.overflow = "hidden");
                var s = createNS("svg");
                s.setAttribute("width", "1"),
                  s.setAttribute("height", "1"),
                  styleDiv(s),
                  this.resizerElem.appendChild(s);
                var o = createNS("defs");
                s.appendChild(o),
                  (this.data = n),
                  this.setupGlobalData(n, s),
                  (this.globalData.defs = o),
                  (this.layers = n.layers),
                  (this.layerElement = this.resizerElem),
                  this.build3dContainers(),
                  this.updateContainerSize();
              }),
              (HybridRendererBase.prototype.destroy = function () {
                this.animationItem.wrapper &&
                  (this.animationItem.wrapper.innerText = ""),
                  (this.animationItem.container = null),
                  (this.globalData.defs = null);
                var n,
                  e = this.layers ? this.layers.length : 0;
                for (n = 0; n < e; n += 1)
                  this.elements[n] &&
                    this.elements[n].destroy &&
                    this.elements[n].destroy();
                (this.elements.length = 0),
                  (this.destroyed = !0),
                  (this.animationItem = null);
              }),
              (HybridRendererBase.prototype.updateContainerSize = function () {
                var n = this.animationItem.wrapper.offsetWidth,
                  e = this.animationItem.wrapper.offsetHeight,
                  t = n / e,
                  r = this.globalData.compSize.w / this.globalData.compSize.h,
                  s,
                  o,
                  a,
                  l;
                r > t
                  ? ((s = n / this.globalData.compSize.w),
                    (o = n / this.globalData.compSize.w),
                    (a = 0),
                    (l =
                      (e -
                        this.globalData.compSize.h *
                          (n / this.globalData.compSize.w)) /
                      2))
                  : ((s = e / this.globalData.compSize.h),
                    (o = e / this.globalData.compSize.h),
                    (a =
                      (n -
                        this.globalData.compSize.w *
                          (e / this.globalData.compSize.h)) /
                      2),
                    (l = 0));
                var c = this.resizerElem.style;
                (c.webkitTransform =
                  "matrix3d(" +
                  s +
                  ",0,0,0,0," +
                  o +
                  ",0,0,0,0,1,0," +
                  a +
                  "," +
                  l +
                  ",0,1)"),
                  (c.transform = c.webkitTransform);
              }),
              (HybridRendererBase.prototype.renderFrame =
                SVGRenderer.prototype.renderFrame),
              (HybridRendererBase.prototype.hide = function () {
                this.resizerElem.style.display = "none";
              }),
              (HybridRendererBase.prototype.show = function () {
                this.resizerElem.style.display = "block";
              }),
              (HybridRendererBase.prototype.initItems = function () {
                if ((this.buildAllItems(), this.camera)) this.camera.setup();
                else {
                  var n = this.globalData.compSize.w,
                    e = this.globalData.compSize.h,
                    t,
                    r = this.threeDElements.length;
                  for (t = 0; t < r; t += 1) {
                    var s = this.threeDElements[t].perspectiveElem.style;
                    (s.webkitPerspective =
                      Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2)) + "px"),
                      (s.perspective = s.webkitPerspective);
                  }
                }
              }),
              (HybridRendererBase.prototype.searchExtraCompositions = function (
                n
              ) {
                var e,
                  t = n.length,
                  r = createTag("div");
                for (e = 0; e < t; e += 1)
                  if (n[e].xt) {
                    var s = this.createComp(
                      n[e],
                      r,
                      this.globalData.comp,
                      null
                    );
                    s.initExpressions(),
                      this.globalData.projectInterface.registerComposition(s);
                  }
              });
            function HCompElement(n, e, t) {
              (this.layers = n.layers),
                (this.supports3d = !n.hasMask),
                (this.completeLayers = !1),
                (this.pendingElements = []),
                (this.elements = this.layers
                  ? createSizedArray(this.layers.length)
                  : []),
                this.initElement(n, e, t),
                (this.tm = n.tm
                  ? PropertyFactory.getProp(this, n.tm, 0, e.frameRate, this)
                  : { _placeholder: !0 });
            }
            extendPrototype(
              [HybridRendererBase, ICompElement, HBaseElement],
              HCompElement
            ),
              (HCompElement.prototype._createBaseContainerElements =
                HCompElement.prototype.createContainerElements),
              (HCompElement.prototype.createContainerElements = function () {
                this._createBaseContainerElements(),
                  this.data.hasMask
                    ? (this.svgElement.setAttribute("width", this.data.w),
                      this.svgElement.setAttribute("height", this.data.h),
                      (this.transformedElement = this.baseElement))
                    : (this.transformedElement = this.layerElement);
              }),
              (HCompElement.prototype.addTo3dContainer = function (n, e) {
                for (var t = 0, r; t < e; )
                  this.elements[t] &&
                    this.elements[t].getBaseElement &&
                    (r = this.elements[t].getBaseElement()),
                    (t += 1);
                r
                  ? this.layerElement.insertBefore(n, r)
                  : this.layerElement.appendChild(n);
              }),
              (HCompElement.prototype.createComp = function (n) {
                return this.supports3d
                  ? new HCompElement(n, this.globalData, this)
                  : new SVGCompElement(n, this.globalData, this);
              });
            function HybridRenderer(n, e) {
              (this.animationItem = n),
                (this.layers = null),
                (this.renderedFrame = -1),
                (this.renderConfig = {
                  className: (e && e.className) || "",
                  imagePreserveAspectRatio:
                    (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
                  hideOnTransparent: !(e && e.hideOnTransparent === !1),
                  filterSize: {
                    width: (e && e.filterSize && e.filterSize.width) || "400%",
                    height:
                      (e && e.filterSize && e.filterSize.height) || "400%",
                    x: (e && e.filterSize && e.filterSize.x) || "-100%",
                    y: (e && e.filterSize && e.filterSize.y) || "-100%",
                  },
                  runExpressions:
                    !e || e.runExpressions === void 0 || e.runExpressions,
                }),
                (this.globalData = {
                  _mdf: !1,
                  frameNum: -1,
                  renderConfig: this.renderConfig,
                }),
                (this.pendingElements = []),
                (this.elements = []),
                (this.threeDElements = []),
                (this.destroyed = !1),
                (this.camera = null),
                (this.supports3d = !0),
                (this.rendererType = "html");
            }
            extendPrototype([HybridRendererBase], HybridRenderer),
              (HybridRenderer.prototype.createComp = function (n) {
                return this.supports3d
                  ? new HCompElement(n, this.globalData, this)
                  : new SVGCompElement(n, this.globalData, this);
              });
            var CompExpressionInterface = (function () {
              return function (n) {
                function e(t) {
                  for (var r = 0, s = n.layers.length; r < s; ) {
                    if (n.layers[r].nm === t || n.layers[r].ind === t)
                      return n.elements[r].layerInterface;
                    r += 1;
                  }
                  return null;
                }
                return (
                  Object.defineProperty(e, "_name", { value: n.data.nm }),
                  (e.layer = e),
                  (e.pixelAspect = 1),
                  (e.height = n.data.h || n.globalData.compSize.h),
                  (e.width = n.data.w || n.globalData.compSize.w),
                  (e.pixelAspect = 1),
                  (e.frameDuration = 1 / n.globalData.frameRate),
                  (e.displayStartTime = 0),
                  (e.numLayers = n.layers.length),
                  e
                );
              };
            })();
            function _typeof$2(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof$2 =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof$2(n)
              );
            }
            function seedRandom(n, e) {
              var t = this,
                r = 256,
                s = 6,
                o = 52,
                a = "random",
                l = e.pow(r, s),
                c = e.pow(2, o),
                u = c * 2,
                p = r - 1,
                N;
              function P(st, vt, xt) {
                var St = [];
                vt = vt === !0 ? { entropy: !0 } : vt || {};
                var wt = nt(
                    Ye(vt.entropy ? [st, ot(n)] : st === null ? Be() : st, 3),
                    St
                  ),
                  bt = new de(St),
                  Tt = function () {
                    for (var kt = bt.g(s), Dt = l, Vt = 0; kt < c; )
                      (kt = (kt + Vt) * r), (Dt *= r), (Vt = bt.g(1));
                    for (; kt >= u; ) (kt /= 2), (Dt /= 2), (Vt >>>= 1);
                    return (kt + Vt) / Dt;
                  };
                return (
                  (Tt.int32 = function () {
                    return bt.g(4) | 0;
                  }),
                  (Tt.quick = function () {
                    return bt.g(4) / 4294967296;
                  }),
                  (Tt.double = Tt),
                  nt(ot(bt.S), n),
                  (
                    vt.pass ||
                    xt ||
                    function (Ct, kt, Dt, Vt) {
                      return (
                        Vt &&
                          (Vt.S && me(Vt, bt),
                          (Ct.state = function () {
                            return me(bt, {});
                          })),
                        Dt ? ((e[a] = Ct), kt) : Ct
                      );
                    }
                  )(Tt, wt, "global" in vt ? vt.global : this == e, vt.state)
                );
              }
              e["seed" + a] = P;
              function de(st) {
                var vt,
                  xt = st.length,
                  St = this,
                  wt = 0,
                  bt = (St.i = St.j = 0),
                  Tt = (St.S = []);
                for (xt || (st = [xt++]); wt < r; ) Tt[wt] = wt++;
                for (wt = 0; wt < r; wt++)
                  (Tt[wt] = Tt[(bt = p & (bt + st[wt % xt] + (vt = Tt[wt])))]),
                    (Tt[bt] = vt);
                St.g = function (Ct) {
                  for (var kt, Dt = 0, Vt = St.i, Ht = St.j, qt = St.S; Ct--; )
                    (kt = qt[(Vt = p & (Vt + 1))]),
                      (Dt =
                        Dt * r +
                        qt[
                          p &
                            ((qt[Vt] = qt[(Ht = p & (Ht + kt))]) +
                              (qt[Ht] = kt))
                        ]);
                  return (St.i = Vt), (St.j = Ht), Dt;
                };
              }
              function me(st, vt) {
                return (vt.i = st.i), (vt.j = st.j), (vt.S = st.S.slice()), vt;
              }
              function Ye(st, vt) {
                var xt = [],
                  St = _typeof$2(st),
                  wt;
                if (vt && St == "object")
                  for (wt in st)
                    try {
                      xt.push(Ye(st[wt], vt - 1));
                    } catch {}
                return xt.length ? xt : St == "string" ? st : st + "\0";
              }
              function nt(st, vt) {
                for (var xt = st + "", St, wt = 0; wt < xt.length; )
                  vt[p & wt] =
                    p & ((St ^= vt[p & wt] * 19) + xt.charCodeAt(wt++));
                return ot(vt);
              }
              function Be() {
                try {
                  var st = new Uint8Array(r);
                  return (t.crypto || t.msCrypto).getRandomValues(st), ot(st);
                } catch {
                  var vt = t.navigator,
                    xt = vt && vt.plugins;
                  return [+new Date(), t, xt, t.screen, ot(n)];
                }
              }
              function ot(st) {
                return String.fromCharCode.apply(0, st);
              }
              nt(e.random(), n);
            }
            function initialize$2(n) {
              seedRandom([], n);
            }
            var propTypes = { SHAPE: "shape" };
            function _typeof$1(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof$1 =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof$1(n)
              );
            }
            var ExpressionManager = (function () {
                var ob = {},
                  Math = BMMath,
                  window = null,
                  document = null,
                  XMLHttpRequest = null,
                  fetch = null,
                  frames = null,
                  _lottieGlobal = {};
                initialize$2(BMMath);
                function resetFrame() {
                  _lottieGlobal = {};
                }
                function $bm_isInstanceOfArray(n) {
                  return (
                    n.constructor === Array || n.constructor === Float32Array
                  );
                }
                function isNumerable(n, e) {
                  return (
                    n === "number" ||
                    e instanceof Number ||
                    n === "boolean" ||
                    n === "string"
                  );
                }
                function $bm_neg(n) {
                  var e = _typeof$1(n);
                  if (e === "number" || n instanceof Number || e === "boolean")
                    return -n;
                  if ($bm_isInstanceOfArray(n)) {
                    var t,
                      r = n.length,
                      s = [];
                    for (t = 0; t < r; t += 1) s[t] = -n[t];
                    return s;
                  }
                  return n.propType ? n.v : -n;
                }
                var easeInBez = BezierFactory.getBezierEasing(
                    0.333,
                    0,
                    0.833,
                    0.833,
                    "easeIn"
                  ).get,
                  easeOutBez = BezierFactory.getBezierEasing(
                    0.167,
                    0.167,
                    0.667,
                    1,
                    "easeOut"
                  ).get,
                  easeInOutBez = BezierFactory.getBezierEasing(
                    0.33,
                    0,
                    0.667,
                    1,
                    "easeInOut"
                  ).get;
                function sum(n, e) {
                  var t = _typeof$1(n),
                    r = _typeof$1(e);
                  if (
                    (isNumerable(t, n) && isNumerable(r, e)) ||
                    t === "string" ||
                    r === "string"
                  )
                    return n + e;
                  if ($bm_isInstanceOfArray(n) && isNumerable(r, e))
                    return (n = n.slice(0)), (n[0] += e), n;
                  if (isNumerable(t, n) && $bm_isInstanceOfArray(e))
                    return (e = e.slice(0)), (e[0] = n + e[0]), e;
                  if ($bm_isInstanceOfArray(n) && $bm_isInstanceOfArray(e)) {
                    for (
                      var s = 0, o = n.length, a = e.length, l = [];
                      s < o || s < a;

                    )
                      (typeof n[s] == "number" || n[s] instanceof Number) &&
                      (typeof e[s] == "number" || e[s] instanceof Number)
                        ? (l[s] = n[s] + e[s])
                        : (l[s] = e[s] === void 0 ? n[s] : n[s] || e[s]),
                        (s += 1);
                    return l;
                  }
                  return 0;
                }
                var add = sum;
                function sub(n, e) {
                  var t = _typeof$1(n),
                    r = _typeof$1(e);
                  if (isNumerable(t, n) && isNumerable(r, e))
                    return (
                      t === "string" && (n = parseInt(n, 10)),
                      r === "string" && (e = parseInt(e, 10)),
                      n - e
                    );
                  if ($bm_isInstanceOfArray(n) && isNumerable(r, e))
                    return (n = n.slice(0)), (n[0] -= e), n;
                  if (isNumerable(t, n) && $bm_isInstanceOfArray(e))
                    return (e = e.slice(0)), (e[0] = n - e[0]), e;
                  if ($bm_isInstanceOfArray(n) && $bm_isInstanceOfArray(e)) {
                    for (
                      var s = 0, o = n.length, a = e.length, l = [];
                      s < o || s < a;

                    )
                      (typeof n[s] == "number" || n[s] instanceof Number) &&
                      (typeof e[s] == "number" || e[s] instanceof Number)
                        ? (l[s] = n[s] - e[s])
                        : (l[s] = e[s] === void 0 ? n[s] : n[s] || e[s]),
                        (s += 1);
                    return l;
                  }
                  return 0;
                }
                function mul(n, e) {
                  var t = _typeof$1(n),
                    r = _typeof$1(e),
                    s;
                  if (isNumerable(t, n) && isNumerable(r, e)) return n * e;
                  var o, a;
                  if ($bm_isInstanceOfArray(n) && isNumerable(r, e)) {
                    for (
                      a = n.length, s = createTypedArray("float32", a), o = 0;
                      o < a;
                      o += 1
                    )
                      s[o] = n[o] * e;
                    return s;
                  }
                  if (isNumerable(t, n) && $bm_isInstanceOfArray(e)) {
                    for (
                      a = e.length, s = createTypedArray("float32", a), o = 0;
                      o < a;
                      o += 1
                    )
                      s[o] = n * e[o];
                    return s;
                  }
                  return 0;
                }
                function div(n, e) {
                  var t = _typeof$1(n),
                    r = _typeof$1(e),
                    s;
                  if (isNumerable(t, n) && isNumerable(r, e)) return n / e;
                  var o, a;
                  if ($bm_isInstanceOfArray(n) && isNumerable(r, e)) {
                    for (
                      a = n.length, s = createTypedArray("float32", a), o = 0;
                      o < a;
                      o += 1
                    )
                      s[o] = n[o] / e;
                    return s;
                  }
                  if (isNumerable(t, n) && $bm_isInstanceOfArray(e)) {
                    for (
                      a = e.length, s = createTypedArray("float32", a), o = 0;
                      o < a;
                      o += 1
                    )
                      s[o] = n / e[o];
                    return s;
                  }
                  return 0;
                }
                function mod(n, e) {
                  return (
                    typeof n == "string" && (n = parseInt(n, 10)),
                    typeof e == "string" && (e = parseInt(e, 10)),
                    n % e
                  );
                }
                var $bm_sum = sum,
                  $bm_sub = sub,
                  $bm_mul = mul,
                  $bm_div = div,
                  $bm_mod = mod;
                function clamp(n, e, t) {
                  if (e > t) {
                    var r = t;
                    (t = e), (e = r);
                  }
                  return Math.min(Math.max(n, e), t);
                }
                function radiansToDegrees(n) {
                  return n / degToRads;
                }
                var radians_to_degrees = radiansToDegrees;
                function degreesToRadians(n) {
                  return n * degToRads;
                }
                var degrees_to_radians = radiansToDegrees,
                  helperLengthArray = [0, 0, 0, 0, 0, 0];
                function length(n, e) {
                  if (typeof n == "number" || n instanceof Number)
                    return (e = e || 0), Math.abs(n - e);
                  e || (e = helperLengthArray);
                  var t,
                    r = Math.min(n.length, e.length),
                    s = 0;
                  for (t = 0; t < r; t += 1) s += Math.pow(e[t] - n[t], 2);
                  return Math.sqrt(s);
                }
                function normalize(n) {
                  return div(n, length(n));
                }
                function rgbToHsl(n) {
                  var e = n[0],
                    t = n[1],
                    r = n[2],
                    s = Math.max(e, t, r),
                    o = Math.min(e, t, r),
                    a,
                    l,
                    c = (s + o) / 2;
                  if (s === o) (a = 0), (l = 0);
                  else {
                    var u = s - o;
                    switch (
                      ((l = c > 0.5 ? u / (2 - s - o) : u / (s + o)), s)
                    ) {
                      case e:
                        a = (t - r) / u + (t < r ? 6 : 0);
                        break;
                      case t:
                        a = (r - e) / u + 2;
                        break;
                      case r:
                        a = (e - t) / u + 4;
                        break;
                    }
                    a /= 6;
                  }
                  return [a, l, c, n[3]];
                }
                function hue2rgb(n, e, t) {
                  return (
                    t < 0 && (t += 1),
                    t > 1 && (t -= 1),
                    t < 1 / 6
                      ? n + (e - n) * 6 * t
                      : t < 1 / 2
                      ? e
                      : t < 2 / 3
                      ? n + (e - n) * (2 / 3 - t) * 6
                      : n
                  );
                }
                function hslToRgb(n) {
                  var e = n[0],
                    t = n[1],
                    r = n[2],
                    s,
                    o,
                    a;
                  if (t === 0) (s = r), (a = r), (o = r);
                  else {
                    var l = r < 0.5 ? r * (1 + t) : r + t - r * t,
                      c = 2 * r - l;
                    (s = hue2rgb(c, l, e + 1 / 3)),
                      (o = hue2rgb(c, l, e)),
                      (a = hue2rgb(c, l, e - 1 / 3));
                  }
                  return [s, o, a, n[3]];
                }
                function linear(n, e, t, r, s) {
                  if (
                    ((r === void 0 || s === void 0) &&
                      ((r = e), (s = t), (e = 0), (t = 1)),
                    t < e)
                  ) {
                    var o = t;
                    (t = e), (e = o);
                  }
                  if (n <= e) return r;
                  if (n >= t) return s;
                  var a = t === e ? 0 : (n - e) / (t - e);
                  if (!r.length) return r + (s - r) * a;
                  var l,
                    c = r.length,
                    u = createTypedArray("float32", c);
                  for (l = 0; l < c; l += 1) u[l] = r[l] + (s[l] - r[l]) * a;
                  return u;
                }
                function random(n, e) {
                  if (
                    (e === void 0 &&
                      (n === void 0
                        ? ((n = 0), (e = 1))
                        : ((e = n), (n = void 0))),
                    e.length)
                  ) {
                    var t,
                      r = e.length;
                    n || (n = createTypedArray("float32", r));
                    var s = createTypedArray("float32", r),
                      o = BMMath.random();
                    for (t = 0; t < r; t += 1) s[t] = n[t] + o * (e[t] - n[t]);
                    return s;
                  }
                  n === void 0 && (n = 0);
                  var a = BMMath.random();
                  return n + a * (e - n);
                }
                function createPath(n, e, t, r) {
                  var s,
                    o = n.length,
                    a = shapePool.newElement();
                  a.setPathData(!!r, o);
                  var l = [0, 0],
                    c,
                    u;
                  for (s = 0; s < o; s += 1)
                    (c = e && e[s] ? e[s] : l),
                      (u = t && t[s] ? t[s] : l),
                      a.setTripleAt(
                        n[s][0],
                        n[s][1],
                        u[0] + n[s][0],
                        u[1] + n[s][1],
                        c[0] + n[s][0],
                        c[1] + n[s][1],
                        s,
                        !0
                      );
                  return a;
                }
                function initiateExpression(elem, data, property) {
                  function noOp(n) {
                    return n;
                  }
                  if (!elem.globalData.renderConfig.runExpressions) return noOp;
                  var val = data.x,
                    needsVelocity = /velocity(?![\w\d])/.test(val),
                    _needsRandom = val.indexOf("random") !== -1,
                    elemType = elem.data.ty,
                    transform,
                    $bm_transform,
                    content,
                    effect,
                    thisProperty = property;
                  (thisProperty._name = elem.data.nm),
                    (thisProperty.valueAtTime = thisProperty.getValueAtTime),
                    Object.defineProperty(thisProperty, "value", {
                      get: function () {
                        return thisProperty.v;
                      },
                    }),
                    (elem.comp.frameDuration =
                      1 / elem.comp.globalData.frameRate),
                    (elem.comp.displayStartTime = 0);
                  var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                    outPoint = elem.data.op / elem.comp.globalData.frameRate,
                    width = elem.data.sw ? elem.data.sw : 0,
                    height = elem.data.sh ? elem.data.sh : 0,
                    name = elem.data.nm,
                    loopIn,
                    loop_in,
                    loopOut,
                    loop_out,
                    smooth,
                    toWorld,
                    fromWorld,
                    fromComp,
                    toComp,
                    fromCompToSurface,
                    position,
                    rotation,
                    anchorPoint,
                    scale,
                    thisLayer,
                    thisComp,
                    mask,
                    valueAtTime,
                    velocityAtTime,
                    scoped_bm_rt,
                    expression_function = eval(
                      "[function _expression_function(){" +
                        val +
                        ";scoped_bm_rt=$bm_rt}]"
                    )[0],
                    numKeys = property.kf ? data.k.length : 0,
                    active = !this.data || this.data.hd !== !0,
                    wiggle = function n(e, t) {
                      var r,
                        s,
                        o = this.pv.length ? this.pv.length : 1,
                        a = createTypedArray("float32", o);
                      e = 5;
                      var l = Math.floor(time * e);
                      for (r = 0, s = 0; r < l; ) {
                        for (s = 0; s < o; s += 1)
                          a[s] += -t + t * 2 * BMMath.random();
                        r += 1;
                      }
                      var c = time * e,
                        u = c - Math.floor(c),
                        p = createTypedArray("float32", o);
                      if (o > 1) {
                        for (s = 0; s < o; s += 1)
                          p[s] =
                            this.pv[s] +
                            a[s] +
                            (-t + t * 2 * BMMath.random()) * u;
                        return p;
                      }
                      return (
                        this.pv + a[0] + (-t + t * 2 * BMMath.random()) * u
                      );
                    }.bind(this);
                  thisProperty.loopIn &&
                    ((loopIn = thisProperty.loopIn.bind(thisProperty)),
                    (loop_in = loopIn)),
                    thisProperty.loopOut &&
                      ((loopOut = thisProperty.loopOut.bind(thisProperty)),
                      (loop_out = loopOut)),
                    thisProperty.smooth &&
                      (smooth = thisProperty.smooth.bind(thisProperty));
                  function loopInDuration(n, e) {
                    return loopIn(n, e, !0);
                  }
                  function loopOutDuration(n, e) {
                    return loopOut(n, e, !0);
                  }
                  this.getValueAtTime &&
                    (valueAtTime = this.getValueAtTime.bind(this)),
                    this.getVelocityAtTime &&
                      (velocityAtTime = this.getVelocityAtTime.bind(this));
                  var comp = elem.comp.globalData.projectInterface.bind(
                    elem.comp.globalData.projectInterface
                  );
                  function lookAt(n, e) {
                    var t = [e[0] - n[0], e[1] - n[1], e[2] - n[2]],
                      r =
                        Math.atan2(t[0], Math.sqrt(t[1] * t[1] + t[2] * t[2])) /
                        degToRads,
                      s = -Math.atan2(t[1], t[2]) / degToRads;
                    return [s, r, 0];
                  }
                  function easeOut(n, e, t, r, s) {
                    return applyEase(easeOutBez, n, e, t, r, s);
                  }
                  function easeIn(n, e, t, r, s) {
                    return applyEase(easeInBez, n, e, t, r, s);
                  }
                  function ease(n, e, t, r, s) {
                    return applyEase(easeInOutBez, n, e, t, r, s);
                  }
                  function applyEase(n, e, t, r, s, o) {
                    s === void 0 ? ((s = t), (o = r)) : (e = (e - t) / (r - t)),
                      e > 1 ? (e = 1) : e < 0 && (e = 0);
                    var a = n(e);
                    if ($bm_isInstanceOfArray(s)) {
                      var l,
                        c = s.length,
                        u = createTypedArray("float32", c);
                      for (l = 0; l < c; l += 1)
                        u[l] = (o[l] - s[l]) * a + s[l];
                      return u;
                    }
                    return (o - s) * a + s;
                  }
                  function nearestKey(n) {
                    var e,
                      t = data.k.length,
                      r,
                      s;
                    if (!data.k.length || typeof data.k[0] == "number")
                      (r = 0), (s = 0);
                    else if (
                      ((r = -1),
                      (n *= elem.comp.globalData.frameRate),
                      n < data.k[0].t)
                    )
                      (r = 1), (s = data.k[0].t);
                    else {
                      for (e = 0; e < t - 1; e += 1)
                        if (n === data.k[e].t) {
                          (r = e + 1), (s = data.k[e].t);
                          break;
                        } else if (n > data.k[e].t && n < data.k[e + 1].t) {
                          n - data.k[e].t > data.k[e + 1].t - n
                            ? ((r = e + 2), (s = data.k[e + 1].t))
                            : ((r = e + 1), (s = data.k[e].t));
                          break;
                        }
                      r === -1 && ((r = e + 1), (s = data.k[e].t));
                    }
                    var o = {};
                    return (
                      (o.index = r),
                      (o.time = s / elem.comp.globalData.frameRate),
                      o
                    );
                  }
                  function key(n) {
                    var e, t, r;
                    if (!data.k.length || typeof data.k[0] == "number")
                      throw new Error(
                        "The property has no keyframe at index " + n
                      );
                    (n -= 1),
                      (e = {
                        time: data.k[n].t / elem.comp.globalData.frameRate,
                        value: [],
                      });
                    var s = Object.prototype.hasOwnProperty.call(data.k[n], "s")
                      ? data.k[n].s
                      : data.k[n - 1].e;
                    for (r = s.length, t = 0; t < r; t += 1)
                      (e[t] = s[t]), (e.value[t] = s[t]);
                    return e;
                  }
                  function framesToTime(n, e) {
                    return e || (e = elem.comp.globalData.frameRate), n / e;
                  }
                  function timeToFrames(n, e) {
                    return (
                      !n && n !== 0 && (n = time),
                      e || (e = elem.comp.globalData.frameRate),
                      n * e
                    );
                  }
                  function seedRandom(n) {
                    BMMath.seedrandom(randSeed + n);
                  }
                  function sourceRectAtTime() {
                    return elem.sourceRectAtTime();
                  }
                  function substring(n, e) {
                    return typeof value == "string"
                      ? e === void 0
                        ? value.substring(n)
                        : value.substring(n, e)
                      : "";
                  }
                  function substr(n, e) {
                    return typeof value == "string"
                      ? e === void 0
                        ? value.substr(n)
                        : value.substr(n, e)
                      : "";
                  }
                  function posterizeTime(n) {
                    (time = n === 0 ? 0 : Math.floor(time * n) / n),
                      (value = valueAtTime(time));
                  }
                  var time,
                    velocity,
                    value,
                    text,
                    textIndex,
                    textTotal,
                    selectorValue,
                    index = elem.data.ind,
                    hasParent = !!(elem.hierarchy && elem.hierarchy.length),
                    parent,
                    randSeed = Math.floor(Math.random() * 1e6),
                    globalData = elem.globalData;
                  function executeExpression(n) {
                    return (
                      (value = n),
                      this.frameExpressionId === elem.globalData.frameId &&
                      this.propType !== "textSelector"
                        ? value
                        : (this.propType === "textSelector" &&
                            ((textIndex = this.textIndex),
                            (textTotal = this.textTotal),
                            (selectorValue = this.selectorValue)),
                          thisLayer ||
                            ((text = elem.layerInterface.text),
                            (thisLayer = elem.layerInterface),
                            (thisComp = elem.comp.compInterface),
                            (toWorld = thisLayer.toWorld.bind(thisLayer)),
                            (fromWorld = thisLayer.fromWorld.bind(thisLayer)),
                            (fromComp = thisLayer.fromComp.bind(thisLayer)),
                            (toComp = thisLayer.toComp.bind(thisLayer)),
                            (mask = thisLayer.mask
                              ? thisLayer.mask.bind(thisLayer)
                              : null),
                            (fromCompToSurface = fromComp)),
                          transform ||
                            ((transform = elem.layerInterface(
                              "ADBE Transform Group"
                            )),
                            ($bm_transform = transform),
                            transform && (anchorPoint = transform.anchorPoint)),
                          elemType === 4 &&
                            !content &&
                            (content = thisLayer("ADBE Root Vectors Group")),
                          effect || (effect = thisLayer(4)),
                          (hasParent = !!(
                            elem.hierarchy && elem.hierarchy.length
                          )),
                          hasParent &&
                            !parent &&
                            (parent = elem.hierarchy[0].layerInterface),
                          (time =
                            this.comp.renderedFrame /
                            this.comp.globalData.frameRate),
                          _needsRandom && seedRandom(randSeed + time),
                          needsVelocity && (velocity = velocityAtTime(time)),
                          expression_function(),
                          (this.frameExpressionId = elem.globalData.frameId),
                          (scoped_bm_rt =
                            scoped_bm_rt.propType === propTypes.SHAPE
                              ? scoped_bm_rt.v
                              : scoped_bm_rt),
                          scoped_bm_rt)
                    );
                  }
                  return (
                    (executeExpression.__preventDeadCodeRemoval = [
                      $bm_transform,
                      anchorPoint,
                      time,
                      velocity,
                      inPoint,
                      outPoint,
                      width,
                      height,
                      name,
                      loop_in,
                      loop_out,
                      smooth,
                      toComp,
                      fromCompToSurface,
                      toWorld,
                      fromWorld,
                      mask,
                      position,
                      rotation,
                      scale,
                      thisComp,
                      numKeys,
                      active,
                      wiggle,
                      loopInDuration,
                      loopOutDuration,
                      comp,
                      lookAt,
                      easeOut,
                      easeIn,
                      ease,
                      nearestKey,
                      key,
                      text,
                      textIndex,
                      textTotal,
                      selectorValue,
                      framesToTime,
                      timeToFrames,
                      sourceRectAtTime,
                      substring,
                      substr,
                      posterizeTime,
                      index,
                      globalData,
                    ]),
                    executeExpression
                  );
                }
                return (
                  (ob.initiateExpression = initiateExpression),
                  (ob.__preventDeadCodeRemoval = [
                    window,
                    document,
                    XMLHttpRequest,
                    fetch,
                    frames,
                    $bm_neg,
                    add,
                    $bm_sum,
                    $bm_sub,
                    $bm_mul,
                    $bm_div,
                    $bm_mod,
                    clamp,
                    radians_to_degrees,
                    degreesToRadians,
                    degrees_to_radians,
                    normalize,
                    rgbToHsl,
                    hslToRgb,
                    linear,
                    random,
                    createPath,
                    _lottieGlobal,
                  ]),
                  (ob.resetFrame = resetFrame),
                  ob
                );
              })(),
              Expressions = (function () {
                var n = {};
                (n.initExpressions = e),
                  (n.resetFrame = ExpressionManager.resetFrame);
                function e(t) {
                  var r = 0,
                    s = [];
                  function o() {
                    r += 1;
                  }
                  function a() {
                    (r -= 1), r === 0 && c();
                  }
                  function l(u) {
                    s.indexOf(u) === -1 && s.push(u);
                  }
                  function c() {
                    var u,
                      p = s.length;
                    for (u = 0; u < p; u += 1) s[u].release();
                    s.length = 0;
                  }
                  (t.renderer.compInterface = CompExpressionInterface(
                    t.renderer
                  )),
                    t.renderer.globalData.projectInterface.registerComposition(
                      t.renderer
                    ),
                    (t.renderer.globalData.pushExpression = o),
                    (t.renderer.globalData.popExpression = a),
                    (t.renderer.globalData.registerExpressionProperty = l);
                }
                return n;
              })(),
              MaskManagerInterface = (function () {
                function n(t, r) {
                  (this._mask = t), (this._data = r);
                }
                Object.defineProperty(n.prototype, "maskPath", {
                  get: function () {
                    return (
                      this._mask.prop.k && this._mask.prop.getValue(),
                      this._mask.prop
                    );
                  },
                }),
                  Object.defineProperty(n.prototype, "maskOpacity", {
                    get: function () {
                      return (
                        this._mask.op.k && this._mask.op.getValue(),
                        this._mask.op.v * 100
                      );
                    },
                  });
                var e = function (r) {
                  var s = createSizedArray(r.viewData.length),
                    o,
                    a = r.viewData.length;
                  for (o = 0; o < a; o += 1)
                    s[o] = new n(r.viewData[o], r.masksProperties[o]);
                  var l = function (u) {
                    for (o = 0; o < a; ) {
                      if (r.masksProperties[o].nm === u) return s[o];
                      o += 1;
                    }
                    return null;
                  };
                  return l;
                };
                return e;
              })(),
              ExpressionPropertyInterface = (function () {
                var n = { pv: 0, v: 0, mult: 1 },
                  e = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };
                function t(a, l, c) {
                  Object.defineProperty(a, "velocity", {
                    get: function () {
                      return l.getVelocityAtTime(l.comp.currentFrame);
                    },
                  }),
                    (a.numKeys = l.keyframes ? l.keyframes.length : 0),
                    (a.key = function (u) {
                      if (!a.numKeys) return 0;
                      var p = "";
                      "s" in l.keyframes[u - 1]
                        ? (p = l.keyframes[u - 1].s)
                        : "e" in l.keyframes[u - 2]
                        ? (p = l.keyframes[u - 2].e)
                        : (p = l.keyframes[u - 2].s);
                      var N =
                        c === "unidimensional"
                          ? new Number(p)
                          : Object.assign({}, p);
                      return (
                        (N.time =
                          l.keyframes[u - 1].t /
                          l.elem.comp.globalData.frameRate),
                        (N.value = c === "unidimensional" ? p[0] : p),
                        N
                      );
                    }),
                    (a.valueAtTime = l.getValueAtTime),
                    (a.speedAtTime = l.getSpeedAtTime),
                    (a.velocityAtTime = l.getVelocityAtTime),
                    (a.propertyGroup = l.propertyGroup);
                }
                function r(a) {
                  (!a || !("pv" in a)) && (a = n);
                  var l = 1 / a.mult,
                    c = a.pv * l,
                    u = new Number(c);
                  return (
                    (u.value = c),
                    t(u, a, "unidimensional"),
                    function () {
                      return (
                        a.k && a.getValue(),
                        (c = a.v * l),
                        u.value !== c &&
                          ((u = new Number(c)),
                          (u.value = c),
                          (u[0] = c),
                          t(u, a, "unidimensional")),
                        u
                      );
                    }
                  );
                }
                function s(a) {
                  (!a || !("pv" in a)) && (a = e);
                  var l = 1 / a.mult,
                    c = (a.data && a.data.l) || a.pv.length,
                    u = createTypedArray("float32", c),
                    p = createTypedArray("float32", c);
                  return (
                    (u.value = p),
                    t(u, a, "multidimensional"),
                    function () {
                      a.k && a.getValue();
                      for (var N = 0; N < c; N += 1)
                        (p[N] = a.v[N] * l), (u[N] = p[N]);
                      return u;
                    }
                  );
                }
                function o() {
                  return n;
                }
                return function (a) {
                  return a
                    ? a.propType === "unidimensional"
                      ? r(a)
                      : s(a)
                    : o;
                };
              })(),
              TransformExpressionInterface = (function () {
                return function (n) {
                  function e(a) {
                    switch (a) {
                      case "scale":
                      case "Scale":
                      case "ADBE Scale":
                      case 6:
                        return e.scale;
                      case "rotation":
                      case "Rotation":
                      case "ADBE Rotation":
                      case "ADBE Rotate Z":
                      case 10:
                        return e.rotation;
                      case "ADBE Rotate X":
                        return e.xRotation;
                      case "ADBE Rotate Y":
                        return e.yRotation;
                      case "position":
                      case "Position":
                      case "ADBE Position":
                      case 2:
                        return e.position;
                      case "ADBE Position_0":
                        return e.xPosition;
                      case "ADBE Position_1":
                        return e.yPosition;
                      case "ADBE Position_2":
                        return e.zPosition;
                      case "anchorPoint":
                      case "AnchorPoint":
                      case "Anchor Point":
                      case "ADBE AnchorPoint":
                      case 1:
                        return e.anchorPoint;
                      case "opacity":
                      case "Opacity":
                      case 11:
                        return e.opacity;
                      default:
                        return null;
                    }
                  }
                  Object.defineProperty(e, "rotation", {
                    get: ExpressionPropertyInterface(n.r || n.rz),
                  }),
                    Object.defineProperty(e, "zRotation", {
                      get: ExpressionPropertyInterface(n.rz || n.r),
                    }),
                    Object.defineProperty(e, "xRotation", {
                      get: ExpressionPropertyInterface(n.rx),
                    }),
                    Object.defineProperty(e, "yRotation", {
                      get: ExpressionPropertyInterface(n.ry),
                    }),
                    Object.defineProperty(e, "scale", {
                      get: ExpressionPropertyInterface(n.s),
                    });
                  var t, r, s, o;
                  return (
                    n.p
                      ? (o = ExpressionPropertyInterface(n.p))
                      : ((t = ExpressionPropertyInterface(n.px)),
                        (r = ExpressionPropertyInterface(n.py)),
                        n.pz && (s = ExpressionPropertyInterface(n.pz))),
                    Object.defineProperty(e, "position", {
                      get: function () {
                        return n.p ? o() : [t(), r(), s ? s() : 0];
                      },
                    }),
                    Object.defineProperty(e, "xPosition", {
                      get: ExpressionPropertyInterface(n.px),
                    }),
                    Object.defineProperty(e, "yPosition", {
                      get: ExpressionPropertyInterface(n.py),
                    }),
                    Object.defineProperty(e, "zPosition", {
                      get: ExpressionPropertyInterface(n.pz),
                    }),
                    Object.defineProperty(e, "anchorPoint", {
                      get: ExpressionPropertyInterface(n.a),
                    }),
                    Object.defineProperty(e, "opacity", {
                      get: ExpressionPropertyInterface(n.o),
                    }),
                    Object.defineProperty(e, "skew", {
                      get: ExpressionPropertyInterface(n.sk),
                    }),
                    Object.defineProperty(e, "skewAxis", {
                      get: ExpressionPropertyInterface(n.sa),
                    }),
                    Object.defineProperty(e, "orientation", {
                      get: ExpressionPropertyInterface(n.or),
                    }),
                    e
                  );
                };
              })(),
              LayerExpressionInterface = (function () {
                function n(u) {
                  var p = new Matrix();
                  if (u !== void 0) {
                    var N = this._elem.finalTransform.mProp.getValueAtTime(u);
                    N.clone(p);
                  } else {
                    var P = this._elem.finalTransform.mProp;
                    P.applyToMatrix(p);
                  }
                  return p;
                }
                function e(u, p) {
                  var N = this.getMatrix(p);
                  return (
                    (N.props[12] = 0),
                    (N.props[13] = 0),
                    (N.props[14] = 0),
                    this.applyPoint(N, u)
                  );
                }
                function t(u, p) {
                  var N = this.getMatrix(p);
                  return this.applyPoint(N, u);
                }
                function r(u, p) {
                  var N = this.getMatrix(p);
                  return (
                    (N.props[12] = 0),
                    (N.props[13] = 0),
                    (N.props[14] = 0),
                    this.invertPoint(N, u)
                  );
                }
                function s(u, p) {
                  var N = this.getMatrix(p);
                  return this.invertPoint(N, u);
                }
                function o(u, p) {
                  if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var N,
                      P = this._elem.hierarchy.length;
                    for (N = 0; N < P; N += 1)
                      this._elem.hierarchy[
                        N
                      ].finalTransform.mProp.applyToMatrix(u);
                  }
                  return u.applyToPointArray(p[0], p[1], p[2] || 0);
                }
                function a(u, p) {
                  if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var N,
                      P = this._elem.hierarchy.length;
                    for (N = 0; N < P; N += 1)
                      this._elem.hierarchy[
                        N
                      ].finalTransform.mProp.applyToMatrix(u);
                  }
                  return u.inversePoint(p);
                }
                function l(u) {
                  var p = new Matrix();
                  if (
                    (p.reset(),
                    this._elem.finalTransform.mProp.applyToMatrix(p),
                    this._elem.hierarchy && this._elem.hierarchy.length)
                  ) {
                    var N,
                      P = this._elem.hierarchy.length;
                    for (N = 0; N < P; N += 1)
                      this._elem.hierarchy[
                        N
                      ].finalTransform.mProp.applyToMatrix(p);
                    return p.inversePoint(u);
                  }
                  return p.inversePoint(u);
                }
                function c() {
                  return [1, 1, 1, 1];
                }
                return function (u) {
                  var p;
                  function N(Ye) {
                    de.mask = new MaskManagerInterface(Ye, u);
                  }
                  function P(Ye) {
                    de.effect = Ye;
                  }
                  function de(Ye) {
                    switch (Ye) {
                      case "ADBE Root Vectors Group":
                      case "Contents":
                      case 2:
                        return de.shapeInterface;
                      case 1:
                      case 6:
                      case "Transform":
                      case "transform":
                      case "ADBE Transform Group":
                        return p;
                      case 4:
                      case "ADBE Effect Parade":
                      case "effects":
                      case "Effects":
                        return de.effect;
                      case "ADBE Text Properties":
                        return de.textInterface;
                      default:
                        return null;
                    }
                  }
                  (de.getMatrix = n),
                    (de.invertPoint = a),
                    (de.applyPoint = o),
                    (de.toWorld = t),
                    (de.toWorldVec = e),
                    (de.fromWorld = s),
                    (de.fromWorldVec = r),
                    (de.toComp = t),
                    (de.fromComp = l),
                    (de.sampleImage = c),
                    (de.sourceRectAtTime = u.sourceRectAtTime.bind(u)),
                    (de._elem = u),
                    (p = TransformExpressionInterface(u.finalTransform.mProp));
                  var me = getDescriptor(p, "anchorPoint");
                  return (
                    Object.defineProperties(de, {
                      hasParent: {
                        get: function () {
                          return u.hierarchy.length;
                        },
                      },
                      parent: {
                        get: function () {
                          return u.hierarchy[0].layerInterface;
                        },
                      },
                      rotation: getDescriptor(p, "rotation"),
                      scale: getDescriptor(p, "scale"),
                      position: getDescriptor(p, "position"),
                      opacity: getDescriptor(p, "opacity"),
                      anchorPoint: me,
                      anchor_point: me,
                      transform: {
                        get: function () {
                          return p;
                        },
                      },
                      active: {
                        get: function () {
                          return u.isInRange;
                        },
                      },
                    }),
                    (de.startTime = u.data.st),
                    (de.index = u.data.ind),
                    (de.source = u.data.refId),
                    (de.height = u.data.ty === 0 ? u.data.h : 100),
                    (de.width = u.data.ty === 0 ? u.data.w : 100),
                    (de.inPoint = u.data.ip / u.comp.globalData.frameRate),
                    (de.outPoint = u.data.op / u.comp.globalData.frameRate),
                    (de._name = u.data.nm),
                    (de.registerMaskInterface = N),
                    (de.registerEffectsInterface = P),
                    de
                  );
                };
              })(),
              propertyGroupFactory = (function () {
                return function (n, e) {
                  return function (t) {
                    return (t = t === void 0 ? 1 : t), t <= 0 ? n : e(t - 1);
                  };
                };
              })(),
              PropertyInterface = (function () {
                return function (n, e) {
                  var t = { _name: n };
                  function r(s) {
                    return (s = s === void 0 ? 1 : s), s <= 0 ? t : e(s - 1);
                  }
                  return r;
                };
              })(),
              EffectsExpressionInterface = (function () {
                var n = { createEffectsInterface: e };
                function e(s, o) {
                  if (s.effectsManager) {
                    var a = [],
                      l = s.data.ef,
                      c,
                      u = s.effectsManager.effectElements.length;
                    for (c = 0; c < u; c += 1)
                      a.push(t(l[c], s.effectsManager.effectElements[c], o, s));
                    var p = s.data.ef || [],
                      N = function (de) {
                        for (c = 0, u = p.length; c < u; ) {
                          if (
                            de === p[c].nm ||
                            de === p[c].mn ||
                            de === p[c].ix
                          )
                            return a[c];
                          c += 1;
                        }
                        return null;
                      };
                    return (
                      Object.defineProperty(N, "numProperties", {
                        get: function () {
                          return p.length;
                        },
                      }),
                      N
                    );
                  }
                  return null;
                }
                function t(s, o, a, l) {
                  function c(de) {
                    for (var me = s.ef, Ye = 0, nt = me.length; Ye < nt; ) {
                      if (
                        de === me[Ye].nm ||
                        de === me[Ye].mn ||
                        de === me[Ye].ix
                      )
                        return me[Ye].ty === 5 ? p[Ye] : p[Ye]();
                      Ye += 1;
                    }
                    throw new Error();
                  }
                  var u = propertyGroupFactory(c, a),
                    p = [],
                    N,
                    P = s.ef.length;
                  for (N = 0; N < P; N += 1)
                    s.ef[N].ty === 5
                      ? p.push(
                          t(
                            s.ef[N],
                            o.effectElements[N],
                            o.effectElements[N].propertyGroup,
                            l
                          )
                        )
                      : p.push(r(o.effectElements[N], s.ef[N].ty, l, u));
                  return (
                    s.mn === "ADBE Color Control" &&
                      Object.defineProperty(c, "color", {
                        get: function () {
                          return p[0]();
                        },
                      }),
                    Object.defineProperties(c, {
                      numProperties: {
                        get: function () {
                          return s.np;
                        },
                      },
                      _name: { value: s.nm },
                      propertyGroup: { value: u },
                    }),
                    (c.enabled = s.en !== 0),
                    (c.active = c.enabled),
                    c
                  );
                }
                function r(s, o, a, l) {
                  var c = ExpressionPropertyInterface(s.p);
                  function u() {
                    return o === 10 ? a.comp.compInterface(s.p.v) : c();
                  }
                  return (
                    s.p.setGroupProperty &&
                      s.p.setGroupProperty(PropertyInterface("", l)),
                    u
                  );
                }
                return n;
              })(),
              ShapePathInterface = (function () {
                return function (e, t, r) {
                  var s = t.sh;
                  function o(l) {
                    return l === "Shape" ||
                      l === "shape" ||
                      l === "Path" ||
                      l === "path" ||
                      l === "ADBE Vector Shape" ||
                      l === 2
                      ? o.path
                      : null;
                  }
                  var a = propertyGroupFactory(o, r);
                  return (
                    s.setGroupProperty(PropertyInterface("Path", a)),
                    Object.defineProperties(o, {
                      path: {
                        get: function () {
                          return s.k && s.getValue(), s;
                        },
                      },
                      shape: {
                        get: function () {
                          return s.k && s.getValue(), s;
                        },
                      },
                      _name: { value: e.nm },
                      ix: { value: e.ix },
                      propertyIndex: { value: e.ix },
                      mn: { value: e.mn },
                      propertyGroup: { value: r },
                    }),
                    o
                  );
                };
              })(),
              ShapeExpressionInterface = (function () {
                function n(me, Ye, nt) {
                  var Be = [],
                    ot,
                    st = me ? me.length : 0;
                  for (ot = 0; ot < st; ot += 1)
                    me[ot].ty === "gr"
                      ? Be.push(t(me[ot], Ye[ot], nt))
                      : me[ot].ty === "fl"
                      ? Be.push(r(me[ot], Ye[ot], nt))
                      : me[ot].ty === "st"
                      ? Be.push(a(me[ot], Ye[ot], nt))
                      : me[ot].ty === "tm"
                      ? Be.push(l(me[ot], Ye[ot], nt))
                      : me[ot].ty === "tr" ||
                        (me[ot].ty === "el"
                          ? Be.push(u(me[ot], Ye[ot], nt))
                          : me[ot].ty === "sr"
                          ? Be.push(p(me[ot], Ye[ot], nt))
                          : me[ot].ty === "sh"
                          ? Be.push(ShapePathInterface(me[ot], Ye[ot], nt))
                          : me[ot].ty === "rc"
                          ? Be.push(N(me[ot], Ye[ot], nt))
                          : me[ot].ty === "rd"
                          ? Be.push(P(me[ot], Ye[ot], nt))
                          : me[ot].ty === "rp"
                          ? Be.push(de(me[ot], Ye[ot], nt))
                          : me[ot].ty === "gf"
                          ? Be.push(s(me[ot], Ye[ot], nt))
                          : Be.push(o(me[ot], Ye[ot])));
                  return Be;
                }
                function e(me, Ye, nt) {
                  var Be,
                    ot = function (xt) {
                      for (var St = 0, wt = Be.length; St < wt; ) {
                        if (
                          Be[St]._name === xt ||
                          Be[St].mn === xt ||
                          Be[St].propertyIndex === xt ||
                          Be[St].ix === xt ||
                          Be[St].ind === xt
                        )
                          return Be[St];
                        St += 1;
                      }
                      return typeof xt == "number" ? Be[xt - 1] : null;
                    };
                  (ot.propertyGroup = propertyGroupFactory(ot, nt)),
                    (Be = n(me.it, Ye.it, ot.propertyGroup)),
                    (ot.numProperties = Be.length);
                  var st = c(
                    me.it[me.it.length - 1],
                    Ye.it[Ye.it.length - 1],
                    ot.propertyGroup
                  );
                  return (
                    (ot.transform = st),
                    (ot.propertyIndex = me.cix),
                    (ot._name = me.nm),
                    ot
                  );
                }
                function t(me, Ye, nt) {
                  var Be = function (xt) {
                    switch (xt) {
                      case "ADBE Vectors Group":
                      case "Contents":
                      case 2:
                        return Be.content;
                      default:
                        return Be.transform;
                    }
                  };
                  Be.propertyGroup = propertyGroupFactory(Be, nt);
                  var ot = e(me, Ye, Be.propertyGroup),
                    st = c(
                      me.it[me.it.length - 1],
                      Ye.it[Ye.it.length - 1],
                      Be.propertyGroup
                    );
                  return (
                    (Be.content = ot),
                    (Be.transform = st),
                    Object.defineProperty(Be, "_name", {
                      get: function () {
                        return me.nm;
                      },
                    }),
                    (Be.numProperties = me.np),
                    (Be.propertyIndex = me.ix),
                    (Be.nm = me.nm),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                function r(me, Ye, nt) {
                  function Be(ot) {
                    return ot === "Color" || ot === "color"
                      ? Be.color
                      : ot === "Opacity" || ot === "opacity"
                      ? Be.opacity
                      : null;
                  }
                  return (
                    Object.defineProperties(Be, {
                      color: { get: ExpressionPropertyInterface(Ye.c) },
                      opacity: { get: ExpressionPropertyInterface(Ye.o) },
                      _name: { value: me.nm },
                      mn: { value: me.mn },
                    }),
                    Ye.c.setGroupProperty(PropertyInterface("Color", nt)),
                    Ye.o.setGroupProperty(PropertyInterface("Opacity", nt)),
                    Be
                  );
                }
                function s(me, Ye, nt) {
                  function Be(ot) {
                    return ot === "Start Point" || ot === "start point"
                      ? Be.startPoint
                      : ot === "End Point" || ot === "end point"
                      ? Be.endPoint
                      : ot === "Opacity" || ot === "opacity"
                      ? Be.opacity
                      : null;
                  }
                  return (
                    Object.defineProperties(Be, {
                      startPoint: { get: ExpressionPropertyInterface(Ye.s) },
                      endPoint: { get: ExpressionPropertyInterface(Ye.e) },
                      opacity: { get: ExpressionPropertyInterface(Ye.o) },
                      type: {
                        get: function () {
                          return "a";
                        },
                      },
                      _name: { value: me.nm },
                      mn: { value: me.mn },
                    }),
                    Ye.s.setGroupProperty(PropertyInterface("Start Point", nt)),
                    Ye.e.setGroupProperty(PropertyInterface("End Point", nt)),
                    Ye.o.setGroupProperty(PropertyInterface("Opacity", nt)),
                    Be
                  );
                }
                function o() {
                  function me() {
                    return null;
                  }
                  return me;
                }
                function a(me, Ye, nt) {
                  var Be = propertyGroupFactory(wt, nt),
                    ot = propertyGroupFactory(St, Be);
                  function st(bt) {
                    Object.defineProperty(St, me.d[bt].nm, {
                      get: ExpressionPropertyInterface(Ye.d.dataProps[bt].p),
                    });
                  }
                  var vt,
                    xt = me.d ? me.d.length : 0,
                    St = {};
                  for (vt = 0; vt < xt; vt += 1)
                    st(vt), Ye.d.dataProps[vt].p.setGroupProperty(ot);
                  function wt(bt) {
                    return bt === "Color" || bt === "color"
                      ? wt.color
                      : bt === "Opacity" || bt === "opacity"
                      ? wt.opacity
                      : bt === "Stroke Width" || bt === "stroke width"
                      ? wt.strokeWidth
                      : null;
                  }
                  return (
                    Object.defineProperties(wt, {
                      color: { get: ExpressionPropertyInterface(Ye.c) },
                      opacity: { get: ExpressionPropertyInterface(Ye.o) },
                      strokeWidth: { get: ExpressionPropertyInterface(Ye.w) },
                      dash: {
                        get: function () {
                          return St;
                        },
                      },
                      _name: { value: me.nm },
                      mn: { value: me.mn },
                    }),
                    Ye.c.setGroupProperty(PropertyInterface("Color", Be)),
                    Ye.o.setGroupProperty(PropertyInterface("Opacity", Be)),
                    Ye.w.setGroupProperty(
                      PropertyInterface("Stroke Width", Be)
                    ),
                    wt
                  );
                }
                function l(me, Ye, nt) {
                  function Be(st) {
                    return st === me.e.ix || st === "End" || st === "end"
                      ? Be.end
                      : st === me.s.ix
                      ? Be.start
                      : st === me.o.ix
                      ? Be.offset
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt);
                  return (
                    (Be.propertyIndex = me.ix),
                    Ye.s.setGroupProperty(PropertyInterface("Start", ot)),
                    Ye.e.setGroupProperty(PropertyInterface("End", ot)),
                    Ye.o.setGroupProperty(PropertyInterface("Offset", ot)),
                    (Be.propertyIndex = me.ix),
                    (Be.propertyGroup = nt),
                    Object.defineProperties(Be, {
                      start: { get: ExpressionPropertyInterface(Ye.s) },
                      end: { get: ExpressionPropertyInterface(Ye.e) },
                      offset: { get: ExpressionPropertyInterface(Ye.o) },
                      _name: { value: me.nm },
                    }),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                function c(me, Ye, nt) {
                  function Be(st) {
                    return me.a.ix === st || st === "Anchor Point"
                      ? Be.anchorPoint
                      : me.o.ix === st || st === "Opacity"
                      ? Be.opacity
                      : me.p.ix === st || st === "Position"
                      ? Be.position
                      : me.r.ix === st ||
                        st === "Rotation" ||
                        st === "ADBE Vector Rotation"
                      ? Be.rotation
                      : me.s.ix === st || st === "Scale"
                      ? Be.scale
                      : (me.sk && me.sk.ix === st) || st === "Skew"
                      ? Be.skew
                      : (me.sa && me.sa.ix === st) || st === "Skew Axis"
                      ? Be.skewAxis
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt);
                  return (
                    Ye.transform.mProps.o.setGroupProperty(
                      PropertyInterface("Opacity", ot)
                    ),
                    Ye.transform.mProps.p.setGroupProperty(
                      PropertyInterface("Position", ot)
                    ),
                    Ye.transform.mProps.a.setGroupProperty(
                      PropertyInterface("Anchor Point", ot)
                    ),
                    Ye.transform.mProps.s.setGroupProperty(
                      PropertyInterface("Scale", ot)
                    ),
                    Ye.transform.mProps.r.setGroupProperty(
                      PropertyInterface("Rotation", ot)
                    ),
                    Ye.transform.mProps.sk &&
                      (Ye.transform.mProps.sk.setGroupProperty(
                        PropertyInterface("Skew", ot)
                      ),
                      Ye.transform.mProps.sa.setGroupProperty(
                        PropertyInterface("Skew Angle", ot)
                      )),
                    Ye.transform.op.setGroupProperty(
                      PropertyInterface("Opacity", ot)
                    ),
                    Object.defineProperties(Be, {
                      opacity: {
                        get: ExpressionPropertyInterface(Ye.transform.mProps.o),
                      },
                      position: {
                        get: ExpressionPropertyInterface(Ye.transform.mProps.p),
                      },
                      anchorPoint: {
                        get: ExpressionPropertyInterface(Ye.transform.mProps.a),
                      },
                      scale: {
                        get: ExpressionPropertyInterface(Ye.transform.mProps.s),
                      },
                      rotation: {
                        get: ExpressionPropertyInterface(Ye.transform.mProps.r),
                      },
                      skew: {
                        get: ExpressionPropertyInterface(
                          Ye.transform.mProps.sk
                        ),
                      },
                      skewAxis: {
                        get: ExpressionPropertyInterface(
                          Ye.transform.mProps.sa
                        ),
                      },
                      _name: { value: me.nm },
                    }),
                    (Be.ty = "tr"),
                    (Be.mn = me.mn),
                    (Be.propertyGroup = nt),
                    Be
                  );
                }
                function u(me, Ye, nt) {
                  function Be(vt) {
                    return me.p.ix === vt
                      ? Be.position
                      : me.s.ix === vt
                      ? Be.size
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt);
                  Be.propertyIndex = me.ix;
                  var st = Ye.sh.ty === "tm" ? Ye.sh.prop : Ye.sh;
                  return (
                    st.s.setGroupProperty(PropertyInterface("Size", ot)),
                    st.p.setGroupProperty(PropertyInterface("Position", ot)),
                    Object.defineProperties(Be, {
                      size: { get: ExpressionPropertyInterface(st.s) },
                      position: { get: ExpressionPropertyInterface(st.p) },
                      _name: { value: me.nm },
                    }),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                function p(me, Ye, nt) {
                  function Be(vt) {
                    return me.p.ix === vt
                      ? Be.position
                      : me.r.ix === vt
                      ? Be.rotation
                      : me.pt.ix === vt
                      ? Be.points
                      : me.or.ix === vt ||
                        vt === "ADBE Vector Star Outer Radius"
                      ? Be.outerRadius
                      : me.os.ix === vt
                      ? Be.outerRoundness
                      : me.ir &&
                        (me.ir.ix === vt ||
                          vt === "ADBE Vector Star Inner Radius")
                      ? Be.innerRadius
                      : me.is && me.is.ix === vt
                      ? Be.innerRoundness
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt),
                    st = Ye.sh.ty === "tm" ? Ye.sh.prop : Ye.sh;
                  return (
                    (Be.propertyIndex = me.ix),
                    st.or.setGroupProperty(
                      PropertyInterface("Outer Radius", ot)
                    ),
                    st.os.setGroupProperty(
                      PropertyInterface("Outer Roundness", ot)
                    ),
                    st.pt.setGroupProperty(PropertyInterface("Points", ot)),
                    st.p.setGroupProperty(PropertyInterface("Position", ot)),
                    st.r.setGroupProperty(PropertyInterface("Rotation", ot)),
                    me.ir &&
                      (st.ir.setGroupProperty(
                        PropertyInterface("Inner Radius", ot)
                      ),
                      st.is.setGroupProperty(
                        PropertyInterface("Inner Roundness", ot)
                      )),
                    Object.defineProperties(Be, {
                      position: { get: ExpressionPropertyInterface(st.p) },
                      rotation: { get: ExpressionPropertyInterface(st.r) },
                      points: { get: ExpressionPropertyInterface(st.pt) },
                      outerRadius: { get: ExpressionPropertyInterface(st.or) },
                      outerRoundness: {
                        get: ExpressionPropertyInterface(st.os),
                      },
                      innerRadius: { get: ExpressionPropertyInterface(st.ir) },
                      innerRoundness: {
                        get: ExpressionPropertyInterface(st.is),
                      },
                      _name: { value: me.nm },
                    }),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                function N(me, Ye, nt) {
                  function Be(vt) {
                    return me.p.ix === vt
                      ? Be.position
                      : me.r.ix === vt
                      ? Be.roundness
                      : me.s.ix === vt ||
                        vt === "Size" ||
                        vt === "ADBE Vector Rect Size"
                      ? Be.size
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt),
                    st = Ye.sh.ty === "tm" ? Ye.sh.prop : Ye.sh;
                  return (
                    (Be.propertyIndex = me.ix),
                    st.p.setGroupProperty(PropertyInterface("Position", ot)),
                    st.s.setGroupProperty(PropertyInterface("Size", ot)),
                    st.r.setGroupProperty(PropertyInterface("Rotation", ot)),
                    Object.defineProperties(Be, {
                      position: { get: ExpressionPropertyInterface(st.p) },
                      roundness: { get: ExpressionPropertyInterface(st.r) },
                      size: { get: ExpressionPropertyInterface(st.s) },
                      _name: { value: me.nm },
                    }),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                function P(me, Ye, nt) {
                  function Be(vt) {
                    return me.r.ix === vt || vt === "Round Corners 1"
                      ? Be.radius
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt),
                    st = Ye;
                  return (
                    (Be.propertyIndex = me.ix),
                    st.rd.setGroupProperty(PropertyInterface("Radius", ot)),
                    Object.defineProperties(Be, {
                      radius: { get: ExpressionPropertyInterface(st.rd) },
                      _name: { value: me.nm },
                    }),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                function de(me, Ye, nt) {
                  function Be(vt) {
                    return me.c.ix === vt || vt === "Copies"
                      ? Be.copies
                      : me.o.ix === vt || vt === "Offset"
                      ? Be.offset
                      : null;
                  }
                  var ot = propertyGroupFactory(Be, nt),
                    st = Ye;
                  return (
                    (Be.propertyIndex = me.ix),
                    st.c.setGroupProperty(PropertyInterface("Copies", ot)),
                    st.o.setGroupProperty(PropertyInterface("Offset", ot)),
                    Object.defineProperties(Be, {
                      copies: { get: ExpressionPropertyInterface(st.c) },
                      offset: { get: ExpressionPropertyInterface(st.o) },
                      _name: { value: me.nm },
                    }),
                    (Be.mn = me.mn),
                    Be
                  );
                }
                return function (me, Ye, nt) {
                  var Be;
                  function ot(vt) {
                    if (typeof vt == "number")
                      return (
                        (vt = vt === void 0 ? 1 : vt),
                        vt === 0 ? nt : Be[vt - 1]
                      );
                    for (var xt = 0, St = Be.length; xt < St; ) {
                      if (Be[xt]._name === vt) return Be[xt];
                      xt += 1;
                    }
                    return null;
                  }
                  function st() {
                    return nt;
                  }
                  return (
                    (ot.propertyGroup = propertyGroupFactory(ot, st)),
                    (Be = n(me, Ye, ot.propertyGroup)),
                    (ot.numProperties = Be.length),
                    (ot._name = "Contents"),
                    ot
                  );
                };
              })(),
              TextExpressionInterface = (function () {
                return function (n) {
                  var e;
                  function t(r) {
                    switch (r) {
                      case "ADBE Text Document":
                        return t.sourceText;
                      default:
                        return null;
                    }
                  }
                  return (
                    Object.defineProperty(t, "sourceText", {
                      get: function () {
                        n.textProperty.getValue();
                        var s = n.textProperty.currentData.t;
                        return (
                          (!e || s !== e.value) &&
                            ((e = new String(s)),
                            (e.value = s || new String(s)),
                            Object.defineProperty(e, "style", {
                              get: function () {
                                return {
                                  fillColor: n.textProperty.currentData.fc,
                                };
                              },
                            })),
                          e
                        );
                      },
                    }),
                    t
                  );
                };
              })();
            function _typeof(n) {
              "@babel/helpers - typeof";
              return (
                (_typeof =
                  typeof Symbol == "function" &&
                  typeof Symbol.iterator == "symbol"
                    ? function (e) {
                        return typeof e;
                      }
                    : function (e) {
                        return e &&
                          typeof Symbol == "function" &&
                          e.constructor === Symbol &&
                          e !== Symbol.prototype
                          ? "symbol"
                          : typeof e;
                      }),
                _typeof(n)
              );
            }
            var FootageInterface = (function () {
                var n = function (r) {
                    var s = "",
                      o = r.getFootageData();
                    function a() {
                      return (s = ""), (o = r.getFootageData()), l;
                    }
                    function l(c) {
                      if (o[c])
                        return (
                          (s = c), (o = o[c]), _typeof(o) === "object" ? l : o
                        );
                      var u = c.indexOf(s);
                      if (u !== -1) {
                        var p = parseInt(c.substr(u + s.length), 10);
                        return (o = o[p]), _typeof(o) === "object" ? l : o;
                      }
                      return "";
                    }
                    return a;
                  },
                  e = function (r) {
                    function s(o) {
                      return o === "Outline" ? s.outlineInterface() : null;
                    }
                    return (
                      (s._name = "Outline"), (s.outlineInterface = n(r)), s
                    );
                  };
                return function (t) {
                  function r(s) {
                    return s === "Data" ? r.dataInterface : null;
                  }
                  return (r._name = "Data"), (r.dataInterface = e(t)), r;
                };
              })(),
              interfaces = {
                layer: LayerExpressionInterface,
                effects: EffectsExpressionInterface,
                comp: CompExpressionInterface,
                shape: ShapeExpressionInterface,
                text: TextExpressionInterface,
                footage: FootageInterface,
              };
            function getInterface(n) {
              return interfaces[n] || null;
            }
            var expressionHelpers = (function () {
              function n(a, l, c) {
                l.x &&
                  ((c.k = !0),
                  (c.x = !0),
                  (c.initiateExpression = ExpressionManager.initiateExpression),
                  c.effectsSequence.push(
                    c.initiateExpression(a, l, c).bind(c)
                  ));
              }
              function e(a) {
                return (
                  (a *= this.elem.globalData.frameRate),
                  (a -= this.offsetTime),
                  a !== this._cachingAtTime.lastFrame &&
                    ((this._cachingAtTime.lastIndex =
                      this._cachingAtTime.lastFrame < a
                        ? this._cachingAtTime.lastIndex
                        : 0),
                    (this._cachingAtTime.value = this.interpolateValue(
                      a,
                      this._cachingAtTime
                    )),
                    (this._cachingAtTime.lastFrame = a)),
                  this._cachingAtTime.value
                );
              }
              function t(a) {
                var l = -0.01,
                  c = this.getValueAtTime(a),
                  u = this.getValueAtTime(a + l),
                  p = 0;
                if (c.length) {
                  var N;
                  for (N = 0; N < c.length; N += 1)
                    p += Math.pow(u[N] - c[N], 2);
                  p = Math.sqrt(p) * 100;
                } else p = 0;
                return p;
              }
              function r(a) {
                if (this.vel !== void 0) return this.vel;
                var l = -0.001,
                  c = this.getValueAtTime(a),
                  u = this.getValueAtTime(a + l),
                  p;
                if (c.length) {
                  p = createTypedArray("float32", c.length);
                  var N;
                  for (N = 0; N < c.length; N += 1) p[N] = (u[N] - c[N]) / l;
                } else p = (u - c) / l;
                return p;
              }
              function s() {
                return this.pv;
              }
              function o(a) {
                this.propertyGroup = a;
              }
              return {
                searchExpressions: n,
                getSpeedAtTime: t,
                getVelocityAtTime: r,
                getValueAtTime: e,
                getStaticValueAtTime: s,
                setGroupProperty: o,
              };
            })();
            function addPropertyDecorator() {
              function n(P, de, me) {
                if (!this.k || !this.keyframes) return this.pv;
                P = P ? P.toLowerCase() : "";
                var Ye = this.comp.renderedFrame,
                  nt = this.keyframes,
                  Be = nt[nt.length - 1].t;
                if (Ye <= Be) return this.pv;
                var ot, st;
                me
                  ? (de
                      ? (ot = Math.abs(
                          Be - this.elem.comp.globalData.frameRate * de
                        ))
                      : (ot = Math.max(0, Be - this.elem.data.ip)),
                    (st = Be - ot))
                  : ((!de || de > nt.length - 1) && (de = nt.length - 1),
                    (st = nt[nt.length - 1 - de].t),
                    (ot = Be - st));
                var vt, xt, St;
                if (P === "pingpong") {
                  var wt = Math.floor((Ye - st) / ot);
                  if (wt % 2 !== 0)
                    return this.getValueAtTime(
                      (ot - ((Ye - st) % ot) + st) /
                        this.comp.globalData.frameRate,
                      0
                    );
                } else if (P === "offset") {
                  var bt = this.getValueAtTime(
                      st / this.comp.globalData.frameRate,
                      0
                    ),
                    Tt = this.getValueAtTime(
                      Be / this.comp.globalData.frameRate,
                      0
                    ),
                    Ct = this.getValueAtTime(
                      (((Ye - st) % ot) + st) / this.comp.globalData.frameRate,
                      0
                    ),
                    kt = Math.floor((Ye - st) / ot);
                  if (this.pv.length) {
                    for (
                      St = new Array(bt.length), xt = St.length, vt = 0;
                      vt < xt;
                      vt += 1
                    )
                      St[vt] = (Tt[vt] - bt[vt]) * kt + Ct[vt];
                    return St;
                  }
                  return (Tt - bt) * kt + Ct;
                } else if (P === "continue") {
                  var Dt = this.getValueAtTime(
                      Be / this.comp.globalData.frameRate,
                      0
                    ),
                    Vt = this.getValueAtTime(
                      (Be - 0.001) / this.comp.globalData.frameRate,
                      0
                    );
                  if (this.pv.length) {
                    for (
                      St = new Array(Dt.length), xt = St.length, vt = 0;
                      vt < xt;
                      vt += 1
                    )
                      St[vt] =
                        Dt[vt] +
                        ((Dt[vt] - Vt[vt]) *
                          ((Ye - Be) / this.comp.globalData.frameRate)) /
                          5e-4;
                    return St;
                  }
                  return Dt + (Dt - Vt) * ((Ye - Be) / 0.001);
                }
                return this.getValueAtTime(
                  (((Ye - st) % ot) + st) / this.comp.globalData.frameRate,
                  0
                );
              }
              function e(P, de, me) {
                if (!this.k) return this.pv;
                P = P ? P.toLowerCase() : "";
                var Ye = this.comp.renderedFrame,
                  nt = this.keyframes,
                  Be = nt[0].t;
                if (Ye >= Be) return this.pv;
                var ot, st;
                me
                  ? (de
                      ? (ot = Math.abs(
                          this.elem.comp.globalData.frameRate * de
                        ))
                      : (ot = Math.max(0, this.elem.data.op - Be)),
                    (st = Be + ot))
                  : ((!de || de > nt.length - 1) && (de = nt.length - 1),
                    (st = nt[de].t),
                    (ot = st - Be));
                var vt, xt, St;
                if (P === "pingpong") {
                  var wt = Math.floor((Be - Ye) / ot);
                  if (wt % 2 === 0)
                    return this.getValueAtTime(
                      (((Be - Ye) % ot) + Be) / this.comp.globalData.frameRate,
                      0
                    );
                } else if (P === "offset") {
                  var bt = this.getValueAtTime(
                      Be / this.comp.globalData.frameRate,
                      0
                    ),
                    Tt = this.getValueAtTime(
                      st / this.comp.globalData.frameRate,
                      0
                    ),
                    Ct = this.getValueAtTime(
                      (ot - ((Be - Ye) % ot) + Be) /
                        this.comp.globalData.frameRate,
                      0
                    ),
                    kt = Math.floor((Be - Ye) / ot) + 1;
                  if (this.pv.length) {
                    for (
                      St = new Array(bt.length), xt = St.length, vt = 0;
                      vt < xt;
                      vt += 1
                    )
                      St[vt] = Ct[vt] - (Tt[vt] - bt[vt]) * kt;
                    return St;
                  }
                  return Ct - (Tt - bt) * kt;
                } else if (P === "continue") {
                  var Dt = this.getValueAtTime(
                      Be / this.comp.globalData.frameRate,
                      0
                    ),
                    Vt = this.getValueAtTime(
                      (Be + 0.001) / this.comp.globalData.frameRate,
                      0
                    );
                  if (this.pv.length) {
                    for (
                      St = new Array(Dt.length), xt = St.length, vt = 0;
                      vt < xt;
                      vt += 1
                    )
                      St[vt] = Dt[vt] + ((Dt[vt] - Vt[vt]) * (Be - Ye)) / 0.001;
                    return St;
                  }
                  return Dt + ((Dt - Vt) * (Be - Ye)) / 0.001;
                }
                return this.getValueAtTime(
                  (ot - (((Be - Ye) % ot) + Be)) /
                    this.comp.globalData.frameRate,
                  0
                );
              }
              function t(P, de) {
                if (!this.k) return this.pv;
                if (
                  ((P = (P || 0.4) * 0.5), (de = Math.floor(de || 5)), de <= 1)
                )
                  return this.pv;
                var me =
                    this.comp.renderedFrame / this.comp.globalData.frameRate,
                  Ye = me - P,
                  nt = me + P,
                  Be = de > 1 ? (nt - Ye) / (de - 1) : 1,
                  ot = 0,
                  st = 0,
                  vt;
                this.pv.length
                  ? (vt = createTypedArray("float32", this.pv.length))
                  : (vt = 0);
                for (var xt; ot < de; ) {
                  if (
                    ((xt = this.getValueAtTime(Ye + ot * Be)), this.pv.length)
                  )
                    for (st = 0; st < this.pv.length; st += 1) vt[st] += xt[st];
                  else vt += xt;
                  ot += 1;
                }
                if (this.pv.length)
                  for (st = 0; st < this.pv.length; st += 1) vt[st] /= de;
                else vt /= de;
                return vt;
              }
              function r(P) {
                this._transformCachingAtTime ||
                  (this._transformCachingAtTime = { v: new Matrix() });
                var de = this._transformCachingAtTime.v;
                if (
                  (de.cloneFromProps(this.pre.props),
                  this.appliedTransformations < 1)
                ) {
                  var me = this.a.getValueAtTime(P);
                  de.translate(
                    -me[0] * this.a.mult,
                    -me[1] * this.a.mult,
                    me[2] * this.a.mult
                  );
                }
                if (this.appliedTransformations < 2) {
                  var Ye = this.s.getValueAtTime(P);
                  de.scale(
                    Ye[0] * this.s.mult,
                    Ye[1] * this.s.mult,
                    Ye[2] * this.s.mult
                  );
                }
                if (this.sk && this.appliedTransformations < 3) {
                  var nt = this.sk.getValueAtTime(P),
                    Be = this.sa.getValueAtTime(P);
                  de.skewFromAxis(-nt * this.sk.mult, Be * this.sa.mult);
                }
                if (this.r && this.appliedTransformations < 4) {
                  var ot = this.r.getValueAtTime(P);
                  de.rotate(-ot * this.r.mult);
                } else if (!this.r && this.appliedTransformations < 4) {
                  var st = this.rz.getValueAtTime(P),
                    vt = this.ry.getValueAtTime(P),
                    xt = this.rx.getValueAtTime(P),
                    St = this.or.getValueAtTime(P);
                  de.rotateZ(-st * this.rz.mult)
                    .rotateY(vt * this.ry.mult)
                    .rotateX(xt * this.rx.mult)
                    .rotateZ(-St[2] * this.or.mult)
                    .rotateY(St[1] * this.or.mult)
                    .rotateX(St[0] * this.or.mult);
                }
                if (this.data.p && this.data.p.s) {
                  var wt = this.px.getValueAtTime(P),
                    bt = this.py.getValueAtTime(P);
                  if (this.data.p.z) {
                    var Tt = this.pz.getValueAtTime(P);
                    de.translate(
                      wt * this.px.mult,
                      bt * this.py.mult,
                      -Tt * this.pz.mult
                    );
                  } else de.translate(wt * this.px.mult, bt * this.py.mult, 0);
                } else {
                  var Ct = this.p.getValueAtTime(P);
                  de.translate(
                    Ct[0] * this.p.mult,
                    Ct[1] * this.p.mult,
                    -Ct[2] * this.p.mult
                  );
                }
                return de;
              }
              function s() {
                return this.v.clone(new Matrix());
              }
              var o = TransformPropertyFactory.getTransformProperty;
              TransformPropertyFactory.getTransformProperty = function (
                P,
                de,
                me
              ) {
                var Ye = o(P, de, me);
                return (
                  Ye.dynamicProperties.length
                    ? (Ye.getValueAtTime = r.bind(Ye))
                    : (Ye.getValueAtTime = s.bind(Ye)),
                  (Ye.setGroupProperty = expressionHelpers.setGroupProperty),
                  Ye
                );
              };
              var a = PropertyFactory.getProp;
              PropertyFactory.getProp = function (P, de, me, Ye, nt) {
                var Be = a(P, de, me, Ye, nt);
                Be.kf
                  ? (Be.getValueAtTime =
                      expressionHelpers.getValueAtTime.bind(Be))
                  : (Be.getValueAtTime =
                      expressionHelpers.getStaticValueAtTime.bind(Be)),
                  (Be.setGroupProperty = expressionHelpers.setGroupProperty),
                  (Be.loopOut = n),
                  (Be.loopIn = e),
                  (Be.smooth = t),
                  (Be.getVelocityAtTime =
                    expressionHelpers.getVelocityAtTime.bind(Be)),
                  (Be.getSpeedAtTime =
                    expressionHelpers.getSpeedAtTime.bind(Be)),
                  (Be.numKeys = de.a === 1 ? de.k.length : 0),
                  (Be.propertyIndex = de.ix);
                var ot = 0;
                return (
                  me !== 0 &&
                    (ot = createTypedArray(
                      "float32",
                      de.a === 1 ? de.k[0].s.length : de.k.length
                    )),
                  (Be._cachingAtTime = {
                    lastFrame: initialDefaultFrame,
                    lastIndex: 0,
                    value: ot,
                  }),
                  expressionHelpers.searchExpressions(P, de, Be),
                  Be.k && nt.addDynamicProperty(Be),
                  Be
                );
              };
              function l(P) {
                return (
                  this._cachingAtTime ||
                    (this._cachingAtTime = {
                      shapeValue: shapePool.clone(this.pv),
                      lastIndex: 0,
                      lastTime: initialDefaultFrame,
                    }),
                  (P *= this.elem.globalData.frameRate),
                  (P -= this.offsetTime),
                  P !== this._cachingAtTime.lastTime &&
                    ((this._cachingAtTime.lastIndex =
                      this._cachingAtTime.lastTime < P
                        ? this._caching.lastIndex
                        : 0),
                    (this._cachingAtTime.lastTime = P),
                    this.interpolateShape(
                      P,
                      this._cachingAtTime.shapeValue,
                      this._cachingAtTime
                    )),
                  this._cachingAtTime.shapeValue
                );
              }
              var c = ShapePropertyFactory.getConstructorFunction(),
                u = ShapePropertyFactory.getKeyframedConstructorFunction();
              function p() {}
              (p.prototype = {
                vertices: function (de, me) {
                  this.k && this.getValue();
                  var Ye = this.v;
                  me !== void 0 && (Ye = this.getValueAtTime(me, 0));
                  var nt,
                    Be = Ye._length,
                    ot = Ye[de],
                    st = Ye.v,
                    vt = createSizedArray(Be);
                  for (nt = 0; nt < Be; nt += 1)
                    de === "i" || de === "o"
                      ? (vt[nt] = [
                          ot[nt][0] - st[nt][0],
                          ot[nt][1] - st[nt][1],
                        ])
                      : (vt[nt] = [ot[nt][0], ot[nt][1]]);
                  return vt;
                },
                points: function (de) {
                  return this.vertices("v", de);
                },
                inTangents: function (de) {
                  return this.vertices("i", de);
                },
                outTangents: function (de) {
                  return this.vertices("o", de);
                },
                isClosed: function () {
                  return this.v.c;
                },
                pointOnPath: function (de, me) {
                  var Ye = this.v;
                  me !== void 0 && (Ye = this.getValueAtTime(me, 0)),
                    this._segmentsLength ||
                      (this._segmentsLength = bez.getSegmentsLength(Ye));
                  for (
                    var nt = this._segmentsLength,
                      Be = nt.lengths,
                      ot = nt.totalLength * de,
                      st = 0,
                      vt = Be.length,
                      xt = 0,
                      St;
                    st < vt;

                  ) {
                    if (xt + Be[st].addedLength > ot) {
                      var wt = st,
                        bt = Ye.c && st === vt - 1 ? 0 : st + 1,
                        Tt = (ot - xt) / Be[st].addedLength;
                      St = bez.getPointInSegment(
                        Ye.v[wt],
                        Ye.v[bt],
                        Ye.o[wt],
                        Ye.i[bt],
                        Tt,
                        Be[st]
                      );
                      break;
                    } else xt += Be[st].addedLength;
                    st += 1;
                  }
                  return (
                    St ||
                      (St = Ye.c
                        ? [Ye.v[0][0], Ye.v[0][1]]
                        : [Ye.v[Ye._length - 1][0], Ye.v[Ye._length - 1][1]]),
                    St
                  );
                },
                vectorOnPath: function (de, me, Ye) {
                  de == 1 ? (de = this.v.c) : de == 0 && (de = 0.999);
                  var nt = this.pointOnPath(de, me),
                    Be = this.pointOnPath(de + 0.001, me),
                    ot = Be[0] - nt[0],
                    st = Be[1] - nt[1],
                    vt = Math.sqrt(Math.pow(ot, 2) + Math.pow(st, 2));
                  if (vt === 0) return [0, 0];
                  var xt =
                    Ye === "tangent" ? [ot / vt, st / vt] : [-st / vt, ot / vt];
                  return xt;
                },
                tangentOnPath: function (de, me) {
                  return this.vectorOnPath(de, me, "tangent");
                },
                normalOnPath: function (de, me) {
                  return this.vectorOnPath(de, me, "normal");
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime,
              }),
                extendPrototype([p], c),
                extendPrototype([p], u),
                (u.prototype.getValueAtTime = l),
                (u.prototype.initiateExpression =
                  ExpressionManager.initiateExpression);
              var N = ShapePropertyFactory.getShapeProp;
              ShapePropertyFactory.getShapeProp = function (P, de, me, Ye, nt) {
                var Be = N(P, de, me, Ye, nt);
                return (
                  (Be.propertyIndex = de.ix),
                  (Be.lock = !1),
                  me === 3
                    ? expressionHelpers.searchExpressions(P, de.pt, Be)
                    : me === 4 &&
                      expressionHelpers.searchExpressions(P, de.ks, Be),
                  Be.k && P.addDynamicProperty(Be),
                  Be
                );
              };
            }
            function initialize$1() {
              addPropertyDecorator();
            }
            function addDecorator() {
              function n() {
                return this.data.d.x
                  ? ((this.calculateExpression =
                      ExpressionManager.initiateExpression.bind(this)(
                        this.elem,
                        this.data.d,
                        this
                      )),
                    this.addEffect(this.getExpressionValue.bind(this)),
                    !0)
                  : null;
              }
              (TextProperty.prototype.getExpressionValue = function (e, t) {
                var r = this.calculateExpression(t);
                if (e.t !== r) {
                  var s = {};
                  return (
                    this.copyData(s, e),
                    (s.t = r.toString()),
                    (s.__complete = !1),
                    s
                  );
                }
                return e;
              }),
                (TextProperty.prototype.searchProperty = function () {
                  var e = this.searchKeyframes(),
                    t = this.searchExpressions();
                  return (this.kf = e || t), this.kf;
                }),
                (TextProperty.prototype.searchExpressions = n);
            }
            function initialize() {
              addDecorator();
            }
            function SVGComposableEffect() {}
            SVGComposableEffect.prototype = {
              createMergeNode: function n(e, t) {
                var r = createNS("feMerge");
                r.setAttribute("result", e);
                var s, o;
                for (o = 0; o < t.length; o += 1)
                  (s = createNS("feMergeNode")),
                    s.setAttribute("in", t[o]),
                    r.appendChild(s),
                    r.appendChild(s);
                return r;
              },
            };
            var linearFilterValue =
              "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
            function SVGTintFilter(n, e, t, r, s) {
              this.filterManager = e;
              var o = createNS("feColorMatrix");
              o.setAttribute("type", "matrix"),
                o.setAttribute("color-interpolation-filters", "linearRGB"),
                o.setAttribute("values", linearFilterValue + " 1 0"),
                (this.linearFilter = o),
                o.setAttribute("result", r + "_tint_1"),
                n.appendChild(o),
                (o = createNS("feColorMatrix")),
                o.setAttribute("type", "matrix"),
                o.setAttribute("color-interpolation-filters", "sRGB"),
                o.setAttribute(
                  "values",
                  "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"
                ),
                o.setAttribute("result", r + "_tint_2"),
                n.appendChild(o),
                (this.matrixFilter = o);
              var a = this.createMergeNode(r, [
                s,
                r + "_tint_1",
                r + "_tint_2",
              ]);
              n.appendChild(a);
            }
            extendPrototype([SVGComposableEffect], SVGTintFilter),
              (SVGTintFilter.prototype.renderFrame = function (n) {
                if (n || this.filterManager._mdf) {
                  var e = this.filterManager.effectElements[0].p.v,
                    t = this.filterManager.effectElements[1].p.v,
                    r = this.filterManager.effectElements[2].p.v / 100;
                  this.linearFilter.setAttribute(
                    "values",
                    linearFilterValue + " " + r + " 0"
                  ),
                    this.matrixFilter.setAttribute(
                      "values",
                      t[0] -
                        e[0] +
                        " 0 0 0 " +
                        e[0] +
                        " " +
                        (t[1] - e[1]) +
                        " 0 0 0 " +
                        e[1] +
                        " " +
                        (t[2] - e[2]) +
                        " 0 0 0 " +
                        e[2] +
                        " 0 0 0 1 0"
                    );
                }
              });
            function SVGFillFilter(n, e, t, r) {
              this.filterManager = e;
              var s = createNS("feColorMatrix");
              s.setAttribute("type", "matrix"),
                s.setAttribute("color-interpolation-filters", "sRGB"),
                s.setAttribute(
                  "values",
                  "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"
                ),
                s.setAttribute("result", r),
                n.appendChild(s),
                (this.matrixFilter = s);
            }
            SVGFillFilter.prototype.renderFrame = function (n) {
              if (n || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[2].p.v,
                  t = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute(
                  "values",
                  "0 0 0 0 " +
                    e[0] +
                    " 0 0 0 0 " +
                    e[1] +
                    " 0 0 0 0 " +
                    e[2] +
                    " 0 0 0 " +
                    t +
                    " 0"
                );
              }
            };
            function SVGStrokeEffect(n, e, t) {
              (this.initialized = !1),
                (this.filterManager = e),
                (this.elem = t),
                (this.paths = []);
            }
            (SVGStrokeEffect.prototype.initialize = function () {
              var n =
                  this.elem.layerElement.children ||
                  this.elem.layerElement.childNodes,
                e,
                t,
                r,
                s;
              for (
                this.filterManager.effectElements[1].p.v === 1
                  ? ((s = this.elem.maskManager.masksProperties.length),
                    (r = 0))
                  : ((r = this.filterManager.effectElements[0].p.v - 1),
                    (s = r + 1)),
                  t = createNS("g"),
                  t.setAttribute("fill", "none"),
                  t.setAttribute("stroke-linecap", "round"),
                  t.setAttribute("stroke-dashoffset", 1),
                  r;
                r < s;
                r += 1
              )
                (e = createNS("path")),
                  t.appendChild(e),
                  this.paths.push({ p: e, m: r });
              if (this.filterManager.effectElements[10].p.v === 3) {
                var o = createNS("mask"),
                  a = createElementID();
                o.setAttribute("id", a),
                  o.setAttribute("mask-type", "alpha"),
                  o.appendChild(t),
                  this.elem.globalData.defs.appendChild(o);
                var l = createNS("g");
                for (
                  l.setAttribute(
                    "mask",
                    "url(" + getLocationHref() + "#" + a + ")"
                  );
                  n[0];

                )
                  l.appendChild(n[0]);
                this.elem.layerElement.appendChild(l),
                  (this.masker = o),
                  t.setAttribute("stroke", "#fff");
              } else if (
                this.filterManager.effectElements[10].p.v === 1 ||
                this.filterManager.effectElements[10].p.v === 2
              ) {
                if (this.filterManager.effectElements[10].p.v === 2)
                  for (
                    n =
                      this.elem.layerElement.children ||
                      this.elem.layerElement.childNodes;
                    n.length;

                  )
                    this.elem.layerElement.removeChild(n[0]);
                this.elem.layerElement.appendChild(t),
                  this.elem.layerElement.removeAttribute("mask"),
                  t.setAttribute("stroke", "#fff");
              }
              (this.initialized = !0), (this.pathMasker = t);
            }),
              (SVGStrokeEffect.prototype.renderFrame = function (n) {
                this.initialized || this.initialize();
                var e,
                  t = this.paths.length,
                  r,
                  s;
                for (e = 0; e < t; e += 1)
                  if (
                    this.paths[e].m !== -1 &&
                    ((r = this.elem.maskManager.viewData[this.paths[e].m]),
                    (s = this.paths[e].p),
                    (n || this.filterManager._mdf || r.prop._mdf) &&
                      s.setAttribute("d", r.lastPath),
                    n ||
                      this.filterManager.effectElements[9].p._mdf ||
                      this.filterManager.effectElements[4].p._mdf ||
                      this.filterManager.effectElements[7].p._mdf ||
                      this.filterManager.effectElements[8].p._mdf ||
                      r.prop._mdf)
                  ) {
                    var o;
                    if (
                      this.filterManager.effectElements[7].p.v !== 0 ||
                      this.filterManager.effectElements[8].p.v !== 100
                    ) {
                      var a =
                          Math.min(
                            this.filterManager.effectElements[7].p.v,
                            this.filterManager.effectElements[8].p.v
                          ) * 0.01,
                        l =
                          Math.max(
                            this.filterManager.effectElements[7].p.v,
                            this.filterManager.effectElements[8].p.v
                          ) * 0.01,
                        c = s.getTotalLength();
                      o = "0 0 0 " + c * a + " ";
                      var u = c * (l - a),
                        p =
                          1 +
                          this.filterManager.effectElements[4].p.v *
                            2 *
                            this.filterManager.effectElements[9].p.v *
                            0.01,
                        N = Math.floor(u / p),
                        P;
                      for (P = 0; P < N; P += 1)
                        o +=
                          "1 " +
                          this.filterManager.effectElements[4].p.v *
                            2 *
                            this.filterManager.effectElements[9].p.v *
                            0.01 +
                          " ";
                      o += "0 " + c * 10 + " 0 0";
                    } else
                      o =
                        "1 " +
                        this.filterManager.effectElements[4].p.v *
                          2 *
                          this.filterManager.effectElements[9].p.v *
                          0.01;
                    s.setAttribute("stroke-dasharray", o);
                  }
                if (
                  ((n || this.filterManager.effectElements[4].p._mdf) &&
                    this.pathMasker.setAttribute(
                      "stroke-width",
                      this.filterManager.effectElements[4].p.v * 2
                    ),
                  (n || this.filterManager.effectElements[6].p._mdf) &&
                    this.pathMasker.setAttribute(
                      "opacity",
                      this.filterManager.effectElements[6].p.v
                    ),
                  (this.filterManager.effectElements[10].p.v === 1 ||
                    this.filterManager.effectElements[10].p.v === 2) &&
                    (n || this.filterManager.effectElements[3].p._mdf))
                ) {
                  var de = this.filterManager.effectElements[3].p.v;
                  this.pathMasker.setAttribute(
                    "stroke",
                    "rgb(" +
                      bmFloor(de[0] * 255) +
                      "," +
                      bmFloor(de[1] * 255) +
                      "," +
                      bmFloor(de[2] * 255) +
                      ")"
                  );
                }
              });
            function SVGTritoneFilter(n, e, t, r) {
              this.filterManager = e;
              var s = createNS("feColorMatrix");
              s.setAttribute("type", "matrix"),
                s.setAttribute("color-interpolation-filters", "linearRGB"),
                s.setAttribute(
                  "values",
                  "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
                ),
                n.appendChild(s);
              var o = createNS("feComponentTransfer");
              o.setAttribute("color-interpolation-filters", "sRGB"),
                o.setAttribute("result", r),
                (this.matrixFilter = o);
              var a = createNS("feFuncR");
              a.setAttribute("type", "table"),
                o.appendChild(a),
                (this.feFuncR = a);
              var l = createNS("feFuncG");
              l.setAttribute("type", "table"),
                o.appendChild(l),
                (this.feFuncG = l);
              var c = createNS("feFuncB");
              c.setAttribute("type", "table"),
                o.appendChild(c),
                (this.feFuncB = c),
                n.appendChild(o);
            }
            SVGTritoneFilter.prototype.renderFrame = function (n) {
              if (n || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[0].p.v,
                  t = this.filterManager.effectElements[1].p.v,
                  r = this.filterManager.effectElements[2].p.v,
                  s = r[0] + " " + t[0] + " " + e[0],
                  o = r[1] + " " + t[1] + " " + e[1],
                  a = r[2] + " " + t[2] + " " + e[2];
                this.feFuncR.setAttribute("tableValues", s),
                  this.feFuncG.setAttribute("tableValues", o),
                  this.feFuncB.setAttribute("tableValues", a);
              }
            };
            function SVGProLevelsFilter(n, e, t, r) {
              this.filterManager = e;
              var s = this.filterManager.effectElements,
                o = createNS("feComponentTransfer");
              (s[10].p.k ||
                s[10].p.v !== 0 ||
                s[11].p.k ||
                s[11].p.v !== 1 ||
                s[12].p.k ||
                s[12].p.v !== 1 ||
                s[13].p.k ||
                s[13].p.v !== 0 ||
                s[14].p.k ||
                s[14].p.v !== 1) &&
                (this.feFuncR = this.createFeFunc("feFuncR", o)),
                (s[17].p.k ||
                  s[17].p.v !== 0 ||
                  s[18].p.k ||
                  s[18].p.v !== 1 ||
                  s[19].p.k ||
                  s[19].p.v !== 1 ||
                  s[20].p.k ||
                  s[20].p.v !== 0 ||
                  s[21].p.k ||
                  s[21].p.v !== 1) &&
                  (this.feFuncG = this.createFeFunc("feFuncG", o)),
                (s[24].p.k ||
                  s[24].p.v !== 0 ||
                  s[25].p.k ||
                  s[25].p.v !== 1 ||
                  s[26].p.k ||
                  s[26].p.v !== 1 ||
                  s[27].p.k ||
                  s[27].p.v !== 0 ||
                  s[28].p.k ||
                  s[28].p.v !== 1) &&
                  (this.feFuncB = this.createFeFunc("feFuncB", o)),
                (s[31].p.k ||
                  s[31].p.v !== 0 ||
                  s[32].p.k ||
                  s[32].p.v !== 1 ||
                  s[33].p.k ||
                  s[33].p.v !== 1 ||
                  s[34].p.k ||
                  s[34].p.v !== 0 ||
                  s[35].p.k ||
                  s[35].p.v !== 1) &&
                  (this.feFuncA = this.createFeFunc("feFuncA", o)),
                (this.feFuncR ||
                  this.feFuncG ||
                  this.feFuncB ||
                  this.feFuncA) &&
                  (o.setAttribute("color-interpolation-filters", "sRGB"),
                  n.appendChild(o)),
                (s[3].p.k ||
                  s[3].p.v !== 0 ||
                  s[4].p.k ||
                  s[4].p.v !== 1 ||
                  s[5].p.k ||
                  s[5].p.v !== 1 ||
                  s[6].p.k ||
                  s[6].p.v !== 0 ||
                  s[7].p.k ||
                  s[7].p.v !== 1) &&
                  ((o = createNS("feComponentTransfer")),
                  o.setAttribute("color-interpolation-filters", "sRGB"),
                  o.setAttribute("result", r),
                  n.appendChild(o),
                  (this.feFuncRComposed = this.createFeFunc("feFuncR", o)),
                  (this.feFuncGComposed = this.createFeFunc("feFuncG", o)),
                  (this.feFuncBComposed = this.createFeFunc("feFuncB", o)));
            }
            (SVGProLevelsFilter.prototype.createFeFunc = function (n, e) {
              var t = createNS(n);
              return t.setAttribute("type", "table"), e.appendChild(t), t;
            }),
              (SVGProLevelsFilter.prototype.getTableValue = function (
                n,
                e,
                t,
                r,
                s
              ) {
                for (
                  var o = 0,
                    a = 256,
                    l,
                    c = Math.min(n, e),
                    u = Math.max(n, e),
                    p = Array.call(null, { length: a }),
                    N,
                    P = 0,
                    de = s - r,
                    me = e - n;
                  o <= 256;

                )
                  (l = o / 256),
                    l <= c
                      ? (N = me < 0 ? s : r)
                      : l >= u
                      ? (N = me < 0 ? r : s)
                      : (N = r + de * Math.pow((l - n) / me, 1 / t)),
                    (p[P] = N),
                    (P += 1),
                    (o += 256 / (a - 1));
                return p.join(" ");
              }),
              (SVGProLevelsFilter.prototype.renderFrame = function (n) {
                if (n || this.filterManager._mdf) {
                  var e,
                    t = this.filterManager.effectElements;
                  this.feFuncRComposed &&
                    (n ||
                      t[3].p._mdf ||
                      t[4].p._mdf ||
                      t[5].p._mdf ||
                      t[6].p._mdf ||
                      t[7].p._mdf) &&
                    ((e = this.getTableValue(
                      t[3].p.v,
                      t[4].p.v,
                      t[5].p.v,
                      t[6].p.v,
                      t[7].p.v
                    )),
                    this.feFuncRComposed.setAttribute("tableValues", e),
                    this.feFuncGComposed.setAttribute("tableValues", e),
                    this.feFuncBComposed.setAttribute("tableValues", e)),
                    this.feFuncR &&
                      (n ||
                        t[10].p._mdf ||
                        t[11].p._mdf ||
                        t[12].p._mdf ||
                        t[13].p._mdf ||
                        t[14].p._mdf) &&
                      ((e = this.getTableValue(
                        t[10].p.v,
                        t[11].p.v,
                        t[12].p.v,
                        t[13].p.v,
                        t[14].p.v
                      )),
                      this.feFuncR.setAttribute("tableValues", e)),
                    this.feFuncG &&
                      (n ||
                        t[17].p._mdf ||
                        t[18].p._mdf ||
                        t[19].p._mdf ||
                        t[20].p._mdf ||
                        t[21].p._mdf) &&
                      ((e = this.getTableValue(
                        t[17].p.v,
                        t[18].p.v,
                        t[19].p.v,
                        t[20].p.v,
                        t[21].p.v
                      )),
                      this.feFuncG.setAttribute("tableValues", e)),
                    this.feFuncB &&
                      (n ||
                        t[24].p._mdf ||
                        t[25].p._mdf ||
                        t[26].p._mdf ||
                        t[27].p._mdf ||
                        t[28].p._mdf) &&
                      ((e = this.getTableValue(
                        t[24].p.v,
                        t[25].p.v,
                        t[26].p.v,
                        t[27].p.v,
                        t[28].p.v
                      )),
                      this.feFuncB.setAttribute("tableValues", e)),
                    this.feFuncA &&
                      (n ||
                        t[31].p._mdf ||
                        t[32].p._mdf ||
                        t[33].p._mdf ||
                        t[34].p._mdf ||
                        t[35].p._mdf) &&
                      ((e = this.getTableValue(
                        t[31].p.v,
                        t[32].p.v,
                        t[33].p.v,
                        t[34].p.v,
                        t[35].p.v
                      )),
                      this.feFuncA.setAttribute("tableValues", e));
                }
              });
            function SVGDropShadowEffect(n, e, t, r, s) {
              var o = e.container.globalData.renderConfig.filterSize,
                a = e.data.fs || o;
              n.setAttribute("x", a.x || o.x),
                n.setAttribute("y", a.y || o.y),
                n.setAttribute("width", a.width || o.width),
                n.setAttribute("height", a.height || o.height),
                (this.filterManager = e);
              var l = createNS("feGaussianBlur");
              l.setAttribute("in", "SourceAlpha"),
                l.setAttribute("result", r + "_drop_shadow_1"),
                l.setAttribute("stdDeviation", "0"),
                (this.feGaussianBlur = l),
                n.appendChild(l);
              var c = createNS("feOffset");
              c.setAttribute("dx", "25"),
                c.setAttribute("dy", "0"),
                c.setAttribute("in", r + "_drop_shadow_1"),
                c.setAttribute("result", r + "_drop_shadow_2"),
                (this.feOffset = c),
                n.appendChild(c);
              var u = createNS("feFlood");
              u.setAttribute("flood-color", "#00ff00"),
                u.setAttribute("flood-opacity", "1"),
                u.setAttribute("result", r + "_drop_shadow_3"),
                (this.feFlood = u),
                n.appendChild(u);
              var p = createNS("feComposite");
              p.setAttribute("in", r + "_drop_shadow_3"),
                p.setAttribute("in2", r + "_drop_shadow_2"),
                p.setAttribute("operator", "in"),
                p.setAttribute("result", r + "_drop_shadow_4"),
                n.appendChild(p);
              var N = this.createMergeNode(r, [r + "_drop_shadow_4", s]);
              n.appendChild(N);
            }
            extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
              (SVGDropShadowEffect.prototype.renderFrame = function (n) {
                if (n || this.filterManager._mdf) {
                  if (
                    ((n || this.filterManager.effectElements[4].p._mdf) &&
                      this.feGaussianBlur.setAttribute(
                        "stdDeviation",
                        this.filterManager.effectElements[4].p.v / 4
                      ),
                    n || this.filterManager.effectElements[0].p._mdf)
                  ) {
                    var e = this.filterManager.effectElements[0].p.v;
                    this.feFlood.setAttribute(
                      "flood-color",
                      rgbToHex(
                        Math.round(e[0] * 255),
                        Math.round(e[1] * 255),
                        Math.round(e[2] * 255)
                      )
                    );
                  }
                  if (
                    ((n || this.filterManager.effectElements[1].p._mdf) &&
                      this.feFlood.setAttribute(
                        "flood-opacity",
                        this.filterManager.effectElements[1].p.v / 255
                      ),
                    n ||
                      this.filterManager.effectElements[2].p._mdf ||
                      this.filterManager.effectElements[3].p._mdf)
                  ) {
                    var t = this.filterManager.effectElements[3].p.v,
                      r =
                        (this.filterManager.effectElements[2].p.v - 90) *
                        degToRads,
                      s = t * Math.cos(r),
                      o = t * Math.sin(r);
                    this.feOffset.setAttribute("dx", s),
                      this.feOffset.setAttribute("dy", o);
                  }
                }
              });
            var _svgMatteSymbols = [];
            function SVGMatte3Effect(n, e, t) {
              (this.initialized = !1),
                (this.filterManager = e),
                (this.filterElem = n),
                (this.elem = t),
                (t.matteElement = createNS("g")),
                t.matteElement.appendChild(t.layerElement),
                t.matteElement.appendChild(t.transformedElement),
                (t.baseElement = t.matteElement);
            }
            (SVGMatte3Effect.prototype.findSymbol = function (n) {
              for (var e = 0, t = _svgMatteSymbols.length; e < t; ) {
                if (_svgMatteSymbols[e] === n) return _svgMatteSymbols[e];
                e += 1;
              }
              return null;
            }),
              (SVGMatte3Effect.prototype.replaceInParent = function (n, e) {
                var t = n.layerElement.parentNode;
                if (t) {
                  for (
                    var r = t.children, s = 0, o = r.length;
                    s < o && r[s] !== n.layerElement;

                  )
                    s += 1;
                  var a;
                  s <= o - 2 && (a = r[s + 1]);
                  var l = createNS("use");
                  l.setAttribute("href", "#" + e),
                    a ? t.insertBefore(l, a) : t.appendChild(l);
                }
              }),
              (SVGMatte3Effect.prototype.setElementAsMask = function (n, e) {
                if (!this.findSymbol(e)) {
                  var t = createElementID(),
                    r = createNS("mask");
                  r.setAttribute("id", e.layerId),
                    r.setAttribute("mask-type", "alpha"),
                    _svgMatteSymbols.push(e);
                  var s = n.globalData.defs;
                  s.appendChild(r);
                  var o = createNS("symbol");
                  o.setAttribute("id", t),
                    this.replaceInParent(e, t),
                    o.appendChild(e.layerElement),
                    s.appendChild(o);
                  var a = createNS("use");
                  a.setAttribute("href", "#" + t),
                    r.appendChild(a),
                    (e.data.hd = !1),
                    e.show();
                }
                n.setMatte(e.layerId);
              }),
              (SVGMatte3Effect.prototype.initialize = function () {
                for (
                  var n = this.filterManager.effectElements[0].p.v,
                    e = this.elem.comp.elements,
                    t = 0,
                    r = e.length;
                  t < r;

                )
                  e[t] &&
                    e[t].data.ind === n &&
                    this.setElementAsMask(this.elem, e[t]),
                    (t += 1);
                this.initialized = !0;
              }),
              (SVGMatte3Effect.prototype.renderFrame = function () {
                this.initialized || this.initialize();
              });
            function SVGGaussianBlurEffect(n, e, t, r) {
              n.setAttribute("x", "-100%"),
                n.setAttribute("y", "-100%"),
                n.setAttribute("width", "300%"),
                n.setAttribute("height", "300%"),
                (this.filterManager = e);
              var s = createNS("feGaussianBlur");
              s.setAttribute("result", r),
                n.appendChild(s),
                (this.feGaussianBlur = s);
            }
            SVGGaussianBlurEffect.prototype.renderFrame = function (n) {
              if (n || this.filterManager._mdf) {
                var e = 0.3,
                  t = this.filterManager.effectElements[0].p.v * e,
                  r = this.filterManager.effectElements[1].p.v,
                  s = r == 3 ? 0 : t,
                  o = r == 2 ? 0 : t;
                this.feGaussianBlur.setAttribute("stdDeviation", s + " " + o);
                var a =
                  this.filterManager.effectElements[2].p.v == 1
                    ? "wrap"
                    : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", a);
              }
            };
            function TransformEffect() {}
            (TransformEffect.prototype.init = function (n) {
              (this.effectsManager = n),
                (this.type = effectTypes.TRANSFORM_EFFECT),
                (this.matrix = new Matrix()),
                (this.opacity = -1),
                (this._mdf = !1),
                (this._opMdf = !1);
            }),
              (TransformEffect.prototype.renderFrame = function (n) {
                if (
                  ((this._opMdf = !1),
                  (this._mdf = !1),
                  n || this.effectsManager._mdf)
                ) {
                  var e = this.effectsManager.effectElements,
                    t = e[0].p.v,
                    r = e[1].p.v,
                    s = e[2].p.v === 1,
                    o = e[3].p.v,
                    a = s ? o : e[4].p.v,
                    l = e[5].p.v,
                    c = e[6].p.v,
                    u = e[7].p.v;
                  this.matrix.reset(),
                    this.matrix.translate(-t[0], -t[1], t[2]),
                    this.matrix.scale(a * 0.01, o * 0.01, 1),
                    this.matrix.rotate(-u * degToRads),
                    this.matrix.skewFromAxis(
                      -l * degToRads,
                      (c + 90) * degToRads
                    ),
                    this.matrix.translate(r[0], r[1], 0),
                    (this._mdf = !0),
                    this.opacity !== e[8].p.v &&
                      ((this.opacity = e[8].p.v), (this._opMdf = !0));
                }
              });
            function SVGTransformEffect(n, e) {
              this.init(e);
            }
            extendPrototype([TransformEffect], SVGTransformEffect);
            function CVTransformEffect(n) {
              this.init(n);
            }
            return (
              extendPrototype([TransformEffect], CVTransformEffect),
              registerRenderer("canvas", CanvasRenderer),
              registerRenderer("html", HybridRenderer),
              registerRenderer("svg", SVGRenderer),
              ShapeModifiers.registerModifier("tm", TrimModifier),
              ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
              ShapeModifiers.registerModifier("rp", RepeaterModifier),
              ShapeModifiers.registerModifier("rd", RoundCornersModifier),
              ShapeModifiers.registerModifier("zz", ZigZagModifier),
              ShapeModifiers.registerModifier("op", OffsetPathModifier),
              setExpressionsPlugin(Expressions),
              setExpressionInterfaces(getInterface),
              initialize$1(),
              initialize(),
              registerEffect$1(20, SVGTintFilter, !0),
              registerEffect$1(21, SVGFillFilter, !0),
              registerEffect$1(22, SVGStrokeEffect, !1),
              registerEffect$1(23, SVGTritoneFilter, !0),
              registerEffect$1(24, SVGProLevelsFilter, !0),
              registerEffect$1(25, SVGDropShadowEffect, !0),
              registerEffect$1(28, SVGMatte3Effect, !1),
              registerEffect$1(29, SVGGaussianBlurEffect, !0),
              registerEffect$1(35, SVGTransformEffect, !1),
              registerEffect(35, CVTransformEffect),
              lottie
            );
          });
      })(lottie$2, lottie$2.exports)),
    lottie$2.exports
  );
}
var lottieExports = requireLottie();
const lottie = getDefaultExportFromCjs(lottieExports);
function _arrayLikeToArray(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = Array(e); t < e; t++) r[t] = n[t];
  return r;
}
function _arrayWithHoles(n) {
  if (Array.isArray(n)) return n;
}
function _defineProperty(n, e, t) {
  return (
    (e = _toPropertyKey(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function _iterableToArrayLimit(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol < "u" && n[Symbol.iterator]) || n["@@iterator"];
  if (t != null) {
    var r,
      s,
      o,
      a,
      l = [],
      c = !0,
      u = !1;
    try {
      if (((o = (t = t.call(n)).next), e !== 0))
        for (
          ;
          !(c = (r = o.call(t)).done) && (l.push(r.value), l.length !== e);
          c = !0
        );
    } catch (p) {
      (u = !0), (s = p);
    } finally {
      try {
        if (!c && t.return != null && ((a = t.return()), Object(a) !== a))
          return;
      } finally {
        if (u) throw s;
      }
    }
    return l;
  }
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ownKeys(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e &&
      (r = r.filter(function (s) {
        return Object.getOwnPropertyDescriptor(n, s).enumerable;
      })),
      t.push.apply(t, r);
  }
  return t;
}
function _objectSpread2(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? ownKeys(Object(t), !0).forEach(function (r) {
          _defineProperty(n, r, t[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : ownKeys(Object(t)).forEach(function (r) {
          Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
        });
  }
  return n;
}
function _objectWithoutProperties(n, e) {
  if (n == null) return {};
  var t,
    r,
    s = _objectWithoutPropertiesLoose(n, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(n);
    for (r = 0; r < o.length; r++)
      (t = o[r]),
        e.includes(t) || ({}.propertyIsEnumerable.call(n, t) && (s[t] = n[t]));
  }
  return s;
}
function _objectWithoutPropertiesLoose(n, e) {
  if (n == null) return {};
  var t = {};
  for (var r in n)
    if ({}.hasOwnProperty.call(n, r)) {
      if (e.includes(r)) continue;
      t[r] = n[r];
    }
  return t;
}
function _slicedToArray(n, e) {
  return (
    _arrayWithHoles(n) ||
    _iterableToArrayLimit(n, e) ||
    _unsupportedIterableToArray(n, e) ||
    _nonIterableRest()
  );
}
function _toPrimitive(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function _toPropertyKey(n) {
  var e = _toPrimitive(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _unsupportedIterableToArray(n, e) {
  if (n) {
    if (typeof n == "string") return _arrayLikeToArray(n, e);
    var t = {}.toString.call(n).slice(8, -1);
    return (
      t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set"
        ? Array.from(n)
        : t === "Arguments" ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)
        ? _arrayLikeToArray(n, e)
        : void 0
    );
  }
}
var _excluded$1 = [
    "animationData",
    "loop",
    "autoplay",
    "initialSegment",
    "onComplete",
    "onLoopComplete",
    "onEnterFrame",
    "onSegmentStart",
    "onConfigReady",
    "onDataReady",
    "onDataFailed",
    "onLoadedImages",
    "onDOMLoaded",
    "onDestroy",
    "lottieRef",
    "renderer",
    "name",
    "assetsPath",
    "rendererSettings",
  ],
  useLottie = function n(e, t) {
    var r = e.animationData,
      s = e.loop,
      o = e.autoplay,
      a = e.initialSegment,
      l = e.onComplete,
      c = e.onLoopComplete,
      u = e.onEnterFrame,
      p = e.onSegmentStart,
      N = e.onConfigReady,
      P = e.onDataReady,
      de = e.onDataFailed,
      me = e.onLoadedImages,
      Ye = e.onDOMLoaded,
      nt = e.onDestroy;
    e.lottieRef, e.renderer, e.name, e.assetsPath, e.rendererSettings;
    var Be = _objectWithoutProperties(e, _excluded$1),
      ot = reactExports.useState(!1),
      st = _slicedToArray(ot, 2),
      vt = st[0],
      xt = st[1],
      St = reactExports.useRef(),
      wt = reactExports.useRef(null),
      bt = function () {
        var Xt;
        (Xt = St.current) === null || Xt === void 0 || Xt.play();
      },
      Tt = function () {
        var Xt;
        (Xt = St.current) === null || Xt === void 0 || Xt.stop();
      },
      Ct = function () {
        var Xt;
        (Xt = St.current) === null || Xt === void 0 || Xt.pause();
      },
      kt = function (Xt) {
        var sn;
        (sn = St.current) === null || sn === void 0 || sn.setSpeed(Xt);
      },
      Dt = function (Xt, sn) {
        var Kt;
        (Kt = St.current) === null || Kt === void 0 || Kt.goToAndPlay(Xt, sn);
      },
      Vt = function (Xt, sn) {
        var Kt;
        (Kt = St.current) === null || Kt === void 0 || Kt.goToAndStop(Xt, sn);
      },
      Ht = function (Xt) {
        var sn;
        (sn = St.current) === null || sn === void 0 || sn.setDirection(Xt);
      },
      qt = function (Xt, sn) {
        var Kt;
        (Kt = St.current) === null || Kt === void 0 || Kt.playSegments(Xt, sn);
      },
      Ft = function (Xt) {
        var sn;
        (sn = St.current) === null || sn === void 0 || sn.setSubframe(Xt);
      },
      Bt = function (Xt) {
        var sn;
        return (sn = St.current) === null || sn === void 0
          ? void 0
          : sn.getDuration(Xt);
      },
      Mt = function () {
        var Xt;
        (Xt = St.current) === null || Xt === void 0 || Xt.destroy(),
          (St.current = void 0);
      },
      Pt = function () {
        var Xt =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          sn;
        if (wt.current) {
          (sn = St.current) === null || sn === void 0 || sn.destroy();
          var Kt = _objectSpread2(
            _objectSpread2(_objectSpread2({}, e), Xt),
            {},
            { container: wt.current }
          );
          return (
            (St.current = lottie.loadAnimation(Kt)),
            xt(!!St.current),
            function () {
              var tn;
              (tn = St.current) === null || tn === void 0 || tn.destroy(),
                (St.current = void 0);
            }
          );
        }
      };
    reactExports.useEffect(
      function () {
        var Ot = Pt();
        return function () {
          return Ot == null ? void 0 : Ot();
        };
      },
      [r, s]
    ),
      reactExports.useEffect(
        function () {
          St.current && (St.current.autoplay = !!o);
        },
        [o]
      ),
      reactExports.useEffect(
        function () {
          if (St.current) {
            if (!a) {
              St.current.resetSegments(!0);
              return;
            }
            !Array.isArray(a) ||
              !a.length ||
              ((St.current.currentRawFrame < a[0] ||
                St.current.currentRawFrame > a[1]) &&
                (St.current.currentRawFrame = a[0]),
              St.current.setSegment(a[0], a[1]));
          }
        },
        [a]
      ),
      reactExports.useEffect(
        function () {
          var Ot = [
              { name: "complete", handler: l },
              { name: "loopComplete", handler: c },
              { name: "enterFrame", handler: u },
              { name: "segmentStart", handler: p },
              { name: "config_ready", handler: N },
              { name: "data_ready", handler: P },
              { name: "data_failed", handler: de },
              { name: "loaded_images", handler: me },
              { name: "DOMLoaded", handler: Ye },
              { name: "destroy", handler: nt },
            ],
            Xt = Ot.filter(function (Kt) {
              return Kt.handler != null;
            });
          if (Xt.length) {
            var sn = Xt.map(function (Kt) {
              var tn;
              return (
                (tn = St.current) === null ||
                  tn === void 0 ||
                  tn.addEventListener(Kt.name, Kt.handler),
                function () {
                  var pn;
                  (pn = St.current) === null ||
                    pn === void 0 ||
                    pn.removeEventListener(Kt.name, Kt.handler);
                }
              );
            });
            return function () {
              sn.forEach(function (Kt) {
                return Kt();
              });
            };
          }
        },
        [l, c, u, p, N, P, de, me, Ye, nt]
      );
    var It = React.createElement(
      "div",
      _objectSpread2({ style: t, ref: wt }, Be)
    );
    return {
      View: It,
      play: bt,
      stop: Tt,
      pause: Ct,
      setSpeed: kt,
      goToAndStop: Vt,
      goToAndPlay: Dt,
      setDirection: Ht,
      playSegments: qt,
      setSubframe: Ft,
      getDuration: Bt,
      destroy: Mt,
      animationContainerRef: wt,
      animationLoaded: vt,
      animationItem: St.current,
    };
  };
function getContainerVisibility(n) {
  var e = n.getBoundingClientRect(),
    t = e.top,
    r = e.height,
    s = window.innerHeight - t,
    o = window.innerHeight + r;
  return s / o;
}
function getContainerCursorPosition(n, e, t) {
  var r = n.getBoundingClientRect(),
    s = r.top,
    o = r.left,
    a = r.width,
    l = r.height,
    c = (e - o) / a,
    u = (t - s) / l;
  return { x: c, y: u };
}
var useInitInteractivity = function n(e) {
    var t = e.wrapperRef,
      r = e.animationItem,
      s = e.mode,
      o = e.actions;
    reactExports.useEffect(
      function () {
        var a = t.current;
        if (!(!a || !r || !o.length)) {
          r.stop();
          var l = function () {
              var p = null,
                N = function () {
                  var de = getContainerVisibility(a),
                    me = o.find(function (nt) {
                      var Be = nt.visibility;
                      return Be && de >= Be[0] && de <= Be[1];
                    });
                  if (me) {
                    if (
                      me.type === "seek" &&
                      me.visibility &&
                      me.frames.length === 2
                    ) {
                      var Ye =
                        me.frames[0] +
                        Math.ceil(
                          ((de - me.visibility[0]) /
                            (me.visibility[1] - me.visibility[0])) *
                            me.frames[1]
                        ); //! goToAndStop must be relative to the start of the current segment
                      r.goToAndStop(Ye - r.firstFrame - 1, !0);
                    }
                    me.type === "loop" &&
                      (p === null || p !== me.frames || r.isPaused) &&
                      (r.playSegments(me.frames, !0), (p = me.frames)),
                      me.type === "play" &&
                        r.isPaused &&
                        (r.resetSegments(!0), r.play()),
                      me.type === "stop" &&
                        r.goToAndStop(me.frames[0] - r.firstFrame - 1, !0);
                  }
                };
              return (
                document.addEventListener("scroll", N),
                function () {
                  document.removeEventListener("scroll", N);
                }
              );
            },
            c = function () {
              var p = function (me, Ye) {
                  var nt = me,
                    Be = Ye;
                  if (nt !== -1 && Be !== -1) {
                    var ot = getContainerCursorPosition(a, nt, Be);
                    (nt = ot.x), (Be = ot.y);
                  }
                  var st = o.find(function (St) {
                    var wt = St.position;
                    return wt && Array.isArray(wt.x) && Array.isArray(wt.y)
                      ? nt >= wt.x[0] &&
                          nt <= wt.x[1] &&
                          Be >= wt.y[0] &&
                          Be <= wt.y[1]
                      : wt && !Number.isNaN(wt.x) && !Number.isNaN(wt.y)
                      ? nt === wt.x && Be === wt.y
                      : !1;
                  });
                  if (st) {
                    if (
                      st.type === "seek" &&
                      st.position &&
                      Array.isArray(st.position.x) &&
                      Array.isArray(st.position.y) &&
                      st.frames.length === 2
                    ) {
                      var vt =
                          (nt - st.position.x[0]) /
                          (st.position.x[1] - st.position.x[0]),
                        xt =
                          (Be - st.position.y[0]) /
                          (st.position.y[1] - st.position.y[0]);
                      r.playSegments(st.frames, !0),
                        r.goToAndStop(
                          Math.ceil(
                            ((vt + xt) / 2) * (st.frames[1] - st.frames[0])
                          ),
                          !0
                        );
                    }
                    st.type === "loop" && r.playSegments(st.frames, !0),
                      st.type === "play" &&
                        (r.isPaused && r.resetSegments(!1),
                        r.playSegments(st.frames)),
                      st.type === "stop" && r.goToAndStop(st.frames[0], !0);
                  }
                },
                N = function (me) {
                  p(me.clientX, me.clientY);
                },
                P = function () {
                  p(-1, -1);
                };
              return (
                a.addEventListener("mousemove", N),
                a.addEventListener("mouseout", P),
                function () {
                  a.removeEventListener("mousemove", N),
                    a.removeEventListener("mouseout", P);
                }
              );
            };
          switch (s) {
            case "scroll":
              return l();
            case "cursor":
              return c();
          }
        }
      },
      [s, r]
    );
  },
  useLottieInteractivity = function n(e) {
    var t = e.actions,
      r = e.mode,
      s = e.lottieObj,
      o = s.animationItem,
      a = s.View,
      l = s.animationContainerRef;
    return (
      useInitInteractivity({
        actions: t,
        animationItem: o,
        mode: r,
        wrapperRef: l,
      }),
      a
    );
  },
  _excluded = ["style", "interactivity"],
  Lottie = function n(e) {
    var t,
      r,
      s,
      o = e.style,
      a = e.interactivity,
      l = _objectWithoutProperties(e, _excluded),
      c = useLottie(l, o),
      u = c.View,
      p = c.play,
      N = c.stop,
      P = c.pause,
      de = c.setSpeed,
      me = c.goToAndStop,
      Ye = c.goToAndPlay,
      nt = c.setDirection,
      Be = c.playSegments,
      ot = c.setSubframe,
      st = c.getDuration,
      vt = c.destroy,
      xt = c.animationContainerRef,
      St = c.animationLoaded,
      wt = c.animationItem;
    return (
      reactExports.useEffect(
        function () {
          e.lottieRef &&
            (e.lottieRef.current = {
              play: p,
              stop: N,
              pause: P,
              setSpeed: de,
              goToAndPlay: Ye,
              goToAndStop: me,
              setDirection: nt,
              playSegments: Be,
              setSubframe: ot,
              getDuration: st,
              destroy: vt,
              animationContainerRef: xt,
              animationLoaded: St,
              animationItem: wt,
            });
        },
        [(t = e.lottieRef) === null || t === void 0 ? void 0 : t.current]
      ),
      useLottieInteractivity({
        lottieObj: {
          View: u,
          play: p,
          stop: N,
          pause: P,
          setSpeed: de,
          goToAndStop: me,
          goToAndPlay: Ye,
          setDirection: nt,
          playSegments: Be,
          setSubframe: ot,
          getDuration: st,
          destroy: vt,
          animationContainerRef: xt,
          animationLoaded: St,
          animationItem: wt,
        },
        actions:
          (r = a == null ? void 0 : a.actions) !== null && r !== void 0
            ? r
            : [],
        mode:
          (s = a == null ? void 0 : a.mode) !== null && s !== void 0
            ? s
            : "scroll",
      })
    );
  };
const v = "5.7.5",
  fr = 100,
  ip = 0,
  op = 269,
  w = 1510,
  h = 228,
  nm = "sint_logo_appearance_1",
  ddd = 0,
  assets = [
    {
      id: "0",
      layers: [
        {
          ddd: 0,
          ind: 1,
          ty: 3,
          nm: "",
          sr: 1,
          ks: {
            p: { a: 0, k: [0, 0], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "1",
          w: 409,
          h: 231,
          ind: 2,
          ty: 0,
          nm: "A (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [1102, -1], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          parent: 1,
        },
        {
          ddd: 0,
          ind: 3,
          ty: 3,
          nm: "",
          sr: 1,
          ks: {
            p: { a: 0, k: [308, 0], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "2",
          w: 664,
          h: 232,
          ind: 4,
          ty: 0,
          nm: "C (Masked) 1",
          sr: 1,
          ks: {
            p: { a: 0, k: [423, -2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          parent: 3,
        },
        {
          ddd: 0,
          ind: 5,
          ty: 3,
          nm: "",
          sr: 1,
          ks: {
            p: { a: 0, k: [0, 0], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "3",
          w: 664,
          h: 232,
          ind: 6,
          ty: 0,
          nm: "C (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [423, -2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          parent: 5,
        },
        {
          ddd: 0,
          ind: 7,
          ty: 3,
          nm: "",
          sr: 1,
          ks: {
            p: { a: 0, k: [0, 0], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "4",
          w: 285,
          h: 231,
          ind: 8,
          ty: 0,
          nm: "O (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [289, -2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          parent: 7,
        },
        {
          ddd: 0,
          ind: 9,
          ty: 3,
          nm: "",
          sr: 1,
          ks: {
            p: { a: 0, k: [0, 0], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "5",
          w: 441,
          h: 231,
          ind: 10,
          ty: 0,
          nm: "D (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [-2, -2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          parent: 9,
        },
      ],
    },
    {
      id: "6",
      layers: [
        {
          ddd: 0,
          ind: 11,
          ty: 4,
          nm: "Path 1",
          sr: 1,
          ks: {
            p: { a: 0, k: [-1102, 1], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "gr",
              nm: "Path 1",
              it: [
                {
                  ty: "sh",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: true,
                      v: [
                        [408.2, 80],
                        [400, 80],
                        [445, 0],
                        [489.9, 80],
                        [481.7, 80],
                        [445, 14.5],
                        [408.2, 80],
                        [408.2, 80],
                      ],
                      i: [
                        [0, 0],
                        [2.7333333333333485, 0],
                        [-15, 26.666666666666668],
                        [-14.96666666666664, -26.66666666666667],
                        [2.7333333333333485, 0],
                        [12.233333333333348, 21.83333333333333],
                        [12.266666666666652, -21.833333333333336],
                        [0, 0],
                      ],
                      o: [
                        [-2.7333333333333485, 0],
                        [15, -26.66666666666667],
                        [14.96666666666664, 26.666666666666664],
                        [-2.7333333333333485, 0],
                        [-12.233333333333348, -21.833333333333336],
                        [-12.266666666666652, 21.83333333333333],
                        [0, 0],
                        [0, 0],
                      ],
                    },
                  },
                },
                {
                  ty: "gf",
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                  g: {
                    p: 3,
                    k: {
                      a: 0,
                      k: [
                        0.09079754162740485, 0.7764705882352941,
                        0.6745098039215687, 1, 0.565535663449362,
                        0.8862745098039215, 0.8352941176470589, 1,
                        0.9004541703512744, 1, 1, 1, 0.09079754162740485, 1,
                        0.565535663449362, 1, 0.9004541703512744, 1,
                      ],
                      ix: 2,
                    },
                  },
                  s: {
                    a: 0,
                    k: [0.2862450182437897, 3.200238296585667e-8],
                    ix: 2,
                  },
                  e: {
                    a: 0,
                    k: [494.605712890625, 3.200238296585667e-8],
                    ix: 2,
                  },
                  t: 1,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [-0.00006763740384485573, -1.6338059902191162],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [308.2261800765991, 287.042236328125],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          ind: 12,
          ty: 4,
          nm: "mask4 - box",
          sr: 1,
          ks: {
            p: { a: 0, k: [-1102, 1], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [409, 231], ix: 2 },
              p: { a: 0, k: [1306.5, 114.5], ix: 2 },
              r: { a: 0, k: 0, ix: 2 },
            },
            {
              ty: "fl",
              c: { a: 0, k: [0, 0, 0], ix: 2 },
              o: { a: 0, k: 0, ix: 2 },
              r: 1,
              bm: 0,
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
      ],
    },
    {
      id: "1",
      layers: [
        {
          ddd: 0,
          ind: 13,
          ty: 4,
          nm: "mask4",
          sr: 1,
          ks: {
            p: { a: 0, k: [-1102, 1], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          td: 1,
          ao: 0,
          shapes: [
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  nm: "Shape Layer 3",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: false,
                          v: [
                            [-140.6407470703125, 126.83914184570312],
                            [-4.42462158203125, -103.03172302246094],
                            [140.4766387939453, 126.83914184570312],
                          ],
                          i: [
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: {
                        a: 1,
                        k: [
                          {
                            t: 0,
                            s: [0],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                          {
                            t: 150,
                            s: [100],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                        ],
                        ix: 2,
                      },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "st",
                      c: { a: 0, k: [0, 0, 0], ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      w: { a: 0, k: 65, ix: 2 },
                      lc: 1,
                      lj: 1,
                      ml: 4,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [618.54541015625, 10.522994995117188],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "tr",
                  p: { a: 0, k: [1391.75, 9], ix: 2 },
                  a: { a: 0, k: [636.75, -105], ix: 2 },
                  s: { a: 0, k: [100, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "6",
          w: 409,
          h: 231,
          ind: 2,
          ty: 0,
          nm: "A (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [1306.5, 114.5], ix: 2 },
            a: { a: 0, k: [1306.5, 114.5], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          tt: 1,
        },
      ],
    },
    {
      id: "7",
      layers: [
        {
          ddd: 0,
          ind: 14,
          ty: 4,
          nm: "C",
          sr: 1,
          ks: {
            p: { a: 0, k: [-423, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "gr",
              nm: "C",
              it: [
                {
                  ty: "sh",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: true,
                      v: [
                        [240, 0],
                        [280, 0],
                        [280, 6.7],
                        [240, 6.7],
                        [223.3, 11.149999999999999],
                        [211.15, 23.3],
                        [206.7, 40],
                        [211.15, 56.699999999999996],
                        [223.3, 68.85000000000001],
                        [240, 73.30000000000001],
                        [280, 73.30000000000001],
                        [280, 80],
                        [240, 80],
                        [211.7, 68.30000000000001],
                        [200, 40],
                        [211.7, 11.7],
                        [240, 0],
                        [240, 0],
                      ],
                      i: [
                        [0, 0],
                        [-13.333333333333314, 0],
                        [0, -2.2333333333333334],
                        [13.333333333333343, 0],
                        [5.133333333333326, -2.966666666666667],
                        [2.96666666666664, -5.133333333333333],
                        [0, -6.000000000000007],
                        [-2.966666666666697, -5.133333333333333],
                        [-5.133333333333354, -2.9666666666666686],
                        [-6, 0],
                        [-13.333333333333314, 0],
                        [0, -2.2333333333333343],
                        [13.333333333333343, 0],
                        [7.800000000000011, 7.799999999999983],
                        [-2.842170943040401e-14, 11.066666666666663],
                        [-7.800000000000011, 7.800000000000001],
                        [-11.066666666666663, -8.673617379884035e-19],
                        [0, 0],
                      ],
                      o: [
                        [13.333333333333343, 0],
                        [0, 2.2333333333333334],
                        [-13.333333333333314, 0],
                        [-6, 0],
                        [-5.133333333333354, 2.966666666666667],
                        [-2.966666666666697, 5.133333333333333],
                        [0, 6],
                        [2.96666666666664, 5.133333333333333],
                        [5.133333333333326, 2.9666666666666686],
                        [13.333333333333343, 0],
                        [0, 2.2333333333333343],
                        [-13.333333333333314, 0],
                        [-11.066666666666663, 0],
                        [-7.800000000000011, -7.8000000000000185],
                        [-2.842170943040401e-14, -11.066666666666666],
                        [7.800000000000011, -7.799999999999999],
                        [0, 0],
                        [0, 0],
                      ],
                    },
                  },
                },
                {
                  ty: "gf",
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                  g: {
                    p: 3,
                    k: {
                      a: 0,
                      k: [
                        0, 0.7764705882352941, 0.6745098039215687, 1,
                        0.5715323266149714, 0.8862745098039215,
                        0.8352941176470589, 1, 1, 1, 1, 1, 0, 1,
                        0.5715323266149714, 1, 1, 1,
                      ],
                      ix: 2,
                    },
                  },
                  s: {
                    a: 0,
                    k: [-100.28541564941406, 3.200238296585667e-8],
                    ix: 2,
                  },
                  e: {
                    a: 0,
                    k: [389.9761657714844, 3.200238296585667e-8],
                    ix: 2,
                  },
                  t: 1,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [-0.00006763740384485573, -1.6338059902191162],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [308.2261800765991, 287.042236328125],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          ind: 15,
          ty: 4,
          nm: "mask3 - box",
          sr: 1,
          ks: {
            p: { a: 0, k: [-423, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [664, 232], ix: 2 },
              p: { a: 0, k: [755, 114], ix: 2 },
              r: { a: 0, k: 0, ix: 2 },
            },
            {
              ty: "fl",
              c: { a: 0, k: [0, 0, 0], ix: 2 },
              o: { a: 0, k: 0, ix: 2 },
              r: 1,
              bm: 0,
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
      ],
    },
    {
      id: "2",
      layers: [
        {
          ddd: 0,
          ind: 16,
          ty: 4,
          nm: "mask3",
          sr: 1,
          ks: {
            p: { a: 0, k: [-423, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          td: 1,
          ao: 0,
          shapes: [
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  nm: "Shape Layer 2",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: false,
                          v: [
                            [-109.8309555053711, -101.63741302490234],
                            [50.14177703857422, -101.97107696533203],
                            [110.41011047363281, -74.7565689086914],
                            [145.56663513183594, 3.0895156860351562],
                            [113.13054656982422, 77.37911987304688],
                            [22.40643310546875, 107.1436996459961],
                            [-99.3694076538086, 107.1436996459961],
                          ],
                          i: [
                            [0, 0],
                            [0, 0],
                            [-22.136670825048387, -22.254992931058872],
                            [-5.766843571564095e-7, -15.806395105681288],
                            [22.243520452039103, -22.148198650855264],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, 0],
                            [0, 0],
                            [22.136670825048387, 22.254992931058872],
                            [7.162070403410326e-7, 19.630584949504307],
                            [-22.243520452039103, 22.148198650855264],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: {
                        a: 1,
                        k: [
                          {
                            t: 0,
                            s: [0],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                          {
                            t: 150,
                            s: [100],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                        ],
                        ix: 2,
                      },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "st",
                      c: { a: 0, k: [0, 0, 0], ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      w: { a: 0, k: 102, ix: 2 },
                      lc: 1,
                      lj: 1,
                      ml: 4,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [17.86785888671875, 1.7694015502929688],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 180, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "tr",
                  p: { a: 0, k: [156.5, 9], ix: 2 },
                  a: { a: 0, k: [-598.5, -105], ix: 2 },
                  s: { a: 0, k: [100, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "7",
          w: 664,
          h: 232,
          ind: 4,
          ty: 0,
          nm: "C (Masked) 1",
          sr: 1,
          ks: {
            p: { a: 0, k: [755, 114], ix: 2 },
            a: { a: 0, k: [755, 114], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          tt: 1,
        },
      ],
    },
    {
      id: "8",
      layers: [
        {
          ddd: 0,
          ind: 17,
          ty: 4,
          nm: "C",
          sr: 1,
          ks: {
            p: { a: 0, k: [-423, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "gr",
              nm: "C",
              it: [
                {
                  ty: "sh",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: true,
                      v: [
                        [240, 0],
                        [280, 0],
                        [280, 6.652331212845093],
                        [240, 6.652331212845093],
                        [223.3, 11.07067060048101],
                        [211.15, 23.13422645661055],
                        [206.7, 39.71541022594086],
                        [211.15, 56.29659399527115],
                        [223.3, 68.3601498514007],
                        [240, 72.77848923903662],
                        [280, 72.77848923903662],
                        [280, 79.43082045188171],
                        [240, 79.43082045188171],
                        [211.7, 67.814062960794],
                        [200, 39.71541022594086],
                        [211.7, 11.616757491087698],
                        [240, 0],
                        [240, 0],
                      ],
                      i: [
                        [0, 0],
                        [-13.333333333333314, 0],
                        [0, -2.2174437376150307],
                        [13.333333333333343, 0],
                        [5.133333333333326, -2.94555959175728],
                        [2.96666666666664, -5.096810978995742],
                        [0, -5.957311533891135],
                        [-2.966666666666697, -5.096810978995742],
                        [-5.133333333333354, -2.9455595917572817],
                        [-6, 0],
                        [-13.333333333333314, 0],
                        [0, -2.2174437376150316],
                        [13.333333333333343, 0],
                        [7.800000000000011, 7.744504994058449],
                        [-2.842170943040401e-14, 10.987930162510297],
                        [-7.800000000000011, 7.744504994058467],
                        [-11.066666666666663, -8.611906809623618e-19],
                        [0, 0],
                      ],
                      o: [
                        [13.333333333333343, 0],
                        [0, 2.2174437376150307],
                        [-13.333333333333314, 0],
                        [-6, 0],
                        [-5.133333333333354, 2.94555959175728],
                        [-2.966666666666697, 5.096810978995742],
                        [0, 5.9573115338911276],
                        [2.96666666666664, 5.096810978995742],
                        [5.133333333333326, 2.9455595917572817],
                        [13.333333333333343, 0],
                        [0, 2.2174437376150316],
                        [-13.333333333333314, 0],
                        [-11.066666666666663, 0],
                        [-7.800000000000011, -7.7445049940584845],
                        [-2.842170943040401e-14, -10.9879301625103],
                        [7.800000000000011, -7.744504994058465],
                        [0, 0],
                        [0, 0],
                      ],
                    },
                  },
                },
                {
                  ty: "gf",
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                  g: {
                    p: 3,
                    k: {
                      a: 0,
                      k: [
                        0, 0.7764705882352941, 0.6745098039215687, 1,
                        0.5749323870799028, 0.8862745098039215,
                        0.8352941176470589, 1, 1, 1, 1, 1, 0, 1,
                        0.5749323870799028, 1, 1, 1,
                      ],
                      ix: 2,
                    },
                  },
                  s: {
                    a: 0,
                    k: [0.7559053301811218, 3.200238296585667e-8],
                    ix: 2,
                  },
                  e: {
                    a: 0,
                    k: [487.6649169921875, 3.200238296585667e-8],
                    ix: 2,
                  },
                  t: 1,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [-0.00009815498196985573, -0.0000016689300537109375],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [308.2261800765991, 287.042236328125],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          ind: 18,
          ty: 4,
          nm: "mask3 - box",
          sr: 1,
          ks: {
            p: { a: 0, k: [-423, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [664, 232], ix: 2 },
              p: { a: 0, k: [755, 114], ix: 2 },
              r: { a: 0, k: 0, ix: 2 },
            },
            {
              ty: "fl",
              c: { a: 0, k: [0, 0, 0], ix: 2 },
              o: { a: 0, k: 0, ix: 2 },
              r: 1,
              bm: 0,
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
      ],
    },
    {
      id: "3",
      layers: [
        {
          ddd: 0,
          ind: 19,
          ty: 4,
          nm: "mask3",
          sr: 1,
          ks: {
            p: { a: 0, k: [-423, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          td: 1,
          ao: 0,
          shapes: [
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  nm: "Shape Layer 2",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: false,
                          v: [
                            [-109.8309555053711, -101.63741302490234],
                            [50.14177703857422, -101.97107696533203],
                            [110.41011047363281, -74.7565689086914],
                            [145.56663513183594, 3.0895156860351562],
                            [113.13054656982422, 77.37911987304688],
                            [22.40643310546875, 107.1436996459961],
                            [-99.3694076538086, 107.1436996459961],
                          ],
                          i: [
                            [0, 0],
                            [0, 0],
                            [-22.136670825048387, -22.254992931058872],
                            [-5.766843571564095e-7, -15.806395105681288],
                            [22.243520452039103, -22.148198650855264],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, 0],
                            [0, 0],
                            [22.136670825048387, 22.254992931058872],
                            [7.162070403410326e-7, 19.630584949504307],
                            [-22.243520452039103, 22.148198650855264],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: {
                        a: 1,
                        k: [
                          {
                            t: 0,
                            s: [0],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                          {
                            t: 150,
                            s: [100],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                        ],
                        ix: 2,
                      },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "st",
                      c: { a: 0, k: [0, 0, 0], ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      w: { a: 0, k: 102, ix: 2 },
                      lc: 1,
                      lj: 1,
                      ml: 4,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [17.86785888671875, 1.7694015502929688],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 180, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "tr",
                  p: { a: 0, k: [156.5, 9], ix: 2 },
                  a: { a: 0, k: [-598.5, -105], ix: 2 },
                  s: { a: 0, k: [100, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "8",
          w: 664,
          h: 232,
          ind: 6,
          ty: 0,
          nm: "C (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [755, 114], ix: 2 },
            a: { a: 0, k: [755, 114], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          tt: 1,
        },
      ],
    },
    {
      id: "9",
      layers: [
        {
          ddd: 0,
          ind: 20,
          ty: 4,
          nm: "O",
          sr: 1,
          ks: {
            p: { a: 0, k: [-289, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "gr",
              nm: "O",
              it: [
                {
                  ty: "sh",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: true,
                      v: [
                        [390.7148533873112, 216.1168115255133],
                        [443.634058996136, 230.08514574902136],
                        [496.55326460496076, 216.1168115255133],
                        [535.0543632964111, 177.9785506680697],
                        [549.1555887430741, 125.55806043602803],
                        [535.0543632964111, 73.13757020398631],
                        [496.55326460496076, 34.9993093465428],
                        [443.634058996136, 21.030975123034697],
                        [390.7148533873112, 34.9993093465428],
                        [352.2137546958608, 73.13757020398631],
                        [338.11252924919796, 125.55806043602803],
                        [352.2137546958608, 177.9785506680697],
                        [390.7148533873112, 216.1168115255133],
                        [390.7148533873112, 216.1168115255133],
                      ],
                      i: [
                        [0, 0],
                        [-19.01288824269154, 0],
                        [-16.26658216319163, 9.312222815672085],
                        [-9.400816964441935, 16.113284422623593],
                        [0, 18.833709065404204],
                        [9.400816964441935, 16.113284422623593],
                        [16.26658216319163, 9.31222281567208],
                        [19.01288824269154, 0],
                        [16.26658216319167, -9.31222281567208],
                        [9.40081696444189, -16.113284422623593],
                        [-4.5031565422210304e-14, -18.833709065404225],
                        [-9.40081696444198, -16.113284422623593],
                        [-16.26658216319167, -9.312222815672085],
                        [0, 0],
                      ],
                      o: [
                        [16.26658216319167, 9.312222815672085],
                        [19.01288824269154, 0],
                        [16.26658216319163, -9.312222815672085],
                        [9.400816964441935, -16.113284422623593],
                        [0, -18.833709065404225],
                        [-9.400816964441935, -16.113284422623593],
                        [-16.26658216319163, -9.31222281567208],
                        [-19.01288824269154, 0],
                        [-16.26658216319167, 9.31222281567208],
                        [-9.40081696444198, 16.113284422623593],
                        [-4.5031565422210304e-14, 18.833709065404204],
                        [9.40081696444189, 16.113284422623593],
                        [0, 0],
                        [0, 0],
                      ],
                    },
                  },
                },
                {
                  ty: "gs",
                  o: { a: 0, k: 100, ix: 2 },
                  bm: 0,
                  g: {
                    p: 3,
                    k: {
                      a: 0,
                      k: [
                        0, 0.7764705882352941, 0.6745098039215687, 1,
                        0.5700438210895259, 0.8862745098039215,
                        0.8352941176470589, 1, 0.9454545454545454, 1, 1, 1, 0,
                        1, 0.5700438210895259, 1, 0.9454545454545454, 1,
                      ],
                      ix: 2,
                    },
                  },
                  s: {
                    a: 0,
                    k: [14.303681373596191, 12.999168395996094],
                    ix: 2,
                  },
                  e: {
                    a: 0,
                    k: [1523.223388671875, 9.706979751586914],
                    ix: 2,
                  },
                  t: 1,
                  w: { a: 0, k: 18, ix: 2 },
                  lc: 1,
                  lj: 1,
                  ml: 4,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [-12.117462158203125, -12.030975341796875],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: { a: 0, k: [100, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          ind: 21,
          ty: 4,
          nm: "mask2 - box",
          sr: 1,
          ks: {
            p: { a: 0, k: [-289, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [285, 231], ix: 2 },
              p: { a: 0, k: [431.5, 113.5], ix: 2 },
              r: { a: 0, k: 0, ix: 2 },
            },
            {
              ty: "fl",
              c: { a: 0, k: [0, 0, 0], ix: 2 },
              o: { a: 0, k: 0, ix: 2 },
              r: 1,
              bm: 0,
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
      ],
    },
    {
      id: "4",
      layers: [
        {
          ddd: 0,
          ind: 22,
          ty: 4,
          nm: "mask2",
          sr: 1,
          ks: {
            p: { a: 0, k: [-289, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          td: 1,
          ao: 0,
          shapes: [
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  nm: "O",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [390.7148533873112, 218.1728925848855],
                            [443.634058996136, 232.27411803154834],
                            [496.55326460496076, 218.1728925848855],
                            [535.0543632964111, 179.67179389343502],
                            [549.1555887430741, 126.75258828461028],
                            [535.0543632964111, 73.83338267578547],
                            [496.55326460496076, 35.332283984335106],
                            [443.634058996136, 21.231058537672222],
                            [390.7148533873112, 35.332283984335106],
                            [352.2137546958608, 73.83338267578547],
                            [338.11252924919796, 126.75258828461028],
                            [352.2137546958608, 179.67179389343502],
                            [390.7148533873112, 218.1728925848855],
                            [390.7148533873112, 218.1728925848855],
                          ],
                          i: [
                            [0, 0],
                            [-19.01288824269154, 0],
                            [-16.26658216319163, 9.400816964441935],
                            [-9.400816964441935, 16.26658216319165],
                            [0, 19.01288824269154],
                            [9.400816964441935, 16.26658216319165],
                            [16.26658216319163, 9.40081696444193],
                            [19.01288824269154, 0],
                            [16.26658216319167, -9.40081696444193],
                            [9.40081696444189, -16.26658216319165],
                            [-4.5031565422210304e-14, -19.012888242691563],
                            [-9.40081696444198, -16.26658216319165],
                            [-16.26658216319167, -9.400816964441935],
                            [0, 0],
                          ],
                          o: [
                            [16.26658216319167, 9.400816964441935],
                            [19.01288824269154, 0],
                            [16.26658216319163, -9.400816964441935],
                            [9.400816964441935, -16.26658216319165],
                            [0, -19.012888242691563],
                            [-9.400816964441935, -16.26658216319165],
                            [-16.26658216319163, -9.40081696444193],
                            [-19.01288824269154, 0],
                            [-16.26658216319167, 9.40081696444193],
                            [-9.40081696444198, 16.26658216319165],
                            [-4.5031565422210304e-14, 19.01288824269154],
                            [9.40081696444189, 16.26658216319165],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: {
                        a: 1,
                        k: [
                          {
                            t: 0,
                            s: [100],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                          {
                            t: 150,
                            s: [0],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                        ],
                        ix: 2,
                      },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "st",
                      c: { a: 0, k: [0, 0, 0], ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      w: { a: 0, k: 18, ix: 2 },
                      lc: 1,
                      lj: 1,
                      ml: 4,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-818.843505859375, -128.21990966796875],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [806.72607421875, 114.98058319091797],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: { a: 0, k: [100, 99.0575909614563], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "9",
          w: 285,
          h: 231,
          ind: 8,
          ty: 0,
          nm: "O (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [431.5, 113.5], ix: 2 },
            a: { a: 0, k: [431.5, 113.5], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          tt: 1,
        },
      ],
    },
    {
      id: "10",
      layers: [
        {
          ddd: 0,
          ind: 23,
          ty: 4,
          nm: "D",
          sr: 1,
          ks: {
            p: { a: 0, k: [2, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "gr",
              nm: "D",
              it: [
                {
                  ty: "sh",
                  d: 1,
                  ks: {
                    a: 0,
                    k: {
                      c: true,
                      v: [
                        [0, 0],
                        [121.99999999999999, 0],
                        [208.31499999999997, 33.44562051773071],
                        [243.99999999999997, 114.34400177001953],
                        [208.31499999999997, 195.2423830223084],
                        [121.99999999999999, 228.68800354003906],
                        [0, 228.68800354003906],
                        [0, 209.53538324356083],
                        [121.99999999999999, 209.53538324356083],
                        [172.93499999999997, 196.81461304664614],
                        [209.99249999999995, 162.08262250900268],
                        [223.56499999999997, 114.34400177001953],
                        [209.99249999999995, 66.60538103103637],
                        [172.93499999999997, 31.87339049339294],
                        [121.99999999999999, 19.152620296478272],
                        [0, 19.152620296478272],
                        [0, 0],
                        [0, 0],
                      ],
                      i: [
                        [0, 0],
                        [-40.666666666666664, 0],
                        [-23.78999999999999, -22.297080345153805],
                        [0, -31.635173823038734],
                        [23.78999999999999, -22.297080345153862],
                        [33.753333333333316, 0],
                        [40.666666666666664, 0],
                        [0, 6.38420676549276],
                        [-40.666666666666664, 0],
                        [-15.656666666666686, 8.480513464609787],
                        [-9.04833333333334, 14.674146893819172],
                        [-4.334310688136611e-14, 17.15160026550293],
                        [9.04833333333334, 14.674146893819172],
                        [15.656666666666663, 8.480513464609782],
                        [18.299999999999997, 0],
                        [40.666666666666664, 0],
                        [0, 6.384206765492757],
                        [0, 0],
                      ],
                      o: [
                        [40.66666666666666, 0],
                        [33.753333333333316, -2.4794403025948307e-18],
                        [23.78999999999999, 22.29708034515381],
                        [0, 31.635173823038727],
                        [-23.78999999999999, 22.29708034515376],
                        [-40.66666666666666, 0],
                        [0, -6.38420676549276],
                        [40.66666666666666, 0],
                        [18.299999999999997, 0],
                        [15.656666666666663, -8.480513464609787],
                        [9.04833333333334, -14.674146893819172],
                        [-4.334310688136611e-14, -17.15160026550295],
                        [-9.04833333333334, -14.674146893819172],
                        [-15.656666666666686, -8.480513464609782],
                        [-40.66666666666666, 0],
                        [0, -6.384206765492757],
                        [0, 0],
                        [0, 0],
                      ],
                    },
                  },
                },
                {
                  ty: "fl",
                  c: {
                    a: 0,
                    k: [0.7764705882352941, 0.6745098039215687, 1],
                    ix: 2,
                  },
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                },
                {
                  ty: "tr",
                  p: { a: 0, k: [0, -0.6880035400390625], ix: 2 },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: { a: 0, k: [100, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          ind: 24,
          ty: 4,
          nm: "mask1 - box",
          sr: 1,
          ks: {
            p: { a: 0, k: [2, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          shapes: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [441, 231], ix: 2 },
              p: { a: 0, k: [218.5, 113.5], ix: 2 },
              r: { a: 0, k: 0, ix: 2 },
            },
            {
              ty: "fl",
              c: { a: 0, k: [0, 0, 0], ix: 2 },
              o: { a: 0, k: 0, ix: 2 },
              r: 1,
              bm: 0,
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
      ],
    },
    {
      id: "5",
      layers: [
        {
          ddd: 0,
          ind: 25,
          ty: 4,
          nm: "mask1",
          sr: 1,
          ks: {
            p: { a: 0, k: [2, 2], ix: 2 },
            a: { a: 0, k: [0, 0], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          td: 1,
          ao: 0,
          shapes: [
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  nm: "Shape Layer 1",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: false,
                          v: [
                            [-109.8309555053711, -101.63741302490234],
                            [50.14177703857422, -101.97107696533203],
                            [110.41011047363281, -74.7565689086914],
                            [145.56663513183594, 3.0895156860351562],
                            [113.13054656982422, 77.37911987304688],
                            [22.40643310546875, 107.1436996459961],
                            [-99.3694076538086, 107.1436996459961],
                          ],
                          i: [
                            [0, 0],
                            [0, 0],
                            [-22.136670825048387, -22.254992931058872],
                            [-5.766843571564095e-7, -15.806395105681288],
                            [22.243520452039103, -22.148198650855264],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, 0],
                            [0, 0],
                            [22.136670825048387, 22.254992931058872],
                            [7.162070403410326e-7, 19.630584949504307],
                            [-22.243520452039103, 22.148198650855264],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: {
                        a: 1,
                        k: [
                          {
                            t: 0,
                            s: [0],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                          {
                            t: 150,
                            s: [100],
                            o: { x: [0], y: [0] },
                            i: { x: [0.58], y: [1] },
                          },
                        ],
                        ix: 2,
                      },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "st",
                      c: { a: 0, k: [0, 0, 0], ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      w: { a: 0, k: 102, ix: 2 },
                      lc: 1,
                      lj: 1,
                      ml: 4,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-665.643798828125, -3.089508056640625],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "tr",
                  p: { a: 0, k: [156.5, 9], ix: 2 },
                  a: { a: 0, k: [-598.5, -105], ix: 2 },
                  s: { a: 0, k: [100, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
          ],
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
        },
        {
          ddd: 0,
          refId: "10",
          w: 441,
          h: 231,
          ind: 10,
          ty: 0,
          nm: "D (Masked)",
          sr: 1,
          ks: {
            p: { a: 0, k: [218.5, 113.5], ix: 2 },
            a: { a: 0, k: [218.5, 113.5], ix: 2 },
            s: { a: 0, k: [100, 100], ix: 2 },
            r: { a: 0, k: 0, ix: 2 },
            o: { a: 0, k: 100, ix: 2 },
            sk: { a: 0, k: 0, ix: 2 },
            sa: { a: 0, k: 0, ix: 2 },
          },
          ao: 0,
          ip: 0,
          op: 270,
          st: 0,
          bm: 0,
          tt: 1,
        },
      ],
    },
  ],
  layers = [
    {
      ddd: 0,
      ind: 12345679,
      ty: 4,
      nm: "Group Layer 8",
      sr: 1,
      ks: {
        p: { a: 0, k: [1227.2800000000002, 166.44, 0], ix: 2 },
        a: { a: 0, k: [0, 0], ix: 2 },
        s: {
          a: 0,
          k: [113.99999999999999, 113.99999999999999, 100],
          ix: 2,
        },
        r: { a: 0, k: 0, ix: 2 },
        o: { a: 0, k: 100, ix: 2 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [220.741, 37.184],
                            [225.501, 35.896],
                            [228.749, 32.36800000000001],
                            [229.981, 27.216000000000008],
                            [228.749, 22.12],
                            [225.501, 18.592],
                            [220.741, 17.304],
                            [215.981, 18.592],
                            [212.677, 22.12],
                            [211.501, 27.216000000000008],
                            [212.677, 32.36800000000001],
                            [215.981, 35.896],
                            [220.741, 37.184],
                            [220.741, 37.184],
                            [220.741, 37.184],
                          ],
                          i: [
                            [0, 0],
                            [-1.380999999999972, 0.8586999999999989],
                            [-0.7839999999999918, 1.493299999999991],
                            [0, 1.903999999999996],
                            [0.8220000000000027, 1.493299999999991],
                            [1.382000000000062, 0.8586999999999989],
                            [1.79200000000003, 0],
                            [1.418999999999983, -0.8586999999999989],
                            [0.8220000000000027, -1.493300000000005],
                            [0, -1.904000000000011],
                            [-0.7839999999999918, -1.5307000000000102],
                            [-1.380999999999972, -0.8586999999999989],
                            [-1.754000000000019, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [1.79200000000003, 0],
                            [1.382000000000062, -0.8586999999999989],
                            [0.8220000000000027, -1.5307000000000102],
                            [0, -1.904000000000011],
                            [-0.7839999999999918, -1.493300000000005],
                            [-1.380999999999972, -0.8586999999999989],
                            [-1.754000000000019, 0],
                            [-1.380999999999972, 0.8586999999999989],
                            [-0.7839999999999918, 1.493299999999991],
                            [0, 1.903999999999996],
                            [0.8220000000000027, 1.493299999999991],
                            [1.418999999999983, 0.8586999999999989],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [221.357, 43.06400000000001],
                            [214.917, 41.608],
                            [210.49300000000005, 37.408],
                            [211.221, 36.232],
                            [211.221, 42.392],
                            [205.173, 42.392],
                            [205.173, 0],
                            [211.501, 0],
                            [211.501, 18.36800000000001],
                            [210.49300000000005, 16.912000000000006],
                            [214.973, 12.88],
                            [221.357, 11.424000000000007],
                            [229.085, 13.49600000000001],
                            [234.51700000000005, 19.152],
                            [236.533, 27.216000000000008],
                            [234.51700000000005, 35.28],
                            [229.141, 40.992],
                            [221.357, 43.06400000000001],
                            [221.357, 43.06400000000001],
                            [221.357, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [1.942000000000007, 0.9706999999999937],
                            [1.045999999999935, 1.829300000000003],
                            [-0.2426666666666506, 0.3919999999999959],
                            [0, -2.053333333333327],
                            [2.015999999999963, 0],
                            [0, 14.13066666666667],
                            [-2.109333333333325, 0],
                            [0, -6.122666666666674],
                            [0.3360000000000127, 0.4853333333333296],
                            [-1.865999999999985, 0.9707000000000079],
                            [-2.38900000000001, 0],
                            [-2.277000000000044, -1.3813000000000102],
                            [-1.30600000000004, -2.389300000000006],
                            [0, -2.986699999999999],
                            [1.343999999999937, -2.389300000000006],
                            [2.27800000000002, -1.4187000000000012],
                            [2.912000000000035, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-2.351999999999975, 0],
                            [-1.903999999999996, -0.9707000000000079],
                            [0.2426666666666506, -0.3919999999999959],
                            [0, 2.053333333333327],
                            [-2.015999999999963, 0],
                            [0, -14.13066666666667],
                            [2.109333333333325, 0],
                            [0, 6.122666666666667],
                            [-0.3360000000000127, -0.4853333333333296],
                            [1.120000000000005, -1.717300000000009],
                            [1.867000000000075, -0.9706999999999937],
                            [2.875, 0],
                            [2.314999999999941, 1.381299999999996],
                            [1.343999999999937, 2.389300000000006],
                            [0, 2.986699999999999],
                            [-1.30600000000004, 2.389300000000006],
                            [-2.27699999999993, 1.381299999999996],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [181.87, 43.06400000000001],
                            [176.438, 42],
                            [172.854, 38.976],
                            [171.566, 34.384],
                            [172.63, 29.960000000000008],
                            [176.046, 26.656000000000006],
                            [181.814, 24.752],
                            [192.342, 23.016000000000005],
                            [192.342, 28],
                            [183.046, 29.624],
                            [179.35, 31.248],
                            [178.174, 34.16],
                            [179.462, 37.016000000000005],
                            [182.878, 38.08],
                            [187.35799999999995, 36.96000000000001],
                            [190.38199999999995, 33.992],
                            [191.446, 29.792],
                            [191.446, 22.008],
                            [189.766, 18.36800000000001],
                            [185.398, 16.912000000000006],
                            [180.974, 18.256],
                            [178.23, 21.616],
                            [172.966, 18.98400000000001],
                            [175.71, 15.064000000000007],
                            [180.134, 12.376],
                            [185.566, 11.424000000000007],
                            [191.894, 12.768],
                            [196.206, 16.52],
                            [197.774, 22.008],
                            [197.774, 42.392],
                            [191.726, 42.392],
                            [191.726, 36.904],
                            [193.014, 37.072],
                            [190.27, 40.264],
                            [186.518, 42.336],
                            [181.87, 43.06400000000001],
                            [181.87, 43.06400000000001],
                            [181.87, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [1.567999999999984, 0.7092999999999989],
                            [0.8589999999999236, 1.2693000000000012],
                            [0, 1.7547],
                            [-0.7089999999999463, 1.306699999999992],
                            [-1.530000000000086, 0.8960000000000008],
                            [-2.313999999999965, 0.3733000000000004],
                            [-3.509333333333302, 0.5786666666666633],
                            [0, -1.661333333333332],
                            [3.098666666666645, -0.541333333333327],
                            [0.7839999999999918, -0.784000000000006],
                            [0, -1.194699999999997],
                            [-0.8579999999999472, -0.7467000000000041],
                            [-1.381000000000085, 0],
                            [-1.268999999999892, 0.7466999999999899],
                            [-0.7089999999999463, 1.2319999999999993],
                            [0, 1.530699999999996],
                            [0, 2.594666666666669],
                            [1.120000000000005, 0.9332999999999885],
                            [1.829999999999927, 0],
                            [1.269999999999982, -0.8960000000000008],
                            [0.5979999999999563, -1.381299999999996],
                            [1.754666666666708, 0.8773333333333255],
                            [-1.269000000000005, 1.11999999999999],
                            [-1.680000000000064, 0.6346999999999952],
                            [-1.903999999999996, 0],
                            [-1.828999999999951, -0.8960000000000008],
                            [-1.008000000000038, -1.6053],
                            [0, -2.090699999999998],
                            [0, -6.794666666666672],
                            [2.015999999999963, 0],
                            [0, 1.829333333333338],
                            [-0.4293333333333749, -0.05599999999999739],
                            [1.120000000000005, -0.8959999999999866],
                            [1.418999999999983, -0.4852999999999952],
                            [1.717999999999961, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-2.052999999999997, 0],
                            [-1.529999999999973, -0.7467000000000041],
                            [-0.8580000000000609, -1.306699999999992],
                            [0, -1.642700000000005],
                            [0.7469999999999573, -1.306700000000006],
                            [1.530999999999949, -0.8960000000000008],
                            [3.509333333333302, -0.5786666666666633],
                            [0, 1.661333333333332],
                            [-3.098666666666645, 0.541333333333327],
                            [-1.680000000000064, 0.2987000000000108],
                            [-0.7839999999999918, 0.7467000000000041],
                            [0, 1.157300000000006],
                            [0.8959999999999582, 0.7092999999999989],
                            [1.717999999999961, 0],
                            [1.307000000000016, -0.7467000000000041],
                            [0.7100000000000364, -1.2693000000000012],
                            [0, -2.594666666666669],
                            [0, -1.493299999999991],
                            [-1.081999999999994, -0.9707000000000079],
                            [-1.680000000000064, 0],
                            [-1.232000000000085, 0.8586999999999989],
                            [-1.754666666666708, -0.8773333333333255],
                            [0.5599999999999454, -1.493300000000005],
                            [1.269999999999982, -1.157300000000006],
                            [1.717999999999961, -0.6347000000000094],
                            [2.389999999999986, 0],
                            [1.866999999999962, 0.8960000000000008],
                            [1.045999999999935, 1.568000000000012],
                            [0, 6.794666666666672],
                            [-2.015999999999963, 0],
                            [0, -1.829333333333338],
                            [0.4293333333333749, 0.05599999999999739],
                            [-0.70900000000006, 1.2319999999999993],
                            [-1.081999999999994, 0.8960000000000008],
                            [-1.380999999999972, 0.4853000000000094],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [159.072, 42.392],
                            [159.072, 0],
                            [165.4, 0],
                            [165.4, 42.392],
                            [159.072, 42.392],
                            [159.072, 42.392],
                            [159.072, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [0, 14.13066666666667],
                            [-2.109333333333325, 0],
                            [0, -14.13066666666667],
                            [2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -14.13066666666667],
                            [2.109333333333325, 0],
                            [0, 14.13066666666667],
                            [-2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [138.952, 43.06400000000001],
                            [130.888, 40.992],
                            [125.456, 35.28],
                            [123.496, 27.16],
                            [125.456, 19.040000000000006],
                            [130.832, 13.49600000000001],
                            [138.448, 11.424000000000007],
                            [144.552, 12.600000000000009],
                            [149.088, 15.848],
                            [151.888, 20.49600000000001],
                            [152.896, 26.096],
                            [152.84, 27.608],
                            [152.616, 29.064000000000007],
                            [128.48, 29.064000000000007],
                            [128.48, 24.024],
                            [149.032, 24.024],
                            [146.008, 26.320000000000007],
                            [145.616, 21.448000000000008],
                            [142.816, 18.032],
                            [138.448, 16.744],
                            [133.968, 18.032],
                            [130.944, 21.616],
                            [130.104, 27.216000000000008],
                            [130.944, 32.592],
                            [134.192, 36.176],
                            [139.008, 37.464],
                            [143.65599999999995, 36.232],
                            [146.736, 33.040000000000006],
                            [151.888, 35.56],
                            [149.088, 39.42400000000001],
                            [144.60799999999995, 42.11200000000001],
                            [138.952, 43.06400000000001],
                            [138.952, 43.06400000000001],
                            [138.952, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [2.351999999999975, 1.381299999999996],
                            [1.307000000000016, 2.389300000000006],
                            [0, 2.986699999999999],
                            [-1.307000000000016, 2.35199999999999],
                            [-2.240000000000009, 1.343999999999994],
                            [-2.836999999999989, 0],
                            [-1.79200000000003, -0.784000000000006],
                            [-1.231999999999971, -1.381299999999996],
                            [-0.6349999999999909, -1.754700000000014],
                            [0, -1.978700000000003],
                            [0.03699999999992087, -0.5227000000000004],
                            [0.1119999999999663, -0.4480000000000075],
                            [8.04533333333336, 0],
                            [0, 1.680000000000007],
                            [-6.850666666666712, 0],
                            [1.008000000000038, -0.7653333333333308],
                            [0.6349999999999909, 1.4187000000000012],
                            [1.269000000000005, 0.8213000000000079],
                            [1.680000000000064, 0],
                            [1.307000000000016, -0.8586999999999989],
                            [0.70900000000006, -1.567999999999998],
                            [-0.1490000000000009, -2.202700000000007],
                            [-0.7469999999999573, -1.530699999999996],
                            [-1.380999999999972, -0.8586999999999989],
                            [-1.79200000000003, 0],
                            [-1.268999999999892, 0.8213000000000079],
                            [-0.7469999999999573, 1.306699999999992],
                            [-1.717333333333386, -0.8400000000000034],
                            [1.269000000000005, -1.157300000000006],
                            [1.755000000000109, -0.6720000000000113],
                            [2.052999999999997, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-3.024000000000001, 0],
                            [-2.315000000000055, -1.4187000000000012],
                            [-1.307000000000016, -2.426699999999997],
                            [0, -3.061299999999989],
                            [1.343999999999937, -2.352000000000004],
                            [2.240000000000009, -1.3813000000000102],
                            [2.277000000000044, 0],
                            [1.79200000000003, 0.7839999999999918],
                            [1.232000000000085, 1.344000000000008],
                            [0.6720000000000255, 1.7547],
                            [0, 0.4852999999999952],
                            [-0.03700000000003456, 0.5227000000000004],
                            [-8.04533333333336, 0],
                            [0, -1.680000000000007],
                            [6.850666666666712, 0],
                            [-1.008000000000038, 0.7653333333333308],
                            [0.3729999999999336, -1.829300000000003],
                            [-0.59699999999998, -1.456000000000003],
                            [-1.232000000000085, -0.8586999999999989],
                            [-1.67999999999995, 0],
                            [-1.306999999999903, 0.8213000000000079],
                            [-0.7089999999999463, 1.530699999999996],
                            [-0.1870000000000118, 2.053299999999993],
                            [0.7839999999999918, 1.53070000000001],
                            [1.418999999999983, 0.8586999999999989],
                            [1.828999999999951, 0],
                            [1.307000000000016, -0.8212999999999937],
                            [1.717333333333386, 0.8400000000000034],
                            [-0.59699999999998, 1.4187000000000012],
                            [-1.231999999999971, 1.11999999999999],
                            [-1.716999999999985, 0.6346999999999952],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [111.001, 7.951999999999998],
                            [111.001, 0.6720000000000041],
                            [117.329, 0.6720000000000041],
                            [117.329, 7.951999999999998],
                            [111.001, 7.951999999999998],
                            [111.001, 7.951999999999998],
                            [111.001, 7.951999999999998],
                          ],
                          i: [
                            [0, 0],
                            [0, 2.426666666666662],
                            [-2.109333333333325, 0],
                            [0, -2.426666666666662],
                            [2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -2.426666666666662],
                            [2.109333333333325, 0],
                            [0, 2.426666666666662],
                            [-2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [111.001, 42.392],
                            [111.001, 12.096],
                            [117.329, 12.096],
                            [117.329, 42.392],
                            [111.001, 42.392],
                            [111.001, 42.392],
                            [111.001, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [0, 10.09866666666667],
                            [-2.109333333333325, 0],
                            [0, -10.09866666666667],
                            [2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -10.09866666666666],
                            [2.109333333333325, 0],
                            [0, 10.09866666666666],
                            [-2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [101.41, 42.72800000000001],
                            [94.01800000000003, 40.040000000000006],
                            [91.38599999999997, 32.48],
                            [91.38599999999997, 17.808000000000007],
                            [86.06600000000003, 17.808000000000007],
                            [86.06600000000003, 12.096],
                            [86.90599999999995, 12.096],
                            [90.21000000000004, 10.864],
                            [91.38599999999997, 7.504000000000005],
                            [91.38599999999997, 5.152000000000001],
                            [97.71400000000006, 5.152000000000001],
                            [97.71400000000006, 12.096],
                            [104.602, 12.096],
                            [104.602, 17.808000000000007],
                            [97.71400000000006, 17.808000000000007],
                            [97.71400000000006, 32.2],
                            [98.21799999999996, 34.888000000000005],
                            [99.84199999999998, 36.568],
                            [102.754, 37.128],
                            [103.76200000000006, 37.072],
                            [104.826, 36.96000000000001],
                            [104.826, 42.392],
                            [103.09, 42.616],
                            [101.41, 42.72800000000001],
                            [101.41, 42.72800000000001],
                            [101.41, 42.72800000000001],
                          ],
                          i: [
                            [0, 0],
                            [1.754999999999995, 1.792000000000002],
                            [0, 3.248000000000005],
                            [0, 4.890666666666661],
                            [1.773333333333312, 0],
                            [0, 1.903999999999996],
                            [-0.2799999999999727, 0],
                            [-0.7839999999999918, 0.8212999999999937],
                            [0, 1.4187000000000012],
                            [0, 0.7839999999999989],
                            [-2.109333333333325, 0],
                            [0, -2.314666666666668],
                            [-2.295999999999935, 0],
                            [0, -1.903999999999996],
                            [2.295999999999935, 0],
                            [0, -4.797333333333327],
                            [-0.3360000000000127, -0.7467000000000041],
                            [-0.7469999999999573, -0.4106999999999914],
                            [-1.19500000000005, 0],
                            [-0.3730000000000473, 0.03730000000000189],
                            [-0.3360000000000127, 0.03729999999998768],
                            [0, -1.810666666666663],
                            [0.6349999999999909, -0.07469999999999288],
                            [0.4850000000000136, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-3.173000000000002, 0],
                            [-1.754999999999995, -1.792000000000002],
                            [0, -4.890666666666661],
                            [-1.773333333333312, 0],
                            [0, -1.903999999999996],
                            [0.2799999999999727, 0],
                            [1.419000000000096, 0],
                            [0.7839999999999918, -0.8213000000000079],
                            [0, -0.7839999999999989],
                            [2.109333333333325, 0],
                            [0, 2.314666666666668],
                            [2.295999999999935, 0],
                            [0, 1.903999999999996],
                            [-2.295999999999935, 0],
                            [0, 4.797333333333327],
                            [0, 1.045299999999997],
                            [0.3360000000000127, 0.7092999999999989],
                            [0.7470000000000709, 0.3733000000000004],
                            [0.2989999999999782, 0],
                            [0.3729999999999336, -0.03730000000000189],
                            [0, 1.810666666666663],
                            [-0.5230000000000246, 0.0747000000000071],
                            [-0.6349999999999909, 0.0747000000000071],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [78.71499999999997, 42.72800000000001],
                            [71.32299999999998, 40.040000000000006],
                            [68.69100000000003, 32.48],
                            [68.69100000000003, 17.808000000000007],
                            [63.37099999999998, 17.808000000000007],
                            [63.37099999999998, 12.096],
                            [64.21100000000001, 12.096],
                            [67.51499999999999, 10.864],
                            [68.69100000000003, 7.504000000000005],
                            [68.69100000000003, 5.152000000000001],
                            [75.019, 5.152000000000001],
                            [75.019, 12.096],
                            [81.90700000000004, 12.096],
                            [81.90700000000004, 17.808000000000007],
                            [75.019, 17.808000000000007],
                            [75.019, 32.2],
                            [75.52300000000002, 34.888000000000005],
                            [77.14699999999999, 36.568],
                            [80.05900000000003, 37.128],
                            [81.06700000000001, 37.072],
                            [82.13099999999997, 36.96000000000001],
                            [82.13099999999997, 42.392],
                            [80.39499999999998, 42.616],
                            [78.71499999999997, 42.72800000000001],
                            [78.71499999999997, 42.72800000000001],
                            [78.71499999999997, 42.72800000000001],
                          ],
                          i: [
                            [0, 0],
                            [1.754000000000019, 1.792000000000002],
                            [0, 3.248000000000005],
                            [0, 4.890666666666661],
                            [1.773333333333369, 0],
                            [0, 1.903999999999996],
                            [-0.2800000000000296, 0],
                            [-0.7839999999999918, 0.8212999999999937],
                            [0, 1.4187000000000012],
                            [0, 0.7839999999999989],
                            [-2.109333333333325, 0],
                            [0, -2.314666666666668],
                            [-2.295999999999992, 0],
                            [0, -1.903999999999996],
                            [2.295999999999992, 0],
                            [0, -4.797333333333327],
                            [-0.3360000000000127, -0.7467000000000041],
                            [-0.7470000000000141, -0.4106999999999914],
                            [-1.19500000000005, 0],
                            [-0.3740000000000236, 0.03730000000000189],
                            [-0.3360000000000127, 0.03729999999998768],
                            [0, -1.810666666666663],
                            [0.6340000000000146, -0.07469999999999288],
                            [0.4850000000000136, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-3.173999999999978, 0],
                            [-1.754999999999995, -1.792000000000002],
                            [0, -4.890666666666661],
                            [-1.773333333333369, 0],
                            [0, -1.903999999999996],
                            [0.2800000000000296, 0],
                            [1.418000000000006, 0],
                            [0.7839999999999918, -0.8213000000000079],
                            [0, -0.7839999999999989],
                            [2.109333333333325, 0],
                            [0, 2.314666666666668],
                            [2.295999999999992, 0],
                            [0, 1.903999999999996],
                            [-2.295999999999992, 0],
                            [0, 4.797333333333327],
                            [0, 1.045299999999997],
                            [0.3359999999999559, 0.7092999999999989],
                            [0.7460000000000377, 0.3733000000000004],
                            [0.297999999999945, 0],
                            [0.3730000000000473, -0.03730000000000189],
                            [0, 1.810666666666663],
                            [-0.5230000000000246, 0.0747000000000071],
                            [-0.6349999999999909, 0.0747000000000071],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [44.18799999999999, 37.184],
                            [48.94799999999998, 35.896],
                            [52.19600000000003, 32.36800000000001],
                            [53.428, 27.216000000000008],
                            [52.19600000000003, 22.12],
                            [48.94799999999998, 18.592],
                            [44.18799999999999, 17.304],
                            [39.428, 18.592],
                            [36.12400000000002, 22.12],
                            [34.94799999999998, 27.216000000000008],
                            [36.12400000000002, 32.36800000000001],
                            [39.428, 35.896],
                            [44.18799999999999, 37.184],
                            [44.18799999999999, 37.184],
                            [44.18799999999999, 37.184],
                          ],
                          i: [
                            [0, 0],
                            [-1.381999999999948, 0.8586999999999989],
                            [-0.7840000000000487, 1.493299999999991],
                            [0, 1.903999999999996],
                            [0.8209999999999695, 1.493299999999991],
                            [1.381000000000029, 0.8586999999999989],
                            [1.79200000000003, 0],
                            [1.418000000000006, -0.8586999999999989],
                            [0.8209999999999695, -1.493300000000005],
                            [0, -1.904000000000011],
                            [-0.7840000000000487, -1.5307000000000102],
                            [-1.382000000000005, -0.8586999999999989],
                            [-1.754999999999995, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [1.79200000000003, 0],
                            [1.381000000000029, -0.8586999999999989],
                            [0.8209999999999695, -1.5307000000000102],
                            [0, -1.904000000000011],
                            [-0.7840000000000487, -1.493300000000005],
                            [-1.381999999999948, -0.8586999999999989],
                            [-1.754999999999995, 0],
                            [-1.382000000000005, 0.8586999999999989],
                            [-0.7840000000000487, 1.493299999999991],
                            [0, 1.903999999999996],
                            [0.8209999999999695, 1.493299999999991],
                            [1.418000000000006, 0.8586999999999989],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [44.18799999999999, 43.06400000000001],
                            [36.18000000000001, 40.992],
                            [30.46800000000002, 35.336],
                            [28.33999999999997, 27.216000000000008],
                            [30.46800000000002, 19.096],
                            [36.18000000000001, 13.49600000000001],
                            [44.18799999999999, 11.424000000000007],
                            [52.19600000000003, 13.49600000000001],
                            [57.85199999999998, 19.096],
                            [59.98000000000002, 27.216000000000008],
                            [57.85199999999998, 35.392],
                            [52.139999999999986, 41.048],
                            [44.18799999999999, 43.06400000000001],
                            [44.18799999999999, 43.06400000000001],
                            [44.18799999999999, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [2.425999999999988, 1.381299999999996],
                            [1.418000000000006, 2.389300000000006],
                            [0, 3.024000000000001],
                            [-1.41900000000004, 2.352000000000004],
                            [-2.389999999999986, 1.343999999999994],
                            [-2.949999999999989, 0],
                            [-2.352000000000032, -1.3813000000000102],
                            [-1.381999999999948, -2.389300000000006],
                            [0, -3.061300000000003],
                            [1.418000000000006, -2.389299999999992],
                            [2.38900000000001, -1.381299999999996],
                            [2.912000000000035, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-2.911999999999978, 0],
                            [-2.389999999999986, -1.381299999999996],
                            [-1.41900000000004, -2.389299999999992],
                            [0, -3.061300000000003],
                            [1.418000000000006, -2.389300000000006],
                            [2.38900000000001, -1.3813000000000102],
                            [2.98599999999999, 0],
                            [2.388999999999953, 1.343999999999994],
                            [1.418000000000006, 2.352000000000004],
                            [0, 3.061299999999989],
                            [-1.418999999999983, 2.389300000000006],
                            [-2.389999999999986, 1.343999999999994],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [0, 42.392],
                            [0, 0.6720000000000041],
                            [6.608000000000004, 0.6720000000000041],
                            [6.608000000000004, 36.512],
                            [24.639999999999986, 36.512],
                            [24.639999999999986, 42.392],
                            [0, 42.392],
                            [0, 42.392],
                            [0, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [0, 13.90666666666666],
                            [-2.202666666666687, 0],
                            [0, -11.94666666666666],
                            [-6.01066666666668, 0],
                            [0, -1.959999999999994],
                            [8.21333333333331, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -13.90666666666667],
                            [2.202666666666687, 0],
                            [0, 11.94666666666667],
                            [6.01066666666668, 0],
                            [0, 1.959999999999994],
                            [-8.21333333333331, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: { a: 0, k: [0, 0], ix: 2 },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "fl",
                  c: { a: 0, k: [1, 1, 1], ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [98.08047485351562, -21.67217254638672],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [99.99999403953552, 99.99999403953552],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [246.681, 42.392],
                            [246.681, 0],
                            [253.009, 0],
                            [253.009, 18.032],
                            [252.001, 17.248],
                            [255.585, 12.936000000000007],
                            [261.297, 11.424000000000007],
                            [267.23299999999995, 12.88],
                            [271.265, 16.912000000000006],
                            [272.721, 22.792],
                            [272.721, 42.392],
                            [266.449, 42.392],
                            [266.449, 24.528000000000006],
                            [265.553, 20.664],
                            [263.201, 18.2],
                            [259.729, 17.304],
                            [256.25699999999995, 18.2],
                            [253.849, 20.664],
                            [253.009, 24.528000000000006],
                            [253.009, 42.392],
                            [246.681, 42.392],
                            [246.681, 42.392],
                            [246.681, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [0, 14.13066666666667],
                            [-2.109333333333325, 0],
                            [0, -6.010666666666665],
                            [0.3360000000000127, 0.2613333333333259],
                            [-1.643000000000029, 0.9706999999999937],
                            [-2.166000000000054, 0],
                            [-1.717999999999961, -0.9706999999999937],
                            [-0.9710000000000036, -1.717300000000009],
                            [0, -2.202699999999993],
                            [0, -6.533333333333331],
                            [2.090666666666721, 0],
                            [0, 5.954666666666668],
                            [0.59699999999998, 1.045299999999997],
                            [1.007999999999925, 0.5600000000000023],
                            [1.305999999999926, 0],
                            [1.045000000000073, -0.5973000000000042],
                            [0.59699999999998, -1.082700000000003],
                            [0, -1.493300000000005],
                            [0, -5.954666666666668],
                            [2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -14.13066666666667],
                            [2.109333333333325, 0],
                            [0, 6.010666666666665],
                            [-0.3360000000000127, -0.2613333333333259],
                            [0.7459999999999809, -1.903999999999996],
                            [1.641999999999967, -1.0080000000000098],
                            [2.240000000000009, 0],
                            [1.717000000000098, 0.9707000000000079],
                            [0.9700000000000273, 1.717299999999994],
                            [0, 6.533333333333331],
                            [-2.090666666666721, 0],
                            [0, -5.954666666666668],
                            [0, -1.5307000000000102],
                            [-0.5599999999999454, -1.082700000000003],
                            [-1.008000000000038, -0.5973000000000042],
                            [-1.270000000000095, 0],
                            [-1.007999999999953, 0.5600000000000023],
                            [-0.5600000000000023, 1.082700000000003],
                            [0, 5.954666666666668],
                            [-2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-354.5325317382812, -77.50520324707031],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [237.089, 42.72800000000001],
                            [229.697, 40.040000000000006],
                            [227.065, 32.48],
                            [227.065, 17.808000000000007],
                            [221.745, 17.808000000000007],
                            [221.745, 12.096],
                            [222.585, 12.096],
                            [225.889, 10.864],
                            [227.065, 7.504000000000005],
                            [227.065, 5.152000000000001],
                            [233.393, 5.152000000000001],
                            [233.393, 12.096],
                            [240.281, 12.096],
                            [240.281, 17.808000000000007],
                            [233.393, 17.808000000000007],
                            [233.393, 32.2],
                            [233.897, 34.888000000000005],
                            [235.521, 36.568],
                            [238.433, 37.128],
                            [239.441, 37.072],
                            [240.505, 36.96000000000001],
                            [240.505, 42.392],
                            [238.769, 42.616],
                            [237.089, 42.72800000000001],
                            [237.089, 42.72800000000001],
                            [237.089, 42.72800000000001],
                          ],
                          i: [
                            [0, 0],
                            [1.755000000000052, 1.792000000000002],
                            [0, 3.248000000000005],
                            [0, 4.890666666666661],
                            [1.773333333333369, 0],
                            [0, 1.903999999999996],
                            [-0.2800000000000296, 0],
                            [-0.7839999999999918, 0.8212999999999937],
                            [0, 1.4187000000000012],
                            [0, 0.7839999999999989],
                            [-2.109333333333325, 0],
                            [0, -2.314666666666668],
                            [-2.295999999999992, 0],
                            [0, -1.903999999999996],
                            [2.295999999999992, 0],
                            [0, -4.797333333333327],
                            [-0.3360000000000127, -0.7467000000000041],
                            [-0.7459999999999809, -0.4106999999999914],
                            [-1.194000000000017, 0],
                            [-0.3729999999999905, 0.03730000000000189],
                            [-0.3360000000000127, 0.03729999999998768],
                            [0, -1.810666666666663],
                            [0.6350000000000477, -0.07469999999999288],
                            [0.48599999999999, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-3.173000000000002, 0],
                            [-1.753999999999962, -1.792000000000002],
                            [0, -4.890666666666661],
                            [-1.773333333333369, 0],
                            [0, -1.903999999999996],
                            [0.2800000000000296, 0],
                            [1.418999999999983, 0],
                            [0.7839999999999918, -0.8213000000000079],
                            [0, -0.7839999999999989],
                            [2.109333333333325, 0],
                            [0, 2.314666666666668],
                            [2.295999999999992, 0],
                            [0, 1.903999999999996],
                            [-2.295999999999992, 0],
                            [0, 4.797333333333327],
                            [0, 1.045299999999997],
                            [0.3359999999999559, 0.7092999999999989],
                            [0.7470000000000141, 0.3733000000000004],
                            [0.2989999999999782, 0],
                            [0.3740000000000236, -0.03730000000000189],
                            [0, 1.810666666666663],
                            [-0.5220000000000482, 0.0747000000000071],
                            [-0.6339999999999577, 0.0747000000000071],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-354.5325317382812, -77.50520324707031],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [210.259, 7.951999999999998],
                            [210.259, 0.6720000000000041],
                            [216.587, 0.6720000000000041],
                            [216.587, 7.951999999999998],
                            [210.259, 7.951999999999998],
                            [210.259, 7.951999999999998],
                            [210.259, 7.951999999999998],
                          ],
                          i: [
                            [0, 0],
                            [0, 2.426666666666662],
                            [-2.109333333333325, 0],
                            [0, -2.426666666666662],
                            [2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -2.426666666666662],
                            [2.109333333333325, 0],
                            [0, 2.426666666666662],
                            [-2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-354.5325317382812, -77.50520324707031],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [210.259, 42.392],
                            [210.259, 12.096],
                            [216.587, 12.096],
                            [216.587, 42.392],
                            [210.259, 42.392],
                            [210.259, 42.392],
                            [210.259, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [0, 10.09866666666667],
                            [-2.109333333333325, 0],
                            [0, -10.09866666666667],
                            [2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -10.09866666666666],
                            [2.109333333333325, 0],
                            [0, 10.09866666666666],
                            [-2.109333333333325, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-354.5325317382812, -77.50520324707031],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [169.688, 42.392],
                            [159.272, 12.096],
                            [165.992, 12.096],
                            [173.944, 36.232],
                            [171.592, 36.232],
                            [179.712, 12.096],
                            [185.48, 12.096],
                            [193.544, 36.232],
                            [191.192, 36.232],
                            [199.2, 12.096],
                            [205.92, 12.096],
                            [195.448, 42.392],
                            [189.736, 42.392],
                            [181.56, 17.696],
                            [183.632, 17.696],
                            [175.456, 42.392],
                            [169.688, 42.392],
                            [169.688, 42.392],
                            [169.688, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [3.47199999999998, 10.09866666666667],
                            [-2.240000000000009, 0],
                            [-2.650666666666666, -8.045333333333332],
                            [0.7839999999999918, 0],
                            [-2.706666666666649, 8.045333333333332],
                            [-1.922666666666657, 0],
                            [-2.687999999999988, -8.045333333333332],
                            [0.7839999999999918, 0],
                            [-2.669333333333327, 8.045333333333332],
                            [-2.240000000000009, 0],
                            [3.490666666666641, -10.09866666666667],
                            [1.903999999999996, 0],
                            [2.725333333333367, 8.232],
                            [-0.6906666666666865, 0],
                            [2.72533333333331, -8.232],
                            [1.922666666666657, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-3.47199999999998, -10.09866666666666],
                            [2.240000000000009, 0],
                            [2.650666666666666, 8.045333333333332],
                            [-0.7839999999999918, 0],
                            [2.706666666666649, -8.045333333333332],
                            [1.922666666666657, 0],
                            [2.687999999999988, 8.045333333333332],
                            [-0.7839999999999918, 0],
                            [2.669333333333327, -8.045333333333332],
                            [2.240000000000009, 0],
                            [-3.490666666666641, 10.09866666666666],
                            [-1.903999999999996, 0],
                            [-2.725333333333367, -8.232],
                            [0.6906666666666865, 0],
                            [-2.72533333333331, 8.232],
                            [-1.922666666666657, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-354.5325317382812, -77.50520324707031],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "fl",
                  c: { a: 0, k: [1, 1, 1], ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [155.86146545410156, 56.001014709472656],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [99.99999403953552, 99.99999403953552],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
            {
              ty: "gr",
              it: [
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [132.444, 43.06400000000001],
                            [124.38, 40.992],
                            [118.948, 35.28],
                            [116.988, 27.16],
                            [118.948, 19.040000000000006],
                            [124.324, 13.49600000000001],
                            [131.94, 11.424000000000007],
                            [138.044, 12.600000000000009],
                            [142.58, 15.848],
                            [145.38, 20.49600000000001],
                            [146.388, 26.096],
                            [146.332, 27.608],
                            [146.108, 29.064000000000007],
                            [121.972, 29.064000000000007],
                            [121.972, 24.024],
                            [142.524, 24.024],
                            [139.5, 26.320000000000007],
                            [139.108, 21.448000000000008],
                            [136.308, 18.032],
                            [131.94, 16.744],
                            [127.46, 18.032],
                            [124.436, 21.616],
                            [123.596, 27.216000000000008],
                            [124.436, 32.592],
                            [127.684, 36.176],
                            [132.5, 37.464],
                            [137.148, 36.232],
                            [140.228, 33.040000000000006],
                            [145.38, 35.56],
                            [142.58, 39.42400000000001],
                            [138.1, 42.11200000000001],
                            [132.444, 43.06400000000001],
                            [132.444, 43.06400000000001],
                            [132.444, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [2.351999999999975, 1.381299999999996],
                            [1.305999999999983, 2.389300000000006],
                            [0, 2.986699999999999],
                            [-1.307000000000016, 2.35199999999999],
                            [-2.240000000000009, 1.343999999999994],
                            [-2.838000000000022, 0],
                            [-1.79200000000003, -0.784000000000006],
                            [-1.232000000000028, -1.381299999999996],
                            [-0.6350000000000477, -1.754700000000014],
                            [0, -1.978700000000003],
                            [0.03699999999997772, -0.5227000000000004],
                            [0.1120000000000232, -0.4480000000000075],
                            [8.045333333333303, 0],
                            [0, 1.680000000000007],
                            [-6.850666666666655, 0],
                            [1.007999999999981, -0.7653333333333308],
                            [0.6340000000000146, 1.4187000000000012],
                            [1.269000000000005, 0.8213000000000079],
                            [1.67999999999995, 0],
                            [1.305999999999983, -0.8586999999999989],
                            [0.7090000000000032, -1.567999999999998],
                            [-0.1499999999999773, -2.202700000000007],
                            [-0.7470000000000141, -1.530699999999996],
                            [-1.382000000000005, -0.8586999999999989],
                            [-1.791999999999973, 0],
                            [-1.269999999999982, 0.8213000000000079],
                            [-0.7469999999999573, 1.306699999999992],
                            [-1.717333333333329, -0.8400000000000034],
                            [1.269000000000005, -1.157300000000006],
                            [1.754000000000019, -0.6720000000000113],
                            [2.052999999999997, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-3.024000000000001, 0],
                            [-2.314999999999998, -1.4187000000000012],
                            [-1.307000000000016, -2.426699999999997],
                            [0, -3.061299999999989],
                            [1.343999999999994, -2.352000000000004],
                            [2.240000000000009, -1.3813000000000102],
                            [2.276999999999987, 0],
                            [1.791999999999973, 0.7839999999999918],
                            [1.231999999999971, 1.344000000000008],
                            [0.6719999999999686, 1.7547],
                            [0, 0.4852999999999952],
                            [-0.03800000000001091, 0.5227000000000004],
                            [-8.045333333333303, 0],
                            [0, -1.680000000000007],
                            [6.850666666666655, 0],
                            [-1.007999999999981, 0.7653333333333308],
                            [0.3730000000000473, -1.829300000000003],
                            [-0.5979999999999563, -1.456000000000003],
                            [-1.232000000000028, -0.8586999999999989],
                            [-1.680000000000007, 0],
                            [-1.307000000000016, 0.8213000000000079],
                            [-0.7100000000000364, 1.530699999999996],
                            [-0.186999999999955, 2.053299999999993],
                            [0.7839999999999918, 1.53070000000001],
                            [1.418000000000006, 0.8586999999999989],
                            [1.829000000000008, 0],
                            [1.305999999999983, -0.8212999999999937],
                            [1.717333333333329, 0.8400000000000034],
                            [-0.5980000000000132, 1.4187000000000012],
                            [-1.232000000000028, 1.11999999999999],
                            [-1.718000000000018, 0.6346999999999952],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-211.7300415039062, -77.67320251464844],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [95.32, 37.184],
                            [100.024, 35.896],
                            [103.328, 32.36800000000001],
                            [104.56, 27.216000000000008],
                            [103.328, 22.12],
                            [100.024, 18.592],
                            [95.32, 17.304],
                            [90.56, 18.592],
                            [87.256, 22.12],
                            [86.08000000000001, 27.216000000000008],
                            [87.256, 32.36800000000001],
                            [90.50399999999999, 35.896],
                            [95.32, 37.184],
                            [95.32, 37.184],
                            [95.32, 37.184],
                          ],
                          i: [
                            [0, 0],
                            [-1.381, 0.8586999999999989],
                            [-0.7839999999999918, 1.493299999999991],
                            [0, 1.903999999999996],
                            [0.820999999999998, 1.493299999999991],
                            [1.419000000000011, 0.8586999999999989],
                            [1.754999999999995, 0],
                            [1.418999999999983, -0.8586999999999989],
                            [0.7839999999999918, -1.493300000000005],
                            [0, -1.904000000000011],
                            [-0.7839999999999918, -1.5307000000000102],
                            [-1.381, -0.8586999999999989],
                            [-1.792000000000002, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [1.754999999999995, 0],
                            [1.419000000000011, -0.8586999999999989],
                            [0.820999999999998, -1.5307000000000102],
                            [0, -1.904000000000011],
                            [-0.7839999999999918, -1.493300000000005],
                            [-1.381, -0.8586999999999989],
                            [-1.754999999999995, 0],
                            [-1.419000000000011, 0.8586999999999989],
                            [-0.7839999999999918, 1.493299999999991],
                            [0, 1.903999999999996],
                            [0.7839999999999918, 1.493299999999991],
                            [1.419000000000011, 0.8586999999999989],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-211.7300415039062, -77.67320251464844],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [94.70400000000001, 43.06400000000001],
                            [86.864, 40.992],
                            [81.43199999999999, 35.28],
                            [79.47200000000001, 27.216000000000008],
                            [81.488, 19.152],
                            [86.91999999999999, 13.49600000000001],
                            [94.648, 11.424000000000007],
                            [101.088, 12.88],
                            [105.512, 16.912000000000006],
                            [104.56, 18.36800000000001],
                            [104.56, 0],
                            [110.832, 0],
                            [110.832, 42.392],
                            [104.84, 42.392],
                            [104.84, 36.232],
                            [105.568, 37.408],
                            [101.088, 41.608],
                            [94.70400000000001, 43.06400000000001],
                            [94.70400000000001, 43.06400000000001],
                            [94.70400000000001, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [2.314999999999998, 1.381299999999996],
                            [1.344000000000023, 2.389300000000006],
                            [0, 2.986699999999999],
                            [-1.343999999999994, 2.389300000000006],
                            [-2.276999999999987, 1.381299999999996],
                            [-2.875, 0],
                            [-1.8669999999999902, -0.9706999999999937],
                            [-1.082999999999998, -1.717300000000009],
                            [0.3173333333333233, -0.4853333333333296],
                            [0, 6.122666666666674],
                            [-2.090666666666664, 0],
                            [0, -14.13066666666667],
                            [1.99733333333333, 0],
                            [0, 2.053333333333327],
                            [-0.242666666666679, -0.3919999999999959],
                            [1.941000000000003, -0.9707000000000079],
                            [2.314999999999998, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-2.912000000000006, 0],
                            [-2.277000000000015, -1.4187000000000012],
                            [-1.306999999999988, -2.389300000000006],
                            [0, -2.986699999999999],
                            [1.343999999999994, -2.389300000000006],
                            [2.277000000000015, -1.3813000000000102],
                            [2.426999999999992, 0],
                            [1.867000000000019, 0.9707000000000079],
                            [-0.3173333333333233, 0.4853333333333296],
                            [0, -6.122666666666674],
                            [2.090666666666664, 0],
                            [0, 14.13066666666667],
                            [-1.99733333333333, 0],
                            [0, -2.053333333333327],
                            [0.242666666666679, 0.3919999999999959],
                            [-1.045000000000016, 1.829300000000003],
                            [-1.941000000000003, 0.9706999999999937],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-211.7300415039062, -77.67320251464844],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [57.40100000000001, 43.06400000000001],
                            [51.968999999999994, 42],
                            [48.38499999999999, 38.976],
                            [47.09700000000001, 34.384],
                            [48.161, 29.960000000000008],
                            [51.577, 26.656000000000006],
                            [57.345, 24.752],
                            [67.87299999999999, 23.016000000000005],
                            [67.87299999999999, 28],
                            [58.577, 29.624],
                            [54.881, 31.248],
                            [53.70500000000001, 34.16],
                            [54.992999999999995, 37.016000000000005],
                            [58.40899999999999, 38.08],
                            [62.88900000000001, 36.96000000000001],
                            [65.91300000000001, 33.992],
                            [66.977, 29.792],
                            [66.977, 22.008],
                            [65.297, 18.36800000000001],
                            [60.929, 16.912000000000006],
                            [56.505, 18.256],
                            [53.761, 21.616],
                            [48.496999999999986, 18.98400000000001],
                            [51.240999999999985, 15.064000000000007],
                            [55.66499999999999, 12.376],
                            [61.09700000000001, 11.424000000000007],
                            [67.42500000000001, 12.768],
                            [71.737, 16.52],
                            [73.305, 22.008],
                            [73.305, 42.392],
                            [67.257, 42.392],
                            [67.257, 36.904],
                            [68.54499999999999, 37.072],
                            [65.80099999999999, 40.264],
                            [62.04900000000001, 42.336],
                            [57.40100000000001, 43.06400000000001],
                            [57.40100000000001, 43.06400000000001],
                            [57.40100000000001, 43.06400000000001],
                          ],
                          i: [
                            [0, 0],
                            [1.568000000000012, 0.7092999999999989],
                            [0.8590000000000089, 1.2693000000000012],
                            [0, 1.7547],
                            [-0.7090000000000032, 1.306699999999992],
                            [-1.531000000000006, 0.8960000000000008],
                            [-2.314999999999998, 0.3733000000000004],
                            [-3.509333333333331, 0.5786666666666633],
                            [0, -1.661333333333332],
                            [3.098666666666674, -0.541333333333327],
                            [0.7839999999999918, -0.784000000000006],
                            [0, -1.194699999999997],
                            [-0.8590000000000089, -0.7467000000000041],
                            [-1.381, 0],
                            [-1.269000000000005, 0.7466999999999899],
                            [-0.7090000000000032, 1.2319999999999993],
                            [0, 1.530699999999996],
                            [0, 2.594666666666669],
                            [1.120000000000005, 0.9332999999999885],
                            [1.829000000000008, 0],
                            [1.269000000000005, -0.8960000000000008],
                            [0.5970000000000084, -1.381299999999996],
                            [1.754666666666679, 0.8773333333333255],
                            [-1.268999999999977, 1.11999999999999],
                            [-1.680000000000007, 0.6346999999999952],
                            [-1.903999999999996, 0],
                            [-1.829000000000008, -0.8960000000000008],
                            [-1.0080000000000098, -1.6053],
                            [0, -2.090699999999998],
                            [0, -6.794666666666672],
                            [2.015999999999991, 0],
                            [0, 1.829333333333338],
                            [-0.429333333333318, -0.05599999999999739],
                            [1.120000000000005, -0.8959999999999866],
                            [1.418999999999983, -0.4852999999999952],
                            [1.716999999999985, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [-2.053000000000026, 0],
                            [-1.531000000000006, -0.7467000000000041],
                            [-0.8589999999999804, -1.306699999999992],
                            [0, -1.642700000000005],
                            [0.7469999999999857, -1.306700000000006],
                            [1.531000000000006, -0.8960000000000008],
                            [3.509333333333331, -0.5786666666666633],
                            [0, 1.661333333333332],
                            [-3.098666666666674, 0.541333333333327],
                            [-1.680000000000007, 0.2987000000000108],
                            [-0.7839999999999918, 0.7467000000000041],
                            [0, 1.157300000000006],
                            [0.896000000000015, 0.7092999999999989],
                            [1.717000000000013, 0],
                            [1.306999999999988, -0.7467000000000041],
                            [0.7089999999999748, -1.2693000000000012],
                            [0, -2.594666666666669],
                            [0, -1.493299999999991],
                            [-1.082999999999998, -0.9707000000000079],
                            [-1.680000000000007, 0],
                            [-1.2319999999999993, 0.8586999999999989],
                            [-1.754666666666679, -0.8773333333333255],
                            [0.5600000000000023, -1.493300000000005],
                            [1.269000000000005, -1.157300000000006],
                            [1.717000000000013, -0.6347000000000094],
                            [2.388999999999982, 0],
                            [1.86699999999999, 0.8960000000000008],
                            [1.045000000000016, 1.568000000000012],
                            [0, 6.794666666666672],
                            [-2.015999999999991, 0],
                            [0, -1.829333333333338],
                            [0.429333333333318, 0.05599999999999739],
                            [-0.7089999999999748, 1.2319999999999993],
                            [-1.082999999999998, 0.8960000000000008],
                            [-1.381, 0.4853000000000094],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-211.7300415039062, -77.67320251464844],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "gr",
                  it: [
                    {
                      ty: "sh",
                      d: 1,
                      ks: {
                        a: 0,
                        k: {
                          c: true,
                          v: [
                            [0, 42.392],
                            [0, 0.6720000000000041],
                            [6.159999999999997, 0.6720000000000041],
                            [21.84, 22.400000000000006],
                            [18.75999999999999, 22.400000000000006],
                            [34.16, 0.6720000000000041],
                            [40.31999999999999, 0.6720000000000041],
                            [40.31999999999999, 42.392],
                            [33.768, 42.392],
                            [33.768, 8.456000000000003],
                            [36.232, 9.128],
                            [20.49600000000001, 30.632000000000005],
                            [19.824000000000012, 30.632000000000005],
                            [4.424000000000007, 9.128],
                            [6.608000000000004, 8.456000000000003],
                            [6.608000000000004, 42.392],
                            [0, 42.392],
                            [0, 42.392],
                            [0, 42.392],
                          ],
                          i: [
                            [0, 0],
                            [0, 13.90666666666666],
                            [-2.053333333333342, 0],
                            [-5.226666666666659, -7.242666666666665],
                            [1.026666666666671, 0],
                            [-5.133333333333326, 7.242666666666672],
                            [-2.053333333333342, 0],
                            [0, -13.90666666666667],
                            [2.183999999999997, 0],
                            [0, 11.312],
                            [-0.8213333333333424, -0.2240000000000038],
                            [5.245333333333321, -7.168000000000006],
                            [0.2239999999999895, 0],
                            [5.133333333333326, 7.168000000000006],
                            [-0.7280000000000086, 0.2240000000000038],
                            [0, -11.312],
                            [2.202666666666659, 0],
                            [0, 0],
                            [0, 0],
                          ],
                          o: [
                            [0, -13.90666666666667],
                            [2.053333333333342, 0],
                            [5.226666666666659, 7.242666666666672],
                            [-1.026666666666671, 0],
                            [5.133333333333326, -7.242666666666665],
                            [2.053333333333342, 0],
                            [0, 13.90666666666666],
                            [-2.183999999999997, 0],
                            [0, -11.312],
                            [0.8213333333333424, 0.2240000000000038],
                            [-5.245333333333321, 7.168000000000006],
                            [-0.2239999999999895, 0],
                            [-5.133333333333326, -7.168000000000006],
                            [0.7280000000000086, -0.2240000000000038],
                            [0, 11.312],
                            [-2.202666666666659, 0],
                            [0, 0],
                            [0, 0],
                            [0, 0],
                          ],
                        },
                      },
                    },
                    {
                      ty: "tm",
                      s: { a: 0, k: 0, ix: 2 },
                      e: { a: 0, k: 100, ix: 2 },
                      o: { a: 0, k: 0, ix: 2 },
                      m: 1,
                    },
                    {
                      ty: "tr",
                      p: {
                        a: 0,
                        k: [-211.7300415039062, -77.67320251464844],
                        ix: 2,
                      },
                      a: { a: 0, k: [0, 0], ix: 2 },
                      s: { a: 0, k: [100, 100], ix: 2 },
                      r: { a: 0, k: 0, ix: 2 },
                      o: { a: 0, k: 100, ix: 2 },
                      sk: { a: 0, k: 0, ix: 2 },
                      sa: { a: 0, k: 0, ix: 2 },
                    },
                  ],
                },
                {
                  ty: "fl",
                  c: { a: 0, k: [1, 1, 1], ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [2.91259765625, 56.001014709472656],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [99.99999403953552, 99.99999403953552],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
            {
              ty: "gr",
              it: [
                {
                  ty: "rc",
                  d: 1,
                  s: { a: 0, k: [702.6863719370097, 144], ix: 2 },
                  p: { a: 0, k: [0, 0], ix: 2 },
                  r: { a: 0, k: 72, ix: 2 },
                },
                {
                  ty: "fl",
                  c: { a: 0, k: [0, 0, 0], ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  r: 1,
                  bm: 0,
                },
                {
                  ty: "tm",
                  s: { a: 0, k: 0, ix: 2 },
                  e: { a: 0, k: 100, ix: 2 },
                  o: { a: 0, k: 0, ix: 2 },
                  m: 1,
                },
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [56.54167175292969, -0.000022762338630855083],
                    ix: 2,
                  },
                  a: { a: 0, k: [0, 0], ix: 2 },
                  s: {
                    a: 0,
                    k: [99.99999403953552, 99.99999403953552],
                    ix: 2,
                  },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 80, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
            {
              ty: "tr",
              p: {
                a: 0,
                k: [122.0000003294881, 25.00000012138912],
                ix: 2,
              },
              a: {
                a: 0,
                k: [56.54167175292969, -0.00002288818359375],
                ix: 2,
              },
              s: {
                a: 0,
                k: [34.403572049765366, 34.403572049765366],
                ix: 2,
              },
              r: { a: 0, k: 0, ix: 2 },
              o: { a: 0, k: 100, ix: 2 },
              sk: { a: 0, k: 0, ix: 2 },
              sa: { a: 0, k: 0, ix: 2 },
            },
          ],
        },
      ],
      ip: 0,
      op: 270,
      st: 0,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 26,
      ty: 4,
      nm: "SVG Import 1",
      sr: 1,
      ks: {
        p: { a: 0, k: [0, 0], ix: 2 },
        a: { a: 0, k: [0, 0], ix: 2 },
        s: { a: 0, k: [100, 100], ix: 2 },
        r: { a: 0, k: 0, ix: 2 },
        o: { a: 0, k: 100, ix: 2 },
        sk: { a: 0, k: 0, ix: 2 },
        sa: { a: 0, k: 0, ix: 2 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ty: "gr",
              it: [
                {
                  ty: "tr",
                  p: {
                    a: 0,
                    k: [263.0274353027344, 40.00499725341797],
                    ix: 2,
                  },
                  a: { a: 0, k: [244.9499969482422, 40], ix: 2 },
                  s: { a: 0, k: [107.38007164000443, 100], ix: 2 },
                  r: { a: 0, k: 0, ix: 2 },
                  o: { a: 0, k: 100, ix: 2 },
                  sk: { a: 0, k: 0, ix: 2 },
                  sa: { a: 0, k: 0, ix: 2 },
                },
              ],
            },
            {
              ty: "tr",
              p: {
                a: 0,
                k: [703.1099853515625, 113.18309783935547],
                ix: 2,
              },
              a: {
                a: 0,
                k: [244.9499740600586, 40.00499725341797],
                ix: 2,
              },
              s: {
                a: 0,
                k: [287.042263448407, 287.042263448407],
                ix: 2,
              },
              r: { a: 0, k: 0, ix: 2 },
              o: { a: 0, k: 100, ix: 2 },
              sk: { a: 0, k: 0, ix: 2 },
              sa: { a: 0, k: 0, ix: 2 },
            },
          ],
        },
      ],
      ip: 0,
      op: 270,
      st: 0,
      bm: 0,
    },
    {
      ddd: 0,
      refId: "0",
      w: 1510,
      h: 228,
      ind: 27,
      ty: 0,
      nm: "DOCCA",
      sr: 1,
      ks: {
        p: { a: 0, k: [755, 114], ix: 2 },
        a: { a: 0, k: [755, 114], ix: 2 },
        s: { a: 0, k: [100, 100], ix: 2 },
        r: { a: 0, k: 0, ix: 2 },
        o: { a: 0, k: 100, ix: 2 },
        sk: { a: 0, k: 0, ix: 2 },
        sa: { a: 0, k: 0, ix: 2 },
      },
      ao: 0,
      ip: 0,
      op: 270,
      st: 0,
      bm: 0,
    },
  ],
  markers = [],
  props = {},
  animationData = {
    v,
    fr,
    ip,
    op,
    w,
    h,
    nm,
    ddd,
    assets,
    layers,
    markers,
    props,
  },
  MainBlock = () => {
    const n = useBreakpoints(),
      { isTouchDevices: e } = useDeviceType(),
      { isModelRendered: t } = useLandingContext(),
      r = getOrbitingDotParams("main", n),
      s = getOrbitingDotParams("main-mini", n),
      { ref: o, inView: a } = useInView({ triggerOnce: !1, threshold: 0 }),
      l = reactExports.useRef(null),
      [c, u] = reactExports.useState(!1);
    reactExports.useEffect(() => {
      (e || a) &&
        l.current &&
        !c &&
        (l.current.setSpeed(0.8), l.current.goToAndPlay(0), u(!0));
    }, [e, a, c]);
    const p = e || (a && t) ? "animateDescr visible" : "",
      N = reactExports.useMemo(
        () => ({
          scrollSnapAlign: "start",
          position: "relative",
          boxShadow:
            n === "small"
              ? "inset 0px 0px 100px 50px rgba(0, 0, 0, 0.2)"
              : "inset 0px 0px 300px 200px rgba(0, 0, 0, 0.2)",
        }),
        [n]
      );
    return jsxRuntimeExports.jsxs(Main, {
      id: "mainBlock",
      style: N,
      children: [
        jsxRuntimeExports.jsx(Header, {}),
        jsxRuntimeExports.jsx(OrbitingDot, { ...r }),
        jsxRuntimeExports.jsx(OrbitingDot, { ...s }),
        jsxRuntimeExports.jsx(GradientBG, {
          width: n === "small" ? "65%" : "45%",
          height: n === "small" ? "35%" : "55%",
          opacity: 0.3,
          position:
            n === "small" ? "top: 15%; left: 0%;" : "top: 15%; left: 8%;",
          children: jsxRuntimeExports.jsx(Gradient, {
            style: {
              background:
                "radial-gradient(50% 50% at 50% 50%, #4535d3ed 30%, #4637d194 60%, #7f64f200 105%)",
            },
          }),
        }),
        jsxRuntimeExports.jsx(Container, {
          children: jsxRuntimeExports.jsxs(Content$5, {
            children: [
              jsxRuntimeExports.jsxs(TextContainer$1, {
                children: [
                  (e || (t && a)) &&
                    jsxRuntimeExports.jsx(Lottie, {
                      animationData,
                      loop: !1,
                      lottieRef: l,
                    }),
                  jsxRuntimeExports.jsxs(TextDescr$1, {
                    ref: o,
                    className: p,
                    children: [
                      "Train Your SYNTHETIC INTELLIGENCE,",
                      jsxRuntimeExports.jsx("br", {}),
                      " Own the Future",
                    ],
                  }),
                ],
              }),
              jsxRuntimeExports.jsx(ButtonContainer$1, {
                children:
                  t &&
                  jsxRuntimeExports.jsx(ButtonAnimate, { text: "Apply Now" }),
              }),
              t &&
                jsxRuntimeExports.jsxs(Hint, {
                  ref: o,
                  className: p,
                  children: [
                    jsxRuntimeExports.jsx("span", {
                      children: "scroll to explore",
                    }),
                    jsxRuntimeExports.jsx(DArrow, {}),
                  ],
                }),
            ],
          }),
        }),
      ],
    });
  },
  RoadmapWrapper = dt.div`
  position: relative;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, #c7acff 0%, #ffffff 100%);
`,
  Wrapper = dt.div`
  width: 100%;
  height: 100%;
  filter: contrast(100%) brightness(100%);
  background: linear-gradient(
      90deg,
      rgba(199, 172, 255, 0.6),
      rgba(255, 255, 255, 0.6)
    ),
    url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");

  @media (min-width: 48rem) {
    height: 100vh;
  }
`,
  Content$2 = dt.div`
  padding: 2.8125rem 0 6.875rem 0;
  @media (min-width: 48rem) {
    padding: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 100%;
  }
`,
  moveUpTitle$2 = mt`
  0% {
    transform: translateY(2rem);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
`,
  Title = dt.h1`
  font-weight: 400;
  font-size: 1.5rem;
  line-height: 130%;
  letter-spacing: 0.16rem;
  text-transform: uppercase;
  text-align: center;
  color: var(--tertiary-color);
  opacity: 0;
  @media (min-width: 48rem) {
    font-size: 2rem;
    position: absolute;
    align-self: center;
    top: 4.875rem;
    &.animateTitle {
      animation: ${moveUpTitle$2} 1s ease-out;
    }
    &.visible {
      opacity: 1;
    }
  }
`,
  ListItems = dt.ul`
  display: flex;
  gap: 2.1875rem;
  margin-top: 2.5rem;
  flex-wrap: wrap;
  align-items: center;
  flex-direction: column;
  @media (min-width: 48rem) {
    flex-wrap: nowrap;
    flex-direction: row;
    gap: 0.9375rem;
    align-items: inherit;
  }
`,
  smoothFlyInFromRight = mt`
  0% {
    opacity: 0;
    transform: translateX(100px);
  }
  60% {
    opacity: 0.7;
    transform: translateX(-5px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
`,
  Item = dt.li`
  position: relative;
  width: 18.0625rem;
  display: flex;
  flex-direction: column;

  @media (min-width: 48rem) {
    opacity: 0;
    &.animateItem1 {
      animation: ${smoothFlyInFromRight} 0.8s ease-in-out 0.3s forwards;
    }
    &.animateItem2 {
      animation: ${smoothFlyInFromRight} 0.8s ease-in-out 0.6s forwards;
    }
    &.animateItem3 {
      animation: ${smoothFlyInFromRight} 0.8s ease-in-out 0.9s forwards;
    }
    &.animateItem4 {
      animation: ${smoothFlyInFromRight} 0.8s ease-in-out 1.2s forwards;
    }
    &.animateItem5 {
      animation: ${smoothFlyInFromRight} 0.8s ease-in-out 1.5s forwards;
    }
  }

  @media (min-width: 48rem) {
    width: 100%;
    &:nth-of-type(even) {
      margin-top: 6.875rem;
    }
  }
`,
  ItemTitle = dt.div`
  h2 {
    font-weight: 400;
    font-size: 3.375rem;
    line-height: 130%;
    letter-spacing: 0.16rem;
    text-transform: uppercase;
    color: var(--tertiary-color);
  }
`,
  ItemDate = dt.div`
  margin-top: 1.25rem;
  span {
    font-weight: 400;
    font-size: 0.9375rem;
    line-height: 130%;
    letter-spacing: 0.16rem;
    text-transform: uppercase;
    color: var(--primary-color);
  }
`,
  ItemLine = dt.div`
  width: 100%;
  height: 0.5rem;
  background: var(--tertiary-color);
  margin-top: 1.5625rem;
`,
  ItemText = dt.div`
  margin-top: 1.25rem;
  p {
    font-weight: 400;
    font-size: 0.9375rem;
    line-height: 130%;
    letter-spacing: 0.16rem;
    text-transform: uppercase;
    color: var(--black-color);
    @media (min-width: 48rem) {
      font-size: 1.375rem;
    }
  }
`,
  drawLine$1 = mt`
  0% {
    width: 0;
    opacity: 0;
  }
  100% {
    transform: translateX(0%);
   width: 100%;
   opacity: 1;
  }
`,
  ItemDecoration = dt.div`
  margin-top: 1.5625rem;
  height: 0.125rem;
  background: linear-gradient(
    to right,
    rgba(112, 88, 213, 0.15) 15%,
    rgba(112, 88, 213, 1) 100%
  );


  @media (min-width: 48rem) {
    width: 0;
    opacity: 0;
    &.animateLine1 {
      animation: ${drawLine$1} 0.8s ease-in-out 1.5s forwards;
    }
    &.animateLine2 {
      animation: ${drawLine$1} 0.8s ease-in-out 1.8s forwards;
    }
    &.animateLine3 {
      animation: ${drawLine$1} 0.8s ease-in-out 2.1s forwards;
    }
    &.animateLine4 {
      animation: ${drawLine$1} 0.8s ease-in-out 2.4s forwards;
    }
    &.animateLine5 {
      animation: ${drawLine$1} 0.8s ease-in-out 2.7s forwards;
    }
  }
`,
  Roadmap = () => {
    const [n, e] = reactExports.useState(window.innerWidth >= 768),
      { ref: t, inView: r } = useInView({ triggerOnce: !1, threshold: 0 }),
      s = (Ct) =>
        Ct * parseFloat(getComputedStyle(document.documentElement).fontSize),
      { ref: o, inView: a } = useInView({ triggerOnce: !1 }),
      { ref: l, inView: c } = useInView({
        triggerOnce: !1,
        threshold: 0,
        rootMargin: `0px 0px ${s(6.875)}px 0px`,
      }),
      { ref: u, inView: p } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: N, inView: P } = useInView({
        triggerOnce: !1,
        threshold: 0,
        rootMargin: `0px 0px ${s(6.875)}px 0px`,
      }),
      { ref: de, inView: me } = useInView({ triggerOnce: !1, threshold: 0 });
    reactExports.useEffect(() => {
      const Ct = () => e(window.innerWidth >= 768);
      return (
        window.addEventListener("resize", Ct),
        () => window.removeEventListener("resize", Ct)
      );
    }, []);
    const Ye = reactExports.useMemo(
        () => (r ? "animateTitle visible" : ""),
        [r]
      ),
      nt = reactExports.useMemo(() => (a ? "animateItem1 visible" : ""), [a]),
      Be = reactExports.useMemo(() => (c ? "animateItem2 visible" : ""), [c]),
      ot = reactExports.useMemo(() => (p ? "animateItem3 visible" : ""), [p]),
      st = reactExports.useMemo(() => (P ? "animateItem4 visible" : ""), [P]),
      vt = reactExports.useMemo(() => (me ? "animateItem5 visible" : ""), [me]),
      xt = reactExports.useMemo(() => (a ? "animateLine1 visible" : ""), [a]),
      St = reactExports.useMemo(() => (c ? "animateLine2 visible" : ""), [c]),
      wt = reactExports.useMemo(() => (p ? "animateLine3 visible" : ""), [p]),
      bt = reactExports.useMemo(() => (P ? "animateLine4 visible" : ""), [P]),
      Tt = reactExports.useMemo(() => (me ? "animateLine5 visible" : ""), [me]);
    return jsxRuntimeExports.jsx(RoadmapWrapper, {
      id: "roadmap",
      style: { scrollSnapAlign: "start" },
      children: jsxRuntimeExports.jsx(Wrapper, {
        children: jsxRuntimeExports.jsx(Container, {
          style: { padding: n ? void 0 : "0 1rem" },
          children: jsxRuntimeExports.jsxs(Content$2, {
            children: [
              jsxRuntimeExports.jsx(Title, {
                ref: t,
                className: Ye,
                children: "Roadmap",
              }),
              jsxRuntimeExports.jsxs(ListItems, {
                children: [
                  jsxRuntimeExports.jsxs(Item, {
                    ref: o,
                    className: nt,
                    children: [
                      jsxRuntimeExports.jsx(ItemTitle, {
                        children: jsxRuntimeExports.jsx("h2", {
                          children: "01/01",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDate, {
                        children: jsxRuntimeExports.jsx("span", {
                          children: "june 2025",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemLine, {}),
                      jsxRuntimeExports.jsx(ItemText, {
                        children: jsxRuntimeExports.jsx("p", {
                          children: "DOCCA SOFT LAUNCH",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDecoration, { className: xt }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs(Item, {
                    ref: l,
                    className: Be,
                    children: [
                      jsxRuntimeExports.jsx(ItemTitle, {
                        children: jsxRuntimeExports.jsx("h2", {
                          children: "q1",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDate, {
                        children: jsxRuntimeExports.jsx("span", {
                          children: "November 2025",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemLine, {}),
                      jsxRuntimeExports.jsx(ItemText, {
                        children: jsxRuntimeExports.jsx("p", {
                          children: "SEQUENCE MINING",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDecoration, { className: St }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs(Item, {
                    ref: u,
                    className: ot,
                    children: [
                      jsxRuntimeExports.jsx(ItemTitle, {
                        children: jsxRuntimeExports.jsx("h2", {
                          children: "q2",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDate, {
                        children: jsxRuntimeExports.jsx("span", {
                          children: "February 2026",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemLine, {}),
                      jsxRuntimeExports.jsx(ItemText, {
                        children: jsxRuntimeExports.jsx("p", {
                          children: "AI DATA LABELING",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDecoration, { className: wt }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs(Item, {
                    ref: N,
                    className: st,
                    children: [
                      jsxRuntimeExports.jsx(ItemTitle, {
                        children: jsxRuntimeExports.jsx("h2", {
                          children: "q3",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDate, {
                        children: jsxRuntimeExports.jsx("span", {
                          children: "june 2026",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemLine, {}),
                      jsxRuntimeExports.jsx(ItemText, {
                        children: jsxRuntimeExports.jsx("p", {
                          children: "DOCCA AGENTS",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDecoration, { className: bt }),
                    ],
                  }),
                  jsxRuntimeExports.jsxs(Item, {
                    ref: de,
                    className: vt,
                    children: [
                      jsxRuntimeExports.jsx(ItemTitle, {
                        children: jsxRuntimeExports.jsx("h2", {
                          children: "q4",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDate, {
                        children: jsxRuntimeExports.jsx("span", {
                          children: "November 2026",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemLine, {}),
                      jsxRuntimeExports.jsx(ItemText, {
                        children: jsxRuntimeExports.jsx("p", {
                          children: "Multi-Platform Integration",
                        }),
                      }),
                      jsxRuntimeExports.jsx(ItemDecoration, { className: Tt }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        }),
      }),
    });
  },
  FeaturesWrapper = dt.div`
  width: 100vw;
  height: 100%;
  @media (min-width: 48rem) {
    height: 100vh;
  }
`,
  Content$1 = dt.div`
  height: 100%;
  width: 100%;
  flex-direction: column;
  display: flex;
  justify-content: center;
  padding: 2.75rem 0 3.75rem 0;
  @media (min-width: 48rem) {
    align-items: center;
    flex-direction: row;
    justify-content: space-between;
  }

  .react-multi-carousel-list {
    ul {
      display: flex;
      flex-direction: column;
      gap: 2.625rem;
      align-items: flex-end;
      width: 100%;
      @media (min-width: 48rem) {
        gap: 2.375rem;
      }
      li {
        width: 100% !important;
        display: flex;
        align-items: center;
        justify-content: start;
        @media (min-width: 48rem) {
          display: list-item;
          width: 30rem !important;
          justify-content: center;
        }
      }
    }
  }
`,
  Card = dt.div`
  cursor: pointer;
  height: 2.125rem !important;
  width: 100%;
  max-width: 37.8125rem;
  position: relative;
  text-align: center;
  display: flex;
  justify-content: start;
  align-items: center;
  background: transparent;
  padding: 0.625rem 0;
  transition: transform 0.3s ease, height 0.3s ease, opacity 0.3s ease,
  max-width 0.3s ease, color 0.3s ease, background-color 0.3s ease;

  h4 {
    font-size: 1rem;
    letter-spacing: 0.12rem;
    text-transform: uppercase;
    color: #fff;
    position: relative;
    @media (min-width: 48rem) {
      font-size: 1.5rem;
      letter-spacing: 0.1625rem;
      -webkit-transition: background 0.3s linear;
      -moz-transition: background 0.3s linear;
      -o-transition: background 0.3s linear;
      transition: background 0.3s linear;
    }
  }

    @media (min-width: 48rem) {
      button { 
      }
      &:hover button {
        background: rgb(127, 100, 242, 0.1)!important;
        color: rgb(127, 100, 242);
        svg {
          path {
            fill: #7658F6;
          }
        }
      }
      
      &:not(.active):hover h4 {
        opacity: 1;
         transition: opacity 0.3s ease, color 0.3s ease;
       }
       &:not(.active) h4::after {
         transition: opacity 0.3s ease;
       }
       &:not(.active):hover h4::after {
         content: attr(data-text);
         position: absolute;
         left: 0;
         top: 0;
         width: 100%;
         height: 100%;
         background: linear-gradient(90deg, #7658F6 0%, #C3B3FA 100%);
         -webkit-background-clip: text;
         -webkit-text-fill-color: transparent;
         opacity: 1;
         transition: opacity 0.3s ease;
       }
   
    }

  p {
    font-weight: 400;
    font-size: 0.75rem;
    line-height: 183%;
    letter-spacing: 0.12rem;
    text-transform: uppercase;
    display: none;
  }

  &.active {
    display: flex;
    flex-direction: column;
    max-width: 37.8125rem;
    padding: 1.25rem;
    height: 14.875rem !important;
    gap: 1.625rem;
    background: linear-gradient(
        90deg,
        rgba(199, 172, 255, 0.6),
        rgba(255, 255, 255, 0.6)
      ),
      url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.3' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
    clip-path: polygon(
      0 0,
      calc(100% - 2.0625rem) 0,
      100% 2.0625rem,
      100% 100%,
      0% 100%
    );
    color: #000;
    text-align: left;
    @media (min-width: 48rem) {
      padding: 1.475rem 1.8625rem 1rem;
    }

    h4 {
      align-self: flex-start;
      font-size: 1.375rem;
      color: inherit;
      text-transform: uppercase;
      @media (min-width: 48rem) {
        font-size: 2rem;
      }
    }

    p {
      text-transform: uppercase;
      display: block;
    }
  }
`,
  CardText = dt.h4`
    
`;
var lib = {},
  Carousel$1 = {},
  utils = {},
  clones = {},
  hasRequiredClones;
function requireClones() {
  return (
    hasRequiredClones ||
      ((hasRequiredClones = 1),
      (function (n) {
        function e(a, l, c) {
          var u = l.slidesToShow,
            p = l.currentSlide;
          return c.length > 2 * u
            ? a + 2 * u
            : p >= c.length
            ? c.length + a
            : a;
        }
        function t(a, l) {
          if (l.length > 2 * a) {
            for (
              var c = {}, u = l.length - 2 * a, p = l.length - u, N = u, P = 0;
              P < p;
              P++
            )
              (c[P] = N), N++;
            var de = l.length + p,
              me = de + l.slice(0, 2 * a).length,
              Ye = 0;
            for (P = de; P <= me; P++) (c[P] = Ye), Ye++;
            var nt = de,
              Be = 0;
            for (P = p; P < nt; P++) (c[P] = Be), Be++;
            return c;
          }
          c = {};
          var ot = 3 * l.length,
            st = 0;
          for (P = 0; P < ot; P++) (c[P] = st), ++st === l.length && (st = 0);
          return c;
        }
        function r(a, l) {
          return l.length < a
            ? l
            : l.length > 2 * a
            ? l.slice(l.length - 2 * a, l.length).concat(l, l.slice(0, 2 * a))
            : l.concat(l, l);
        }
        function s(a, l) {
          return l.length > 2 * a ? 2 * a : l.length;
        }
        function o(a, l, c) {
          var u,
            p = a.currentSlide,
            N = a.slidesToShow,
            P = a.itemWidth,
            de = a.totalItems,
            me = 0,
            Ye = 0,
            nt = p === 0,
            Be = l.length - (l.length - 2 * N);
          return (
            l.length < N
              ? ((Ye = me = 0), (nt = u = !1))
              : l.length > 2 * N
              ? ((u = p >= Be + l.length) && (Ye = -P * (me = p - l.length)),
                nt && (Ye = -P * (me = Be + (l.length - 2 * N))))
              : ((u = p >= 2 * l.length) && (Ye = -P * (me = p - l.length)),
                nt &&
                  (Ye = c.showDots
                    ? -P * (me = l.length)
                    : -P * (me = de / 3))),
            {
              isReachingTheEnd: u,
              isReachingTheStart: nt,
              nextSlide: me,
              nextPosition: Ye,
            }
          );
        }
        Object.defineProperty(n, "__esModule", { value: !0 }),
          (n.getOriginalCounterPart = e),
          (n.getOriginalIndexLookupTableByClones = t),
          (n.getClones = r),
          (n.getInitialSlideInInfiniteMode = s),
          (n.checkClonesPosition = o);
      })(clones)),
    clones
  );
}
var elementWidth = {},
  hasRequiredElementWidth;
function requireElementWidth() {
  if (hasRequiredElementWidth) return elementWidth;
  (hasRequiredElementWidth = 1),
    Object.defineProperty(elementWidth, "__esModule", { value: !0 });
  function n(r, s, o, a) {
    var l = 0,
      c = a || o;
    return (
      s &&
        c &&
        (l = r[c].partialVisibilityGutter || r[c].paritialVisibilityGutter),
      l
    );
  }
  function e(r, s) {
    var o;
    return s[r] && (o = (100 / s[r].items).toFixed(1)), o;
  }
  function t(r, s, o) {
    return Math.round(o / (s + (r.centerMode ? 1 : 0)));
  }
  return (
    (elementWidth.getPartialVisibilityGutter = n),
    (elementWidth.getWidthFromDeviceType = e),
    (elementWidth.getItemClientSideWidth = t),
    elementWidth
  );
}
var common = {},
  hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  (hasRequiredCommon = 1),
    Object.defineProperty(common, "__esModule", { value: !0 });
  var n = requireElementWidth();
  function e(N) {
    var P = N.slidesToShow;
    return N.totalItems < P;
  }
  function t(N, P) {
    var de,
      me = N.domLoaded,
      Ye = N.slidesToShow,
      nt = N.containerWidth,
      Be = N.itemWidth,
      ot = P.deviceType,
      st = P.responsive,
      vt = P.ssr,
      xt = P.partialVisbile,
      St = P.partialVisible,
      wt = !!(me && Ye && nt && Be);
    vt && ot && !wt && (de = n.getWidthFromDeviceType(ot, st));
    var bt = !!(vt && ot && !wt && de);
    return {
      shouldRenderOnSSR: bt,
      flexBisis: de,
      domFullyLoaded: wt,
      partialVisibilityGutter: n.getPartialVisibilityGutter(
        st,
        xt || St,
        ot,
        N.deviceType
      ),
      shouldRenderAtAll: bt || wt,
    };
  }
  function r(N, P) {
    var de = P.currentSlide,
      me = P.slidesToShow;
    return de <= N && N < de + me;
  }
  function s(N, P, de) {
    var me = de || N.transform;
    return (!P.infinite && N.currentSlide === 0) || e(N)
      ? me
      : me + N.itemWidth / 2;
  }
  function o(N) {
    return !(0 < N.currentSlide);
  }
  function a(N) {
    var P = N.currentSlide,
      de = N.totalItems;
    return !(P + N.slidesToShow < de);
  }
  function l(N, P, de, me) {
    P === void 0 && (P = 0);
    var Ye = N.currentSlide,
      nt = N.slidesToShow,
      Be = a(N),
      ot = !de.infinite && Be,
      st = me || N.transform;
    if (e(N)) return st;
    var vt = st + Ye * P;
    return ot ? vt + (N.containerWidth - (N.itemWidth - P) * nt) : vt;
  }
  function c(N, P) {
    return N.rtl ? -1 * P : P;
  }
  function u(N, P, de) {
    var me = P.partialVisbile,
      Ye = P.partialVisible,
      nt = P.responsive,
      Be = P.deviceType,
      ot = P.centerMode,
      st = de || N.transform,
      vt = n.getPartialVisibilityGutter(nt, me || Ye, Be, N.deviceType);
    return c(P, Ye || me ? l(N, vt, P, de) : ot ? s(N, P, de) : st);
  }
  function p(N, P) {
    var de = N.domLoaded,
      me = N.slidesToShow,
      Ye = N.containerWidth,
      nt = N.itemWidth,
      Be = P.deviceType,
      ot = P.responsive,
      st = P.slidesToSlide || 1,
      vt = !!(de && me && Ye && nt);
    return (
      P.ssr &&
        P.deviceType &&
        !vt &&
        Object.keys(ot).forEach(function (xt) {
          var St = ot[xt].slidesToSlide;
          Be === xt && St && (st = St);
        }),
      vt &&
        Object.keys(ot).forEach(function (xt) {
          var St = ot[xt],
            wt = St.breakpoint,
            bt = St.slidesToSlide,
            Tt = wt.max,
            Ct = wt.min;
          bt && window.innerWidth >= Ct && window.innerWidth <= Tt && (st = bt);
        }),
      st
    );
  }
  return (
    (common.notEnoughChildren = e),
    (common.getInitialState = t),
    (common.getIfSlideIsVisbile = r),
    (common.getTransformForCenterMode = s),
    (common.isInLeftEnd = o),
    (common.isInRightEnd = a),
    (common.getTransformForPartialVsibile = l),
    (common.parsePosition = c),
    (common.getTransform = u),
    (common.getSlidesToSlide = p),
    common
  );
}
var throttle = {},
  hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle) return throttle;
  (hasRequiredThrottle = 1),
    Object.defineProperty(throttle, "__esModule", { value: !0 });
  var n = function (e, t, r) {
    var s;
    return function () {
      var o = arguments;
      s ||
        (e.apply(this, o),
        (s = !0),
        typeof r == "function" && r(!0),
        setTimeout(function () {
          (s = !1), typeof r == "function" && r(!1);
        }, t));
    };
  };
  return (throttle.default = n), throttle;
}
var throwError = {},
  hasRequiredThrowError;
function requireThrowError() {
  return (
    hasRequiredThrowError ||
      ((hasRequiredThrowError = 1),
      (function (n) {
        function e(t, r) {
          var s = r.partialVisbile,
            o = r.partialVisible,
            a = r.centerMode,
            l = r.ssr,
            c = r.responsive;
          if ((s || o) && a)
            throw new Error(
              "center mode can not be used at the same time with partialVisible"
            );
          if (!c)
            throw l
              ? new Error(
                  "ssr mode need to be used in conjunction with responsive prop"
                )
              : new Error(
                  "Responsive prop is needed for deciding the amount of items to show on the screen"
                );
          if (c && typeof c != "object")
            throw new Error("responsive prop must be an object");
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), (n.default = e);
      })(throwError)),
    throwError
  );
}
var next = {},
  hasRequiredNext;
function requireNext() {
  if (hasRequiredNext) return next;
  (hasRequiredNext = 1),
    Object.defineProperty(next, "__esModule", { value: !0 });
  var n = requireCommon();
  function e(t, r, s) {
    s === void 0 && (s = 0);
    var o,
      a,
      l = t.slidesToShow,
      c = t.currentSlide,
      u = t.itemWidth,
      p = t.totalItems,
      N = n.getSlidesToSlide(t, r),
      P = c + 1 + s + l + (0 < s ? 0 : N);
    return (
      (a =
        P <= p
          ? -u * (o = c + s + (0 < s ? 0 : N))
          : p < P && c !== p - l
          ? -u * (o = p - l)
          : (o = void 0)),
      { nextSlides: o, nextPosition: a }
    );
  }
  return (next.populateNextSlides = e), next;
}
var previous = {},
  hasRequiredPrevious;
function requirePrevious() {
  if (hasRequiredPrevious) return previous;
  (hasRequiredPrevious = 1),
    Object.defineProperty(previous, "__esModule", { value: !0 });
  var n = requireReact(),
    e = requireCommon(),
    t = requireCommon();
  function r(s, o, a) {
    a === void 0 && (a = 0);
    var l,
      c,
      u = s.currentSlide,
      p = s.itemWidth,
      N = s.slidesToShow,
      P = o.children,
      de = o.showDots,
      me = o.infinite,
      Ye = e.getSlidesToSlide(s, o),
      nt = u - a - (0 < a ? 0 : Ye),
      Be = (n.Children.toArray(P).length - N) % Ye;
    return (
      (c =
        0 <= nt
          ? ((l = nt),
            de && !me && 0 < Be && t.isInRightEnd(s) && (l = u - Be),
            -p * l)
          : (l = nt < 0 && u !== 0 ? 0 : void 0)),
      { nextSlides: l, nextPosition: c }
    );
  }
  return (previous.populatePreviousSlides = r), previous;
}
var mouseOrTouchMove = {},
  hasRequiredMouseOrTouchMove;
function requireMouseOrTouchMove() {
  return (
    hasRequiredMouseOrTouchMove ||
      ((hasRequiredMouseOrTouchMove = 1),
      (function (n) {
        function e(t, r, s, o, a, l) {
          var c,
            u,
            p = t.itemWidth,
            N = t.slidesToShow,
            P = t.totalItems,
            de = t.currentSlide,
            me = r.infinite,
            Ye = !1,
            nt = Math.round((s - o) / p),
            Be = Math.round((o - s) / p),
            ot = s < a;
          if (a < s && nt <= N) {
            c = "right";
            var st = Math.abs(-p * (P - N)),
              vt = l - (o - a),
              xt = de === P - N;
            (Math.abs(vt) <= st || (xt && me)) && ((u = vt), (Ye = !0));
          }
          return (
            ot &&
              Be <= N &&
              ((c = "left"),
              ((vt = l + (a - o)) <= 0 || (de === 0 && me)) &&
                ((Ye = !0), (u = vt))),
            { direction: c, nextPosition: u, canContinue: Ye }
          );
        }
        Object.defineProperty(n, "__esModule", { value: !0 }),
          (n.populateSlidesOnMouseTouchMove = e);
      })(mouseOrTouchMove)),
    mouseOrTouchMove
  );
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  (hasRequiredUtils = 1),
    Object.defineProperty(utils, "__esModule", { value: !0 });
  var n = requireClones();
  (utils.getOriginalCounterPart = n.getOriginalCounterPart),
    (utils.getClones = n.getClones),
    (utils.checkClonesPosition = n.checkClonesPosition),
    (utils.getInitialSlideInInfiniteMode = n.getInitialSlideInInfiniteMode);
  var e = requireElementWidth();
  (utils.getWidthFromDeviceType = e.getWidthFromDeviceType),
    (utils.getPartialVisibilityGutter = e.getPartialVisibilityGutter),
    (utils.getItemClientSideWidth = e.getItemClientSideWidth);
  var t = requireCommon();
  (utils.getInitialState = t.getInitialState),
    (utils.getIfSlideIsVisbile = t.getIfSlideIsVisbile),
    (utils.getTransformForCenterMode = t.getTransformForCenterMode),
    (utils.getTransformForPartialVsibile = t.getTransformForPartialVsibile),
    (utils.isInLeftEnd = t.isInLeftEnd),
    (utils.isInRightEnd = t.isInRightEnd),
    (utils.notEnoughChildren = t.notEnoughChildren),
    (utils.getSlidesToSlide = t.getSlidesToSlide);
  var r = requireThrottle();
  utils.throttle = r.default;
  var s = requireThrowError();
  utils.throwError = s.default;
  var o = requireNext();
  utils.populateNextSlides = o.populateNextSlides;
  var a = requirePrevious();
  utils.populatePreviousSlides = a.populatePreviousSlides;
  var l = requireMouseOrTouchMove();
  return (
    (utils.populateSlidesOnMouseTouchMove = l.populateSlidesOnMouseTouchMove),
    utils
  );
}
var types = {},
  hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  var n =
    (types && types.__extends) ||
    (function () {
      var s = function (o, a) {
        return (s =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (l, c) {
              l.__proto__ = c;
            }) ||
          function (l, c) {
            for (var u in c) c.hasOwnProperty(u) && (l[u] = c[u]);
          })(o, a);
      };
      return function (o, a) {
        function l() {
          this.constructor = o;
        }
        s(o, a),
          (o.prototype =
            a === null
              ? Object.create(a)
              : ((l.prototype = a.prototype), new l()));
      };
    })();
  Object.defineProperty(types, "__esModule", { value: !0 });
  var e = requireReact();
  function t(s) {
    return "clientY" in s;
  }
  types.isMouseMoveEvent = t;
  var r = (function (s) {
    function o() {
      return (s !== null && s.apply(this, arguments)) || this;
    }
    return n(o, s), o;
  })(e.Component);
  return (types.default = r), types;
}
var Dots = {},
  dots = {},
  hasRequiredDots$1;
function requireDots$1() {
  if (hasRequiredDots$1) return dots;
  (hasRequiredDots$1 = 1),
    Object.defineProperty(dots, "__esModule", { value: !0 });
  var n = requireClones(),
    e = requireCommon();
  function t(r, s, o, a) {
    var l = {},
      c = e.getSlidesToSlide(s, o);
    return (
      Array(r)
        .fill(0)
        .forEach(function (u, p) {
          var N = n.getOriginalCounterPart(p, s, a);
          if (p === 0) l[0] = N;
          else {
            var P = l[p - 1] + c;
            l[p] = P;
          }
        }),
      l
    );
  }
  return (dots.getLookupTableForNextSlides = t), dots;
}
var hasRequiredDots;
function requireDots() {
  if (hasRequiredDots) return Dots;
  (hasRequiredDots = 1),
    Object.defineProperty(Dots, "__esModule", { value: !0 });
  var n = requireReact(),
    e = requireClones(),
    t = requireDots$1(),
    r = requireCommon(),
    s = function (o) {
      var a = o.props,
        l = o.state,
        c = o.goToSlide,
        u = o.getState,
        p = a.showDots,
        N = a.customDot,
        P = a.dotListClass,
        de = a.infinite,
        me = a.children;
      if (!p || r.notEnoughChildren(l)) return null;
      var Ye,
        nt = l.currentSlide,
        Be = l.slidesToShow,
        ot = r.getSlidesToSlide(l, a),
        st = n.Children.toArray(me);
      Ye = de
        ? Math.ceil(st.length / ot)
        : Math.ceil((st.length - Be) / ot) + 1;
      var vt = t.getLookupTableForNextSlides(Ye, l, a, st),
        xt = e.getOriginalIndexLookupTableByClones(Be, st),
        St = xt[nt];
      return n.createElement(
        "ul",
        { className: "react-multi-carousel-dot-list " + P },
        Array(Ye)
          .fill(0)
          .map(function (wt, bt) {
            var Tt, Ct;
            if (de) {
              Ct = vt[bt];
              var kt = xt[Ct];
              Tt = St === kt || (kt <= St && St < kt + ot);
            } else {
              var Dt = st.length - Be,
                Vt = bt * ot;
              Tt =
                (Ct = Dt < Vt ? Dt : Vt) === nt ||
                (Ct < nt && nt < Ct + ot && nt < st.length - Be);
            }
            return N
              ? n.cloneElement(N, {
                  index: bt,
                  active: Tt,
                  key: bt,
                  onClick: function () {
                    return c(Ct);
                  },
                  carouselState: u(),
                })
              : n.createElement(
                  "li",
                  {
                    "data-index": bt,
                    key: bt,
                    className:
                      "react-multi-carousel-dot " +
                      (Tt ? "react-multi-carousel-dot--active" : ""),
                  },
                  n.createElement("button", {
                    "aria-label": "Go to slide " + (bt + 1),
                    onClick: function () {
                      return c(Ct);
                    },
                  })
                );
          })
      );
    };
  return (Dots.default = s), Dots;
}
var Arrows = {},
  hasRequiredArrows;
function requireArrows() {
  if (hasRequiredArrows) return Arrows;
  (hasRequiredArrows = 1),
    Object.defineProperty(Arrows, "__esModule", { value: !0 });
  var n = requireReact(),
    e = function (r) {
      var s = r.customLeftArrow,
        o = r.getState,
        a = r.previous,
        l = r.disabled,
        c = r.rtl;
      if (s)
        return n.cloneElement(s, {
          onClick: function () {
            return a();
          },
          carouselState: o(),
          disabled: l,
          rtl: c,
        });
      var u = c ? "rtl" : "";
      return n.createElement("button", {
        "aria-label": "Go to previous slide",
        className:
          "react-multiple-carousel__arrow react-multiple-carousel__arrow--left " +
          u,
        onClick: function () {
          return a();
        },
        type: "button",
        disabled: l,
      });
    };
  Arrows.LeftArrow = e;
  var t = function (r) {
    var s = r.customRightArrow,
      o = r.getState,
      a = r.next,
      l = r.disabled,
      c = r.rtl;
    if (s)
      return n.cloneElement(s, {
        onClick: function () {
          return a();
        },
        carouselState: o(),
        disabled: l,
        rtl: c,
      });
    var u = c ? "rtl" : "";
    return n.createElement("button", {
      "aria-label": "Go to next slide",
      className:
        "react-multiple-carousel__arrow react-multiple-carousel__arrow--right " +
        u,
      onClick: function () {
        return a();
      },
      type: "button",
      disabled: l,
    });
  };
  return (Arrows.RightArrow = t), Arrows;
}
var CarouselItems = {},
  hasRequiredCarouselItems;
function requireCarouselItems() {
  if (hasRequiredCarouselItems) return CarouselItems;
  (hasRequiredCarouselItems = 1),
    Object.defineProperty(CarouselItems, "__esModule", { value: !0 });
  var n = requireReact(),
    e = requireUtils(),
    t = function (r) {
      var s = r.props,
        o = r.state,
        a = r.goToSlide,
        l = r.clones,
        c = r.notEnoughChildren,
        u = o.itemWidth,
        p = s.children,
        N = s.infinite,
        P = s.itemClass,
        de = s.itemAriaLabel,
        me = s.partialVisbile,
        Ye = s.partialVisible,
        nt = e.getInitialState(o, s),
        Be = nt.flexBisis,
        ot = nt.shouldRenderOnSSR,
        st = nt.domFullyLoaded,
        vt = nt.partialVisibilityGutter;
      return nt.shouldRenderAtAll
        ? (me &&
            console.warn(
              'WARNING: Please correct props name: "partialVisible" as old typo will be removed in future versions!'
            ),
          n.createElement(
            n.Fragment,
            null,
            (N ? l : n.Children.toArray(p)).map(function (xt, St) {
              return n.createElement(
                "li",
                {
                  key: St,
                  "data-index": St,
                  onClick: function () {
                    s.focusOnSelect && a(St);
                  },
                  "aria-hidden": e.getIfSlideIsVisbile(St, o)
                    ? "false"
                    : "true",
                  "aria-label":
                    de || (xt.props.ariaLabel ? xt.props.ariaLabel : null),
                  style: {
                    flex: ot ? "1 0 " + Be + "%" : "auto",
                    position: "relative",
                    width: st
                      ? ((me || Ye) && vt && !c ? u - vt : u) + "px"
                      : "auto",
                  },
                  className:
                    "react-multi-carousel-item " +
                    (e.getIfSlideIsVisbile(St, o)
                      ? "react-multi-carousel-item--active"
                      : "") +
                    " " +
                    P,
                },
                xt
              );
            })
          ))
        : null;
    };
  return (CarouselItems.default = t), CarouselItems;
}
var hasRequiredCarousel;
function requireCarousel() {
  if (hasRequiredCarousel) return Carousel$1;
  hasRequiredCarousel = 1;
  var n =
    (Carousel$1 && Carousel$1.__extends) ||
    (function () {
      var N = function (P, de) {
        return (N =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (me, Ye) {
              me.__proto__ = Ye;
            }) ||
          function (me, Ye) {
            for (var nt in Ye) Ye.hasOwnProperty(nt) && (me[nt] = Ye[nt]);
          })(P, de);
      };
      return function (P, de) {
        function me() {
          this.constructor = P;
        }
        N(P, de),
          (P.prototype =
            de === null
              ? Object.create(de)
              : ((me.prototype = de.prototype), new me()));
      };
    })();
  Object.defineProperty(Carousel$1, "__esModule", { value: !0 });
  var e = requireReact(),
    t = requireUtils(),
    r = requireTypes(),
    s = requireDots(),
    o = requireArrows(),
    a = requireCarouselItems(),
    l = requireCommon(),
    c = 400,
    u = "transform 400ms ease-in-out",
    p = (function (N) {
      function P(de) {
        var me = N.call(this, de) || this;
        return (
          (me.containerRef = e.createRef()),
          (me.listRef = e.createRef()),
          (me.state = {
            itemWidth: 0,
            slidesToShow: 0,
            currentSlide: 0,
            totalItems: e.Children.count(de.children),
            deviceType: "",
            domLoaded: !1,
            transform: 0,
            containerWidth: 0,
          }),
          (me.onResize = me.onResize.bind(me)),
          (me.handleDown = me.handleDown.bind(me)),
          (me.handleMove = me.handleMove.bind(me)),
          (me.handleOut = me.handleOut.bind(me)),
          (me.onKeyUp = me.onKeyUp.bind(me)),
          (me.handleEnter = me.handleEnter.bind(me)),
          (me.setIsInThrottle = me.setIsInThrottle.bind(me)),
          (me.next = t.throttle(
            me.next.bind(me),
            de.transitionDuration || c,
            me.setIsInThrottle
          )),
          (me.previous = t.throttle(
            me.previous.bind(me),
            de.transitionDuration || c,
            me.setIsInThrottle
          )),
          (me.goToSlide = t.throttle(
            me.goToSlide.bind(me),
            de.transitionDuration || c,
            me.setIsInThrottle
          )),
          (me.onMove = !1),
          (me.initialX = 0),
          (me.lastX = 0),
          (me.isAnimationAllowed = !1),
          (me.direction = ""),
          (me.initialY = 0),
          (me.isInThrottle = !1),
          (me.transformPlaceHolder = 0),
          me
        );
      }
      return (
        n(P, N),
        (P.prototype.resetTotalItems = function () {
          var de = this,
            me = e.Children.count(this.props.children),
            Ye = t.notEnoughChildren(this.state)
              ? 0
              : Math.max(0, Math.min(this.state.currentSlide, me));
          this.setState({ totalItems: me, currentSlide: Ye }, function () {
            de.setContainerAndItemWidth(de.state.slidesToShow, !0);
          });
        }),
        (P.prototype.setIsInThrottle = function (de) {
          de === void 0 && (de = !1), (this.isInThrottle = de);
        }),
        (P.prototype.setTransformDirectly = function (de, me) {
          var Ye = this.props.additionalTransfrom;
          this.transformPlaceHolder = de;
          var nt = l.getTransform(
            this.state,
            this.props,
            this.transformPlaceHolder
          );
          this.listRef &&
            this.listRef.current &&
            (this.setAnimationDirectly(me),
            (this.listRef.current.style.transform =
              "translate3d(" + (nt + Ye) + "px,0,0)"));
        }),
        (P.prototype.setAnimationDirectly = function (de) {
          this.listRef &&
            this.listRef.current &&
            (this.listRef.current.style.transition = de
              ? this.props.customTransition || u
              : "none");
        }),
        (P.prototype.componentDidMount = function () {
          this.setState({ domLoaded: !0 }),
            this.setItemsToShow(),
            window.addEventListener("resize", this.onResize),
            this.onResize(!0),
            this.props.keyBoardControl &&
              window.addEventListener("keyup", this.onKeyUp),
            this.props.autoPlay &&
              (this.autoPlay = setInterval(
                this.next,
                this.props.autoPlaySpeed
              ));
        }),
        (P.prototype.setClones = function (de, me, Ye, nt) {
          var Be = this;
          nt === void 0 && (nt = !1), (this.isAnimationAllowed = !1);
          var ot = e.Children.toArray(this.props.children),
            st = t.getInitialSlideInInfiniteMode(
              de || this.state.slidesToShow,
              ot
            ),
            vt = t.getClones(this.state.slidesToShow, ot),
            xt =
              ot.length < this.state.slidesToShow ? 0 : this.state.currentSlide;
          this.setState(
            { totalItems: vt.length, currentSlide: Ye && !nt ? xt : st },
            function () {
              Be.correctItemsPosition(me || Be.state.itemWidth);
            }
          );
        }),
        (P.prototype.setItemsToShow = function (de, me) {
          var Ye = this,
            nt = this.props.responsive;
          Object.keys(nt).forEach(function (Be) {
            var ot = nt[Be],
              st = ot.breakpoint,
              vt = ot.items,
              xt = st.max,
              St = st.min,
              wt = [window.innerWidth];
            window.screen &&
              window.screen.width &&
              wt.push(window.screen.width);
            var bt = Math.min.apply(Math, wt);
            St <= bt &&
              bt <= xt &&
              (Ye.setState({ slidesToShow: vt, deviceType: Be }),
              Ye.setContainerAndItemWidth(vt, de, me));
          });
        }),
        (P.prototype.setContainerAndItemWidth = function (de, me, Ye) {
          var nt = this;
          if (this.containerRef && this.containerRef.current) {
            var Be = this.containerRef.current.offsetWidth,
              ot = t.getItemClientSideWidth(this.props, de, Be);
            this.setState({ containerWidth: Be, itemWidth: ot }, function () {
              nt.props.infinite && nt.setClones(de, ot, me, Ye);
            }),
              me && this.correctItemsPosition(ot);
          }
        }),
        (P.prototype.correctItemsPosition = function (de, me, Ye) {
          me && (this.isAnimationAllowed = !0),
            !me && this.isAnimationAllowed && (this.isAnimationAllowed = !1);
          var nt =
            this.state.totalItems < this.state.slidesToShow
              ? 0
              : -de * this.state.currentSlide;
          Ye && this.setTransformDirectly(nt, !0),
            this.setState({ transform: nt });
        }),
        (P.prototype.onResize = function (de) {
          var me;
          (me = !!this.props.infinite && (typeof de != "boolean" || !de)),
            this.setItemsToShow(me);
        }),
        (P.prototype.componentDidUpdate = function (de, me) {
          var Ye = this,
            nt = de.keyBoardControl,
            Be = de.autoPlay,
            ot = de.children,
            st = me.containerWidth,
            vt = me.domLoaded,
            xt = me.currentSlide;
          if (
            (this.containerRef &&
              this.containerRef.current &&
              this.containerRef.current.offsetWidth !== st &&
              (this.itemsToShowTimeout && clearTimeout(this.itemsToShowTimeout),
              (this.itemsToShowTimeout = setTimeout(function () {
                Ye.setItemsToShow(!0);
              }, this.props.transitionDuration || c))),
            nt &&
              !this.props.keyBoardControl &&
              window.removeEventListener("keyup", this.onKeyUp),
            !nt &&
              this.props.keyBoardControl &&
              window.addEventListener("keyup", this.onKeyUp),
            Be &&
              !this.props.autoPlay &&
              this.autoPlay &&
              (clearInterval(this.autoPlay), (this.autoPlay = void 0)),
            Be ||
              !this.props.autoPlay ||
              this.autoPlay ||
              (this.autoPlay = setInterval(
                this.next,
                this.props.autoPlaySpeed
              )),
            ot.length !== this.props.children.length
              ? (P.clonesTimeout = setTimeout(function () {
                  Ye.props.infinite
                    ? Ye.setClones(
                        Ye.state.slidesToShow,
                        Ye.state.itemWidth,
                        !0,
                        !0
                      )
                    : Ye.resetTotalItems();
                }, this.props.transitionDuration || c))
              : this.props.infinite &&
                this.state.currentSlide !== xt &&
                this.correctClonesPosition({ domLoaded: vt }),
            this.transformPlaceHolder !== this.state.transform &&
              (this.transformPlaceHolder = this.state.transform),
            this.props.autoPlay &&
              this.props.rewind &&
              !this.props.infinite &&
              t.isInRightEnd(this.state))
          ) {
            var St = this.props.transitionDuration || c;
            P.isInThrottleTimeout = setTimeout(function () {
              Ye.setIsInThrottle(!1),
                Ye.resetAutoplayInterval(),
                Ye.goToSlide(0, void 0, !!Ye.props.rewindWithAnimation);
            }, St + this.props.autoPlaySpeed);
          }
        }),
        (P.prototype.correctClonesPosition = function (de) {
          var me = this,
            Ye = de.domLoaded,
            nt = e.Children.toArray(this.props.children),
            Be = t.checkClonesPosition(this.state, nt, this.props),
            ot = Be.isReachingTheEnd,
            st = Be.isReachingTheStart,
            vt = Be.nextSlide,
            xt = Be.nextPosition;
          this.state.domLoaded &&
            Ye &&
            (ot || st) &&
            ((this.isAnimationAllowed = !1),
            (P.transformTimeout = setTimeout(function () {
              me.setState({ transform: xt, currentSlide: vt });
            }, this.props.transitionDuration || c)));
        }),
        (P.prototype.next = function (de) {
          var me = this;
          de === void 0 && (de = 0);
          var Ye = this.props,
            nt = Ye.afterChange,
            Be = Ye.beforeChange;
          if (!t.notEnoughChildren(this.state)) {
            var ot = t.populateNextSlides(this.state, this.props, de),
              st = ot.nextSlides,
              vt = ot.nextPosition,
              xt = this.state.currentSlide;
            st !== void 0 &&
              vt !== void 0 &&
              (typeof Be == "function" && Be(st, this.getState()),
              (this.isAnimationAllowed = !0),
              this.props.shouldResetAutoplay && this.resetAutoplayInterval(),
              this.setState({ transform: vt, currentSlide: st }, function () {
                typeof nt == "function" &&
                  (P.afterChangeTimeout = setTimeout(function () {
                    nt(xt, me.getState());
                  }, me.props.transitionDuration || c));
              }));
          }
        }),
        (P.prototype.previous = function (de) {
          var me = this;
          de === void 0 && (de = 0);
          var Ye = this.props,
            nt = Ye.afterChange,
            Be = Ye.beforeChange;
          if (!t.notEnoughChildren(this.state)) {
            var ot = t.populatePreviousSlides(this.state, this.props, de),
              st = ot.nextSlides,
              vt = ot.nextPosition;
            if (st !== void 0 && vt !== void 0) {
              var xt = this.state.currentSlide;
              typeof Be == "function" && Be(st, this.getState()),
                (this.isAnimationAllowed = !0),
                this.props.shouldResetAutoplay && this.resetAutoplayInterval(),
                this.setState({ transform: vt, currentSlide: st }, function () {
                  typeof nt == "function" &&
                    (P.afterChangeTimeout2 = setTimeout(function () {
                      nt(xt, me.getState());
                    }, me.props.transitionDuration || c));
                });
            }
          }
        }),
        (P.prototype.resetAutoplayInterval = function () {
          this.props.autoPlay &&
            (clearInterval(this.autoPlay),
            (this.autoPlay = setInterval(this.next, this.props.autoPlaySpeed)));
        }),
        (P.prototype.componentWillUnmount = function () {
          window.removeEventListener("resize", this.onResize),
            this.props.keyBoardControl &&
              window.removeEventListener("keyup", this.onKeyUp),
            this.props.autoPlay &&
              this.autoPlay &&
              (clearInterval(this.autoPlay), (this.autoPlay = void 0)),
            this.itemsToShowTimeout && clearTimeout(this.itemsToShowTimeout),
            P.clonesTimeout && clearTimeout(P.clonesTimeout),
            P.isInThrottleTimeout && clearTimeout(P.isInThrottleTimeout),
            P.transformTimeout && clearTimeout(P.transformTimeout),
            P.afterChangeTimeout && clearTimeout(P.afterChangeTimeout),
            P.afterChangeTimeout2 && clearTimeout(P.afterChangeTimeout2),
            P.afterChangeTimeout3 && clearTimeout(P.afterChangeTimeout3);
        }),
        (P.prototype.resetMoveStatus = function () {
          (this.onMove = !1),
            (this.initialX = 0),
            (this.lastX = 0),
            (this.direction = ""),
            (this.initialY = 0);
        }),
        (P.prototype.getCords = function (de) {
          var me = de.clientX,
            Ye = de.clientY;
          return {
            clientX: l.parsePosition(this.props, me),
            clientY: l.parsePosition(this.props, Ye),
          };
        }),
        (P.prototype.handleDown = function (de) {
          if (
            !(
              (!r.isMouseMoveEvent(de) && !this.props.swipeable) ||
              (r.isMouseMoveEvent(de) && !this.props.draggable) ||
              this.isInThrottle
            )
          ) {
            var me = this.getCords(r.isMouseMoveEvent(de) ? de : de.touches[0]),
              Ye = me.clientX,
              nt = me.clientY;
            (this.onMove = !0),
              (this.initialX = Ye),
              (this.initialY = nt),
              (this.lastX = Ye),
              (this.isAnimationAllowed = !1);
          }
        }),
        (P.prototype.handleMove = function (de) {
          if (
            !(
              (!r.isMouseMoveEvent(de) && !this.props.swipeable) ||
              (r.isMouseMoveEvent(de) && !this.props.draggable) ||
              t.notEnoughChildren(this.state)
            )
          ) {
            var me = this.getCords(r.isMouseMoveEvent(de) ? de : de.touches[0]),
              Ye = me.clientX,
              nt = me.clientY,
              Be = this.initialX - Ye,
              ot = this.initialY - nt;
            if (this.onMove) {
              if (!(Math.abs(Be) > Math.abs(ot))) return;
              var st = t.populateSlidesOnMouseTouchMove(
                  this.state,
                  this.props,
                  this.initialX,
                  this.lastX,
                  Ye,
                  this.transformPlaceHolder
                ),
                vt = st.direction,
                xt = st.nextPosition,
                St = st.canContinue;
              vt &&
                ((this.direction = vt),
                St && xt !== void 0 && this.setTransformDirectly(xt)),
                (this.lastX = Ye);
            }
          }
        }),
        (P.prototype.handleOut = function (de) {
          this.props.autoPlay &&
            !this.autoPlay &&
            (this.autoPlay = setInterval(this.next, this.props.autoPlaySpeed));
          var me = de.type === "touchend" && !this.props.swipeable,
            Ye =
              (de.type === "mouseleave" || de.type === "mouseup") &&
              !this.props.draggable;
          if (!me && !Ye && this.onMove) {
            if ((this.setAnimationDirectly(!0), this.direction === "right"))
              if (this.initialX - this.lastX >= this.props.minimumTouchDrag) {
                var nt = Math.round(
                  (this.initialX - this.lastX) / this.state.itemWidth
                );
                this.next(nt);
              } else this.correctItemsPosition(this.state.itemWidth, !0, !0);
            this.direction === "left" &&
              (this.lastX - this.initialX > this.props.minimumTouchDrag
                ? ((nt = Math.round(
                    (this.lastX - this.initialX) / this.state.itemWidth
                  )),
                  this.previous(nt))
                : this.correctItemsPosition(this.state.itemWidth, !0, !0)),
              this.resetMoveStatus();
          }
        }),
        (P.prototype.isInViewport = function (de) {
          var me = de.getBoundingClientRect(),
            Ye = me.top,
            nt = Ye === void 0 ? 0 : Ye,
            Be = me.left,
            ot = Be === void 0 ? 0 : Be,
            st = me.bottom,
            vt = st === void 0 ? 0 : st,
            xt = me.right,
            St = xt === void 0 ? 0 : xt;
          return (
            0 <= nt &&
            0 <= ot &&
            vt <=
              (window.innerHeight || document.documentElement.clientHeight) &&
            St <= (window.innerWidth || document.documentElement.clientWidth)
          );
        }),
        (P.prototype.isChildOfCarousel = function (de) {
          return (
            !!(de instanceof Element && this.listRef && this.listRef.current) &&
            this.listRef.current.contains(de)
          );
        }),
        (P.prototype.onKeyUp = function (de) {
          var me = de.target;
          switch (de.keyCode) {
            case 37:
              if (this.isChildOfCarousel(me)) return this.previous();
              break;
            case 39:
              if (this.isChildOfCarousel(me)) return this.next();
              break;
            case 9:
              if (
                this.isChildOfCarousel(me) &&
                me instanceof HTMLInputElement &&
                this.isInViewport(me)
              )
                return this.next();
          }
        }),
        (P.prototype.handleEnter = function (de) {
          r.isMouseMoveEvent(de) &&
            this.autoPlay &&
            this.props.autoPlay &&
            this.props.pauseOnHover &&
            (clearInterval(this.autoPlay), (this.autoPlay = void 0));
        }),
        (P.prototype.goToSlide = function (de, me, Ye) {
          var nt = this;
          if ((Ye === void 0 && (Ye = !0), !this.isInThrottle)) {
            var Be = this.state.itemWidth,
              ot = this.props,
              st = ot.afterChange,
              vt = ot.beforeChange,
              xt = this.state.currentSlide;
            typeof vt != "function" ||
              (me && (typeof me != "object" || me.skipBeforeChange)) ||
              vt(de, this.getState()),
              (this.isAnimationAllowed = Ye),
              this.props.shouldResetAutoplay && this.resetAutoplayInterval(),
              this.setState(
                { currentSlide: de, transform: -Be * de },
                function () {
                  nt.props.infinite &&
                    nt.correctClonesPosition({ domLoaded: !0 }),
                    typeof st != "function" ||
                      (me && (typeof me != "object" || me.skipAfterChange)) ||
                      (P.afterChangeTimeout3 = setTimeout(function () {
                        st(xt, nt.getState());
                      }, nt.props.transitionDuration || c));
                }
              );
          }
        }),
        (P.prototype.getState = function () {
          return this.state;
        }),
        (P.prototype.renderLeftArrow = function (de) {
          var me = this,
            Ye = this.props,
            nt = Ye.customLeftArrow,
            Be = Ye.rtl;
          return e.createElement(o.LeftArrow, {
            customLeftArrow: nt,
            getState: function () {
              return me.getState();
            },
            previous: this.previous,
            disabled: de,
            rtl: Be,
          });
        }),
        (P.prototype.renderRightArrow = function (de) {
          var me = this,
            Ye = this.props,
            nt = Ye.customRightArrow,
            Be = Ye.rtl;
          return e.createElement(o.RightArrow, {
            customRightArrow: nt,
            getState: function () {
              return me.getState();
            },
            next: this.next,
            disabled: de,
            rtl: Be,
          });
        }),
        (P.prototype.renderButtonGroups = function () {
          var de = this,
            me = this.props.customButtonGroup;
          return me
            ? e.cloneElement(me, {
                previous: function () {
                  return de.previous();
                },
                next: function () {
                  return de.next();
                },
                goToSlide: function (Ye, nt) {
                  return de.goToSlide(Ye, nt);
                },
                carouselState: this.getState(),
              })
            : null;
        }),
        (P.prototype.renderDotsList = function () {
          var de = this;
          return e.createElement(s.default, {
            state: this.state,
            props: this.props,
            goToSlide: this.goToSlide,
            getState: function () {
              return de.getState();
            },
          });
        }),
        (P.prototype.renderCarouselItems = function () {
          var de = [];
          if (this.props.infinite) {
            var me = e.Children.toArray(this.props.children);
            de = t.getClones(this.state.slidesToShow, me);
          }
          return e.createElement(a.default, {
            clones: de,
            goToSlide: this.goToSlide,
            state: this.state,
            notEnoughChildren: t.notEnoughChildren(this.state),
            props: this.props,
          });
        }),
        (P.prototype.render = function () {
          var de = this.props,
            me = de.deviceType,
            Ye = de.arrows,
            nt = de.renderArrowsWhenDisabled,
            Be = de.removeArrowOnDeviceType,
            ot = de.infinite,
            st = de.containerClass,
            vt = de.sliderClass,
            xt = de.customTransition,
            St = de.additionalTransfrom,
            wt = de.renderDotsOutside,
            bt = de.renderButtonGroupOutside,
            Tt = de.className,
            Ct = de.rtl,
            kt = t.getInitialState(this.state, this.props),
            Dt = kt.shouldRenderOnSSR,
            Vt = kt.shouldRenderAtAll,
            Ht = t.isInLeftEnd(this.state),
            qt = t.isInRightEnd(this.state),
            Ft =
              Ye &&
              !(
                Be &&
                ((me && -1 < Be.indexOf(me)) ||
                  (this.state.deviceType &&
                    -1 < Be.indexOf(this.state.deviceType)))
              ) &&
              !t.notEnoughChildren(this.state) &&
              Vt,
            Bt = !ot && Ht,
            Mt = !ot && qt,
            Pt = l.getTransform(this.state, this.props);
          return e.createElement(
            e.Fragment,
            null,
            e.createElement(
              "div",
              {
                className: "react-multi-carousel-list " + st + " " + Tt,
                dir: Ct ? "rtl" : "ltr",
                ref: this.containerRef,
              },
              e.createElement(
                "ul",
                {
                  ref: this.listRef,
                  className: "react-multi-carousel-track " + vt,
                  style: {
                    transition: this.isAnimationAllowed ? xt || u : "none",
                    overflow: Dt ? "hidden" : "unset",
                    transform: "translate3d(" + (Pt + St) + "px,0,0)",
                  },
                  onMouseMove: this.handleMove,
                  onMouseDown: this.handleDown,
                  onMouseUp: this.handleOut,
                  onMouseEnter: this.handleEnter,
                  onMouseLeave: this.handleOut,
                  onTouchStart: this.handleDown,
                  onTouchMove: this.handleMove,
                  onTouchEnd: this.handleOut,
                },
                this.renderCarouselItems()
              ),
              Ft && (!Bt || nt) && this.renderLeftArrow(Bt),
              Ft && (!Mt || nt) && this.renderRightArrow(Mt),
              Vt && !bt && this.renderButtonGroups(),
              Vt && !wt && this.renderDotsList()
            ),
            Vt && wt && this.renderDotsList(),
            Vt && bt && this.renderButtonGroups()
          );
        }),
        (P.defaultProps = {
          slidesToSlide: 1,
          infinite: !1,
          draggable: !0,
          swipeable: !0,
          arrows: !0,
          renderArrowsWhenDisabled: !1,
          containerClass: "",
          sliderClass: "",
          itemClass: "",
          keyBoardControl: !0,
          autoPlaySpeed: 3e3,
          showDots: !1,
          renderDotsOutside: !1,
          renderButtonGroupOutside: !1,
          minimumTouchDrag: 80,
          className: "",
          dotListClass: "",
          focusOnSelect: !1,
          centerMode: !1,
          additionalTransfrom: 0,
          pauseOnHover: !0,
          shouldResetAutoplay: !0,
          rewind: !1,
          rtl: !1,
          rewindWithAnimation: !1,
        }),
        P
      );
    })(e.Component);
  return (Carousel$1.default = p), Carousel$1;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  (hasRequiredLib = 1), Object.defineProperty(lib, "__esModule", { value: !0 });
  var n = requireCarousel();
  return (lib.default = n.default), lib;
}
var reactMultiCarousel, hasRequiredReactMultiCarousel;
function requireReactMultiCarousel() {
  return (
    hasRequiredReactMultiCarousel ||
      ((hasRequiredReactMultiCarousel = 1),
      (reactMultiCarousel = requireLib())),
    reactMultiCarousel
  );
}
var reactMultiCarouselExports = requireReactMultiCarousel();
const MultiCarousel = getDefaultExportFromCjs(reactMultiCarouselExports),
  CarouselContainer = dt.div`
  position: relative;

  height: fit-content;
`,
  GradientLeft = dt.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 10%;
  height: 100%;
  background: linear-gradient(to right, rgba(0, 0, 0, 0.7), transparent);
  pointer-events: none;
  z-index: 2;
`,
  GradientRight = dt.div`
  position: absolute;
  top: 0;
  right: 0;
  width: 10%;
  height: 100%;
  background: linear-gradient(to left, rgba(0, 0, 0, 0.7), transparent);
  pointer-events: none;
  z-index: 2;
`,
  defaultResponsive = {
    mobile: {
      breakpoint: { max: 4e3, min: 0 },
      items: 1,
      partialVisibilityGutter: 1e3,
    },
  },
  Carousel = reactExports.forwardRef((n, e) => {
    const { enableGradient: t = !1 } = n,
      r = reactExports.useRef(null);
    return (
      reactExports.useImperativeHandle(e, () => ({
        next: () => {
          var s;
          return (s = r.current) == null ? void 0 : s.next();
        },
        previous: () => {
          var s;
          return (s = r.current) == null ? void 0 : s.previous();
        },
        goToSlide: (s) => {
          var o;
          return (o = r.current) == null ? void 0 : o.goToSlide(s);
        },
      })),
      jsxRuntimeExports.jsxs(CarouselContainer, {
        children: [
          t &&
            jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [
                jsxRuntimeExports.jsx(GradientLeft, {}),
                jsxRuntimeExports.jsx(GradientRight, {}),
              ],
            }),
          jsxRuntimeExports.jsx(MultiCarousel, {
            ref: r,
            ...n,
            responsive: n.responsive || defaultResponsive,
          }),
        ],
      })
    );
  }),
  Features = () => {
    const n = reactExports.useRef(null),
      [e, t] = reactExports.useState(1),
      { ref: r, inView: s } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: o, inView: a } = useInView({ triggerOnce: !1, threshold: 0 }),
      l = useBreakpoints(),
      c = getOrbitingDotParams("future", l),
      u = [
        {
          id: 1,
          title: "Avatar Builder",
          descr:
            "Create a fully customizable AI persona that learns, adapts, and grows with you. Transform your digital twin into a powerful, intelligent assistant tailored to your unique needs.",
        },
        {
          id: 2,
          title: "Sequence Tapping",
          descr:
            "Engage in innovative, gamified training sequences that allow you to directly influence and shape your AI's learning path. Turn training into an interactive, rewarding experience.",
        },
        {
          id: 3,
          title: "Knowledge Graphs",
          descr:
            "Transform every interaction into valuable data. Our advanced system organizes and structures your AI's learning, creating a comprehensive knowledge ecosystem that continually expands.",
        },
        {
          id: 4,
          title: "Hive Mind",
          descr:
            "Join collaborative challenges that leverage collective intelligence. Work together with a global community to train and evolve AI ecosystems, pushing the boundaries of artificial intelligence.",
        },
        {
          id: 5,
          title: "DOCCA NPC",
          descr:
            "Meet your AI companion DOCCA, an intuitive NPC that guides you through training quests, provides insights, and helps you navigate the complex world of AI development.",
        },
        {
          id: 6,
          title: "Secure Wallets",
          descr:
            "Seamlessly integrate with leading Web3 wallets like Sentience, Ton, and Trust. Securely store your tokens, NFTs, and digital assets while maintaining full control of your digital identity.",
        },
        {
          id: 7,
          title: "AI Marketplace",
          descr:
            "Buy, sell, and trade unique AI modules, skill sets, and visual enhancements. Build, customize, and monetize your digital personas in a thriving, innovative ecosystem.",
        },
      ],
      p = (me) => {
        t(me + 1);
      },
      N = {
        mobile: {
          breakpoint: { max: 3e3, min: 0 },
          items: 7,
          partialVisibilityGutter: 0,
        },
      },
      P = reactExports.useMemo(() => (s ? "animateTitle visible" : ""), [s]),
      de = reactExports.useMemo(() => (a ? "animateDescr visible" : ""), [a]);
    return jsxRuntimeExports.jsxs(FeaturesWrapper, {
      id: "features",
      style: {
        scrollSnapAlign: "start",
        position: "relative",
        boxShadow:
          l === "small"
            ? "inset 0px 0px 100px 50px rgba(0, 0, 0, 0.2)"
            : "inset 0px 0px 300px 200px rgba(0, 0, 0, 0.2)",
      },
      children: [
        jsxRuntimeExports.jsx(OrbitingDot, { ...c }),
        jsxRuntimeExports.jsx(GradientBG, {
          width: l === "small" ? "80%" : "60%",
          height: l === "small" ? "65%" : "75%",
          opacity: 0.2,
          position:
            l === "small" ? "top: 10%; left: -10%;" : "top: 15%; left: 5%;",
          children: jsxRuntimeExports.jsx(Gradient, {
            style: {
              background:
                "radial-gradient(50% 50% at 50% 50%, #4535d3ed 30%, #4637d194 60%, #7f64f200 105%)",
            },
          }),
        }),
        jsxRuntimeExports.jsx(Container, {
          children: jsxRuntimeExports.jsxs(Content$1, {
            children: [
              jsxRuntimeExports.jsxs(TextBlockAnimate, {
                children: [
                  jsxRuntimeExports.jsx(TextTitle$1, {
                    ref: r,
                    className: P,
                    children: "AI Future",
                  }),
                  jsxRuntimeExports.jsx(TextDescr$2, {
                    ref: o,
                    className: de,
                    children:
                      "Unlock the next frontier of artificial intelligence through collaborative learning, personalized development, and groundbreaking Web3 technologies that put you at the center of AI evolution.",
                  }),
                ],
              }),
              jsxRuntimeExports.jsx("div", {
                style: { display: "flex  " },
                children: jsxRuntimeExports.jsx("div", {
                  style: {
                    height: "100%",
                    marginTop: l === "small" ? "10rem" : void 0,
                    width: l === "small" ? "100%" : "30rem",
                  },
                  children: jsxRuntimeExports.jsx(Carousel, {
                    ref: n,
                    arrows: !1,
                    draggable: !1,
                    swipeable: !1,
                    responsive: N,
                    children: u.map((me, Ye) => {
                      const nt = e - 1 === Ye;
                      return jsxRuntimeExports.jsx(
                        Card,
                        {
                          className: nt ? "active" : "",
                          style: { backgroundColor: nt ? "#fff" : "" },
                          onClick: () => p(Ye),
                          children: nt
                            ? jsxRuntimeExports.jsxs(
                                jsxRuntimeExports.Fragment,
                                {
                                  children: [
                                    jsxRuntimeExports.jsx("h4", {
                                      children: me.title,
                                    }),
                                    jsxRuntimeExports.jsx("p", {
                                      children: me.descr,
                                    }),
                                  ],
                                }
                              )
                            : jsxRuntimeExports.jsxs(
                                jsxRuntimeExports.Fragment,
                                {
                                  children: [
                                    jsxRuntimeExports.jsx(Button$1, {
                                      borderColor: colors.whiteColor,
                                      decoration: "basic",
                                      style: {
                                        height: "2.125rem",
                                        width: "2.125rem",
                                        marginRight: "1rem",
                                        background: "#FFFFFF1A",
                                        fontSize: "1.125rem",
                                        borderTop: "0",
                                        borderBottom: "0",
                                      },
                                      children:
                                        Ye + 1 !== e ? `0${Ye + 1}` : "",
                                    }),
                                    jsxRuntimeExports.jsx(CardText, {
                                      "data-text": me.title,
                                      children: me.title,
                                    }),
                                  ],
                                }
                              ),
                        },
                        me.id
                      );
                    }),
                  }),
                }),
              }),
            ],
          }),
        }),
      ],
    });
  },
  moveUpTitle$1 = mt`
  0% {
    transform: translateY(12px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
`,
  moveUpDescr$1 = mt`
  0% {
    transform: translateY(10px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
`,
  WorkWIthUsWrapper = dt.div`
  width: 100vw;
  height: 100vh;
`,
  Content = dt.div`
  height: fit-content;
  width: 100%;
  display: flex;
  flex-direction: column;
  padding: 2.75rem 1rem 0;
  @media (min-width: 48rem) {
    flex-direction: column;
    padding: 0 6.35vw;
    height: 100%;
  }
`,
  InfoBlock = dt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  justify-content: space-between;
  @media (min-width: 48rem) {
    flex-direction: row;
    justify-content: start;
    height: 100%;
  }
`,
  TextContainer = dt.div`
  display: flex;
  flex-direction: column;
  position: relative;
  justify-content: center;
  text-align: start;
  align-items: center;
  gap: 2rem;
  max-width: 31.5rem;

  @media (min-width: 48rem) {
    justify-content: start;
    align-items: start;
    flex: 0 0 50%;
    max-width: 50%;
  }
`,
  TextTitle = dt.h2`
  display: flex;
  font-weight: 400;
  font-size: 1.5rem;
  line-height: 1.3;
  letter-spacing: 0.1625rem;
  text-transform: uppercase;
  opacity: 0;
  h4 {
    color: #fff !important;
  }

  @media (min-width: 48rem) {
    font-size: 2rem;
    &.animateTitle {
      animation: ${moveUpTitle$1} 1.4s ease-out;
    }
  }
  &.visible {
    opacity: 1;
  }
`,
  TextDescr = dt.p`
  max-width: 23.4375rem;
  font-weight: 400;
  font-size: 0.75rem;
  line-height: 1.83;
  letter-spacing: 0.12rem;
  text-transform: uppercase;
  display: flex;
  opacity: 0;
  p {
    color: #fff !important;
  }
  &.visible {
    opacity: 1;
  }
  @media (min-width: 48rem) {
    width: 100%;
    max-width: 31.5rem;
    &.animateDescr {
      animation: ${moveUpDescr$1} 1s ease-out;
    }
  }
`,
  TimerContainer$1 = dt.div`
  display: flex;
  z-index: 1;
  flex-direction: column;
  align-items: center;
  gap: 0.6875rem;
  margin-top: 4.625rem;
  @media (min-width: 48rem) {
    margin-top: 0;
    flex: 0 0 50%;
    max-width: 50%;
  }
`,
  FooterBlock = dt.div`
  width: 100%;
  height: 100%;
  max-height: 30.6875rem;
  display: flex;
  padding: 3.9375rem 1rem 1.25rem;
  background: linear-gradient(to top, #000 50%, rgba(0, 0, 0, 0));
  @media (min-width: 48rem) {
    padding: 0 6.35vw;
    max-height: 7.1875rem;
    background: transparent;
    box-shadow: none;
    position: absolute;
    bottom: 0;
  }
`,
  FooterContent = dt.div`
  width: 100%;
  display: flex;
  align-items: center;
  text-transform: uppercase;

  @media (min-width: 48rem) {
    justify-content: space-between;
  }
`,
  FooterSection = dt.div`
  height: 100%;
  display: flex;
  align-items: center;
  flex-direction: row;
`,
  StyledList = dt.ul`
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  align-items: center;

  @media (min-width: 48rem) {
    gap: 2rem;
  }
`,
  StyledListItem = dt.li`
  font-size: 0.75rem;
  letter-spacing: 0.09rem;
  cursor: pointer;
  position: relative;

  &::before,
  &::after {
    content: '';
    position: absolute;
    width: 0;
    height: 1px;
    bottom: -1px;
    background-color: var(--white-color);
    transition: width 0.3s ease;
  }

  &::before {
    left: 50%;
    transform: translateX(-50%);
  }

  &::after {
    right: 50%;
    transform: translateX(50%);
  }

  &:hover::before,
  &:hover::after {
    width: 98%;
  }
`,
  CountWrapper = dt.div`
&.animateDescr {
  animation: ${moveUpDescr$1} 1s ease-out;
}
`,
  constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(n, e) {
  return typeof n == "function"
    ? n(e)
    : n && typeof n == "object" && constructFromSymbol in n
    ? n[constructFromSymbol](e)
    : n instanceof Date
    ? new n.constructor(e)
    : new Date(e);
}
function toDate(n, e) {
  return constructFrom(n, n);
}
function getRoundingMethod(n) {
  return (e) => {
    const r = (n ? Math[n] : Math.trunc)(e);
    return r === 0 ? 0 : r;
  };
}
function differenceInMilliseconds(n, e) {
  return +toDate(n) - +toDate(e);
}
function differenceInSeconds(n, e, t) {
  const r = differenceInMilliseconds(n, e) / 1e3;
  return getRoundingMethod(t == null ? void 0 : t.roundingMethod)(r);
}
const TimerContainer = dt.div`
  display: flex;
  flex-direction: column;
  align-items: center;
`,
  TimerDisplay = dt.div`
  // Accept fontSize as a prop
  display: flex;
  gap: 5px;
  font-weight: 400;
  font-size: ${(n) => n.fontSize || "24px"}; // Default to 24px
  line-height: 150%;
  letter-spacing: 0.02em;
`,
  TimerUnit = dt.span`
  color: #d8f34f;
`,
  TimerLabel = dt.span`
  color: #848e58;
`,
  Timer = ({ targetDate: n, fontSize: e = "24px" }) => {
    const t = (l) => (l < 10 ? `0${l}` : l),
      r = () => {
        const l = differenceInSeconds(n, new Date());
        if (l <= 0) return null;
        const c = Math.floor(l / (3600 * 24)),
          u = Math.floor((l % (3600 * 24)) / 3600),
          p = Math.floor((l % 3600) / 60),
          N = l % 60;
        return `${t(c)}:${t(u)}:${t(p)}:${t(N)}`;
      },
      [s, o] = reactExports.useState(r);
    if (
      (reactExports.useEffect(() => {
        const l = setInterval(() => {
          const c = r();
          c || clearInterval(l), o(c);
        }, 1e3);
        return () => clearInterval(l);
      }, [n]),
      !s)
    )
      return null;
    const a = s.split(":").map((l) => l.trim());
    return jsxRuntimeExports.jsx(TimerContainer, {
      children: jsxRuntimeExports.jsxs(TimerDisplay, {
        fontSize: e,
        children: [
          jsxRuntimeExports.jsxs(TimerUnit, {
            children: [
              a[0],
              jsxRuntimeExports.jsx(TimerLabel, { children: "d" }),
              ":",
            ],
          }),
          jsxRuntimeExports.jsxs(TimerUnit, {
            children: [
              a[1],
              jsxRuntimeExports.jsx(TimerLabel, { children: "h" }),
              ":",
            ],
          }),
          jsxRuntimeExports.jsxs(TimerUnit, {
            children: [
              a[2],
              jsxRuntimeExports.jsx(TimerLabel, { children: "m" }),
              ":",
            ],
          }),
          jsxRuntimeExports.jsxs(TimerUnit, {
            children: [
              a[3],
              jsxRuntimeExports.jsx(TimerLabel, { children: "s" }),
            ],
          }),
        ],
      }),
    });
  },
  WorkWIthUs = () => {
    const { moveModelToPosition: n } = useLandingContext(),
      [e, t] = reactExports.useState(!1),
      r = useBreakpoints(),
      s = new Date("2024-12-31T23:59:59Z"),
      { ref: o, inView: a } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: l, inView: c } = useInView({ triggerOnce: !1, threshold: 0 }),
      u = reactExports.useMemo(() => (a ? "animateTitle visible" : ""), [a]),
      p = reactExports.useMemo(() => (c ? "animateDescr visible" : ""), [c]),
      N = () => differenceInSeconds(s, new Date()) > 0,
      [P, de] = reactExports.useState(N);
    return (
      reactExports.useEffect(() => {
        const me = setInterval(() => {
          const Ye = N();
          de(Ye), Ye || clearInterval(me);
        }, 1e3);
        return () => clearInterval(me);
      }, [s]),
      jsxRuntimeExports.jsxs(WorkWIthUsWrapper, {
        id: "workWithUs",
        style: {
          scrollSnapAlign: "start",
          position: "relative",
          boxShadow:
            r === "small"
              ? "inset 0px 0px 100px 50px rgba(0, 0, 0, 0.3)"
              : "inset 0px 0px 300px 200px rgba(0, 0, 0, 0.3)",
        },
        children: [
          jsxRuntimeExports.jsx(GradientBG, {
            width: r === "small" ? "100%" : "65%",
            height: r === "small" ? "45%" : "55%",
            opacity: 0.5,
            position:
              r === "small" ? "top: 10%; left: -5%;" : "top: 30%; left: -15%;",
            children: jsxRuntimeExports.jsx(Gradient, {
              style: {
                background:
                  "radial-gradient(50% 50% at 50% 50%, #4535d3ed 30%, #4637d194 60%, #7f64f200 105%)",
              },
            }),
          }),
          jsxRuntimeExports.jsxs(Container, {
            style: {
              display: "flex",
              flexDirection: "column",
              padding: "0",
              justifyContent: "space-between",
            },
            children: [
              jsxRuntimeExports.jsx(Content, {
                children: jsxRuntimeExports.jsxs(InfoBlock, {
                  children: [
                    jsxRuntimeExports.jsxs(TextContainer, {
                      children: [
                        jsxRuntimeExports.jsx(TextTitle, {
                          ref: o,
                          className: u,
                          children: "Join the AI Revolution",
                        }),
                        jsxRuntimeExports.jsx(TextDescr, {
                          ref: l,
                          className: p,
                          children:
                            "Become a pioneer in the next generation of artificial intelligence. Transform your digital experience, earn rewards, and shape the future of AI development.",
                        }),
                        jsxRuntimeExports.jsx(ButtonAnimate, {
                          text: "Apply Now",
                        }),
                      ],
                    }),
                    P &&
                      jsxRuntimeExports.jsxs(TimerContainer$1, {
                        children: [
                          jsxRuntimeExports.jsx(TextTitle, {
                            ref: o,
                            className: u,
                            style: {
                              fontSize: r === "small" ? "1rem" : "1.375rem",
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "Launch Countdown",
                            }),
                          }),
                          jsxRuntimeExports.jsx(CountWrapper, {
                            ref: l,
                            className: p,
                            children: jsxRuntimeExports.jsx(Timer, {
                              targetDate: s,
                              fontSize: r === "small" ? "2rem" : "3.375rem",
                            }),
                          }),
                        ],
                      }),
                  ],
                }),
              }),
              jsxRuntimeExports.jsx(FooterBlock, {
                children: jsxRuntimeExports.jsxs(FooterContent, {
                  style: {
                    flexDirection: r === "small" ? "column" : "row",
                    gap: r === "small" ? "2rem" : "0",
                  },
                  children: [
                    jsxRuntimeExports.jsx(FooterSection, {
                      style: {
                        flexDirection: r === "small" ? "column" : "row",
                        order: r === "small" ? 2 : 1,
                        width: r === "small" ? "fit-content" : "30.5rem",
                        justifyContent: "flex-start",
                      },
                      children: jsxRuntimeExports.jsxs(StyledList, {
                        style: {
                          flexDirection: r === "small" ? "column" : "row",
                          gap: r === "small" ? "0.75rem" : "2rem",
                        },
                        children: [
                          jsxRuntimeExports.jsx(StyledListItem, {
                            onClick: () => {
                              scrollToBlock("legend"), n("legend");
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "Legend",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem, {
                            onClick: () => {
                              scrollToBlock("howItWorks"), n("howItWorks");
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "How it works",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem, {
                            onClick: () => {
                              scrollToBlock("features"), n("features");
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "AI Future",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem, {
                            onClick: () => {
                              scrollToBlock("roadmap"), n("roadmap");
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "RoadMap",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem, {
                            onClick: () => {
                              scrollToBlock("workWithUs"), n("workWithUs");
                            },
                            children: jsxRuntimeExports.jsx("h4", {
                              children: "Apply Now",
                            }),
                          }),
                        ],
                      }),
                    }),
                    jsxRuntimeExports.jsxs(FooterSection, {
                      onClick: () => {
                        scrollToBlock("mainBlock"), n("mainBlock");
                      },
                      style: {
                        cursor: "pointer",
                        height: "fit-content",
                        order: r === "small" ? 1 : 2,
                      },
                      onMouseEnter: () => t(!0),
                      onMouseLeave: () => t(!1),
                      children: [
                        jsxRuntimeExports.jsx(LogoIcon, {
                          style: {
                            position: r === "small" ? "relative" : "absolute",
                            width: "2.8125rem",
                            height: "2.625rem",
                            opacity: e ? 0 : 1,
                            transition: "opacity 0.3s ease-in-out",
                          },
                        }),
                        jsxRuntimeExports.jsx(LogoHover, {
                          style: {
                            position: "absolute",
                            width: "2.8125rem",
                            height: "2.625rem",
                            opacity: e ? 1 : 0,
                            transition: "opacity 0.3s ease-in-out",
                            display: r === "small" ? "none" : "block",
                          },
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsx(FooterSection, {
                      style: {
                        flexDirection: r === "small" ? "column" : "row",
                        gap: r === "small" ? "2.5rem" : "0px",
                        order: 3,
                        width: r === "small" ? "fit-content" : "30.5rem",
                        justifyContent: "flex-end",
                      },
                      children: jsxRuntimeExports.jsxs(StyledList, {
                        style: {
                          flexDirection: "row",
                          gap: r === "small" ? "1rem" : "2rem",
                        },
                        children: [
                          jsxRuntimeExports.jsx(StyledListItem, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://x.com/docca",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              children: "X",
                            }),
                          }),
                          jsxRuntimeExports.jsx(StyledListItem, {
                            children: jsxRuntimeExports.jsx("a", {
                              href: "https://www.linkedin.com/",
                              target: "_blank",
                              rel: "noopener noreferrer",
                              children: "LI",
                            }),
                          }),
                        ],
                      }),
                    }),
                  ],
                }),
              }),
            ],
          }),
        ],
      })
    );
  },
  HowItWorksWrapper = dt.div`
  width: 100vw;
  height: 100vh;
  padding: 2.5rem 6.875rem 3.75rem 6.875rem;
  background: transparent;
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: space-between;

  @media (max-width: 48rem) {
    height: 100% !important;
    padding: 2.5rem 1rem 2.5rem 1rem;
  }
`,
  ContentWrapper = dt.div`
  position: relative;
  width: 100%;
  height: 80%;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: space-between;

  @media (max-width: 48rem) {
    flex-direction: column;
  }
`,
  expandAnimation = mt`
0% {
  transform: translateY(4.375rem);
  opacity: 0;
}
100% {
  transform: translateY(0);
  opacity: 1;
}
`,
  BorderLeftIconContainer = dt.div`
  position: absolute;
  left: 0;
  opacity: 0;
  &.expandDecorLeft {
    @media (min-width: 48rem) {
      will-change: transform, opacity;
      transform-origin: center;
      animation: ${expandAnimation} 1.5s ease-out;
    }
  }
  &.visible {
    opacity: 1;
  }
  svg {
    height: 31.6875rem;
  }
`,
  BorderRightIconContainer = dt.div`
  position: absolute;
  right: 0;
  opacity: 0;
  &.expandDecorRight {
    @media (min-width: 48rem) {
      will-change: transform, opacity;
      transform-origin: center;
      animation: ${expandAnimation} 1.5s ease-out;
    }
  }
  &.visible {
    opacity: 1;
  }
  svg {
    height: 31.6875rem;
  }
`,
  BorderContainer = dt.div`
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;

  display: flex;
  align-items: center;
  justify-content: space-between;

  overflow: hidden;

  svg {
  }

  @media (max-width: 48rem) {
    position: relative;
    height: 31.25rem;
  }
`,
  LeftContentContainer = dt.div`
  width: 28vw;
  height: 100%;

  display: flex;
  align-items: flex-start;
  justify-content: center;
  flex-direction: column;

  padding: 0 0 0 2.8125rem;

  background: transparent;

  @media (max-width: 48rem) {
    width: 100%;
    padding: 3.125rem 0 0 0;
  }
`,
  RightContentContainer = dt.div`
  width: 28vw;
  height: 100%;

  display: flex;
  align-items: flex-end;
  justify-content: center;
  flex-direction: column;

  padding: 5rem 2.8125rem 5rem 0;

  background: transparent;

  @media (max-width: 48rem) {
    width: 100%;
    padding: 3.125rem 0;
  }
`,
  ContentItem = dt.div`
  position: relative;
  // border-top: 0.0625rem solid rgba(127, 100, 242, 0.47);
  padding-top: 1.25rem;
  width: 100%;

  &:first-child {
    margin-bottom: 3.125rem;
  }

  :before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 0.0625rem;
    // background: linear-gradient(
    //   ${({ reverse: n }) => (n ? "to left" : "to right")},
    //   rgba(73, 58, 140, 1),
    //   rgba(127, 100, 242, 0)
    // );
  }
`,
  ContentItemTitle = dt.div`
  text-align: left;
  text-underline-position: from-font;
  text-decoration-skip-ink: none;
  text-transform: uppercase;
  margin-bottom: 1rem;
  margin-top: 0.9375rem;
  h2 {
    font-size: 1.375rem;
    font-weight: 400;
    line-height: 1.7875rem;
    letter-spacing: 0.16em;
  }
  @media (min-width: 48rem) {
    margin-top: 1.25rem;
  }
`,
  moveUpDescr = mt`
  0% {
    transform: translateY(10px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 0.5;
  }
`,
  ContentItemDescr = dt.p`
  width: 90%;
  font-size: 0.75rem;
  letter-spacing: 0.16em;
  font-weight: 400;
  line-height: 1.375rem;
  text-align: left;
  text-underline-position: from-font;
  text-decoration-skip-ink: none;
  text-transform: uppercase;
  opacity: 0.5;
  &.animateDescr {
    @media (min-width: 48rem) {
      animation: ${moveUpDescr} 1s ease-out;
    }
  }
  &.visible {
    opacity: 0.5;
  }
`,
  moveUpTitle = mt`
  0% {
    transform: translateY(12px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
`,
  BlockTitleContainer = dt.h1`
  display: flex;
  position: relative;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  width: 100%;
  font-weight: 400;
  font-size: 3.375rem;
  line-height: 4.3875rem;
  letter-spacing: 0.16rem;
  text-transform: uppercase;
  opacity: 0;
  &.animateTitle {
    @media (min-width: 48rem) {
      animation: ${moveUpTitle} 1.4s ease-out;
    }
  }
  &.visible {
    opacity: 1;
  }

  @media (max-width: 48rem) {
    font-size: 2rem;
    line-height: 2.6rem;
    text-align: center;
    margin-bottom: 2.5rem;
  }
`,
  IconContainer = dt.div`
  width: 32px;
  height: 32px;
  margin-right: 1.25rem;
  background: rgba(255, 255, 255, 0.1);

  display: flex;
  align-items: center;
  justify-content: space-between;
  overflow: hidden;
  position: relative;

  .icon-list {
    position: absolute;
    top: 0;
    transform: translateY(-50%);
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    transition: transform 0.2s linear;
  }

  .icon {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;

    svg {
      height: 24px;
      width: 24px;
    }
  }
`,
  drawLine = mt`
  0% {
    width: 0;
    opacity: 0;
  }
  100% {
    transform: translateX(0%);
   width: 100%;
   opacity: 1;
  }
`,
  drawLineReverse = mt`
  0% {
    width: 0;
    opacity: 0;
    transform: translateX(100%);
  }
  100% {
    width: 100%;
    opacity: 1;
    transform: translateX(0%);
`,
  GradientLine = dt.div.withConfig({
    shouldForwardProp: (n) => !["reverse"].includes(n),
  })`
  position: relative;
  width: 0;
  opacity: 0;
  height: 0.0625rem;
  background: #7f64f278;
  transform-origin: ${({ reverse: n }) => (n ? "right" : "left")};

  &.animateLine1 {
    @media (min-width: 48rem) {
      animation: ${drawLineReverse} 1.5s ease-in-out forwards;
    }
  }
  &.animateLine2 {
    @media (min-width: 48rem) {
      animation: ${drawLine} 1.5s ease-in-out forwards;
    }
  }
  &.animateLine3 {
    @media (min-width: 48rem) {
      animation: ${drawLineReverse} 1.5s ease-in-out forwards;
    }
  }
  &.animateLine4 {
    @media (min-width: 48rem) {
      animation: ${drawLine} 1.5s ease-in-out forwards;
    }
  }
  &.visible {
    opacity: 1;
  }

  @media (min-width: 48rem) {
    background: linear-gradient(
      ${({ reverse: n }) => (n ? "to right" : "to left")},
      rgba(112, 88, 213, 0.15) 15%,
      rgba(112, 88, 213, 1) 100%
    );
  }
`,
  StyledContainerBase = dt.div`
  width: 100%;
  padding: 15px 0 15px 20px;
  display: flex;
  align-items: center;
`,
  polygonDeriction = {
    left: "polygon(0 0, 0 36%, 0 51%, 0 80%, 5% 100%, 51% 100%, 100% 100%, 100% 51%, 98% 51%, 98% 25%, 100% 25%, 100% 0)",
    right:
      "polygon(0 26%, 2% 26%, 2% 51%, 0 51%, 0 100%, 51% 100%, 95% 100%, 100% 80%, 100% 49%, 100% 20%, 100% 0, 0 0)",
  },
  StyledContainer = ({
    children: n,
    direction: e = "right",
    bgColor: t = "#262241",
  }) =>
    jsxRuntimeExports.jsx(StyledContainerBase, {
      style: { background: t, clipPath: polygonDeriction[e] },
      children: n,
    }),
  iconArray = [
    { id: 1, icon: jsxRuntimeExports.jsx(ProfileIcon, {}) },
    { id: 2, icon: jsxRuntimeExports.jsx(ToolIcon, {}) },
    { id: 3, icon: jsxRuntimeExports.jsx(PenIcon, {}) },
    { id: 4, icon: jsxRuntimeExports.jsx(QuarterIcon, {}) },
    { id: 5, icon: jsxRuntimeExports.jsx(ProfileIcon, {}) },
    { id: 6, icon: jsxRuntimeExports.jsx(ToolIcon, {}) },
    { id: 7, icon: jsxRuntimeExports.jsx(PenIcon, {}) },
    { id: 8, icon: jsxRuntimeExports.jsx(QuarterIcon, {}) },
    { id: 9, icon: jsxRuntimeExports.jsx(ProfileIcon, {}) },
    { id: 10, icon: jsxRuntimeExports.jsx(ToolIcon, {}) },
    { id: 11, icon: jsxRuntimeExports.jsx(PenIcon, {}) },
    { id: 12, icon: jsxRuntimeExports.jsx(QuarterIcon, {}) },
    { id: 13, icon: jsxRuntimeExports.jsx(ProfileIcon, {}) },
    { id: 14, icon: jsxRuntimeExports.jsx(ToolIcon, {}) },
    { id: 15, icon: jsxRuntimeExports.jsx(PenIcon, {}) },
    { id: 16, icon: jsxRuntimeExports.jsx(QuarterIcon, {}) },
  ],
  ScrollableIcon = ({ selectedId: n, isStatic: e = !1 }) => {
    const [t, r] = reactExports.useState(0),
      [s, o] = reactExports.useState(!1),
      { ref: a, inView: l } = useInView({ triggerOnce: !1, threshold: 0.5 });
    return (
      reactExports.useEffect(() => {
        if (e) {
          r(iconArray.findIndex((p) => p.id === n));
          return;
        }
        if (!l) return;
        o(!0);
        const c = setInterval(() => {
            r((p) => (p + 1) % iconArray.length);
          }, 200),
          u = setTimeout(() => {
            o(!1), clearInterval(c), r(iconArray.findIndex((p) => p.id === n));
          }, 1e3);
        return () => {
          clearInterval(c), clearTimeout(u);
        };
      }, [n, e, l]),
      jsxRuntimeExports.jsxs(IconContainer, {
        ref: e ? void 0 : a,
        children: [
          jsxRuntimeExports.jsx(StyledBorderIcon, {
            decoration: "basic",
            color: "#FFFFFF",
            height: "100%",
            width: 3,
            isShifted: !1,
            isParentHeight: !1,
            isFirst: !0,
          }),
          jsxRuntimeExports.jsx("div", {
            className: "icon-list",
            style: {
              transform: `translateY(-${t * 32}px)`,
              transition: s
                ? "transform 0.2s linear"
                : "transform 0.5s ease-out",
            },
            children: iconArray.map((c, u) =>
              jsxRuntimeExports.jsx(
                "div",
                { id: `icon-${c.id}`, className: "icon", children: c.icon },
                u
              )
            ),
          }),
          jsxRuntimeExports.jsx(StyledBorderIcon, {
            decoration: "reverse",
            color: "#FFFFFF",
            height: "100%",
            isShifted: !1,
            isParentHeight: !1,
            width: 3,
            isFirst: !0,
          }),
        ],
      })
    );
  },
  HowItWorks = () => {
    const n = useBreakpoints(),
      e = getOrbitingDotParams("howItWorks", n),
      { ref: t, inView: r } = useInView({ triggerOnce: !1, threshold: 0 }),
      s = reactExports.useMemo(() => (r ? "animateTitle visible" : ""), [r]),
      { ref: o, inView: a } = useInView({ triggerOnce: !1, threshold: 0 }),
      l = reactExports.useMemo(() => (a ? "animateDescr visible" : ""), [a]),
      { ref: c, inView: u } = useInView({ triggerOnce: !1, threshold: 0 }),
      p = reactExports.useMemo(() => (u ? "animateDescr visible" : ""), [u]),
      { ref: N, inView: P } = useInView({ triggerOnce: !1, threshold: 0 }),
      de = reactExports.useMemo(() => (P ? "animateDescr visible" : ""), [P]),
      { ref: me, inView: Ye } = useInView({ triggerOnce: !1, threshold: 0 }),
      nt = reactExports.useMemo(() => (Ye ? "animateDescr visible" : ""), [Ye]),
      { ref: Be, inView: ot } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: st, inView: vt } = useInView({ triggerOnce: !1, threshold: 0 }),
      xt = reactExports.useMemo(
        () => (ot ? "expandDecorLeft visible" : ""),
        [ot]
      ),
      St = reactExports.useMemo(
        () => (vt ? "expandDecorRight visible" : ""),
        [vt]
      ),
      { ref: wt, inView: bt } = useInView({ triggerOnce: !1, threshold: 0.1 }),
      { ref: Tt, inView: Ct } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: kt, inView: Dt } = useInView({ triggerOnce: !1, threshold: 0 }),
      { ref: Vt, inView: Ht } = useInView({ triggerOnce: !1, threshold: 0 }),
      qt = reactExports.useMemo(() => (bt ? "animateLine1 visible" : ""), [bt]),
      Ft = reactExports.useMemo(() => (Ct ? "animateLine1 visible" : ""), [Ct]),
      Bt = reactExports.useMemo(() => (Dt ? "animateLine1 visible" : ""), [Dt]),
      Mt = reactExports.useMemo(() => (Ht ? "animateLine1 visible" : ""), [Ht]);
    return jsxRuntimeExports.jsxs(HowItWorksWrapper, {
      id: "howItWorks",
      style: {
        scrollSnapAlign: "start",
        position: "relative",
        boxShadow:
          n === "small"
            ? "inset 0px 0px 100px 50px rgba(0, 0, 0, 0.2)"
            : "inset 0px 0px 300px 200px rgba(0, 0, 0, 0.2)",
      },
      children: [
        jsxRuntimeExports.jsx(OrbitingDot, { ...e }),
        jsxRuntimeExports.jsx(GradientBG, {
          width: n === "small" ? "100%" : "40%",
          height: n === "small" ? "40%" : "50%",
          opacity: 0.2,
          position: "top: 20%; left: auto;",
          children: jsxRuntimeExports.jsx(Gradient, {
            style: {
              background:
                "radial-gradient(50% 50% at 50% 50%, #4535d3ed 30%, #4637d194 60%, #7f64f200 105%)",
            },
          }),
        }),
        jsxRuntimeExports.jsx(BlockTitleContainer, {
          ref: t,
          className: s,
          children: "How It Works",
        }),
        jsxRuntimeExports.jsxs(ContentWrapper, {
          children: [
            jsxRuntimeExports.jsx(BorderContainer, {
              children: jsxRuntimeExports.jsxs(BorderContainer, {
                children: [
                  jsxRuntimeExports.jsx(BorderLeftIconContainer, {
                    ref: Be,
                    className: xt,
                    children: jsxRuntimeExports.jsx(BorderIcon, {
                      color: "#FFFFFF",
                      style: { transform: "rotate(180deg)" },
                    }),
                  }),
                  jsxRuntimeExports.jsx(BorderRightIconContainer, {
                    ref: st,
                    className: St,
                    children: jsxRuntimeExports.jsx(BorderIcon, {
                      color: "#FFFFFF",
                    }),
                  }),
                ],
              }),
            }),
            jsxRuntimeExports.jsxs(LeftContentContainer, {
              children: [
                jsxRuntimeExports.jsxs(ContentItem, {
                  children: [
                    jsxRuntimeExports.jsx(GradientLine, {
                      ref: wt,
                      className: qt,
                    }),
                    jsxRuntimeExports.jsx(ContentItemTitle, {
                      children: jsxRuntimeExports.jsxs(StyledContainer, {
                        bgColor: "#262241",
                        children: [
                          jsxRuntimeExports.jsx(ScrollableIcon, {
                            selectedId: 1,
                            isStatic: n === "small",
                          }),
                          jsxRuntimeExports.jsx("h2", {
                            children: "Create DOCCA",
                          }),
                        ],
                      }),
                    }),
                    jsxRuntimeExports.jsx(ContentItemDescr, {
                      ref: o,
                      className: l,
                      children:
                        "Design your personalized AI assistant with unique traits, skills, and appearance using intuitive tools",
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(ContentItem, {
                  children: [
                    jsxRuntimeExports.jsx(GradientLine, {
                      ref: Tt,
                      className: Ft,
                    }),
                    jsxRuntimeExports.jsx(ContentItemTitle, {
                      children: jsxRuntimeExports.jsxs(StyledContainer, {
                        bgColor: "#262241",
                        children: [
                          jsxRuntimeExports.jsx(ScrollableIcon, {
                            selectedId: 2,
                            isStatic: n === "small",
                          }),
                          jsxRuntimeExports.jsx("h2", { children: "Train AI" }),
                        ],
                      }),
                    }),
                    jsxRuntimeExports.jsx(ContentItemDescr, {
                      ref: c,
                      className: p,
                      children:
                        "Complete engaging quests and challenges to enhance your AI's capabilities and expand its knowledge base",
                    }),
                  ],
                }),
              ],
            }),
            jsxRuntimeExports.jsxs(RightContentContainer, {
              children: [
                jsxRuntimeExports.jsxs(ContentItem, {
                  children: [
                    jsxRuntimeExports.jsx(GradientLine, {
                      reverse: !0,
                      ref: kt,
                      className: Bt,
                    }),
                    jsxRuntimeExports.jsx(ContentItemTitle, {
                      children: jsxRuntimeExports.jsxs(StyledContainer, {
                        bgColor: "#262241",
                        children: [
                          jsxRuntimeExports.jsx(ScrollableIcon, {
                            selectedId: 3,
                            isStatic: n === "small",
                          }),
                          jsxRuntimeExports.jsx("h2", {
                            children: "Earn Rewards",
                          }),
                        ],
                      }),
                    }),
                    jsxRuntimeExports.jsx(ContentItemDescr, {
                      ref: N,
                      className: de,
                      children:
                        "Receive $DOCCA for successfully training and improving your AI assistant  level up, unlock new abilities, and gain rewards based on performance and community votes.",
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(ContentItem, {
                  children: [
                    jsxRuntimeExports.jsx(GradientLine, {
                      reverse: !0,
                      ref: Vt,
                      className: Mt,
                    }),
                    jsxRuntimeExports.jsx(ContentItemTitle, {
                      children: jsxRuntimeExports.jsxs(StyledContainer, {
                        bgColor: "#262241",
                        children: [
                          jsxRuntimeExports.jsx(ScrollableIcon, {
                            selectedId: 4,
                            isStatic: n === "small",
                          }),
                          jsxRuntimeExports.jsx("h2", {
                            children: "Trade & Grow",
                          }),
                        ],
                      }),
                    }),
                    jsxRuntimeExports.jsx(ContentItemDescr, {
                      ref: me,
                      className: nt,
                      children:
                        "Exchange AI modules, skills, and assets in our marketplace, creating new opportunities for monetization",
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
        jsxRuntimeExports.jsx(ButtonAnimate, { text: "Apply Now" }),
      ],
    });
  },
  LandscapeWrapper = dt.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 9999;
`,
  Overlay = dt.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  text-align: center;
  span{
    margin-top: 1.5rem;
    text-transform: uppercase;
    font-size: 2rem;
  }
  svg{
  width: 100%;
  height: 100%;
    scale: 0.385;
  }
    img{
      width: 100px;
      height: 100px;
    }
`,
  RotateMessage = dt.div`
  color: var(--text-primary);
  font-size: 1rem;
  margin-top: 1rem;
  text-transform: uppercase
`,
  rotating_phone =
    "data:image/svg+xml,%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Transformed%20by:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20fill='%23ffffff'%20version='1.1'%20id='Capa_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='150px'%20height='150px'%20viewBox='0%200%20463.708%20463.707'%20xml:space='preserve'%20stroke='%23ffffff'%3e%3cg%20id='SVGRepo_bgCarrier'%20stroke-width='0'/%3e%3cg%20id='SVGRepo_tracerCarrier'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cg%20id='SVGRepo_iconCarrier'%3e%3cg%3e%3cg%3e%3cpath%20d='M432.771,351.013v-28.2c0-1.396-1.118-2.524-2.515-2.524c-1.387,0-2.505,1.119-2.505,2.524v28.2%20c0,1.387,1.118,2.506,2.505,2.506C431.653,353.519,432.771,352.399,432.771,351.013z'/%3e%3cpath%20d='M229.569,231.816c-5.279,0-9.562,2.248-9.562,5.01c0,2.773,4.283,5.012,9.562,5.012h198.985%20c8.606,0,15.625,6.999,15.625,15.615v158.881c0,8.626-7.009,15.635-15.625,15.635H229.262c-5.278,0-9.562-2.228-9.562-4.973%20c0-2.744,4.284-4.973,9.562-4.973h180.712c1.387,0,2.516-1.118,2.516-2.505v-165.25c0-1.387-1.119-2.505-2.516-2.505H229.262%20c-5.278,0-9.562-4.284-9.562-9.562V111.329c0-14.133-11.504-25.646-25.656-25.646H35.163c-14.152,0-25.656,11.503-25.656,25.646%20v326.712c0,14.143,11.504,25.666,25.656,25.666h158.881c9.429,0,17.644-5.136,22.07-12.747c2.658-4.562,7.459-8.96,12.737-8.96%20h199.693c14.144,0,25.656-11.504,25.656-25.666V257.463c0-14.144-11.503-25.647-25.656-25.647H229.569z%20M229.262,256.784h168.654%20c5.278,0,9.562,4.283,9.562,9.562V407.47c0,5.278-4.284,9.562-9.562,9.562H229.262c-5.278,0-9.562-4.284-9.562-9.562V266.347%20C219.7,261.067,223.974,256.784,229.262,256.784z%20M209.668,438.051c0,8.606-6.999,15.615-15.625,15.615H35.163%20c-8.606,0-15.625-7-15.625-15.615V111.329c0-8.606,7.009-15.616,15.625-15.616h158.881c8.616,0,15.625,7.01,15.625,15.616V438.051%20z'/%3e%3cpath%20d='M197.228,127.394H31.969c-1.386,0-2.505,1.119-2.505,2.505v286.818c0,1.377,1.119,2.524,2.505,2.524h165.259%20c1.396,0,2.515-1.138,2.515-2.524V129.899C199.743,128.513,198.625,127.394,197.228,127.394z%20M185.16,414.211H44.046%20c-5.278,0-9.562-4.284-9.562-9.562V141.986c0-5.278,4.284-9.562,9.562-9.562H185.16c5.279,0,9.562,4.284,9.562,9.562v262.672%20C194.722,409.937,190.448,414.211,185.16,414.211z'/%3e%3cpath%20d='M100.503,112.122h28.2c1.396,0,2.515-1.119,2.515-2.505c0-1.387-1.119-2.506-2.515-2.506h-28.2%20c-1.396,0-2.515,1.119-2.515,2.506C97.988,110.994,99.107,112.122,100.503,112.122z'/%3e%3cpath%20d='M129.047,424.969h-28.888c-5.929,0-10.758,4.82-10.758,10.739v1.74c0,5.919,4.829,10.758,10.758,10.758h28.888%20c5.929,0,10.758-4.839,10.758-10.758v-1.74C139.805,429.788,134.976,424.969,129.047,424.969z%20M134.794,437.448%20c0,3.155-2.572,5.737-5.747,5.737h-28.888c-3.156,0-5.747-2.582-5.747-5.737v-1.74c0-3.156,2.591-5.737,5.747-5.737h28.888%20c3.175,0,5.747,2.581,5.747,5.737V437.448z'/%3e%3cpath%20d='M313.241,131.745c-0.058,0.449,2.122,1.1,4.867,1.454c2.764,0.334,5.029,0.239,5.087-0.201%20c0.058-0.468,0.105-0.841,0.105-0.841c3.643-29.251-3.815-58.666-20.99-82.831c-9.084-12.775-20.444-23.438-33.717-31.661%20c-44.781-27.808-102.109-22.147-140.55,12.498c-2.754,2.467-7.21,2.783-10.136,0.526l-8.291-6.407%20c-2.936-2.257-4.924-1.119-4.446,2.543l3.423,26.574c0.478,3.682,3.806,6.254,7.478,5.786l26.574-3.414%20c3.663-0.449,4.265-2.668,1.349-4.915l-7.497-5.805c-2.926-2.257-3.175-6.215-0.392-8.645%20c35.142-30.59,86.77-35.314,127.219-10.231c12.145,7.544,22.511,17.298,30.83,28.984c15.721,22.108,22.538,49.008,19.221,75.773%20L313.241,131.745z'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e",
  LandscapeBlocker = ({
    className: n,
    message: e = "This website is best viewed in portrait mode",
  }) => {
    const [t, r] = reactExports.useState(!1),
      { deviceType: s } = useDeviceType();
    return (
      reactExports.useEffect(() => {
        const o = () => {
          if (s !== "mobile") {
            r(!1);
            return;
          }
          let a = !1;
          window.screen.orientation
            ? (a = window.screen.orientation.type.includes("landscape"))
            : (a = window.innerWidth > window.innerHeight),
            r(a);
        };
        return (
          window.addEventListener("resize", o),
          window.addEventListener("orientationchange", o),
          o(),
          () => {
            window.removeEventListener("resize", o),
              window.removeEventListener("orientationchange", o);
          }
        );
      }, [s]),
      !t || s !== "mobile"
        ? null
        : jsxRuntimeExports.jsx(LandscapeWrapper, {
            children: jsxRuntimeExports.jsx(AnimatedBG, {
              children: jsxRuntimeExports.jsxs(Overlay, {
                className: n,
                children: [
                  jsxRuntimeExports.jsx("img", {
                    src: rotating_phone,
                    alt: "rotating phone",
                  }),
                  jsxRuntimeExports.jsx("span", {
                    children: "Please rotate your device",
                  }),
                  jsxRuntimeExports.jsx(RotateMessage, { children: e }),
                  jsxRuntimeExports.jsx(Lottie, {
                    animationData,
                    loop: !1,
                    autoplay: !0,
                  }),
                ],
              }),
            }),
          })
    );
  },
  VideoWrapper = dt.div`
  width: 100vw;
  height: 100vh;
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: center;
  background: #000000;
  overflow: hidden;
  scroll-snap-align: start;
`,
  MuteButton = dt.div`
  position: absolute;
  bottom: 2rem;
  right: 2rem;
  width: 2.5rem;
  height: 2.5rem;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
`,
  VideoContainer = dt.div`
  position: absolute;
  left: 50%;
  transform: translate(-50%, -50%);
  top: 50%;
  aspect-ratio: 16/9;
  width: auto;
  height: 100vh;
  @media (min-aspect-ratio: 16/9) {
    width: 100vw;
    height: auto;
  }
`,
  ButtonLayer = dt.div`
  position: absolute;
  left: 0;
  bottom: 0;
  top: 0;
  right: 0;
  z-index: 50;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  ButtonStopLayer = dt.div`
  position: absolute;
  left: 0;
  bottom: 0;
  top: 0;
  right: 0;
  z-index: 60;
  display: flex;
`,
  ButtonPlay = dt.button`
  width: 5.5rem;
  height: 5.5rem;
  border-radius: 50%;
  border: 1px solid #7f64f2;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  transition: 0.3s;
  @media (min-width: 48rem) {
    &:hover {
      background: #7f64f2;
      transition: 0.3s;
    }
  }
`,
  Unmute = ({
    color: n = "#fff",
    width: e = 24,
    height: t = 24,
    isMuted: r = !1,
    ...s
  }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M11.0855 4.11636C10.7981 3.96604 10.4973 3.96866 10.2057 4.08235C9.93279 4.18878 9.66639 4.39205 9.39978 4.64526C8.87158 5.14691 8.22913 5.95806 7.40866 6.99398L7.38614 7.02242C6.95953 7.56104 6.65912 7.84335 6.346 8.00341C6.03798 8.16085 5.67612 8.22107 5.07756 8.22107L5.05278 8.22107C4.53293 8.22106 4.10712 8.22105 3.76415 8.2651C3.40385 8.31138 3.09327 8.41045 2.82443 8.63725C2.31603 9.06615 2.12469 9.68082 2.04944 10.27C1.99146 10.7239 1.99782 11.2146 2.00344 11.6482C2.00503 11.7707 2.00656 11.8887 2.00656 12C2.00656 12.1113 2.00503 12.2293 2.00344 12.3518C1.99782 12.7853 1.99146 13.276 2.04944 13.73C2.12469 14.3191 2.31603 14.9338 2.82443 15.3627C3.09327 15.5895 3.40385 15.6886 3.76415 15.7349C4.10712 15.7789 4.53293 15.7789 5.05278 15.7789H5.07756C5.67612 15.7789 6.03798 15.8391 6.346 15.9966C6.65912 16.1566 6.95953 16.4389 7.38614 16.9775L7.40867 17.006C8.22914 18.0419 8.87158 18.853 9.39978 19.3547C9.66639 19.6079 9.93279 19.8112 10.2057 19.9176C10.4973 20.0313 10.7981 20.0339 11.0855 19.8836C11.3639 19.738 11.5473 19.4928 11.67 19.1993C11.7905 18.9113 11.8624 18.5544 11.9085 18.1425C12 17.3256 12 16.1849 12 14.7096V9.29037C12 7.81505 12 6.67441 11.9085 5.85747C11.8624 5.44553 11.7905 5.08865 11.67 4.80065C11.5473 4.5072 11.3639 4.26193 11.0855 4.11636ZM7.97407 7.48808C8.82172 6.41786 9.43153 5.64945 9.91627 5.18908C10.1585 4.95897 10.3407 4.83473 10.4782 4.78111C10.5971 4.73474 10.6687 4.74476 10.7379 4.78096C10.8162 4.82189 10.9002 4.90386 10.9781 5.09005C11.0583 5.28168 11.1201 5.55682 11.1632 5.94095C11.2494 6.711 11.25 7.80943 11.25 9.31833V14.6816C11.25 16.1905 11.2494 17.289 11.1632 18.059C11.1201 18.4431 11.0583 18.7183 10.9781 18.9099C10.9002 19.0961 10.8162 19.1781 10.7379 19.219C10.6687 19.2552 10.5971 19.2652 10.4782 19.2189C10.3407 19.1652 10.1585 19.041 9.91627 18.8109C9.43153 18.3505 8.82172 17.5821 7.97407 16.5119C7.53123 15.9528 7.14889 15.5647 6.68736 15.3287C6.22072 15.0902 5.71604 15.0289 5.07756 15.0289C4.52683 15.0289 4.14934 15.0282 3.85969 14.991C3.58192 14.9553 3.42776 14.8905 3.30804 14.7895C3.00983 14.5379 2.85883 14.1473 2.7934 13.6349C2.74276 13.2385 2.74797 12.8212 2.75326 12.3965C2.75491 12.2649 2.75656 12.1326 2.75656 12C2.75656 11.8674 2.75491 11.7351 2.75326 11.6035C2.74797 11.1788 2.74276 10.7615 2.7934 10.365C2.85883 9.85266 3.00983 9.46208 3.30804 9.21051C3.42776 9.1095 3.58192 9.04467 3.85969 9.00899C4.14934 8.97179 4.52683 8.97107 5.07756 8.97107C5.71604 8.97107 6.22072 8.90975 6.68736 8.67122C7.14889 8.4353 7.53123 8.04719 7.97407 7.48808Z",
            fill: n,
          }),
          jsxRuntimeExports.jsx("path", {
            d: "M16.6402 9.10984C16.4937 8.96339 16.2563 8.96339 16.1098 9.10984C15.9634 9.25628 15.9634 9.49372 16.1098 9.64016L18.4697 12L16.1098 14.3598C15.9634 14.5063 15.9634 14.7437 16.1098 14.8902C16.2563 15.0366 16.4937 15.0366 16.6402 14.8902L19 12.5303L21.3598 14.8902C21.5063 15.0366 21.7437 15.0366 21.8902 14.8902C22.0366 14.7437 22.0366 14.5063 21.8902 14.3598L19.5303 12L21.8902 9.64017C22.0366 9.49372 22.0366 9.25628 21.8902 9.10984C21.7437 8.96339 21.5063 8.96339 21.3598 9.10984L19 11.4697L16.6402 9.10984Z",
            fill: n,
          }),
        ],
      }),
    }),
  Mute = ({
    color: n = "#fff",
    width: e = 24,
    height: t = 24,
    isMuted: r = !1,
    ...s
  }) =>
    jsxRuntimeExports.jsx("svg", {
      width: e,
      height: t,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M10.2057 4.08235C10.4973 3.96866 10.7981 3.96604 11.0855 4.11636C11.3639 4.26193 11.5473 4.5072 11.67 4.80065C11.7905 5.08865 11.8624 5.44553 11.9085 5.85747C12 6.67441 12 7.81505 12 9.29037V14.7096C12 16.1849 12 17.3256 11.9085 18.1425C11.8624 18.5544 11.7905 18.9113 11.67 19.1993C11.5473 19.4928 11.3639 19.738 11.0855 19.8836C10.7981 20.0339 10.4973 20.0313 10.2057 19.9176C9.93279 19.8112 9.66639 19.6079 9.39978 19.3547C8.87158 18.853 8.22914 18.0419 7.40867 17.006L7.38614 16.9775C6.95953 16.4389 6.65912 16.1566 6.346 15.9966C6.03798 15.8391 5.67612 15.7789 5.07756 15.7789H5.05278C4.53293 15.7789 4.10712 15.7789 3.76415 15.7349C3.40385 15.6886 3.09327 15.5895 2.82443 15.3627C2.31603 14.9338 2.12469 14.3191 2.04944 13.73C1.99146 13.276 1.99782 12.7854 2.00344 12.3518C2.00503 12.2293 2.00656 12.1113 2.00656 12C2.00656 11.8887 2.00503 11.7707 2.00344 11.6482C1.99782 11.2146 1.99146 10.7239 2.04944 10.27C2.12469 9.68082 2.31603 9.06615 2.82443 8.63725C3.09327 8.41045 3.40385 8.31138 3.76415 8.2651C4.10712 8.22105 4.53293 8.22106 5.05278 8.22107L5.07756 8.22107C5.67612 8.22107 6.03798 8.16085 6.346 8.00341C6.65912 7.84335 6.95953 7.56104 7.38614 7.02242L7.40865 6.99399C8.22913 5.95806 8.87158 5.14691 9.39978 4.64526C9.66639 4.39205 9.93279 4.18878 10.2057 4.08235ZM9.91627 5.18908C9.43153 5.64945 8.82172 6.41786 7.97407 7.48808C7.53123 8.04719 7.14889 8.4353 6.68736 8.67122C6.22072 8.90975 5.71604 8.97107 5.07756 8.97107C4.52683 8.97107 4.14934 8.97179 3.85969 9.00899C3.58192 9.04467 3.42776 9.1095 3.30804 9.21051C3.00983 9.46208 2.85883 9.85266 2.7934 10.365C2.74276 10.7615 2.74797 11.1788 2.75326 11.6035C2.75491 11.7351 2.75656 11.8674 2.75656 12C2.75656 12.1326 2.75491 12.2649 2.75326 12.3965C2.74797 12.8212 2.74276 13.2385 2.7934 13.6349C2.85883 14.1473 3.00983 14.5379 3.30804 14.7895C3.42776 14.8905 3.58192 14.9553 3.85969 14.991C4.14934 15.0282 4.52683 15.0289 5.07756 15.0289C5.71604 15.0289 6.22072 15.0902 6.68736 15.3287C7.14889 15.5647 7.53123 15.9528 7.97407 16.5119C8.82172 17.5821 9.43153 18.3505 9.91627 18.8109C10.1585 19.041 10.3407 19.1652 10.4782 19.2189C10.5971 19.2652 10.6687 19.2552 10.7379 19.219C10.8162 19.1781 10.9002 19.0961 10.9781 18.9099C11.0583 18.7183 11.1201 18.4431 11.1632 18.059C11.2494 17.289 11.25 16.1905 11.25 14.6816V9.31833C11.25 7.80943 11.2494 6.711 11.1632 5.94095C11.1201 5.55682 11.0583 5.28168 10.9781 5.09005C10.9002 4.90386 10.8162 4.82189 10.7379 4.78096C10.6687 4.74476 10.5971 4.73474 10.4782 4.78111C10.3407 4.83473 10.1585 4.95897 9.91627 5.18908Z",
            fill: n,
          }),
          jsxRuntimeExports.jsx("path", {
            d: "M16.1218 8.59842C16.2745 8.45856 16.5117 8.46902 16.6516 8.62177C17.4905 9.53802 18 10.7136 18 12C18 13.2864 17.4905 14.462 16.6516 15.3782C16.5117 15.531 16.2745 15.5414 16.1218 15.4016C15.969 15.2617 15.9586 15.0245 16.0984 14.8718C16.823 14.0804 17.25 13.0814 17.25 12C17.25 10.9186 16.823 9.91964 16.0984 9.12824C15.9586 8.97548 15.969 8.73828 16.1218 8.59842Z",
            fill: n,
          }),
          jsxRuntimeExports.jsx("path", {
            d: "M19.6395 6.60919C19.4927 6.4631 19.2553 6.46368 19.1092 6.61048C18.9631 6.75729 18.9637 6.99473 19.1105 7.14081C20.4576 8.48137 21.25 10.1723 21.25 12C21.25 13.8277 20.4576 15.5186 19.1105 16.8592C18.9637 17.0053 18.9631 17.2427 19.1092 17.3895C19.2553 17.5363 19.4927 17.5369 19.6395 17.3908C21.1067 15.9308 22 14.0556 22 12C22 9.94445 21.1067 8.06919 19.6395 6.60919Z",
            fill: n,
          }),
        ],
      }),
    }),
  PlayIcon = (n) =>
    jsxRuntimeExports.jsx("svg", {
      width: "17",
      height: "18",
      viewBox: "0 0 17 18",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...n,
      children: jsxRuntimeExports.jsx("path", {
        d: "M1.25 18C1.05109 18 0.860322 17.921 0.71967 17.7803C0.579018 17.6397 0.5 17.4489 0.5 17.25V0.749994C0.500022 0.619666 0.534006 0.491593 0.5986 0.378399C0.663195 0.265205 0.756171 0.170796 0.868365 0.104479C0.980559 0.0381625 1.1081 0.0022257 1.23841 0.000211652C1.36872 -0.0018024 1.49731 0.0301758 1.6115 0.0929939L16.6115 8.34299C16.7291 8.40774 16.8271 8.50285 16.8954 8.61842C16.9637 8.73398 16.9998 8.86576 16.9998 8.99999C16.9998 9.13423 16.9637 9.26601 16.8954 9.38157C16.8271 9.49713 16.7291 9.59225 16.6115 9.65699L1.6115 17.907C1.50076 17.968 1.37641 18 1.25 18ZM2 2.01749V15.9825L14.6937 8.99999L2 2.01749Z",
        fill: "white",
      }),
    }),
  Video = ({ src: n }) => {
    const e = reactExports.useRef(null),
      [t, r] = reactExports.useState(!1),
      [s, o] = reactExports.useState(!0),
      [a, l] = reactExports.useState(!0),
      [c, u] = reactExports.useState(!1),
      [p, N] = reactExports.useState(!0),
      P = async () => {
        if (e.current)
          try {
            e.current.requestFullscreen
              ? await e.current.requestFullscreen()
              : e.current.webkitRequestFullscreen
              ? await e.current.webkitRequestFullscreen()
              : e.current.webkitEnterFullscreen &&
                e.current.webkitEnterFullscreen();
          } catch (nt) {
            console.error("     :", nt);
          }
      },
      de = async () => {
        if (e.current)
          try {
            if (libExports.isMobile) {
              (e.current.muted = !1), await e.current.play(), await P();
              return;
            }
            (e.current.muted = !1),
              await e.current.play(),
              r(!0),
              o(!1),
              u(!0),
              N(!1),
              l(!1);
          } catch (nt) {
            console.error("Error while playing video:".toUpperCase(), nt);
          }
      },
      me = () => {
        e.current && e.current.pause(), r(!1), N(!0), l(!0);
      },
      Ye = () => {
        e.current && (e.current.muted = !s), o((nt) => !nt);
      };
    return (
      reactExports.useEffect(() => {
        const nt = () => {
          document.fullscreenElement || me();
        };
        return (
          document.addEventListener("fullscreenchange", nt),
          document.addEventListener("webkitfullscreenchange", nt),
          document.addEventListener("mozfullscreenchange", nt),
          document.addEventListener("MSFullscreenChange", nt),
          () => {
            document.removeEventListener("fullscreenchange", nt),
              document.removeEventListener("webkitfullscreenchange", nt),
              document.removeEventListener("mozfullscreenchange", nt),
              document.removeEventListener("MSFullscreenChange", nt);
          }
        );
      }, []),
      reactExports.useEffect(() => {
        if (!c || a) return;
        const nt = new IntersectionObserver(
          (Be) => {
            Be.forEach((ot) => {
              e.current &&
                (ot.isIntersecting
                  ? (e.current.play(), r(!0), N(!1))
                  : (e.current.pause(), r(!1), N(!0)));
            });
          },
          { threshold: 0.5 }
        );
        return (
          e.current && nt.observe(e.current),
          () => {
            e.current && nt.unobserve(e.current);
          }
        );
      }, [c, a]),
      jsxRuntimeExports.jsxs(VideoWrapper, {
        id: "videoBlock",
        children: [
          jsxRuntimeExports.jsxs(VideoContainer, {
            children: [
              jsxRuntimeExports.jsx("video", {
                style: { height: "100%", width: "100%", objectFit: "cover" },
                ref: e,
                controls: !1,
                playsInline: !0,
                poster: "/video/preview.webp",
                children: jsxRuntimeExports.jsx("source", {
                  src: n,
                  type: "video/mp4",
                }),
              }),
              jsxRuntimeExports.jsx(ButtonLayer, {
                children:
                  p &&
                  jsxRuntimeExports.jsxs(ButtonPlay, {
                    onClick: de,
                    children: [
                      jsxRuntimeExports.jsx(PlayIcon, {}),
                      jsxRuntimeExports.jsx(Gradient, {
                        style: { position: "absolute" },
                      }),
                    ],
                  }),
              }),
              t && jsxRuntimeExports.jsx(ButtonStopLayer, { onClick: me }),
            ],
          }),
          !libExports.isMobile &&
            jsxRuntimeExports.jsx(MuteButton, {
              style: { cursor: "pointer", position: "absolute", zIndex: "30" },
              onClick: Ye,
              children: s
                ? jsxRuntimeExports.jsx(Unmute, {})
                : jsxRuntimeExports.jsx(Mute, {}),
            }),
        ],
      })
    );
  },
  LandingContent = () => {
    const n = reactExports.useMemo(
      () =>
        libExports.isMobile
          ? "/video/docca_vid_1.mp4"
          : "/video/docca_vid_1.mp4",
      []
    );
    return jsxRuntimeExports.jsxs(Wrapper$1, {
      id: "landingWrapper",
      children: [
        jsxRuntimeExports.jsx(Loader$1, {}),
        jsxRuntimeExports.jsx(GlobalScene, {}),
        jsxRuntimeExports.jsxs(Main$1, {
          id: "blocksContainer",
          children: [
            jsxRuntimeExports.jsx(MainBlock, {}),
            jsxRuntimeExports.jsx(Video, { src: n }),
            jsxRuntimeExports.jsx(Legend, {}),
            jsxRuntimeExports.jsx(HowItWorks, {}),
            jsxRuntimeExports.jsx(Features, {}),
            jsxRuntimeExports.jsx(Roadmap, {}),
            jsxRuntimeExports.jsx(WorkWIthUs, {}),
          ],
        }),
        jsxRuntimeExports.jsx(LandscapeBlocker, {}),
      ],
    });
  },
  titilliumWebRegularPath = "/assets/TitilliumWeb-Regular-BNW2HhQP.ttf",
  duneRiseFont = "/assets/Dune_Rise-DLpwl851.ttf",
  GlobalStyle = ft`
    /* Load custom fonts */
    @font-face {
        font-family: 'Titillium Web';
        src: url(${titilliumWebRegularPath}) format('truetype');
        font-weight: 400;
        font-style: normal;
    }

    @font-face {
        font-family: 'dune rise';
        src: url(${duneRiseFont}) format('truetype');
        font-weight: 400;
        font-style: normal;
    }

    /* Reset basic styles */
    *, *::before, *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;

        -webkit-tap-highlight-color: transparent;   
        -webkit-touch-callout: none; 
        -webkit-user-select: none; 
        -khtml-user-select: none; 
        -moz-user-select: none; 
        -ms-user-select: none; 
        user-select: none; 
    }

    #root {
        height: 100%;
    }

    html, body {
        width: 100%;
        height: auto !important;
        touch-action: manipulation;
        overscroll-behavior: none;
        margin: 0;
        padding: 0;
        font-size: calc(1.296vw + 1.296vh);
        font-family: 'Titillium Web';
        color: #333;
        line-height: 1.5;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        color: var(--white-color);
        @media (min-width: 48rem) {
            font-size: calc(0.603vw + 0.603vh);
        }
    }

    body { 
        overflow: auto;
    }

    h1, h2, h3, h4 {
        font-weight: 400 !important;
    }

    p {
        font-weight: 400 !important;
    }

    /* Styles for links */
    a {
        text-decoration: none;
        color: inherit;
        cursor: pointer;
    }

    /* Remove default list styles */
    ul, ol {
        list-style: none;
        font-weight: 400;
    }

    /* Adjust image styles */
    img {
        max-width: 100%;
        display: block;
        height: auto;
    }

    /* Remove default table styles */
    table {
        border-collapse: collapse;
        border-spacing: 0;
    }

    /* Buttons and interactive elements */
    button, input, textarea, select {
        font: inherit;
        color: inherit;
        background: none;
        border: none;
        outline: none;
        font-weight: 400;
    }

    /* CSS variables for colors */
    :root {
        --primary-color: ${colors.primaryColor};
        --secondary-color: ${colors.secondaryColor};
        --tertiary-color: ${colors.tertiaryColor};
        --fourth-color: ${colors.fourthColor};
        --text-inactive-color: ${colors.textInactiveColor};
        --black-color: ${colors.blackColor};
        --white-color: ${colors.whiteColor};
        --gradient: ${colors.gradient};
    }

    .active-slide {
      height: 10.8125rem;
      @media (min-width: 80rem) {
        width: 35vw !important;
        height: 11.25rem;
      }
    }
    
    .inactive-slide {
      height: 3.5rem;
      @media (min-width: 80rem) {
        width: 16.72vw !important;
      }
    }

    .swiper-wrapper {
        height: 10.8125rem;
        transition: height 0.3s ease;
        @media (min-width: 80rem) {
            height: 11.25rem;
          }
      }
`,
  Landing = () =>
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: jsxRuntimeExports.jsxs(LandingContextProvider, {
        children: [
          jsxRuntimeExports.jsx(GlobalStyle, {}),
          jsxRuntimeExports.jsx(LandingContent, {}),
        ],
      }),
    });
function App() {
  return jsxRuntimeExports.jsx(Landing, {});
}
clientExports.createRoot(document.getElementById("root")).render(
  jsxRuntimeExports.jsx(reactExports.StrictMode, {
    children: jsxRuntimeExports.jsx(App, {}),
  })
);
